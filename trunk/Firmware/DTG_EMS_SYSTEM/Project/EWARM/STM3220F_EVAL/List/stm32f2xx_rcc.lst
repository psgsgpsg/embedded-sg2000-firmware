###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     08/Jan/2012  13:10:09 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Libraries\STM32F2xx_ #
#                    StdPeriph_Driver\src\stm32f2xx_rcc.c                     #
#    Command line =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Libraries\STM32F2xx_ #
#                    StdPeriph_Driver\src\stm32f2xx_rcc.c -D                  #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D RTC_CLOCK_SOURCE_LSE -lC            #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\List\ -lA E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Pr #
#                    oject\EWARM\STM3220F_EVAL\List\ -o                       #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\Obj\ --no_cse --no_unroll --no_inline            #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWAR #
#                    M\..\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWA #
#                    RM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I             #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I       #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I             #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Utilities\STM32_EVAL\ -I E:\Work\Firmware\DTG\DTG_EMS_SY #
#                    STEM\Project\EWARM\..\..\Utilities\STM32_EVAL\Common\    #
#                    -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\ #
#                    ..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I                #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_OTG_Driver\inc\ -I                   #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_Device_Library\Core\inc\ -I          #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_Device_Library\Class\msc\inc\ -I     #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\Usb #
#                    \ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\. #
#                    .\Usb\Inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Projec #
#                    t\EWARM\..\Usb\src\ -I E:\Work\Firmware\DTG\DTG_EMS_SYST #
#                    EM\Project\EWARM\..\..\Libraries\STM32_USB_HOST_Library\ #
#                    Core\inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project #
#                    \EWARM\..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\ #
#                    inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWAR #
#                    M\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc #
#                    \ -Ol --use_c++_inline                                   #
#    List file    =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\List\stm32f2xx_rcc.lst                           #
#    Object file  =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\Obj\stm32f2xx_rcc.o                              #
#                                                                             #
#                                                                             #
###############################################################################

E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_rcc.c
      4            * @author  MCD Application Team
      5            * @version V0.0.4
      6            * @date    13-January-2011
      7            * @brief   This file provides all the RCC firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f2xx_rcc.h"
     24          
     25          /** @addtogroup STM32F2xx_StdPeriph_Driver
     26            * @{
     27            */
     28          
     29          
     30          
     31          /** @defgroup RCC 
     32            * @brief RCC driver modules
     33            * @{
     34            */ 
     35          
     36          /** @defgroup RCC_Private_TypesDefinitions
     37            * @{
     38            */ 
     39          /**
     40            * @}
     41            */ 
     42          
     43          
     44          /** @defgroup RCC_Private_Defines
     45            * @{
     46            */ 
     47          /* ------------ RCC registers bit address in the alias region ----------- */
     48          #define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)
     49          /* --- CR Register ---*/
     50          /* Alias word address of HSION bit */
     51          #define CR_OFFSET                 (RCC_OFFSET + 0x00)
     52          #define HSION_BitNumber           0x00
     53          #define CR_HSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (HSION_BitNumber * 4))
     54          /* Alias word address of CSSON bit */
     55          #define CSSON_BitNumber           0x13
     56          #define CR_CSSON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (CSSON_BitNumber * 4))
     57          /* Alias word address of PLLON bit */
     58          #define PLLON_BitNumber           0x18
     59          #define CR_PLLON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLON_BitNumber * 4))
     60          /* Alias word address of PLLI2SON bit */
     61          #define PLLI2SON_BitNumber        0x1A
     62          #define CR_PLLI2SON_BB            (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLI2SON_BitNumber * 4))
     63          
     64          /* --- CFGR Register ---*/
     65          /* Alias word address of I2SSRC bit */
     66          #define CFGR_OFFSET               (RCC_OFFSET + 0x08)
     67          #define I2SSRC_BitNumber          0x17
     68          #define CFGR_I2SSRC_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (I2SSRC_BitNumber * 4))
     69          
     70          /* --- BDCR Register ---*/
     71          /* Alias word address of RTCEN bit */
     72          #define BDCR_OFFSET               (RCC_OFFSET + 0x70)
     73          #define RTCEN_BitNumber           0x0F
     74          #define BDCR_RTCEN_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (RTCEN_BitNumber * 4))
     75          /* Alias word address of BDRST bit */
     76          #define BDRST_BitNumber           0x10
     77          #define BDCR_BDRST_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (BDRST_BitNumber * 4))
     78          /* --- CSR Register ---*/
     79          /* Alias word address of LSION bit */
     80          #define CSR_OFFSET                (RCC_OFFSET + 0x74)
     81          #define LSION_BitNumber           0x00
     82          #define CSR_LSION_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (LSION_BitNumber * 4))
     83          /* ---------------------- RCC registers bit mask ------------------------ */
     84          /* CFGR register bit mask */
     85          #define CFGR_MCO2_RESET_MASK      ((uint32_t)0x07FFFFFF)
     86          #define CFGR_MCO1_RESET_MASK      ((uint32_t)0xF89FFFFF)
     87          
     88          /* RCC Flag Mask */
     89          #define FLAG_MASK                 ((uint8_t)0x1F)
     90          
     91          /* CR register byte 3 (Bits[23:16]) base address */
     92          #define CR_BYTE3_ADDRESS          ((uint32_t)0x40023802)
     93          
     94          /* CIR register byte 2 (Bits[15:8]) base address */
     95          #define CIR_BYTE2_ADDRESS         ((uint32_t)(RCC_BASE + 0x0C + 0x01))
     96          
     97          /* CIR register byte 3 (Bits[23:16]) base address */
     98          #define CIR_BYTE3_ADDRESS         ((uint32_t)(RCC_BASE + 0x0C + 0x02))
     99          
    100          /* BDCR register base address */
    101          #define BDCR_ADDRESS              (PERIPH_BASE + BDCR_OFFSET)
    102          
    103          
    104          /**
    105            * @}
    106            */ 
    107          
    108          
    109          /** @defgroup RCC_Private_Macros
    110            * @{
    111            */ 
    112          /**
    113            * @}
    114            */ 
    115          
    116          
    117          /** @defgroup RCC_Private_Variables
    118            * @{
    119            */ 

   \                                 In section .text, align 4, keep-with-next
    120          static const uint8_t APBAHBPrescTable[16] =
   \                     APBAHBPrescTable:
   \   00000000                      ; Initializer data, 16 bytes
   \   00000000   000000000102       DC8 0, 0, 0, 0, 1, 2, 3, 4, 1, 2
   \              03040102    
   \   0000000A   030406070809       DC8 3, 4, 6, 7, 8, 9
    121            {
    122              0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9
    123            };
    124          /**
    125            * @}
    126            */ 
    127          
    128          
    129          /** @defgroup RCC_Private_FunctionPrototypes
    130            * @{
    131            */ 
    132          /**
    133            * @}
    134            */ 
    135          
    136          
    137          /** @defgroup RCC_Private_Functions
    138            * @{
    139            */ 
    140          
    141          
    142          /**
    143            * @brief  Resets the RCC clock configuration to the default reset state.
    144            * @param  None
    145            * @retval None
    146            */

   \                                 In section .text, align 2, keep-with-next
    147          void RCC_DeInit(void)
    148          {
    149            /* Set HSION bit */
    150            RCC->CR |= (uint32_t)0x00000001;
   \                     RCC_DeInit:
   \   00000000   ........           LDR.W    R0,??DataTable43  ;; 0x40023800
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   50F00100           ORRS     R0,R0,#0x1
   \   0000000A   ........           LDR.W    R1,??DataTable43  ;; 0x40023800
   \   0000000E   0860               STR      R0,[R1, #+0]
    151            /* Reset CFGR register */
    152            RCC->CFGR = 0x00000000;
   \   00000010   ........           LDR.W    R0,??DataTable43_1  ;; 0x40023808
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   0160               STR      R1,[R0, #+0]
    153            /* Reset HSEON, CSSON and PLLON bits */
    154            RCC->CR &= (uint32_t)0xFEF6FFFF;
   \   00000018   ........           LDR.W    R0,??DataTable43  ;; 0x40023800
   \   0000001C   0068               LDR      R0,[R0, #+0]
   \   0000001E   ........           LDR.W    R1,??DataTable43_2  ;; 0xfef6ffff
   \   00000022   0840               ANDS     R0,R1,R0
   \   00000024   ........           LDR.W    R1,??DataTable43  ;; 0x40023800
   \   00000028   0860               STR      R0,[R1, #+0]
    155            /* Reset PLLCFGR register */
    156            RCC->PLLCFGR = 0x24003010;
   \   0000002A   ........           LDR.W    R0,??DataTable43_3  ;; 0x40023804
   \   0000002E   ........           LDR.W    R1,??DataTable43_4  ;; 0x24003010
   \   00000032   0160               STR      R1,[R0, #+0]
    157            /* Reset HSEBYP bit */
    158            RCC->CR &= (uint32_t)0xFFFBFFFF;
   \   00000034   ........           LDR.W    R0,??DataTable43  ;; 0x40023800
   \   00000038   0068               LDR      R0,[R0, #+0]
   \   0000003A   30F48020           BICS     R0,R0,#0x40000
   \   0000003E   ........           LDR.W    R1,??DataTable43  ;; 0x40023800
   \   00000042   0860               STR      R0,[R1, #+0]
    159            /* Disable all interrupts */
    160            RCC->CIR = 0x00000000;
   \   00000044   ........           LDR.W    R0,??DataTable43_5  ;; 0x4002380c
   \   00000048   0021               MOVS     R1,#+0
   \   0000004A   0160               STR      R1,[R0, #+0]
    161          }
   \   0000004C   7047               BX       LR               ;; return
    162          
    163          
    164          /**
    165            * @brief  Configures the External High Speed oscillator (HSE).
    166            * @note   HSE can not be stopped if it is used directly or through the main PLL
    167            *         as system clock.
    168            * @note   This function reset the CSSON bit, so if the Clock security system(CSS)
    169            *         was previously enabled you have to enable it again after calling this
    170            *         function.    
    171            * @param  RCC_HSE: specifies the new state of the HSE.
    172            *   This parameter can be one of the following values:
    173            *     @arg RCC_HSE_OFF: HSE oscillator OFF
    174            *     @arg RCC_HSE_ON: HSE oscillator ON
    175            *     @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
    176            * @retval None
    177            */

   \                                 In section .text, align 2, keep-with-next
    178          void RCC_HSEConfig(uint8_t RCC_HSE)
    179          {
    180            /* Check the parameters */
    181            assert_param(IS_RCC_HSE(RCC_HSE));
    182          
    183            /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
    184            *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
   \                     RCC_HSEConfig:
   \   00000000   ........           LDR.W    R1,??DataTable43_6  ;; 0x40023802
   \   00000004   0022               MOVS     R2,#+0
   \   00000006   0A70               STRB     R2,[R1, #+0]
    185          
    186            /* Set the new HSE configuration -------------------------------------------*/
    187            *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
   \   00000008   ........           LDR.W    R1,??DataTable43_6  ;; 0x40023802
   \   0000000C   0870               STRB     R0,[R1, #+0]
    188          }
   \   0000000E   7047               BX       LR               ;; return
    189          
    190          
    191          /**
    192            * @brief  Waits for HSE start-up.
    193            * @param  None
    194            * @retval An ErrorStatus enumuration value:
    195            * - SUCCESS: HSE oscillator is stable and ready to use
    196            * - ERROR: HSE oscillator not yet ready
    197            */

   \                                 In section .text, align 2, keep-with-next
    198          ErrorStatus RCC_WaitForHSEStartUp(void)
    199          {
   \                     RCC_WaitForHSEStartUp:
   \   00000000   80B5               PUSH     {R7,LR}
    200            __IO uint32_t startupcounter = 0;
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   0090               STR      R0,[SP, #+0]
    201            ErrorStatus status = ERROR;
   \   00000006   0020               MOVS     R0,#+0
    202            FlagStatus hsestatus = RESET;
   \   00000008   0021               MOVS     R1,#+0
    203            /* Wait till HSE is ready and if Time out is reached exit */
    204            do
    205            {
    206              hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
   \                     ??RCC_WaitForHSEStartUp_0:
   \   0000000A   3120               MOVS     R0,#+49
   \   0000000C   ........           BL       RCC_GetFlagStatus
   \   00000010   0100               MOVS     R1,R0
    207              startupcounter++;
   \   00000012   0098               LDR      R0,[SP, #+0]
   \   00000014   401C               ADDS     R0,R0,#+1
   \   00000016   0090               STR      R0,[SP, #+0]
    208            }
    209            while ((hsestatus == RESET) && (startupcounter != HSE_STARTUP_TIMEOUT));
   \   00000018   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0029               CMP      R1,#+0
   \   0000001C   03D1               BNE.N    ??RCC_WaitForHSEStartUp_1
   \   0000001E   0098               LDR      R0,[SP, #+0]
   \   00000020   B0F5A06F           CMP      R0,#+1280
   \   00000024   F1D1               BNE.N    ??RCC_WaitForHSEStartUp_0
    210            if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
   \                     ??RCC_WaitForHSEStartUp_1:
   \   00000026   3120               MOVS     R0,#+49
   \   00000028   ........           BL       RCC_GetFlagStatus
   \   0000002C   0028               CMP      R0,#+0
   \   0000002E   01D0               BEQ.N    ??RCC_WaitForHSEStartUp_2
    211            {
    212              status = SUCCESS;
   \   00000030   0120               MOVS     R0,#+1
   \   00000032   00E0               B.N      ??RCC_WaitForHSEStartUp_3
    213            }
    214            else
    215            {
    216              status = ERROR;
   \                     ??RCC_WaitForHSEStartUp_2:
   \   00000034   0020               MOVS     R0,#+0
    217            }
    218            return (status);
   \                     ??RCC_WaitForHSEStartUp_3:
   \   00000036   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   02BD               POP      {R1,PC}          ;; return
    219          }
    220          
    221          /**
    222            * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.
    223            * @param  HSICalibrationValue: specifies the calibration trimming value.
    224            *   This parameter must be a number between 0 and 0x1F.
    225            * @retval None
    226            */

   \                                 In section .text, align 2, keep-with-next
    227          void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
    228          {
    229            uint32_t tmpreg = 0;
   \                     RCC_AdjustHSICalibrationValue:
   \   00000000   0021               MOVS     R1,#+0
    230            /* Check the parameters */
    231            assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
    232          
    233            tmpreg = RCC->CR;
   \   00000002   ........           LDR.W    R2,??DataTable43  ;; 0x40023800
   \   00000006   1268               LDR      R2,[R2, #+0]
   \   00000008   1100               MOVS     R1,R2
    234          
    235            /* Clear HSITRIM[4:0] bits */
    236            tmpreg &= ~RCC_CR_HSITRIM;
   \   0000000A   31F0F801           BICS     R1,R1,#0xF8
    237          
    238            /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
    239            tmpreg |= (uint32_t)HSICalibrationValue << 3;
   \   0000000E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   51EAC001           ORRS     R1,R1,R0, LSL #+3
    240          
    241            /* Store the new value */
    242            RCC->CR = tmpreg;
   \   00000014   ........           LDR.W    R0,??DataTable43  ;; 0x40023800
   \   00000018   0160               STR      R1,[R0, #+0]
    243          }
   \   0000001A   7047               BX       LR               ;; return
    244          
    245          /**
    246            * @brief  Enables or disables the Internal High Speed oscillator (HSI).
    247            * @note   HSI can not be stopped if it is used directly or through the main PLL
    248            *   as system clock.
    249            * @param  NewState: new state of the HSI. This parameter can be: ENABLE or DISABLE.
    250            * @retval None
    251            */

   \                                 In section .text, align 2, keep-with-next
    252          void RCC_HSICmd(FunctionalState NewState)
    253          {
    254            /* Check the parameters */
    255            assert_param(IS_FUNCTIONAL_STATE(NewState));
    256            *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
   \                     RCC_HSICmd:
   \   00000000   ........           LDR.W    R1,??DataTable43_7  ;; 0x42470000
   \   00000004   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0860               STR      R0,[R1, #+0]
    257          }
   \   00000008   7047               BX       LR               ;; return
    258          
    259          /**
    260            * @brief  Enables or disables the main PLL.
    261            * @note   The main PLL can not be disabled if it is used as system clock.
    262            * @param  NewState: new state of the main PLL. This parameter can be: ENABLE or DISABLE.
    263            * @retval None
    264            */

   \                                 In section .text, align 2, keep-with-next
    265          void RCC_PLLCmd(FunctionalState NewState)
    266          {
    267            /* Check the parameters */
    268            assert_param(IS_FUNCTIONAL_STATE(NewState));
    269            *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
   \                     RCC_PLLCmd:
   \   00000000   ........           LDR.W    R1,??DataTable43_8  ;; 0x42470060
   \   00000004   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0860               STR      R0,[R1, #+0]
    270          }
   \   00000008   7047               BX       LR               ;; return
    271          
    272          /**
    273            * @brief  Configures the main PLL clock source, multiplication and division factors.
    274            * @note   This function must be used only when the main PLL is disabled.
    275            * @param  RCC_PLLSource: specifies the PLL entry clock source.
    276            *   This parameter can be one of the following values:
    277            *     @arg RCC_PLLSource_HSI: HSI oscillator clock selected as PLL clock entry
    278            *     @arg RCC_PLLSource_HSE: HSE oscillator clock selected as PLL clock entry
    279            *   This clock source is common for the main PLL and PLLI2S.  
    280            * @param  PLLM: specifies the division factor for PLL VCO input clock
    281            *   This parameter must be a number between 0 and 63.
    282            * @param  PLLN: specifies the multiplication factor for PLL VCO output clock
    283            *   This parameter must be a number between 192 and 432.
    284            * @param  PLLP: specifies the division factor for main system clock (SYSCLK)
    285            *   This parameter must be a number in the range {2, 4, 6, or 8}.
    286            * @param  PLLQ: specifies the division factor for OTG FS, SDIO and RNG clocks
    287            *   This parameter must be a number between 4 and 15.
    288            * @param  PLLR: specifies the division factor for I2S clock
    289            *   This parameter must be a number between 2 and 7.  
    290            *   This parameter is not applicable for Silicon RevB  
    291            * @retval None
    292            */

   \                                 In section .text, align 2, keep-with-next
    293          void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ, uint32_t PLLR)
    294          {
   \                     RCC_PLLConfig:
   \   00000000   30B4               PUSH     {R4,R5}
   \   00000002   029C               LDR      R4,[SP, #+8]
   \   00000004   039D               LDR      R5,[SP, #+12]
    295            /* Check the parameters */
    296            assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
    297            assert_param(IS_RCC_PLLM_VALUE(PLLM));
    298            assert_param(IS_RCC_PLLN_VALUE(PLLN));
    299            assert_param(IS_RCC_PLLP_VALUE(PLLP));
    300            assert_param(IS_RCC_PLLQ_VALUE(PLLQ));
    301            assert_param(IS_RCC_PLLR_VALUE(PLLR));
    302            RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
    303                           (PLLQ << 24) | (PLLR << 28);
   \   00000006   51EA8211           ORRS     R1,R1,R2, LSL #+6
   \   0000000A   5A08               LSRS     R2,R3,#+1
   \   0000000C   521E               SUBS     R2,R2,#+1
   \   0000000E   51EA0241           ORRS     R1,R1,R2, LSL #+16
   \   00000012   0843               ORRS     R0,R0,R1
   \   00000014   50EA0460           ORRS     R0,R0,R4, LSL #+24
   \   00000018   50EA0570           ORRS     R0,R0,R5, LSL #+28
   \   0000001C   ........           LDR.W    R1,??DataTable43_3  ;; 0x40023804
   \   00000020   0860               STR      R0,[R1, #+0]
    304          }
   \   00000022   30BC               POP      {R4,R5}
   \   00000024   7047               BX       LR               ;; return
    305          
    306          /**
    307            * @brief  Enables or disables the PLLI2S.
    308            * @note   PLLI2S is available only in Silicon RevB
    309            * @param  NewState: new state of the PLLI2S. This parameter can be: ENABLE or DISABLE.
    310            * @retval None
    311            */

   \                                 In section .text, align 2, keep-with-next
    312          void RCC_PLLI2SCmd(FunctionalState NewState)
    313          {
    314            /* Check the parameters */
    315            assert_param(IS_FUNCTIONAL_STATE(NewState));
    316            *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
   \                     RCC_PLLI2SCmd:
   \   00000000   ........           LDR.W    R1,??DataTable43_9  ;; 0x42470068
   \   00000004   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0860               STR      R0,[R1, #+0]
    317          }
   \   00000008   7047               BX       LR               ;; return
    318          
    319          /**
    320            * @brief  Configures the PLLI2S clock multiplication and division factors.
    321            * @note   - PLLI2S is available only in Silicon RevB   
    322            *         - This function must be used only when the PLLI2S is disabled.
    323            *         - PLLI2S clock source is common with the main PLL (configured in 
    324            *           RCC_PLLConfig function )  
    325            * @param  PLLI2SN: specifies the multiplication factor for PLLI2S VCO output clock
    326            *   This parameter must be a number between 192 and 432.
    327            * @param  PLLI2SR: specifies the division factor for I2S clock
    328            *   This parameter must be a number between 2 and 7.  
    329            * @retval None
    330            */

   \                                 In section .text, align 2, keep-with-next
    331          void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR)
    332          {
    333            /* Check the parameters */
    334            assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
    335            assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
    336          
    337            RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
   \                     RCC_PLLI2SConfig:
   \   00000000   0907               LSLS     R1,R1,#+28
   \   00000002   51EA8010           ORRS     R0,R1,R0, LSL #+6
   \   00000006   ........           LDR.W    R1,??DataTable43_10  ;; 0x40023884
   \   0000000A   0860               STR      R0,[R1, #+0]
    338          }
   \   0000000C   7047               BX       LR               ;; return
    339          
    340          /**
    341            * @brief  Configures the system clock (SYSCLK).
    342            * @param  RCC_SYSCLKSource: specifies the clock source used as system clock.
    343            *   This parameter can be one of the following values:
    344            *     @arg RCC_SYSCLKSource_HSI: HSI selected as system clock
    345            *     @arg RCC_SYSCLKSource_HSE: HSE selected as system clock
    346            *     @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock
    347            * @retval None
    348            */

   \                                 In section .text, align 2, keep-with-next
    349          void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
    350          {
    351            uint32_t tmpreg = 0;
   \                     RCC_SYSCLKConfig:
   \   00000000   0021               MOVS     R1,#+0
    352            /* Check the parameters */
    353            assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
    354          
    355            tmpreg = RCC->CFGR;
   \   00000002   ........           LDR.W    R2,??DataTable43_1  ;; 0x40023808
   \   00000006   1268               LDR      R2,[R2, #+0]
   \   00000008   1100               MOVS     R1,R2
    356          
    357            /* Clear SW[1:0] bits */
    358            tmpreg &= ~RCC_CFGR_SW;
   \   0000000A   8908               LSRS     R1,R1,#+2
   \   0000000C   8900               LSLS     R1,R1,#+2
    359          
    360            /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
    361            tmpreg |= RCC_SYSCLKSource;
   \   0000000E   0143               ORRS     R1,R0,R1
    362          
    363            /* Store the new value */
    364            RCC->CFGR = tmpreg;
   \   00000010   ........           LDR.W    R0,??DataTable43_1  ;; 0x40023808
   \   00000014   0160               STR      R1,[R0, #+0]
    365          }
   \   00000016   7047               BX       LR               ;; return
    366          
    367          /**
    368            * @brief  Returns the clock source used as system clock.
    369            * @param  None
    370            * @retval The clock source used as system clock. The returned value can
    371            *   be one of the following:
    372            *     - 0x00: HSI used as system clock
    373            *     - 0x04: HSE used as system clock
    374            *     - 0x08: PLL used as system clock
    375            */

   \                                 In section .text, align 2, keep-with-next
    376          uint8_t RCC_GetSYSCLKSource(void)
    377          {
    378            return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
   \                     RCC_GetSYSCLKSource:
   \   00000000   ........           LDR.W    R0,??DataTable43_1  ;; 0x40023808
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   10F00C00           ANDS     R0,R0,#0xC
   \   0000000A   7047               BX       LR               ;; return
    379          }
    380          
    381          /**
    382            * @brief  Configures the AHB clock (HCLK).
    383            * @param  RCC_SYSCLK: defines the AHB clock divider. This clock is derived from 
    384            *   the system clock (SYSCLK).
    385            *   This parameter can be one of the following values:
    386            *     @arg RCC_SYSCLK_Div1: AHB clock = SYSCLK
    387            *     @arg RCC_SYSCLK_Div2: AHB clock = SYSCLK/2
    388            *     @arg RCC_SYSCLK_Div4: AHB clock = SYSCLK/4
    389            *     @arg RCC_SYSCLK_Div8: AHB clock = SYSCLK/8
    390            *     @arg RCC_SYSCLK_Div16: AHB clock = SYSCLK/16
    391            *     @arg RCC_SYSCLK_Div64: AHB clock = SYSCLK/64
    392            *     @arg RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
    393            *     @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
    394            *     @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
    395            * @retval None
    396            */

   \                                 In section .text, align 2, keep-with-next
    397          void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
    398          {
    399            uint32_t tmpreg = 0;
   \                     RCC_HCLKConfig:
   \   00000000   0021               MOVS     R1,#+0
    400            /* Check the parameters */
    401            assert_param(IS_RCC_HCLK(RCC_SYSCLK));
    402          
    403            tmpreg = RCC->CFGR;
   \   00000002   ........           LDR.W    R2,??DataTable43_1  ;; 0x40023808
   \   00000006   1268               LDR      R2,[R2, #+0]
   \   00000008   1100               MOVS     R1,R2
    404          
    405            /* Clear HPRE[3:0] bits */
    406            tmpreg &= ~RCC_CFGR_HPRE;
   \   0000000A   31F0F001           BICS     R1,R1,#0xF0
    407          
    408            /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
    409            tmpreg |= RCC_SYSCLK;
   \   0000000E   0143               ORRS     R1,R0,R1
    410          
    411            /* Store the new value */
    412            RCC->CFGR = tmpreg;
   \   00000010   ........           LDR.W    R0,??DataTable43_1  ;; 0x40023808
   \   00000014   0160               STR      R1,[R0, #+0]
    413          }
   \   00000016   7047               BX       LR               ;; return
    414          
    415          
    416          /**
    417            * @brief  Configures the Low Speed APB clock (PCLK1).
    418            * @param  RCC_HCLK: defines the APB1 clock divider. This clock is derived from 
    419            *   the AHB clock (HCLK).
    420            *   This parameter can be one of the following values:
    421            *     @arg RCC_HCLK_Div1: APB1 clock = HCLK
    422            *     @arg RCC_HCLK_Div2: APB1 clock = HCLK/2
    423            *     @arg RCC_HCLK_Div4: APB1 clock = HCLK/4
    424            *     @arg RCC_HCLK_Div8: APB1 clock = HCLK/8
    425            *     @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
    426            * @retval None
    427            */

   \                                 In section .text, align 2, keep-with-next
    428          void RCC_PCLK1Config(uint32_t RCC_HCLK)
    429          {
    430            uint32_t tmpreg = 0;
   \                     RCC_PCLK1Config:
   \   00000000   0021               MOVS     R1,#+0
    431            /* Check the parameters */
    432            assert_param(IS_RCC_PCLK(RCC_HCLK));
    433          
    434            tmpreg = RCC->CFGR;
   \   00000002   ........           LDR.W    R2,??DataTable43_1  ;; 0x40023808
   \   00000006   1268               LDR      R2,[R2, #+0]
   \   00000008   1100               MOVS     R1,R2
    435          
    436            /* Clear PPRE1[2:0] bits */
    437            tmpreg &= ~RCC_CFGR_PPRE1;
   \   0000000A   31F4E051           BICS     R1,R1,#0x1C00
    438          
    439            /* Set PPRE1[2:0] bits according to RCC_HCLK value */
    440            tmpreg |= RCC_HCLK;
   \   0000000E   0143               ORRS     R1,R0,R1
    441          
    442            /* Store the new value */
    443            RCC->CFGR = tmpreg;
   \   00000010   ........           LDR.W    R0,??DataTable43_1  ;; 0x40023808
   \   00000014   0160               STR      R1,[R0, #+0]
    444          }
   \   00000016   7047               BX       LR               ;; return
    445          
    446          /**
    447            * @brief  Configures the High Speed APB clock (PCLK2).
    448            * @param  RCC_HCLK: defines the APB2 clock divider. This clock is derived from 
    449            *   the AHB clock (HCLK).
    450            *   This parameter can be one of the following values:
    451            *     @arg RCC_HCLK_Div1: APB2 clock = HCLK
    452            *     @arg RCC_HCLK_Div2: APB2 clock = HCLK/2
    453            *     @arg RCC_HCLK_Div4: APB2 clock = HCLK/4
    454            *     @arg RCC_HCLK_Div8: APB2 clock = HCLK/8
    455            *     @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
    456            * @retval None
    457            */

   \                                 In section .text, align 2, keep-with-next
    458          void RCC_PCLK2Config(uint32_t RCC_HCLK)
    459          {
    460            uint32_t tmpreg = 0;
   \                     RCC_PCLK2Config:
   \   00000000   0021               MOVS     R1,#+0
    461            /* Check the parameters */
    462            assert_param(IS_RCC_PCLK(RCC_HCLK));
    463          
    464            tmpreg = RCC->CFGR;
   \   00000002   ........           LDR.W    R2,??DataTable43_1  ;; 0x40023808
   \   00000006   1268               LDR      R2,[R2, #+0]
   \   00000008   1100               MOVS     R1,R2
    465          
    466            /* Clear PPRE2[2:0] bits */
    467            tmpreg &= ~RCC_CFGR_PPRE2;
   \   0000000A   31F46041           BICS     R1,R1,#0xE000
    468          
    469            /* Set PPRE2[2:0] bits according to RCC_HCLK value */
    470            tmpreg |= RCC_HCLK << 3;
   \   0000000E   51EAC001           ORRS     R1,R1,R0, LSL #+3
    471          
    472            /* Store the new value */
    473            RCC->CFGR = tmpreg;
   \   00000012   ........           LDR.W    R0,??DataTable43_1  ;; 0x40023808
   \   00000016   0160               STR      R1,[R0, #+0]
    474          }
   \   00000018   7047               BX       LR               ;; return
    475          
    476          
    477          /**
    478            * @brief  Enables or disables the specified RCC interrupts.
    479            * @param  RCC_IT: specifies the RCC interrupt sources to be enabled or disabled.
    480            *   This parameter can be any combination of the following values:
    481            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
    482            *     @arg RCC_IT_LSERDY: LSE ready interrupt
    483            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
    484            *     @arg RCC_IT_HSERDY: HSE ready interrupt
    485            *     @arg RCC_IT_PLLRDY: main PLL ready interrupt
    486            *     @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt  
    487            * @param  NewState: new state of the specified RCC interrupts.
    488            *   This parameter can be: ENABLE or DISABLE.
    489            * @retval None
    490            */

   \                                 In section .text, align 2, keep-with-next
    491          void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
    492          {
    493            /* Check the parameters */
    494            assert_param(IS_RCC_IT(RCC_IT));
    495            assert_param(IS_FUNCTIONAL_STATE(NewState));
    496            if (NewState != DISABLE)
   \                     RCC_ITConfig:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   07D0               BEQ.N    ??RCC_ITConfig_0
    497            {
    498              /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
    499              *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
   \   00000006   ........           LDR.W    R1,??DataTable43_11  ;; 0x4002380d
   \   0000000A   0978               LDRB     R1,[R1, #+0]
   \   0000000C   0843               ORRS     R0,R0,R1
   \   0000000E   ........           LDR.W    R1,??DataTable43_11  ;; 0x4002380d
   \   00000012   0870               STRB     R0,[R1, #+0]
   \   00000014   07E0               B.N      ??RCC_ITConfig_1
    500            }
    501            else
    502            {
    503              /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
    504              *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
   \                     ??RCC_ITConfig_0:
   \   00000016   ........           LDR.W    R1,??DataTable43_11  ;; 0x4002380d
   \   0000001A   0978               LDRB     R1,[R1, #+0]
   \   0000001C   31EA0000           BICS     R0,R1,R0
   \   00000020   ........           LDR.W    R1,??DataTable43_11  ;; 0x4002380d
   \   00000024   0870               STRB     R0,[R1, #+0]
    505            }
    506          }
   \                     ??RCC_ITConfig_1:
   \   00000026   7047               BX       LR               ;; return
    507          
    508          /**
    509            * @brief  Configures the External Low Speed oscillator (LSE).
    510            * @param  RCC_LSE: specifies the new state of the LSE.
    511            *   This parameter can be one of the following values:
    512            *     @arg RCC_LSE_OFF: LSE oscillator OFF
    513            *     @arg RCC_LSE_ON: LSE oscillator ON
    514            *     @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
    515            * @retval None
    516            */

   \                                 In section .text, align 2, keep-with-next
    517          void RCC_LSEConfig(uint8_t RCC_LSE)
    518          {
    519            /* Check the parameters */
    520            assert_param(IS_RCC_LSE(RCC_LSE));
    521            /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
    522            /* Reset LSEON bit */
    523            *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
   \                     RCC_LSEConfig:
   \   00000000   ........           LDR.W    R1,??DataTable43_12  ;; 0x40023870
   \   00000004   0022               MOVS     R2,#+0
   \   00000006   0A70               STRB     R2,[R1, #+0]
    524            /* Reset LSEBYP bit */
    525            *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
   \   00000008   ........           LDR.W    R1,??DataTable43_12  ;; 0x40023870
   \   0000000C   0022               MOVS     R2,#+0
   \   0000000E   0A70               STRB     R2,[R1, #+0]
    526            /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
    527            switch (RCC_LSE)
   \   00000010   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0128               CMP      R0,#+1
   \   00000014   02D0               BEQ.N    ??RCC_LSEConfig_0
   \   00000016   0428               CMP      R0,#+4
   \   00000018   05D0               BEQ.N    ??RCC_LSEConfig_1
   \   0000001A   09E0               B.N      ??RCC_LSEConfig_2
    528            {
    529              case RCC_LSE_ON:
    530                /* Set LSEON bit */
    531                *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
   \                     ??RCC_LSEConfig_0:
   \   0000001C   ........           LDR.W    R0,??DataTable43_12  ;; 0x40023870
   \   00000020   0121               MOVS     R1,#+1
   \   00000022   0170               STRB     R1,[R0, #+0]
    532                break;
   \   00000024   04E0               B.N      ??RCC_LSEConfig_3
    533              case RCC_LSE_Bypass:
    534                /* Set LSEBYP and LSEON bits */
    535                *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
   \                     ??RCC_LSEConfig_1:
   \   00000026   ........           LDR.W    R0,??DataTable43_12  ;; 0x40023870
   \   0000002A   0521               MOVS     R1,#+5
   \   0000002C   0170               STRB     R1,[R0, #+0]
    536                break;
   \   0000002E   FFE7               B.N      ??RCC_LSEConfig_3
    537              default:
    538                break;
    539            }
    540          }
   \                     ??RCC_LSEConfig_2:
   \                     ??RCC_LSEConfig_3:
   \   00000030   7047               BX       LR               ;; return
    541          
    542          
    543          /**
    544            * @brief  Enables or disables the Internal Low Speed oscillator (LSI).
    545            * @note   LSI can not be disabled if the IWDG is running.
    546            * @param  NewState: new state of the LSI. This parameter can be: ENABLE or DISABLE.
    547            * @retval None
    548            */

   \                                 In section .text, align 2, keep-with-next
    549          void RCC_LSICmd(FunctionalState NewState)
    550          {
    551            /* Check the parameters */
    552            assert_param(IS_FUNCTIONAL_STATE(NewState));
    553            *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
   \                     RCC_LSICmd:
   \   00000000   ........           LDR.W    R1,??DataTable43_13  ;; 0x42470e80
   \   00000004   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0860               STR      R0,[R1, #+0]
    554          }
   \   00000008   7047               BX       LR               ;; return
    555          
    556          /**
    557            * @brief  Configures the RTC clock (RTCCLK).
    558            * @note   Once the RTC clock is selected it can’t be changed unless the Backup domain is reset.
    559            * @param  RCC_RTCCLKSource: specifies the RTC clock source.
    560            *   This parameter can be one of the following values:
    561            *     @arg RCC_RTCCLKSource_LSE: LSE selected as RTC clock
    562            *     @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
    563            *     @arg RCC_RTCCLKSource_HSE_Divx: HSE clock divided by x selected as RTC clock, where x:[2,31]
    564            * @retval None
    565            */

   \                                 In section .text, align 2, keep-with-next
    566          void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
    567          {
    568            uint32_t tmpreg = 0;
   \                     RCC_RTCCLKConfig:
   \   00000000   0021               MOVS     R1,#+0
    569            /* Check the parameters */
    570            assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
    571          
    572            if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
   \   00000002   4FF44072           MOV      R2,#+768
   \   00000006   0240               ANDS     R2,R2,R0
   \   00000008   4FF44073           MOV      R3,#+768
   \   0000000C   9A42               CMP      R2,R3
   \   0000000E   0BD1               BNE.N    ??RCC_RTCCLKConfig_0
    573            { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    574              tmpreg = RCC->CFGR;
   \   00000010   ........           LDR.W    R1,??DataTable43_1  ;; 0x40023808
   \   00000014   0968               LDR      R1,[R1, #+0]
    575          
    576              /* Clear RTCPRE[4:0] bits */
    577              tmpreg &= ~RCC_CFGR_RTCPRE;
   \   00000016   31F4F811           BICS     R1,R1,#0x1F0000
    578          
    579              /* Configure HSE division factor for RTC clock */
    580              tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
   \   0000001A   ........           LDR.W    R2,??DataTable43_14  ;; 0xffffcff
   \   0000001E   0240               ANDS     R2,R2,R0
   \   00000020   1143               ORRS     R1,R2,R1
    581          
    582              /* Store the new value */
    583              RCC->CFGR = tmpreg;
   \   00000022   ........           LDR.W    R2,??DataTable43_1  ;; 0x40023808
   \   00000026   1160               STR      R1,[R2, #+0]
    584            }
    585              
    586            /* Select the RTC clock source */
    587            RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
   \                     ??RCC_RTCCLKConfig_0:
   \   00000028   ........           LDR.W    R1,??DataTable43_12  ;; 0x40023870
   \   0000002C   0968               LDR      R1,[R1, #+0]
   \   0000002E   0005               LSLS     R0,R0,#+20
   \   00000030   000D               LSRS     R0,R0,#+20
   \   00000032   0843               ORRS     R0,R0,R1
   \   00000034   ........           LDR.W    R1,??DataTable43_12  ;; 0x40023870
   \   00000038   0860               STR      R0,[R1, #+0]
    588          }
   \   0000003A   7047               BX       LR               ;; return
    589          
    590          /**
    591            * @brief  Enables or disables the RTC clock.
    592            * @note   This function must be used only after the RTC clock was selected using the RCC_RTCCLKConfig function.
    593            * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.
    594            * @retval None
    595            */

   \                                 In section .text, align 2, keep-with-next
    596          void RCC_RTCCLKCmd(FunctionalState NewState)
    597          {
    598            /* Check the parameters */
    599            assert_param(IS_FUNCTIONAL_STATE(NewState));
    600            *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
   \                     RCC_RTCCLKCmd:
   \   00000000   ........           LDR.W    R1,??DataTable43_15  ;; 0x42470e3c
   \   00000004   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0860               STR      R0,[R1, #+0]
    601          }
   \   00000008   7047               BX       LR               ;; return
    602          
    603          /**
    604            * @brief  Configures the I2S clock source (I2SCLK).
    605            * @note   - This function must be called before enabling the I2S APB clock.
    606            *         - This function applies only to Silicon RevB
    607            * @param  RCC_I2SCLKSource: specifies the I2S clock source.
    608            *   This parameter can be one of the following values:
    609            *     @arg RCC_I2S2CLKSource_PLLI2S: PLLI2S clock used as I2S clock source
    610            *     @arg RCC_I2S2CLKSource_Ext: External clock mapped on the I2S_CKIN pin
    611            *                                 used as I2S clock source
    612            * @retval None
    613            */

   \                                 In section .text, align 2, keep-with-next
    614          void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
    615          {
    616            /* Check the parameters */
    617            assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
    618          
    619            *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
   \                     RCC_I2SCLKConfig:
   \   00000000   ........           LDR.W    R1,??DataTable43_16  ;; 0x4247015c
   \   00000004   0860               STR      R0,[R1, #+0]
    620          }
   \   00000006   7047               BX       LR               ;; return
    621          
    622          /**
    623            * @brief  Returns the frequencies of different on chip clocks.
    624            * @note   - The system frequency computed by this function is not the real 
    625            *           frequency in the chip. It is calculated based on the predefined 
    626            *           constant and the selected clock source:
    627            *             
    628            *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(*)
    629            *                                              
    630            *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(**)
    631            *                          
    632            *           - If SYSCLK source is PLL, SystemCoreClock will contain the HSE_VALUE(**) 
    633            *             or HSI_VALUE(*) multiplied/divided by the PLL factors.
    634            *         
    635            *         (*) HSI_VALUE is a constant defined in stm32f2xx.h file (default value
    636            *             16 MHz) but the real value may vary depending on the variations
    637            *             in voltage and temperature.   
    638            *    
    639            *         (**) HSE_VALUE is a constant defined in stm32f2xx.h file (default value
    640            *              25 MHz), user has to ensure that HSE_VALUE is same as the real
    641            *              frequency of the crystal used. Otherwise, this function may
    642            *              have wrong result.
    643            *                
    644            *         - The result of this function could be not correct when using fractional
    645            *           value for HSE crystal. 
    646            *   
    647            * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold
    648            *   the clocks frequencies.
    649            * @retval None
    650            */

   \                                 In section .text, align 2, keep-with-next
    651          void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
    652          {
   \                     RCC_GetClocksFreq:
   \   00000000   F0B4               PUSH     {R4-R7}
    653            uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
   \   00000002   0021               MOVS     R1,#+0
   \   00000004   0022               MOVS     R2,#+0
   \   00000006   0023               MOVS     R3,#+0
   \   00000008   0224               MOVS     R4,#+2
   \   0000000A   0025               MOVS     R5,#+0
   \   0000000C   0226               MOVS     R6,#+2
    654            /* Get SYSCLK source -------------------------------------------------------*/
    655            tmp = RCC->CFGR & RCC_CFGR_SWS;
   \   0000000E   ........           LDR.W    R7,??DataTable43_1  ;; 0x40023808
   \   00000012   3F68               LDR      R7,[R7, #+0]
   \   00000014   17F00C07           ANDS     R7,R7,#0xC
   \   00000018   3900               MOVS     R1,R7
    656          
    657            switch (tmp)
   \   0000001A   0029               CMP      R1,#+0
   \   0000001C   04D0               BEQ.N    ??RCC_GetClocksFreq_0
   \   0000001E   0429               CMP      R1,#+4
   \   00000020   06D0               BEQ.N    ??RCC_GetClocksFreq_1
   \   00000022   0829               CMP      R1,#+8
   \   00000024   08D0               BEQ.N    ??RCC_GetClocksFreq_2
   \   00000026   35E0               B.N      ??RCC_GetClocksFreq_3
    658            {
    659              case 0x00:  /* HSI used as system clock source */
    660                RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
   \                     ??RCC_GetClocksFreq_0:
   \   00000028   ........           LDR.W    R1,??DataTable43_17  ;; 0xf42400
   \   0000002C   0160               STR      R1,[R0, #+0]
    661                break;
   \   0000002E   34E0               B.N      ??RCC_GetClocksFreq_4
    662              case 0x04:  /* HSE used as system clock  source */
    663                RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
   \                     ??RCC_GetClocksFreq_1:
   \   00000030   ........           LDR.W    R1,??DataTable43_18  ;; 0x7a1200
   \   00000034   0160               STR      R1,[R0, #+0]
    664                break;
   \   00000036   30E0               B.N      ??RCC_GetClocksFreq_4
    665              case 0x08:  /* PLL used as system clock  source */
    666          
    667                /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
    668                   SYSCLK = PLL_VCO / PLL_P
    669                   */    
    670                pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
   \                     ??RCC_GetClocksFreq_2:
   \   00000038   ........           LDR.W    R1,??DataTable43_3  ;; 0x40023804
   \   0000003C   0968               LDR      R1,[R1, #+0]
   \   0000003E   C1F38055           UBFX     R5,R1,#+22,#+1
    671                pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
   \   00000042   ........           LDR.W    R1,??DataTable43_3  ;; 0x40023804
   \   00000046   0968               LDR      R1,[R1, #+0]
   \   00000048   11F03F06           ANDS     R6,R1,#0x3F
    672                
    673                if (pllsource != 0)
   \   0000004C   002D               CMP      R5,#+0
   \   0000004E   0BD0               BEQ.N    ??RCC_GetClocksFreq_5
    674                {
    675                  /* HSE used as PLL clock source */
    676                  pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
   \   00000050   ........           LDR.W    R1,??DataTable43_18  ;; 0x7a1200
   \   00000054   B1FBF6F1           UDIV     R1,R1,R6
   \   00000058   ........           LDR.W    R2,??DataTable43_3  ;; 0x40023804
   \   0000005C   1268               LDR      R2,[R2, #+0]
   \   0000005E   C2F38812           UBFX     R2,R2,#+6,#+9
   \   00000062   02FB01F3           MUL      R3,R2,R1
   \   00000066   0AE0               B.N      ??RCC_GetClocksFreq_6
    677                }
    678                else
    679                {
    680                  /* HSI used as PLL clock source */
    681                  pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
   \                     ??RCC_GetClocksFreq_5:
   \   00000068   ........           LDR.W    R1,??DataTable43_17  ;; 0xf42400
   \   0000006C   B1FBF6F1           UDIV     R1,R1,R6
   \   00000070   ........           LDR.W    R2,??DataTable43_3  ;; 0x40023804
   \   00000074   1268               LDR      R2,[R2, #+0]
   \   00000076   C2F38812           UBFX     R2,R2,#+6,#+9
   \   0000007A   02FB01F3           MUL      R3,R2,R1
    682                }
    683          
    684                pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
   \                     ??RCC_GetClocksFreq_6:
   \   0000007E   ........           LDR.W    R1,??DataTable43_3  ;; 0x40023804
   \   00000082   0968               LDR      R1,[R1, #+0]
   \   00000084   C1F30141           UBFX     R1,R1,#+16,#+2
   \   00000088   491C               ADDS     R1,R1,#+1
   \   0000008A   4C00               LSLS     R4,R1,#+1
    685                RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
   \   0000008C   B3FBF4F1           UDIV     R1,R3,R4
   \   00000090   0160               STR      R1,[R0, #+0]
    686                break;
   \   00000092   02E0               B.N      ??RCC_GetClocksFreq_4
    687              default:
    688                RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
   \                     ??RCC_GetClocksFreq_3:
   \   00000094   ........           LDR.W    R1,??DataTable43_17  ;; 0xf42400
   \   00000098   0160               STR      R1,[R0, #+0]
    689                break;
    690            }
    691            /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/
    692            /* Get HCLK prescaler */
    693            tmp = RCC->CFGR & RCC_CFGR_HPRE;
   \                     ??RCC_GetClocksFreq_4:
   \   0000009A   ....               LDR.N    R1,??DataTable43_1  ;; 0x40023808
   \   0000009C   0968               LDR      R1,[R1, #+0]
   \   0000009E   11F0F001           ANDS     R1,R1,#0xF0
    694            tmp = tmp >> 4;
   \   000000A2   0909               LSRS     R1,R1,#+4
    695            presc = APBAHBPrescTable[tmp];
   \   000000A4   ........           ADR.W    R2,APBAHBPrescTable
   \   000000A8   8A5C               LDRB     R2,[R1, R2]
    696            /* HCLK clock frequency */
    697            RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
   \   000000AA   0168               LDR      R1,[R0, #+0]
   \   000000AC   D140               LSRS     R1,R1,R2
   \   000000AE   4160               STR      R1,[R0, #+4]
    698            /* Get PCLK1 prescaler */
    699            tmp = RCC->CFGR & RCC_CFGR_PPRE1;
   \   000000B0   ....               LDR.N    R1,??DataTable43_1  ;; 0x40023808
   \   000000B2   0968               LDR      R1,[R1, #+0]
   \   000000B4   11F4E051           ANDS     R1,R1,#0x1C00
    700            tmp = tmp >> 10;
   \   000000B8   890A               LSRS     R1,R1,#+10
    701            presc = APBAHBPrescTable[tmp];
   \   000000BA   ........           ADR.W    R2,APBAHBPrescTable
   \   000000BE   8A5C               LDRB     R2,[R1, R2]
    702            /* PCLK1 clock frequency */
    703            RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   \   000000C0   4168               LDR      R1,[R0, #+4]
   \   000000C2   D140               LSRS     R1,R1,R2
   \   000000C4   8160               STR      R1,[R0, #+8]
    704            /* Get PCLK2 prescaler */
    705            tmp = RCC->CFGR & RCC_CFGR_PPRE2;
   \   000000C6   ....               LDR.N    R1,??DataTable43_1  ;; 0x40023808
   \   000000C8   0968               LDR      R1,[R1, #+0]
   \   000000CA   11F46041           ANDS     R1,R1,#0xE000
    706            tmp = tmp >> 13;
   \   000000CE   490B               LSRS     R1,R1,#+13
    707            presc = APBAHBPrescTable[tmp];
   \   000000D0   ........           ADR.W    R2,APBAHBPrescTable
   \   000000D4   8A5C               LDRB     R2,[R1, R2]
    708            /* PCLK2 clock frequency */
    709            RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   \   000000D6   4168               LDR      R1,[R0, #+4]
   \   000000D8   D140               LSRS     R1,R1,R2
   \   000000DA   C160               STR      R1,[R0, #+12]
    710          }
   \   000000DC   F0BC               POP      {R4-R7}
   \   000000DE   7047               BX       LR               ;; return
    711          
    712          /**
    713            * @brief  Enables or disables the AHB1 peripheral clock.
    714            * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
    715            *   This parameter can be any combination of the following values:
    716            *     RCC_AHB1Periph_GPIOA, RCC_AHB1Periph_GPIOB, RCC_AHB1Periph_GPIOC,
    717            *     RCC_AHB1Periph_GPIOD, RCC_AHB1Periph_GPIOE, RCC_AHB1Periph_GPIOF,
    718            *     RCC_AHB1Periph_GPIOG, RCC_AHB1Periph_GPIOH, RCC_AHB1Periph_GPIOI,
    719            *     RCC_AHB1Periph_CRC, RCC_AHB1Periph_BKPSRAM, RCC_AHB1Periph_DMA1,
    720            *     RCC_AHB1Periph_DMA2, RCC_AHB1Periph_ETH_MAC,
    721            *     RCC_AHB1Periph_ETH_MAC_Tx, RCC_AHB1Periph_ETH_MAC_Rx,
    722            *     RCC_AHB1Periph_ETH_MAC_PTP, RCC_AHB1Periph_OTG_HS,
    723            *     RCC_AHB1Periph_OTG_HS_ULPI
    724            * @param  NewState: new state of the specified peripheral clock.
    725            *   This parameter can be: ENABLE or DISABLE.
    726            * @retval None
    727            */

   \                                 In section .text, align 2, keep-with-next
    728          void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
    729          {
    730            /* Check the parameters */
    731            assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
    732            assert_param(IS_FUNCTIONAL_STATE(NewState));
    733            if (NewState != DISABLE)
   \                     RCC_AHB1PeriphClockCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   05D0               BEQ.N    ??RCC_AHB1PeriphClockCmd_0
    734            {
    735              RCC->AHB1ENR |= RCC_AHB1Periph;
   \   00000006   ....               LDR.N    R1,??DataTable43_19  ;; 0x40023830
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   0843               ORRS     R0,R0,R1
   \   0000000C   ....               LDR.N    R1,??DataTable43_19  ;; 0x40023830
   \   0000000E   0860               STR      R0,[R1, #+0]
   \   00000010   05E0               B.N      ??RCC_AHB1PeriphClockCmd_1
    736            }
    737            else
    738            {
    739              RCC->AHB1ENR &= ~RCC_AHB1Periph;
   \                     ??RCC_AHB1PeriphClockCmd_0:
   \   00000012   ....               LDR.N    R1,??DataTable43_19  ;; 0x40023830
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   31EA0000           BICS     R0,R1,R0
   \   0000001A   ....               LDR.N    R1,??DataTable43_19  ;; 0x40023830
   \   0000001C   0860               STR      R0,[R1, #+0]
    740            }
    741          }
   \                     ??RCC_AHB1PeriphClockCmd_1:
   \   0000001E   7047               BX       LR               ;; return
    742          
    743          /**
    744            * @brief  Enables or disables the AHB2 peripheral clock.
    745            * @param  RCC_AHBPeriph: specifies the AHB2 peripheral to gates its clock.
    746            *   This parameter can be any combination of the following values:
    747            *     RCC_AHB2Periph_DCMI, RCC_AHB2Periph_CRYP, RCC_AHB2Periph_HASH,
    748            *     RCC_AHB2Periph_RNG, RCC_AHB2Periph_OTG_FS
    749            * @param  NewState: new state of the specified peripheral clock.
    750            *   This parameter can be: ENABLE or DISABLE.
    751            * @retval None
    752            */

   \                                 In section .text, align 2, keep-with-next
    753          void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
    754          {
    755            /* Check the parameters */
    756            assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
    757            assert_param(IS_FUNCTIONAL_STATE(NewState));
    758            if (NewState != DISABLE)
   \                     RCC_AHB2PeriphClockCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   05D0               BEQ.N    ??RCC_AHB2PeriphClockCmd_0
    759            {
    760              RCC->AHB2ENR |= RCC_AHB2Periph;
   \   00000006   ....               LDR.N    R1,??DataTable43_20  ;; 0x40023834
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   0843               ORRS     R0,R0,R1
   \   0000000C   ....               LDR.N    R1,??DataTable43_20  ;; 0x40023834
   \   0000000E   0860               STR      R0,[R1, #+0]
   \   00000010   05E0               B.N      ??RCC_AHB2PeriphClockCmd_1
    761            }
    762            else
    763            {
    764              RCC->AHB2ENR &= ~RCC_AHB2Periph;
   \                     ??RCC_AHB2PeriphClockCmd_0:
   \   00000012   ....               LDR.N    R1,??DataTable43_20  ;; 0x40023834
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   31EA0000           BICS     R0,R1,R0
   \   0000001A   ....               LDR.N    R1,??DataTable43_20  ;; 0x40023834
   \   0000001C   0860               STR      R0,[R1, #+0]
    765            }
    766          }
   \                     ??RCC_AHB2PeriphClockCmd_1:
   \   0000001E   7047               BX       LR               ;; return
    767          
    768          /**
    769            * @brief  Enables or disables the AHB3 peripheral clock.
    770            * @param  RCC_AHBPeriph: specifies the AHB3 peripheral to gates its clock.
    771            *   This parameter must be: RCC_AHB3Periph_FSMC
    772            * @param  NewState: new state of the specified peripheral clock.
    773            *   This parameter can be: ENABLE or DISABLE.
    774            * @retval None
    775            */

   \                                 In section .text, align 2, keep-with-next
    776          void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
    777          {
    778            /* Check the parameters */
    779            assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
    780            assert_param(IS_FUNCTIONAL_STATE(NewState));
    781            if (NewState != DISABLE)
   \                     RCC_AHB3PeriphClockCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   05D0               BEQ.N    ??RCC_AHB3PeriphClockCmd_0
    782            {
    783              RCC->AHB3ENR |= RCC_AHB3Periph;
   \   00000006   ....               LDR.N    R1,??DataTable43_21  ;; 0x40023838
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   0843               ORRS     R0,R0,R1
   \   0000000C   ....               LDR.N    R1,??DataTable43_21  ;; 0x40023838
   \   0000000E   0860               STR      R0,[R1, #+0]
   \   00000010   05E0               B.N      ??RCC_AHB3PeriphClockCmd_1
    784            }
    785            else
    786            {
    787              RCC->AHB3ENR &= ~RCC_AHB3Periph;
   \                     ??RCC_AHB3PeriphClockCmd_0:
   \   00000012   ....               LDR.N    R1,??DataTable43_21  ;; 0x40023838
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   31EA0000           BICS     R0,R1,R0
   \   0000001A   ....               LDR.N    R1,??DataTable43_21  ;; 0x40023838
   \   0000001C   0860               STR      R0,[R1, #+0]
    788            }
    789          }
   \                     ??RCC_AHB3PeriphClockCmd_1:
   \   0000001E   7047               BX       LR               ;; return
    790          
    791          /**
    792            * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
    793            * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
    794            *   This parameter can be any combination of the following values:
    795            *     RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
    796            *     RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
    797            *     RCC_APB1Periph_TIM12, RCC_APB1Periph_TIM13, RCC_APB1Periph_TIM14,
    798            *     RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
    799            *     RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_UART4,
    800            *     RCC_APB1Periph_UART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
    801            *     RCC_APB1Periph_I2C3, RCC_APB1Periph_CAN11, RCC_APB1Periph_CAN12,
    802            *     RCC_APB1Periph_PWR, RCC_APB1Periph_DAC
    803            * @param  NewState: new state of the specified peripheral clock.
    804            *   This parameter can be: ENABLE or DISABLE.
    805            * @retval None
    806            */

   \                                 In section .text, align 2, keep-with-next
    807          void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
    808          {
    809            /* Check the parameters */
    810            assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
    811            assert_param(IS_FUNCTIONAL_STATE(NewState));
    812            if (NewState != DISABLE)
   \                     RCC_APB1PeriphClockCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   05D0               BEQ.N    ??RCC_APB1PeriphClockCmd_0
    813            {
    814              RCC->APB1ENR |= RCC_APB1Periph;
   \   00000006   ....               LDR.N    R1,??DataTable43_22  ;; 0x40023840
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   0843               ORRS     R0,R0,R1
   \   0000000C   ....               LDR.N    R1,??DataTable43_22  ;; 0x40023840
   \   0000000E   0860               STR      R0,[R1, #+0]
   \   00000010   05E0               B.N      ??RCC_APB1PeriphClockCmd_1
    815            }
    816            else
    817            {
    818              RCC->APB1ENR &= ~RCC_APB1Periph;
   \                     ??RCC_APB1PeriphClockCmd_0:
   \   00000012   ....               LDR.N    R1,??DataTable43_22  ;; 0x40023840
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   31EA0000           BICS     R0,R1,R0
   \   0000001A   ....               LDR.N    R1,??DataTable43_22  ;; 0x40023840
   \   0000001C   0860               STR      R0,[R1, #+0]
    819            }
    820          }
   \                     ??RCC_APB1PeriphClockCmd_1:
   \   0000001E   7047               BX       LR               ;; return
    821          
    822          /**
    823            * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
    824            * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
    825            *   This parameter can be any combination of the following values:
    826            *     RCC_APB2Periph_TIM1, RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1,
    827            *     RCC_APB2Periph_USART6, RCC_APB2Periph_ADC1, RCC_APB2Periph_ADC2,
    828            *     RCC_APB2Periph_ADC3, RCC_APB2Periph_SDIO, RCC_APB2Periph_SPI1,
    829            *     RCC_APB2Periph_SYSCFG, RCC_APB2Periph_TIM9, RCC_APB2Periph_TIM10,
    830            *     RCC_APB2Periph_TIM11
    831            * @param  NewState: new state of the specified peripheral clock.
    832            *   This parameter can be: ENABLE or DISABLE.
    833            * @retval None
    834            */

   \                                 In section .text, align 2, keep-with-next
    835          void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
    836          {
    837            /* Check the parameters */
    838            assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
    839            assert_param(IS_FUNCTIONAL_STATE(NewState));
    840            if (NewState != DISABLE)
   \                     RCC_APB2PeriphClockCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   05D0               BEQ.N    ??RCC_APB2PeriphClockCmd_0
    841            {
    842              RCC->APB2ENR |= RCC_APB2Periph;
   \   00000006   ....               LDR.N    R1,??DataTable43_23  ;; 0x40023844
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   0843               ORRS     R0,R0,R1
   \   0000000C   ....               LDR.N    R1,??DataTable43_23  ;; 0x40023844
   \   0000000E   0860               STR      R0,[R1, #+0]
   \   00000010   05E0               B.N      ??RCC_APB2PeriphClockCmd_1
    843            }
    844            else
    845            {
    846              RCC->APB2ENR &= ~RCC_APB2Periph;
   \                     ??RCC_APB2PeriphClockCmd_0:
   \   00000012   ....               LDR.N    R1,??DataTable43_23  ;; 0x40023844
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   31EA0000           BICS     R0,R1,R0
   \   0000001A   ....               LDR.N    R1,??DataTable43_23  ;; 0x40023844
   \   0000001C   0860               STR      R0,[R1, #+0]
    847            }
    848          }
   \                     ??RCC_APB2PeriphClockCmd_1:
   \   0000001E   7047               BX       LR               ;; return
    849          
    850          /**
    851            * @brief  Forces or releases AHB1 peripheral reset.
    852            * @param  RCC_AHB1Periph: specifies the AHB1 peripheral to reset.
    853            *   This parameter can be any combination of the following values:
    854            *     RCC_AHB1Periph_GPIOA, RCC_AHB1Periph_GPIOB, RCC_AHB1Periph_GPIOC,
    855            *     RCC_AHB1Periph_GPIOD, RCC_AHB1Periph_GPIOE, RCC_AHB1Periph_GPIOF,
    856            *     RCC_AHB1Periph_GPIOG, RCC_AHB1Periph_GPIOH, RCC_AHB1Periph_GPIOI,
    857            *     RCC_AHB1Periph_CRC, RCC_AHB1Periph_DMA1, RCC_AHB1Periph_DMA2,
    858            *     RCC_AHB1Periph_ETH_MAC, RCC_AHB1Periph_OTG_HS
    859            * @param  NewState: new state of the specified peripheral reset.
    860            *   This parameter can be: ENABLE or DISABLE.
    861            * @retval None
    862            */

   \                                 In section .text, align 2, keep-with-next
    863          void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
    864          {
    865            /* Check the parameters */
    866            assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
    867            assert_param(IS_FUNCTIONAL_STATE(NewState));
    868            if (NewState != DISABLE)
   \                     RCC_AHB1PeriphResetCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   05D0               BEQ.N    ??RCC_AHB1PeriphResetCmd_0
    869            {
    870              RCC->AHB1RSTR |= RCC_AHB1Periph;
   \   00000006   ....               LDR.N    R1,??DataTable43_24  ;; 0x40023810
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   0843               ORRS     R0,R0,R1
   \   0000000C   ....               LDR.N    R1,??DataTable43_24  ;; 0x40023810
   \   0000000E   0860               STR      R0,[R1, #+0]
   \   00000010   05E0               B.N      ??RCC_AHB1PeriphResetCmd_1
    871            }
    872            else
    873            {
    874              RCC->AHB1RSTR &= ~RCC_AHB1Periph;
   \                     ??RCC_AHB1PeriphResetCmd_0:
   \   00000012   ....               LDR.N    R1,??DataTable43_24  ;; 0x40023810
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   31EA0000           BICS     R0,R1,R0
   \   0000001A   ....               LDR.N    R1,??DataTable43_24  ;; 0x40023810
   \   0000001C   0860               STR      R0,[R1, #+0]
    875            }
    876          }
   \                     ??RCC_AHB1PeriphResetCmd_1:
   \   0000001E   7047               BX       LR               ;; return
    877          
    878          /**
    879            * @brief  Forces or releases AHB2 peripheral reset.
    880            * @param  RCC_AHB2Periph: specifies the AHB2 peripheral to reset.
    881            *   This parameter can be any combination of the following values:
    882            *     RCC_AHB2Periph_DCMI, RCC_AHB2Periph_CRYP, RCC_AHB2Periph_HASH,
    883            *     RCC_AHB2Periph_RNG, RCC_AHB2Periph_OTG_FS
    884            * @param  NewState: new state of the specified peripheral reset.
    885            *   This parameter can be: ENABLE or DISABLE.
    886            * @retval None
    887            */

   \                                 In section .text, align 2, keep-with-next
    888          void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
    889          {
    890            /* Check the parameters */
    891            assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
    892            assert_param(IS_FUNCTIONAL_STATE(NewState));
    893            if (NewState != DISABLE)
   \                     RCC_AHB2PeriphResetCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   05D0               BEQ.N    ??RCC_AHB2PeriphResetCmd_0
    894            {
    895              RCC->AHB2RSTR |= RCC_AHB2Periph;
   \   00000006   ....               LDR.N    R1,??DataTable43_25  ;; 0x40023814
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   0843               ORRS     R0,R0,R1
   \   0000000C   ....               LDR.N    R1,??DataTable43_25  ;; 0x40023814
   \   0000000E   0860               STR      R0,[R1, #+0]
   \   00000010   05E0               B.N      ??RCC_AHB2PeriphResetCmd_1
    896            }
    897            else
    898            {
    899              RCC->AHB2RSTR &= ~RCC_AHB2Periph;
   \                     ??RCC_AHB2PeriphResetCmd_0:
   \   00000012   ....               LDR.N    R1,??DataTable43_25  ;; 0x40023814
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   31EA0000           BICS     R0,R1,R0
   \   0000001A   ....               LDR.N    R1,??DataTable43_25  ;; 0x40023814
   \   0000001C   0860               STR      R0,[R1, #+0]
    900            }
    901          }
   \                     ??RCC_AHB2PeriphResetCmd_1:
   \   0000001E   7047               BX       LR               ;; return
    902          
    903          /**
    904            * @brief  Forces or releases AHB3 peripheral reset.
    905            * @param  RCC_AHB3Periph: specifies the AHB3 peripheral to reset.
    906            *   This parameter must be: RCC_AHB3Periph_FSMC
    907            * @param  NewState: new state of the specified peripheral reset.
    908            *   This parameter can be: ENABLE or DISABLE.
    909            * @retval None
    910            */

   \                                 In section .text, align 2, keep-with-next
    911          void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
    912          {
    913            /* Check the parameters */
    914            assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
    915            assert_param(IS_FUNCTIONAL_STATE(NewState));
    916            if (NewState != DISABLE)
   \                     RCC_AHB3PeriphResetCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   05D0               BEQ.N    ??RCC_AHB3PeriphResetCmd_0
    917            {
    918              RCC->AHB3RSTR |= RCC_AHB3Periph;
   \   00000006   ....               LDR.N    R1,??DataTable43_26  ;; 0x40023818
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   0843               ORRS     R0,R0,R1
   \   0000000C   ....               LDR.N    R1,??DataTable43_26  ;; 0x40023818
   \   0000000E   0860               STR      R0,[R1, #+0]
   \   00000010   05E0               B.N      ??RCC_AHB3PeriphResetCmd_1
    919            }
    920            else
    921            {
    922              RCC->AHB3RSTR &= ~RCC_AHB3Periph;
   \                     ??RCC_AHB3PeriphResetCmd_0:
   \   00000012   ....               LDR.N    R1,??DataTable43_26  ;; 0x40023818
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   31EA0000           BICS     R0,R1,R0
   \   0000001A   ....               LDR.N    R1,??DataTable43_26  ;; 0x40023818
   \   0000001C   0860               STR      R0,[R1, #+0]
    923            }
    924          }
   \                     ??RCC_AHB3PeriphResetCmd_1:
   \   0000001E   7047               BX       LR               ;; return
    925          
    926          /**
    927            * @brief  Forces or releases Low Speed APB (APB1) peripheral reset.
    928            * @param  RCC_APB1Periph: specifies the APB1 peripheral to reset.
    929            *   This parameter can be any combination of the following values:
    930            *     RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
    931            *     RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
    932            *     RCC_APB1Periph_TIM12, RCC_APB1Periph_TIM13, RCC_APB1Periph_TIM14,
    933            *     RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
    934            *     RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_UART4,
    935            *     RCC_APB1Periph_UART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
    936            *     RCC_APB1Periph_I2C3, RCC_APB1Periph_CAN11, RCC_APB1Periph_CAN12,
    937            *     RCC_APB1Periph_PWR, RCC_APB1Periph_DAC
    938            * @param  NewState: new state of the specified peripheral clock.
    939            *   This parameter can be: ENABLE or DISABLE.
    940            * @retval None
    941            */

   \                                 In section .text, align 2, keep-with-next
    942          void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
    943          {
    944            /* Check the parameters */
    945            assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
    946            assert_param(IS_FUNCTIONAL_STATE(NewState));
    947            if (NewState != DISABLE)
   \                     RCC_APB1PeriphResetCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   05D0               BEQ.N    ??RCC_APB1PeriphResetCmd_0
    948            {
    949              RCC->APB1RSTR |= RCC_APB1Periph;
   \   00000006   ....               LDR.N    R1,??DataTable43_27  ;; 0x40023820
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   0843               ORRS     R0,R0,R1
   \   0000000C   ....               LDR.N    R1,??DataTable43_27  ;; 0x40023820
   \   0000000E   0860               STR      R0,[R1, #+0]
   \   00000010   05E0               B.N      ??RCC_APB1PeriphResetCmd_1
    950            }
    951            else
    952            {
    953              RCC->APB1RSTR &= ~RCC_APB1Periph;
   \                     ??RCC_APB1PeriphResetCmd_0:
   \   00000012   ....               LDR.N    R1,??DataTable43_27  ;; 0x40023820
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   31EA0000           BICS     R0,R1,R0
   \   0000001A   ....               LDR.N    R1,??DataTable43_27  ;; 0x40023820
   \   0000001C   0860               STR      R0,[R1, #+0]
    954            }
    955          }
   \                     ??RCC_APB1PeriphResetCmd_1:
   \   0000001E   7047               BX       LR               ;; return
    956          
    957          /**
    958            * @brief  Forces or releases High Speed APB (APB2) peripheral reset.
    959            * @param  RCC_APB2Periph: specifies the APB2 peripheral to reset.
    960            *   This parameter can be any combination of the following values:
    961            *     RCC_APB2Periph_TIM1, RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1,
    962            *     RCC_APB2Periph_USART6, RCC_APB2Periph_ADC, RCC_APB2Periph_SDIO,
    963            *     RCC_APB2Periph_SPI1, RCC_APB2Periph_SYSCFG, RCC_APB2Periph_TIM9,
    964            *     RCC_APB2Periph_TIM10, RCC_APB2Periph_TIM11
    965            * @param  NewState: new state of the specified peripheral reset.
    966            *   This parameter can be: ENABLE or DISABLE.
    967            * @retval None
    968            */

   \                                 In section .text, align 2, keep-with-next
    969          void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
    970          {
    971            /* Check the parameters */
    972            assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
    973            assert_param(IS_FUNCTIONAL_STATE(NewState));
    974            if (NewState != DISABLE)
   \                     RCC_APB2PeriphResetCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   05D0               BEQ.N    ??RCC_APB2PeriphResetCmd_0
    975            {
    976              RCC->APB2RSTR |= RCC_APB2Periph;
   \   00000006   ....               LDR.N    R1,??DataTable43_28  ;; 0x40023824
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   0843               ORRS     R0,R0,R1
   \   0000000C   ....               LDR.N    R1,??DataTable43_28  ;; 0x40023824
   \   0000000E   0860               STR      R0,[R1, #+0]
   \   00000010   05E0               B.N      ??RCC_APB2PeriphResetCmd_1
    977            }
    978            else
    979            {
    980              RCC->APB2RSTR &= ~RCC_APB2Periph;
   \                     ??RCC_APB2PeriphResetCmd_0:
   \   00000012   ....               LDR.N    R1,??DataTable43_28  ;; 0x40023824
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   31EA0000           BICS     R0,R1,R0
   \   0000001A   ....               LDR.N    R1,??DataTable43_28  ;; 0x40023824
   \   0000001C   0860               STR      R0,[R1, #+0]
    981            }
    982          }
   \                     ??RCC_APB2PeriphResetCmd_1:
   \   0000001E   7047               BX       LR               ;; return
    983          
    984          /**
    985            * @brief  Enables or disables the AHB1 peripheral clock during Low Power (Sleep) mode.
    986            * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
    987            *   This parameter can be any combination of the following values:
    988            * @param  RCC_AHB1Periph_GPIOA, RCC_AHB1Periph_GPIOB, RCC_AHB1Periph_GPIOC,
    989            *     RCC_AHB1Periph_GPIOD, RCC_AHB1Periph_GPIOE, RCC_AHB1Periph_GPIOF,
    990            *     RCC_AHB1Periph_GPIOG, RCC_AHB1Periph_GPIOH, RCC_AHB1Periph_GPIOI,
    991            *     RCC_AHB1Periph_CRC, RCC_AHB1Periph_FLITF, RCC_AHB1Periph_BKPSRAM,
    992            *     RCC_AHB1Periph_DMA1, RCC_AHB1Periph_DMA2, RCC_AHB1Periph_ETH_MAC,
    993            *     RCC_AHB1Periph_ETH_MAC_Tx, RCC_AHB1Periph_ETH_MAC_Rx,
    994            *     RCC_AHB1Periph_ETH_MAC_PTP, RCC_AHB1Periph_OTG_HS,
    995            *     RCC_AHB1Periph_OTG_HS_ULPI
    996            * @param  NewState: new state of the specified peripheral clock.
    997            *   This parameter can be: ENABLE or DISABLE.
    998            * @retval None
    999            */

   \                                 In section .text, align 2, keep-with-next
   1000          void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
   1001          {
   1002            /* Check the parameters */
   1003            assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
   1004            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1005            if (NewState != DISABLE)
   \                     RCC_AHB1PeriphClockLPModeCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   05D0               BEQ.N    ??RCC_AHB1PeriphClockLPModeCmd_0
   1006            {
   1007              RCC->AHB1LPENR |= RCC_AHB1Periph;
   \   00000006   ....               LDR.N    R1,??DataTable43_29  ;; 0x40023850
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   0843               ORRS     R0,R0,R1
   \   0000000C   ....               LDR.N    R1,??DataTable43_29  ;; 0x40023850
   \   0000000E   0860               STR      R0,[R1, #+0]
   \   00000010   05E0               B.N      ??RCC_AHB1PeriphClockLPModeCmd_1
   1008            }
   1009            else
   1010            {
   1011              RCC->AHB1LPENR &= ~RCC_AHB1Periph;
   \                     ??RCC_AHB1PeriphClockLPModeCmd_0:
   \   00000012   ....               LDR.N    R1,??DataTable43_29  ;; 0x40023850
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   31EA0000           BICS     R0,R1,R0
   \   0000001A   ....               LDR.N    R1,??DataTable43_29  ;; 0x40023850
   \   0000001C   0860               STR      R0,[R1, #+0]
   1012            }
   1013          }
   \                     ??RCC_AHB1PeriphClockLPModeCmd_1:
   \   0000001E   7047               BX       LR               ;; return
   1014          
   1015          /**
   1016            * @brief  Enables or disables the AHB2 peripheral clock during Low Power (Sleep) mode.
   1017            * @param  RCC_AHBPeriph: specifies the AHB2 peripheral to gates its clock.
   1018            *   This parameter can be any combination of the following values:
   1019            *     RCC_AHB2Periph_DCMI, RCC_AHB2Periph_CRYP, RCC_AHB2Periph_HASH,
   1020            *     RCC_AHB2Periph_RNG, RCC_AHB2Periph_OTG_FS
   1021            * @param  NewState: new state of the specified peripheral clock.
   1022            *   This parameter can be: ENABLE or DISABLE.
   1023            * @retval None
   1024            */

   \                                 In section .text, align 2, keep-with-next
   1025          void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
   1026          {
   1027            /* Check the parameters */
   1028            assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
   1029            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1030            if (NewState != DISABLE)
   \                     RCC_AHB2PeriphClockLPModeCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   05D0               BEQ.N    ??RCC_AHB2PeriphClockLPModeCmd_0
   1031            {
   1032              RCC->AHB2LPENR |= RCC_AHB2Periph;
   \   00000006   ....               LDR.N    R1,??DataTable43_30  ;; 0x40023854
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   0843               ORRS     R0,R0,R1
   \   0000000C   ....               LDR.N    R1,??DataTable43_30  ;; 0x40023854
   \   0000000E   0860               STR      R0,[R1, #+0]
   \   00000010   05E0               B.N      ??RCC_AHB2PeriphClockLPModeCmd_1
   1033            }
   1034            else
   1035            {
   1036              RCC->AHB2LPENR &= ~RCC_AHB2Periph;
   \                     ??RCC_AHB2PeriphClockLPModeCmd_0:
   \   00000012   ....               LDR.N    R1,??DataTable43_30  ;; 0x40023854
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   31EA0000           BICS     R0,R1,R0
   \   0000001A   ....               LDR.N    R1,??DataTable43_30  ;; 0x40023854
   \   0000001C   0860               STR      R0,[R1, #+0]
   1037            }
   1038          }
   \                     ??RCC_AHB2PeriphClockLPModeCmd_1:
   \   0000001E   7047               BX       LR               ;; return
   1039          
   1040          /**
   1041            * @brief  Enables or disables the AHB3 peripheral clock during Low Power (Sleep) mode.
   1042            * @param  RCC_AHBPeriph: specifies the AHB3 peripheral to gates its clock.
   1043            *   This parameter must be: RCC_AHB3Periph_FSMC
   1044            * @param  NewState: new state of the specified peripheral clock.
   1045            *   This parameter can be: ENABLE or DISABLE.
   1046            * @retval None
   1047            */

   \                                 In section .text, align 2, keep-with-next
   1048          void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
   1049          {
   1050            /* Check the parameters */
   1051            assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
   1052            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1053            if (NewState != DISABLE)
   \                     RCC_AHB3PeriphClockLPModeCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   05D0               BEQ.N    ??RCC_AHB3PeriphClockLPModeCmd_0
   1054            {
   1055              RCC->AHB3LPENR |= RCC_AHB3Periph;
   \   00000006   ....               LDR.N    R1,??DataTable43_31  ;; 0x40023858
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   0843               ORRS     R0,R0,R1
   \   0000000C   ....               LDR.N    R1,??DataTable43_31  ;; 0x40023858
   \   0000000E   0860               STR      R0,[R1, #+0]
   \   00000010   05E0               B.N      ??RCC_AHB3PeriphClockLPModeCmd_1
   1056            }
   1057            else
   1058            {
   1059              RCC->AHB3LPENR &= ~RCC_AHB3Periph;
   \                     ??RCC_AHB3PeriphClockLPModeCmd_0:
   \   00000012   ....               LDR.N    R1,??DataTable43_31  ;; 0x40023858
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   31EA0000           BICS     R0,R1,R0
   \   0000001A   ....               LDR.N    R1,??DataTable43_31  ;; 0x40023858
   \   0000001C   0860               STR      R0,[R1, #+0]
   1060            }
   1061          }
   \                     ??RCC_AHB3PeriphClockLPModeCmd_1:
   \   0000001E   7047               BX       LR               ;; return
   1062          
   1063          /**
   1064            * @brief  Enables or disables the APB1 peripheral clock during Low Power (Sleep) mode.
   1065            * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
   1066            *   This parameter can be any combination of the following values:
   1067            *     RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
   1068            *     RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
   1069            *     RCC_APB1Periph_TIM12, RCC_APB1Periph_TIM13, RCC_APB1Periph_TIM14,
   1070            *     RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
   1071            *     RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_UART4,
   1072            *     RCC_APB1Periph_UART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
   1073            *     RCC_APB1Periph_I2C3, RCC_APB1Periph_CAN11, RCC_APB1Periph_CAN12,
   1074            *     RCC_APB1Periph_PWR, RCC_APB1Periph_DAC
   1075            * @param  NewState: new state of the specified peripheral clock.
   1076            *   This parameter can be: ENABLE or DISABLE.
   1077            * @retval None
   1078            */

   \                                 In section .text, align 2, keep-with-next
   1079          void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1080          {
   1081            /* Check the parameters */
   1082            assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
   1083            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1084            if (NewState != DISABLE)
   \                     RCC_APB1PeriphClockLPModeCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   05D0               BEQ.N    ??RCC_APB1PeriphClockLPModeCmd_0
   1085            {
   1086              RCC->APB1LPENR |= RCC_APB1Periph;
   \   00000006   ....               LDR.N    R1,??DataTable43_32  ;; 0x40023860
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   0843               ORRS     R0,R0,R1
   \   0000000C   ....               LDR.N    R1,??DataTable43_32  ;; 0x40023860
   \   0000000E   0860               STR      R0,[R1, #+0]
   \   00000010   05E0               B.N      ??RCC_APB1PeriphClockLPModeCmd_1
   1087            }
   1088            else
   1089            {
   1090              RCC->APB1LPENR &= ~RCC_APB1Periph;
   \                     ??RCC_APB1PeriphClockLPModeCmd_0:
   \   00000012   ....               LDR.N    R1,??DataTable43_32  ;; 0x40023860
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   31EA0000           BICS     R0,R1,R0
   \   0000001A   ....               LDR.N    R1,??DataTable43_32  ;; 0x40023860
   \   0000001C   0860               STR      R0,[R1, #+0]
   1091            }
   1092          }
   \                     ??RCC_APB1PeriphClockLPModeCmd_1:
   \   0000001E   7047               BX       LR               ;; return
   1093          
   1094          /**
   1095            * @brief  Enables or disables the APB2 peripheral clock during Low Power (Sleep) mode.
   1096            * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
   1097            *   This parameter can be any combination of the following values:
   1098            *     RCC_APB2Periph_TIM1, RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1,
   1099            *     RCC_APB2Periph_USART6, RCC_APB2Periph_ADC1, RCC_APB2Periph_ADC2,
   1100            *     RCC_APB2Periph_ADC3, RCC_APB2Periph_SDIO, RCC_APB2Periph_SPI1,
   1101            *     RCC_APB2Periph_SYSCFG, RCC_APB2Periph_TIM9, RCC_APB2Periph_TIM10,
   1102            *     RCC_APB2Periph_TIM11
   1103            * @param  NewState: new state of the specified peripheral clock.
   1104            *   This parameter can be: ENABLE or DISABLE.
   1105            * @retval None
   1106            */

   \                                 In section .text, align 2, keep-with-next
   1107          void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   1108          {
   1109            /* Check the parameters */
   1110            assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
   1111            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1112            if (NewState != DISABLE)
   \                     RCC_APB2PeriphClockLPModeCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   05D0               BEQ.N    ??RCC_APB2PeriphClockLPModeCmd_0
   1113            {
   1114              RCC->APB2LPENR |= RCC_APB2Periph;
   \   00000006   ....               LDR.N    R1,??DataTable43_33  ;; 0x40023864
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   0843               ORRS     R0,R0,R1
   \   0000000C   ....               LDR.N    R1,??DataTable43_33  ;; 0x40023864
   \   0000000E   0860               STR      R0,[R1, #+0]
   \   00000010   05E0               B.N      ??RCC_APB2PeriphClockLPModeCmd_1
   1115            }
   1116            else
   1117            {
   1118              RCC->APB2LPENR &= ~RCC_APB2Periph;
   \                     ??RCC_APB2PeriphClockLPModeCmd_0:
   \   00000012   ....               LDR.N    R1,??DataTable43_33  ;; 0x40023864
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   31EA0000           BICS     R0,R1,R0
   \   0000001A   ....               LDR.N    R1,??DataTable43_33  ;; 0x40023864
   \   0000001C   0860               STR      R0,[R1, #+0]
   1119            }
   1120          }
   \                     ??RCC_APB2PeriphClockLPModeCmd_1:
   \   0000001E   7047               BX       LR               ;; return
   1121          
   1122          /**
   1123            * @brief  Forces or releases the Backup domain reset.
   1124            * @param  NewState: new state of the Backup domain reset.
   1125            *   This parameter can be: ENABLE or DISABLE.
   1126            * @retval None
   1127            */

   \                                 In section .text, align 2, keep-with-next
   1128          void RCC_BackupResetCmd(FunctionalState NewState)
   1129          {
   1130            /* Check the parameters */
   1131            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1132            *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
   \                     RCC_BackupResetCmd:
   \   00000000   ....               LDR.N    R1,??DataTable43_34  ;; 0x42470e40
   \   00000002   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0860               STR      R0,[R1, #+0]
   1133          }
   \   00000006   7047               BX       LR               ;; return
   1134          
   1135          /**
   1136            * @brief  Enables or disables the Clock Security System.
   1137            * @param  NewState: new state of the Clock Security System..
   1138            *   This parameter can be: ENABLE or DISABLE.
   1139            * @retval None
   1140            */

   \                                 In section .text, align 2, keep-with-next
   1141          void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
   1142          {
   1143            /* Check the parameters */
   1144            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1145            *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
   \                     RCC_ClockSecuritySystemCmd:
   \   00000000   ....               LDR.N    R1,??DataTable43_35  ;; 0x4247004c
   \   00000002   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0860               STR      R0,[R1, #+0]
   1146          }
   \   00000006   7047               BX       LR               ;; return
   1147          
   1148          /**
   1149            * @brief  Selects the clock source to output on MCO1 pin(PA8).
   1150            * @param  RCC_MCO1Source: specifies the clock source to output.
   1151            *   This parameter can be one of the following values:
   1152            *     @arg RCC_MCO1Source_HSI: HSI clock selected as MCO1 source
   1153            *     @arg RCC_MCO1Source_LSE: LSE clock selected as MCO1 source
   1154            *     @arg RCC_MCO1Source_HSE: HSE clock selected as MCO1 source
   1155            *     @arg RCC_MCO1Source_PLLCLK: main PLL clock selected as MCO1 source
   1156            * @param  RCC_MCO1Div: specifies the MCO1 prescaler.
   1157            *   This parameter can be one of the following values:
   1158            *     @arg RCC_MCO1Div_1: no division applied to MCO1 clock
   1159            *     @arg RCC_MCO1Div_2: division by 2 applied to MCO1 clock
   1160            *     @arg RCC_MCO1Div_3: division by 3 applied to MCO1 clock
   1161            *     @arg RCC_MCO1Div_4: division by 4 applied to MCO1 clock
   1162            *     @arg RCC_MCO1Div_5: division by 5 applied to MCO1 clock
   1163            * @retval None
   1164            */

   \                                 In section .text, align 2, keep-with-next
   1165          void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
   1166          {
   1167            uint32_t tmpreg = 0;
   \                     RCC_MCO1Config:
   \   00000000   0022               MOVS     R2,#+0
   1168            
   1169            /* Check the parameters */
   1170            assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
   1171            assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  
   1172          
   1173            tmpreg = RCC->CFGR;
   \   00000002   ....               LDR.N    R3,??DataTable43_1  ;; 0x40023808
   \   00000004   1B68               LDR      R3,[R3, #+0]
   \   00000006   1A00               MOVS     R2,R3
   1174          
   1175            /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
   1176            tmpreg &= CFGR_MCO1_RESET_MASK;
   \   00000008   32F0EC62           BICS     R2,R2,#0x7600000
   1177          
   1178            /* Select MCO1 clock source and prescaler */
   1179            tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
   \   0000000C   0843               ORRS     R0,R1,R0
   \   0000000E   0243               ORRS     R2,R0,R2
   1180          
   1181            /* Store the new value */
   1182            RCC->CFGR = tmpreg;  
   \   00000010   ....               LDR.N    R0,??DataTable43_1  ;; 0x40023808
   \   00000012   0260               STR      R2,[R0, #+0]
   1183          }
   \   00000014   7047               BX       LR               ;; return
   1184          
   1185          
   1186          /**
   1187            * @brief  Selects the clock source to output on MCO2 pin(PC9).
   1188            * @param  RCC_MCO2Source: specifies the clock source to output.
   1189            *   This parameter can be one of the following values:
   1190            *     @arg RCC_MCO2Source_SYSCLK: System clock (SYSCLK) selected as MCO2 source
   1191            *     @arg RCC_MCO2Source_PLLI2SCLK: PLLI2S clock selected as MCO2 source
   1192            *     @arg RCC_MCO2Source_HSE: HSE clock selected as MCO2 source
   1193            *     @arg RCC_MCO2Source_PLLCLK: main PLL clock selected as MCO2 source
   1194            * @param  RCC_MCO2Div: specifies the MCO2 prescaler.
   1195            *   This parameter can be one of the following values:
   1196            *     @arg RCC_MCO2Div_1: no division applied to MCO2 clock
   1197            *     @arg RCC_MCO2Div_2: division by 2 applied to MCO2 clock
   1198            *     @arg RCC_MCO2Div_3: division by 3 applied to MCO2 clock
   1199            *     @arg RCC_MCO2Div_4: division by 4 applied to MCO2 clock
   1200            *     @arg RCC_MCO2Div_5: division by 5 applied to MCO2 clock
   1201            * @retval None
   1202            */

   \                                 In section .text, align 2, keep-with-next
   1203          void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
   1204          {
   1205            uint32_t tmpreg = 0;
   \                     RCC_MCO2Config:
   \   00000000   0022               MOVS     R2,#+0
   1206            
   1207            /* Check the parameters */
   1208            assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
   1209            assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
   1210            
   1211            tmpreg = RCC->CFGR;
   \   00000002   ....               LDR.N    R3,??DataTable43_1  ;; 0x40023808
   \   00000004   1B68               LDR      R3,[R3, #+0]
   \   00000006   1A00               MOVS     R2,R3
   1212            
   1213            /* Clear MCO2 and MCO2PRE[2:0] bits */
   1214            tmpreg &= CFGR_MCO2_RESET_MASK;
   \   00000008   5201               LSLS     R2,R2,#+5
   \   0000000A   5209               LSRS     R2,R2,#+5
   1215          
   1216            /* Select MCO2 clock source and prescaler */
   1217            tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
   \   0000000C   0843               ORRS     R0,R1,R0
   \   0000000E   0243               ORRS     R2,R0,R2
   1218          
   1219            /* Store the new value */
   1220            RCC->CFGR = tmpreg;  
   \   00000010   ....               LDR.N    R0,??DataTable43_1  ;; 0x40023808
   \   00000012   0260               STR      R2,[R0, #+0]
   1221          }
   \   00000014   7047               BX       LR               ;; return
   1222          
   1223          
   1224          /**
   1225            * @brief  Checks whether the specified RCC flag is set or not.
   1226            * @param  RCC_FLAG: specifies the flag to check.
   1227            *   This parameter can be one of the following values:
   1228            *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready
   1229            *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
   1230            *     @arg RCC_FLAG_PLLRDY: main PLL clock ready
   1231            *     @arg RCC_FLAG_PLLI2SRDY: PLLI2S clock ready
   1232            *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
   1233            *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
   1234            *     @arg RCC_FLAG_BORRST: POR/PDR or BOR reset
   1235            *     @arg RCC_FLAG_PINRST: Pin reset
   1236            *     @arg RCC_FLAG_PORRST: POR/PDR reset
   1237            *     @arg RCC_FLAG_SFTRST: Software reset
   1238            *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
   1239            *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset
   1240            *     @arg RCC_FLAG_LPWRRST: Low Power reset
   1241            * @retval The new state of RCC_FLAG (SET or RESET).
   1242            */

   \                                 In section .text, align 2, keep-with-next
   1243          FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
   1244          {
   \                     RCC_GetFlagStatus:
   \   00000000   10B4               PUSH     {R4}
   1245            uint32_t tmp = 0;
   \   00000002   0022               MOVS     R2,#+0
   1246            uint32_t statusreg = 0;
   \   00000004   0023               MOVS     R3,#+0
   1247            FlagStatus bitstatus = RESET;
   \   00000006   0021               MOVS     R1,#+0
   1248            /* Check the parameters */
   1249            assert_param(IS_RCC_FLAG(RCC_FLAG));
   1250            /* Get the RCC register index */
   1251            tmp = RCC_FLAG >> 5;
   \   00000008   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   4409               LSRS     R4,R0,#+5
   \   0000000C   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   2200               MOVS     R2,R4
   1252            if (tmp == 1)               /* The flag to check is in CR register */
   \   00000010   012A               CMP      R2,#+1
   \   00000012   02D1               BNE.N    ??RCC_GetFlagStatus_0
   1253            {
   1254              statusreg = RCC->CR;
   \   00000014   ....               LDR.N    R1,??DataTable43  ;; 0x40023800
   \   00000016   0B68               LDR      R3,[R1, #+0]
   \   00000018   06E0               B.N      ??RCC_GetFlagStatus_1
   1255            }
   1256            else if (tmp == 2)          /* The flag to check is in BDCR register */
   \                     ??RCC_GetFlagStatus_0:
   \   0000001A   022A               CMP      R2,#+2
   \   0000001C   02D1               BNE.N    ??RCC_GetFlagStatus_2
   1257            {
   1258              statusreg = RCC->BDCR;
   \   0000001E   ....               LDR.N    R1,??DataTable43_12  ;; 0x40023870
   \   00000020   0B68               LDR      R3,[R1, #+0]
   \   00000022   01E0               B.N      ??RCC_GetFlagStatus_1
   1259            }
   1260            else                       /* The flag to check is in CSR register */
   1261            {
   1262              statusreg = RCC->CSR;
   \                     ??RCC_GetFlagStatus_2:
   \   00000024   ....               LDR.N    R1,??DataTable43_36  ;; 0x40023874
   \   00000026   0B68               LDR      R3,[R1, #+0]
   1263            }
   1264            /* Get the flag position */
   1265            tmp = RCC_FLAG & FLAG_MASK;
   \                     ??RCC_GetFlagStatus_1:
   \   00000028   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   10F01F02           ANDS     R2,R0,#0x1F
   1266            if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
   \   0000002E   0120               MOVS     R0,#+1
   \   00000030   9040               LSLS     R0,R0,R2
   \   00000032   0342               TST      R3,R0
   \   00000034   01D0               BEQ.N    ??RCC_GetFlagStatus_3
   1267            {
   1268              bitstatus = SET;
   \   00000036   0121               MOVS     R1,#+1
   \   00000038   00E0               B.N      ??RCC_GetFlagStatus_4
   1269            }
   1270            else
   1271            {
   1272              bitstatus = RESET;
   \                     ??RCC_GetFlagStatus_3:
   \   0000003A   0021               MOVS     R1,#+0
   1273            }
   1274            /* Return the flag status */
   1275            return bitstatus;
   \                     ??RCC_GetFlagStatus_4:
   \   0000003C   0800               MOVS     R0,R1
   \   0000003E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   10BC               POP      {R4}
   \   00000042   7047               BX       LR               ;; return
   1276          }
   1277          
   1278          
   1279          /**
   1280            * @brief  Clears the RCC reset flags.
   1281            *   The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST,  RCC_FLAG_SFTRST,
   1282            *   RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST
   1283            * @param  None
   1284            * @retval None
   1285            */

   \                                 In section .text, align 2, keep-with-next
   1286          void RCC_ClearFlag(void)
   1287          {
   1288            /* Set RMVF bit to clear the reset flags */
   1289            RCC->CSR |= RCC_CSR_RMVF;
   \                     RCC_ClearFlag:
   \   00000000   ....               LDR.N    R0,??DataTable43_36  ;; 0x40023874
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   50F08070           ORRS     R0,R0,#0x1000000
   \   00000008   ....               LDR.N    R1,??DataTable43_36  ;; 0x40023874
   \   0000000A   0860               STR      R0,[R1, #+0]
   1290          }
   \   0000000C   7047               BX       LR               ;; return
   1291          
   1292          
   1293          /**
   1294            * @brief  Checks whether the specified RCC interrupt has occurred or not.
   1295            * @param  RCC_IT: specifies the RCC interrupt source to check.
   1296            *   This parameter can be one of the following values:
   1297            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
   1298            *     @arg RCC_IT_LSERDY: LSE ready interrupt
   1299            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
   1300            *     @arg RCC_IT_HSERDY: HSE ready interrupt
   1301            *     @arg RCC_IT_PLLRDY: main PLL ready interrupt
   1302            *     @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt  
   1303            *     @arg RCC_IT_CSS: Clock Security System interrupt
   1304            * @retval The new state of RCC_IT (SET or RESET).
   1305            */

   \                                 In section .text, align 2, keep-with-next
   1306          ITStatus RCC_GetITStatus(uint8_t RCC_IT)
   1307          {
   1308            ITStatus bitstatus = RESET;
   \                     RCC_GetITStatus:
   \   00000000   0021               MOVS     R1,#+0
   1309            /* Check the parameters */
   1310            assert_param(IS_RCC_GET_IT(RCC_IT));
   1311            /* Check the status of the specified RCC interrupt */
   1312            if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
   \   00000002   ....               LDR.N    R2,??DataTable43_5  ;; 0x4002380c
   \   00000004   1268               LDR      R2,[R2, #+0]
   \   00000006   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0242               TST      R2,R0
   \   0000000A   01D0               BEQ.N    ??RCC_GetITStatus_0
   1313            {
   1314              bitstatus = SET;
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   00E0               B.N      ??RCC_GetITStatus_1
   1315            }
   1316            else
   1317            {
   1318              bitstatus = RESET;
   \                     ??RCC_GetITStatus_0:
   \   00000010   0021               MOVS     R1,#+0
   1319            }
   1320            /* Return the RCC_IT status */
   1321            return  bitstatus;
   \                     ??RCC_GetITStatus_1:
   \   00000012   0800               MOVS     R0,R1
   \   00000014   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   7047               BX       LR               ;; return
   1322          }
   1323          
   1324          
   1325          /**
   1326            * @brief  Clears the RCC’s interrupt pending bits.
   1327            * @param  RCC_IT: specifies the interrupt pending bit to clear.
   1328            *   This parameter can be any combination of the following values:
   1329            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
   1330            *     @arg RCC_IT_LSERDY: LSE ready interrupt
   1331            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
   1332            *     @arg RCC_IT_HSERDY: HSE ready interrupt
   1333            *     @arg RCC_IT_PLLRDY: main PLL ready interrupt
   1334            *     @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt  
   1335            *     @arg RCC_IT_CSS: Clock Security System interrupt
   1336            * @retval None
   1337            */

   \                                 In section .text, align 2, keep-with-next
   1338          void RCC_ClearITPendingBit(uint8_t RCC_IT)
   1339          {
   1340            /* Check the parameters */
   1341            assert_param(IS_RCC_CLEAR_IT(RCC_IT));
   1342            /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
   1343               pending bits */
   1344            *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
   \                     RCC_ClearITPendingBit:
   \   00000000   ....               LDR.N    R1,??DataTable43_37  ;; 0x4002380e
   \   00000002   0870               STRB     R0,[R1, #+0]
   1345          }
   \   00000004   7047               BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43:
   \   00000000   00380240           DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_1:
   \   00000000   08380240           DC32     0x40023808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_2:
   \   00000000   FFFFF6FE           DC32     0xfef6ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_3:
   \   00000000   04380240           DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_4:
   \   00000000   10300024           DC32     0x24003010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_5:
   \   00000000   0C380240           DC32     0x4002380c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_6:
   \   00000000   02380240           DC32     0x40023802

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_7:
   \   00000000   00004742           DC32     0x42470000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_8:
   \   00000000   60004742           DC32     0x42470060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_9:
   \   00000000   68004742           DC32     0x42470068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_10:
   \   00000000   84380240           DC32     0x40023884

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_11:
   \   00000000   0D380240           DC32     0x4002380d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_12:
   \   00000000   70380240           DC32     0x40023870

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_13:
   \   00000000   800E4742           DC32     0x42470e80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_14:
   \   00000000   FFFCFF0F           DC32     0xffffcff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_15:
   \   00000000   3C0E4742           DC32     0x42470e3c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_16:
   \   00000000   5C014742           DC32     0x4247015c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_17:
   \   00000000   0024F400           DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_18:
   \   00000000   00127A00           DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_19:
   \   00000000   30380240           DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_20:
   \   00000000   34380240           DC32     0x40023834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_21:
   \   00000000   38380240           DC32     0x40023838

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_22:
   \   00000000   40380240           DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_23:
   \   00000000   44380240           DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_24:
   \   00000000   10380240           DC32     0x40023810

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_25:
   \   00000000   14380240           DC32     0x40023814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_26:
   \   00000000   18380240           DC32     0x40023818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_27:
   \   00000000   20380240           DC32     0x40023820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_28:
   \   00000000   24380240           DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_29:
   \   00000000   50380240           DC32     0x40023850

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_30:
   \   00000000   54380240           DC32     0x40023854

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_31:
   \   00000000   58380240           DC32     0x40023858

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_32:
   \   00000000   60380240           DC32     0x40023860

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_33:
   \   00000000   64380240           DC32     0x40023864

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_34:
   \   00000000   400E4742           DC32     0x42470e40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_35:
   \   00000000   4C004742           DC32     0x4247004c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_36:
   \   00000000   74380240           DC32     0x40023874

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_37:
   \   00000000   0E380240           DC32     0x4002380e
   1346          /**
   1347            * @}
   1348            */ 
   1349          
   1350          
   1351          /**
   1352            * @}
   1353            */ 
   1354          
   1355          
   1356          /**
   1357            * @}
   1358            */ 
   1359          
   1360          
   1361          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                      .cstack
     --------                      -------
     RCC_AHB1PeriphClockCmd             0
     RCC_AHB1PeriphClockLPModeCmd       0
     RCC_AHB1PeriphResetCmd             0
     RCC_AHB2PeriphClockCmd             0
     RCC_AHB2PeriphClockLPModeCmd       0
     RCC_AHB2PeriphResetCmd             0
     RCC_AHB3PeriphClockCmd             0
     RCC_AHB3PeriphClockLPModeCmd       0
     RCC_AHB3PeriphResetCmd             0
     RCC_APB1PeriphClockCmd             0
     RCC_APB1PeriphClockLPModeCmd       0
     RCC_APB1PeriphResetCmd             0
     RCC_APB2PeriphClockCmd             0
     RCC_APB2PeriphClockLPModeCmd       0
     RCC_APB2PeriphResetCmd             0
     RCC_AdjustHSICalibrationValue      0
     RCC_BackupResetCmd                 0
     RCC_ClearFlag                      0
     RCC_ClearITPendingBit              0
     RCC_ClockSecuritySystemCmd         0
     RCC_DeInit                         0
     RCC_GetClocksFreq                 16
     RCC_GetFlagStatus                  4
     RCC_GetITStatus                    0
     RCC_GetSYSCLKSource                0
     RCC_HCLKConfig                     0
     RCC_HSEConfig                      0
     RCC_HSICmd                         0
     RCC_I2SCLKConfig                   0
     RCC_ITConfig                       0
     RCC_LSEConfig                      0
     RCC_LSICmd                         0
     RCC_MCO1Config                     0
     RCC_MCO2Config                     0
     RCC_PCLK1Config                    0
     RCC_PCLK2Config                    0
     RCC_PLLCmd                         0
     RCC_PLLConfig                      8
     RCC_PLLI2SCmd                      0
     RCC_PLLI2SConfig                   0
     RCC_RTCCLKCmd                      0
     RCC_RTCCLKConfig                   0
     RCC_SYSCLKConfig                   0
     RCC_WaitForHSEStartUp              8


   Section sizes:

     Function/Label                Bytes
     --------------                -----
     APBAHBPrescTable                16
     RCC_DeInit                      78
     RCC_HSEConfig                   16
     RCC_WaitForHSEStartUp           58
     RCC_AdjustHSICalibrationValue   28
     RCC_HSICmd                      10
     RCC_PLLCmd                      10
     RCC_PLLConfig                   38
     RCC_PLLI2SCmd                   10
     RCC_PLLI2SConfig                14
     RCC_SYSCLKConfig                24
     RCC_GetSYSCLKSource             12
     RCC_HCLKConfig                  24
     RCC_PCLK1Config                 24
     RCC_PCLK2Config                 26
     RCC_ITConfig                    40
     RCC_LSEConfig                   50
     RCC_LSICmd                      10
     RCC_RTCCLKConfig                60
     RCC_RTCCLKCmd                   10
     RCC_I2SCLKConfig                 8
     RCC_GetClocksFreq              224
     RCC_AHB1PeriphClockCmd          32
     RCC_AHB2PeriphClockCmd          32
     RCC_AHB3PeriphClockCmd          32
     RCC_APB1PeriphClockCmd          32
     RCC_APB2PeriphClockCmd          32
     RCC_AHB1PeriphResetCmd          32
     RCC_AHB2PeriphResetCmd          32
     RCC_AHB3PeriphResetCmd          32
     RCC_APB1PeriphResetCmd          32
     RCC_APB2PeriphResetCmd          32
     RCC_AHB1PeriphClockLPModeCmd    32
     RCC_AHB2PeriphClockLPModeCmd    32
     RCC_AHB3PeriphClockLPModeCmd    32
     RCC_APB1PeriphClockLPModeCmd    32
     RCC_APB2PeriphClockLPModeCmd    32
     RCC_BackupResetCmd               8
     RCC_ClockSecuritySystemCmd       8
     RCC_MCO1Config                  22
     RCC_MCO2Config                  22
     RCC_GetFlagStatus               68
     RCC_ClearFlag                   14
     RCC_GetITStatus                 24
     RCC_ClearITPendingBit            6
     ??DataTable43                    4
     ??DataTable43_1                  4
     ??DataTable43_2                  4
     ??DataTable43_3                  4
     ??DataTable43_4                  4
     ??DataTable43_5                  4
     ??DataTable43_6                  4
     ??DataTable43_7                  4
     ??DataTable43_8                  4
     ??DataTable43_9                  4
     ??DataTable43_10                 4
     ??DataTable43_11                 4
     ??DataTable43_12                 4
     ??DataTable43_13                 4
     ??DataTable43_14                 4
     ??DataTable43_15                 4
     ??DataTable43_16                 4
     ??DataTable43_17                 4
     ??DataTable43_18                 4
     ??DataTable43_19                 4
     ??DataTable43_20                 4
     ??DataTable43_21                 4
     ??DataTable43_22                 4
     ??DataTable43_23                 4
     ??DataTable43_24                 4
     ??DataTable43_25                 4
     ??DataTable43_26                 4
     ??DataTable43_27                 4
     ??DataTable43_28                 4
     ??DataTable43_29                 4
     ??DataTable43_30                 4
     ??DataTable43_31                 4
     ??DataTable43_32                 4
     ??DataTable43_33                 4
     ??DataTable43_34                 4
     ??DataTable43_35                 4
     ??DataTable43_36                 4
     ??DataTable43_37                 4

 
 1 594 bytes in section .text
 
 1 594 bytes of CODE memory

Errors: none
Warnings: none
