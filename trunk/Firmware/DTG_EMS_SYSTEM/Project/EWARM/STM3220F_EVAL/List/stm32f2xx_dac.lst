###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     19/Jan/2012  11:09:10 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32F #
#                    2xx_StdPeriph_Driver\src\stm32f2xx_dac.c                 #
#    Command line =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32F #
#                    2xx_StdPeriph_Driver\src\stm32f2xx_dac.c -D              #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D RTC_CLOCK_SOURCE_LSE -lC            #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\ -lA F:\Work\S&G2000\Firmware\DTG_EMS_S #
#                    YSTEM\Project\EWARM\STM3220F_EVAL\List\ -o               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\Obj\ --no_cse --no_unroll --no_inline        #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\ #
#                    EWARM\..\ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Pro #
#                    ject\EWARM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I     #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I         #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\ -I                             #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\Common\ -I                      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_OTG_Driver\inc\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Core\inc\ -I      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\msc\inc\    #
#                    -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM #
#                    \..\Usb\ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Proj #
#                    ect\EWARM\..\Usb\Inc\ -I F:\Work\S&G2000\Firmware\DTG_EM #
#                    S_SYSTEM\Project\EWARM\..\Usb\src\ -I                    #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Core\inc\ -I        #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -Ol --use_c++_inline                                     #
#    List file    =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\stm32f2xx_dac.lst                       #
#    Object file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\Obj\stm32f2xx_dac.o                          #
#                                                                             #
#                                                                             #
###############################################################################

F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_dac.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_dac.c
      4            * @author  MCD Application Team
      5            * @version V0.0.4
      6            * @date    13-January-2011
      7            * @brief   This file provides all the DAC firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f2xx_dac.h"
     24          #include "stm32f2xx_rcc.h"
     25          
     26          /** @addtogroup STM32F2xx_StdPeriph_Driver
     27            * @{
     28            */
     29          
     30          /** @defgroup DAC 
     31            * @brief DAC driver modules
     32            * @{
     33            */ 
     34          
     35          /** @defgroup DAC_Private_TypesDefinitions
     36            * @{
     37            */
     38          
     39          /**
     40            * @}
     41            */
     42          
     43          /** @defgroup DAC_Private_Defines
     44            * @{
     45            */
     46          
     47          /* CR register Mask */
     48          #define CR_CLEAR_MASK              ((uint32_t)0x00000FFE)
     49          /* DAC Dual Channels SWTRIG masks */
     50          #define DUAL_SWTRIG_SET            ((uint32_t)0x00000003)
     51          #define DUAL_SWTRIG_RESET          ((uint32_t)0xFFFFFFFC)
     52          /* DHR registers offsets */
     53          #define DHR12R1_OFFSET             ((uint32_t)0x00000008)
     54          #define DHR12R2_OFFSET             ((uint32_t)0x00000014)
     55          #define DHR12RD_OFFSET             ((uint32_t)0x00000020)
     56          /* DOR register offset */
     57          #define DOR_OFFSET                 ((uint32_t)0x0000002C)
     58          /**
     59            * @}
     60            */
     61          
     62          /** @defgroup DAC_Private_Macros
     63            * @{
     64            */
     65          
     66          /**
     67            * @}
     68            */
     69          
     70          /** @defgroup DAC_Private_Variables
     71            * @{
     72            */
     73          
     74          /**
     75            * @}
     76            */
     77          
     78          /** @defgroup DAC_Private_FunctionPrototypes
     79            * @{
     80            */
     81          
     82          /**
     83            * @}
     84            */
     85          
     86          /** @defgroup DAC_Private_Functions
     87            * @{
     88            */
     89          
     90          /**
     91            * @brief  Deinitializes the DAC peripheral registers to their default reset values.
     92            * @param  None
     93            * @retval None
     94            */

   \                                 In section .text, align 2, keep-with-next
     95          void DAC_DeInit(void)
     96          {
   \                     DAC_DeInit:
   \   00000000   80B5               PUSH     {R7,LR}
     97            /* Enable DAC reset state */
     98            RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   5FF00050           MOVS     R0,#+536870912
   \   00000008   ........           BL       RCC_APB1PeriphResetCmd
     99            /* Release DAC from reset state */
    100            RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   5FF00050           MOVS     R0,#+536870912
   \   00000012   ........           BL       RCC_APB1PeriphResetCmd
    101          }
   \   00000016   01BD               POP      {R0,PC}          ;; return
    102          
    103          /**
    104            * @brief  Initializes the DAC peripheral according to the specified 
    105            *   parameters in the DAC_InitStruct.
    106            * @param  DAC_Channel: the selected DAC channel. 
    107            *   This parameter can be one of the following values:
    108            *     @arg DAC_Channel_1: DAC Channel1 selected
    109            *     @arg DAC_Channel_2: DAC Channel2 selected
    110            * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure that
    111            *   contains the configuration information for the specified DAC channel.
    112            * @retval None
    113            */

   \                                 In section .text, align 2, keep-with-next
    114          void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
    115          {
   \                     DAC_Init:
   \   00000000   30B4               PUSH     {R4,R5}
    116            uint32_t tmpreg1 = 0, tmpreg2 = 0;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   0022               MOVS     R2,#+0
    117            /* Check the DAC parameters */
    118            assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
    119            assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
    120            assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
    121            assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
    122          /*---------------------------- DAC CR Configuration --------------------------*/
    123            /* Get the DAC CR value */
    124            tmpreg1 = DAC->CR;
   \   00000006   ....               LDR.N    R4,??DataTable14  ;; 0x40007400
   \   00000008   2468               LDR      R4,[R4, #+0]
   \   0000000A   2300               MOVS     R3,R4
    125            /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
    126            tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
   \   0000000C   40F6FE74           MOVW     R4,#+4094
   \   00000010   8440               LSLS     R4,R4,R0
   \   00000012   A343               BICS     R3,R3,R4
    127            /* Configure for the selected DAC channel: buffer output, trigger, wave genration,
    128               mask/amplitude for wave genration */
    129            /* Set TSELx and TENx bits according to DAC_Trigger value */
    130            /* Set WAVEx bits according to DAC_WaveGeneration value */
    131            /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
    132            /* Set BOFFx bit according to DAC_OutputBuffer value */   
    133            tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
    134                       DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | DAC_InitStruct->DAC_OutputBuffer);
   \   00000014   0C68               LDR      R4,[R1, #+0]
   \   00000016   4D68               LDR      R5,[R1, #+4]
   \   00000018   2C43               ORRS     R4,R5,R4
   \   0000001A   8D68               LDR      R5,[R1, #+8]
   \   0000001C   2C43               ORRS     R4,R5,R4
   \   0000001E   C968               LDR      R1,[R1, #+12]
   \   00000020   2143               ORRS     R1,R1,R4
   \   00000022   0A00               MOVS     R2,R1
    135            /* Calculate CR register value depending on DAC_Channel */
    136            tmpreg1 |= tmpreg2 << DAC_Channel;
   \   00000024   12FA00F0           LSLS     R0,R2,R0
   \   00000028   0343               ORRS     R3,R0,R3
    137            /* Write to DAC CR */
    138            DAC->CR = tmpreg1;
   \   0000002A   ....               LDR.N    R0,??DataTable14  ;; 0x40007400
   \   0000002C   0360               STR      R3,[R0, #+0]
    139          }
   \   0000002E   30BC               POP      {R4,R5}
   \   00000030   7047               BX       LR               ;; return
    140          
    141          /**
    142            * @brief  Fills each DAC_InitStruct member with its default value.
    143            * @param  DAC_InitStruct : pointer to a DAC_InitTypeDef structure which will
    144            *   be initialized.
    145            * @retval None
    146            */

   \                                 In section .text, align 2, keep-with-next
    147          void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
    148          {
    149          /*--------------- Reset DAC init structure parameters values -----------------*/
    150            /* Initialize the DAC_Trigger member */
    151            DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
   \                     DAC_StructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0160               STR      R1,[R0, #+0]
    152            /* Initialize the DAC_WaveGeneration member */
    153            DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   4160               STR      R1,[R0, #+4]
    154            /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
    155            DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   8160               STR      R1,[R0, #+8]
    156            /* Initialize the DAC_OutputBuffer member */
    157            DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   C160               STR      R1,[R0, #+12]
    158          }
   \   00000010   7047               BX       LR               ;; return
    159          
    160          /**
    161            * @brief  Enables or disables the specified DAC channel.
    162            * @param  DAC_Channel: the selected DAC channel. 
    163            *   This parameter can be one of the following values:
    164            *     @arg DAC_Channel_1: DAC Channel1 selected
    165            *     @arg DAC_Channel_2: DAC Channel2 selected
    166            * @param  NewState: new state of the DAC channel. 
    167            *   This parameter can be: ENABLE or DISABLE.
    168            * @retval None
    169            */

   \                                 In section .text, align 2, keep-with-next
    170          void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
    171          {
    172            /* Check the parameters */
    173            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    174            assert_param(IS_FUNCTIONAL_STATE(NewState));
    175            if (NewState != DISABLE)
   \                     DAC_Cmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   08D0               BEQ.N    ??DAC_Cmd_0
    176            {
    177              /* Enable the selected DAC channel */
    178              DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
   \   00000006   ....               LDR.N    R1,??DataTable14  ;; 0x40007400
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   0122               MOVS     R2,#+1
   \   0000000C   12FA00F0           LSLS     R0,R2,R0
   \   00000010   0843               ORRS     R0,R0,R1
   \   00000012   ....               LDR.N    R1,??DataTable14  ;; 0x40007400
   \   00000014   0860               STR      R0,[R1, #+0]
   \   00000016   08E0               B.N      ??DAC_Cmd_1
    179            }
    180            else
    181            {
    182              /* Disable the selected DAC channel */
    183              DAC->CR &= (~(DAC_CR_EN1 << DAC_Channel));
   \                     ??DAC_Cmd_0:
   \   00000018   ....               LDR.N    R1,??DataTable14  ;; 0x40007400
   \   0000001A   0968               LDR      R1,[R1, #+0]
   \   0000001C   0122               MOVS     R2,#+1
   \   0000001E   12FA00F0           LSLS     R0,R2,R0
   \   00000022   31EA0000           BICS     R0,R1,R0
   \   00000026   ....               LDR.N    R1,??DataTable14  ;; 0x40007400
   \   00000028   0860               STR      R0,[R1, #+0]
    184            }
    185          }
   \                     ??DAC_Cmd_1:
   \   0000002A   7047               BX       LR               ;; return
    186          
    187          /**
    188            * @brief  Enables or disables the specified DAC interrupts.
    189            * @param  DAC_Channel: the selected DAC channel. 
    190            *   This parameter can be one of the following values:
    191            *     @arg DAC_Channel_1: DAC Channel1 selected
    192            *     @arg DAC_Channel_2: DAC Channel2 selected
    193            * @param  DAC_IT: specifies the DAC interrupt sources to be enabled or disabled. 
    194            *   This parameter can be the following values:
    195            *     @arg DAC_IT_DMAUDR: DMA underrun interrupt mask                      
    196            * @param  NewState: new state of the specified DAC interrupts.
    197            *   This parameter can be: ENABLE or DISABLE.
    198            * @retval None
    199            */ 

   \                                 In section .text, align 2, keep-with-next
    200          void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState)  
    201          {
    202            /* Check the parameters */
    203            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    204            assert_param(IS_FUNCTIONAL_STATE(NewState));
    205            assert_param(IS_DAC_IT(DAC_IT)); 
    206          
    207            if (NewState != DISABLE)
   \                     DAC_ITConfig:
   \   00000000   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   002A               CMP      R2,#+0
   \   00000004   07D0               BEQ.N    ??DAC_ITConfig_0
    208            {
    209              /* Enable the selected DAC interrupts */
    210              DAC->CR |=  (DAC_IT << DAC_Channel);
   \   00000006   ....               LDR.N    R2,??DataTable14  ;; 0x40007400
   \   00000008   1268               LDR      R2,[R2, #+0]
   \   0000000A   11FA00F0           LSLS     R0,R1,R0
   \   0000000E   1043               ORRS     R0,R0,R2
   \   00000010   ....               LDR.N    R1,??DataTable14  ;; 0x40007400
   \   00000012   0860               STR      R0,[R1, #+0]
   \   00000014   07E0               B.N      ??DAC_ITConfig_1
    211            }
    212            else
    213            {
    214              /* Disable the selected DAC interrupts */
    215              DAC->CR &= (~(uint32_t)(DAC_IT << DAC_Channel));
   \                     ??DAC_ITConfig_0:
   \   00000016   ....               LDR.N    R2,??DataTable14  ;; 0x40007400
   \   00000018   1268               LDR      R2,[R2, #+0]
   \   0000001A   11FA00F0           LSLS     R0,R1,R0
   \   0000001E   32EA0000           BICS     R0,R2,R0
   \   00000022   ....               LDR.N    R1,??DataTable14  ;; 0x40007400
   \   00000024   0860               STR      R0,[R1, #+0]
    216            }
    217          }
   \                     ??DAC_ITConfig_1:
   \   00000026   7047               BX       LR               ;; return
    218          
    219          
    220          /**
    221            * @brief  Enables or disables the specified DAC channel DMA request.
    222            * @param  DAC_Channel: the selected DAC channel. 
    223            *   This parameter can be one of the following values:
    224            *     @arg DAC_Channel_1: DAC Channel1 selected
    225            *     @arg DAC_Channel_2: DAC Channel2 selected
    226            * @param  NewState: new state of the selected DAC channel DMA request.
    227            *   This parameter can be: ENABLE or DISABLE.
    228            * @retval None
    229            */

   \                                 In section .text, align 2, keep-with-next
    230          void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
    231          {
    232            /* Check the parameters */
    233            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    234            assert_param(IS_FUNCTIONAL_STATE(NewState));
    235            if (NewState != DISABLE)
   \                     DAC_DMACmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   09D0               BEQ.N    ??DAC_DMACmd_0
    236            {
    237              /* Enable the selected DAC channel DMA request */
    238              DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
   \   00000006   ....               LDR.N    R1,??DataTable14  ;; 0x40007400
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   4FF48052           MOV      R2,#+4096
   \   0000000E   12FA00F0           LSLS     R0,R2,R0
   \   00000012   0843               ORRS     R0,R0,R1
   \   00000014   ....               LDR.N    R1,??DataTable14  ;; 0x40007400
   \   00000016   0860               STR      R0,[R1, #+0]
   \   00000018   09E0               B.N      ??DAC_DMACmd_1
    239            }
    240            else
    241            {
    242              /* Disable the selected DAC channel DMA request */
    243              DAC->CR &= (~(DAC_CR_DMAEN1 << DAC_Channel));
   \                     ??DAC_DMACmd_0:
   \   0000001A   ....               LDR.N    R1,??DataTable14  ;; 0x40007400
   \   0000001C   0968               LDR      R1,[R1, #+0]
   \   0000001E   4FF48052           MOV      R2,#+4096
   \   00000022   12FA00F0           LSLS     R0,R2,R0
   \   00000026   31EA0000           BICS     R0,R1,R0
   \   0000002A   ....               LDR.N    R1,??DataTable14  ;; 0x40007400
   \   0000002C   0860               STR      R0,[R1, #+0]
    244            }
    245          }
   \                     ??DAC_DMACmd_1:
   \   0000002E   7047               BX       LR               ;; return
    246          
    247          /**
    248            * @brief  Enables or disables the selected DAC channel software trigger.
    249            * @param  DAC_Channel: the selected DAC channel. 
    250            *   This parameter can be one of the following values:
    251            *     @arg DAC_Channel_1: DAC Channel1 selected
    252            *     @arg DAC_Channel_2: DAC Channel2 selected
    253            * @param  NewState: new state of the selected DAC channel software trigger.
    254            *   This parameter can be: ENABLE or DISABLE.
    255            * @retval None
    256            */

   \                                 In section .text, align 2, keep-with-next
    257          void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
    258          {
    259            /* Check the parameters */
    260            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    261            assert_param(IS_FUNCTIONAL_STATE(NewState));
    262            if (NewState != DISABLE)
   \                     DAC_SoftwareTriggerCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   09D0               BEQ.N    ??DAC_SoftwareTriggerCmd_0
    263            {
    264              /* Enable software trigger for the selected DAC channel */
    265              DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
   \   00000006   ....               LDR.N    R1,??DataTable14_1  ;; 0x40007404
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   0122               MOVS     R2,#+1
   \   0000000C   0009               LSRS     R0,R0,#+4
   \   0000000E   12FA00F0           LSLS     R0,R2,R0
   \   00000012   0843               ORRS     R0,R0,R1
   \   00000014   ....               LDR.N    R1,??DataTable14_1  ;; 0x40007404
   \   00000016   0860               STR      R0,[R1, #+0]
   \   00000018   09E0               B.N      ??DAC_SoftwareTriggerCmd_1
    266            }
    267            else
    268            {
    269              /* Disable software trigger for the selected DAC channel */
    270              DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
   \                     ??DAC_SoftwareTriggerCmd_0:
   \   0000001A   ....               LDR.N    R1,??DataTable14_1  ;; 0x40007404
   \   0000001C   0968               LDR      R1,[R1, #+0]
   \   0000001E   0122               MOVS     R2,#+1
   \   00000020   0009               LSRS     R0,R0,#+4
   \   00000022   12FA00F0           LSLS     R0,R2,R0
   \   00000026   31EA0000           BICS     R0,R1,R0
   \   0000002A   ....               LDR.N    R1,??DataTable14_1  ;; 0x40007404
   \   0000002C   0860               STR      R0,[R1, #+0]
    271            }
    272          }
   \                     ??DAC_SoftwareTriggerCmd_1:
   \   0000002E   7047               BX       LR               ;; return
    273          
    274          /**
    275            * @brief  Enables or disables simultaneously the two DAC channels software
    276            *   triggers.
    277            * @param  NewState: new state of the DAC channels software triggers.
    278            *   This parameter can be: ENABLE or DISABLE.
    279            * @retval None
    280            */

   \                                 In section .text, align 2, keep-with-next
    281          void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
    282          {
    283            /* Check the parameters */
    284            assert_param(IS_FUNCTIONAL_STATE(NewState));
    285            if (NewState != DISABLE)
   \                     DAC_DualSoftwareTriggerCmd:
   \   00000000   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0028               CMP      R0,#+0
   \   00000004   06D0               BEQ.N    ??DAC_DualSoftwareTriggerCmd_0
    286            {
    287              /* Enable software trigger for both DAC channels */
    288              DAC->SWTRIGR |= DUAL_SWTRIG_SET ;
   \   00000006   ....               LDR.N    R0,??DataTable14_1  ;; 0x40007404
   \   00000008   0068               LDR      R0,[R0, #+0]
   \   0000000A   50F00300           ORRS     R0,R0,#0x3
   \   0000000E   ....               LDR.N    R1,??DataTable14_1  ;; 0x40007404
   \   00000010   0860               STR      R0,[R1, #+0]
   \   00000012   05E0               B.N      ??DAC_DualSoftwareTriggerCmd_1
    289            }
    290            else
    291            {
    292              /* Disable software trigger for both DAC channels */
    293              DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
   \                     ??DAC_DualSoftwareTriggerCmd_0:
   \   00000014   ....               LDR.N    R0,??DataTable14_1  ;; 0x40007404
   \   00000016   0068               LDR      R0,[R0, #+0]
   \   00000018   8008               LSRS     R0,R0,#+2
   \   0000001A   8000               LSLS     R0,R0,#+2
   \   0000001C   ....               LDR.N    R1,??DataTable14_1  ;; 0x40007404
   \   0000001E   0860               STR      R0,[R1, #+0]
    294            }
    295          }
   \                     ??DAC_DualSoftwareTriggerCmd_1:
   \   00000020   7047               BX       LR               ;; return
    296          
    297          /**
    298            * @brief  Enables or disables the selected DAC channel wave generation.
    299            * @param  DAC_Channel: the selected DAC channel. 
    300            *   This parameter can be one of the following values:
    301            *     @arg DAC_Channel_1: DAC Channel1 selected
    302            *     @arg DAC_Channel_2: DAC Channel2 selected
    303            * @param  DAC_Wave: Specifies the wave type to enable or disable.
    304            *   This parameter can be one of the following values:
    305            *     @arg DAC_Wave_Noise: noise wave generation
    306            *     @arg DAC_Wave_Triangle: triangle wave generation
    307            * @param  NewState: new state of the selected DAC channel wave generation.
    308            *   This parameter can be: ENABLE or DISABLE.
    309            * @retval None
    310            */

   \                                 In section .text, align 2, keep-with-next
    311          void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
    312          {
    313            /* Check the parameters */
    314            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    315            assert_param(IS_DAC_WAVE(DAC_Wave)); 
    316            assert_param(IS_FUNCTIONAL_STATE(NewState));
    317            if (NewState != DISABLE)
   \                     DAC_WaveGenerationCmd:
   \   00000000   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   002A               CMP      R2,#+0
   \   00000004   07D0               BEQ.N    ??DAC_WaveGenerationCmd_0
    318            {
    319              /* Enable the selected wave generation for the selected DAC channel */
    320              DAC->CR |= DAC_Wave << DAC_Channel;
   \   00000006   ....               LDR.N    R2,??DataTable14  ;; 0x40007400
   \   00000008   1268               LDR      R2,[R2, #+0]
   \   0000000A   11FA00F0           LSLS     R0,R1,R0
   \   0000000E   1043               ORRS     R0,R0,R2
   \   00000010   ....               LDR.N    R1,??DataTable14  ;; 0x40007400
   \   00000012   0860               STR      R0,[R1, #+0]
   \   00000014   07E0               B.N      ??DAC_WaveGenerationCmd_1
    321            }
    322            else
    323            {
    324              /* Disable the selected wave generation for the selected DAC channel */
    325              DAC->CR &= ~(DAC_Wave << DAC_Channel);
   \                     ??DAC_WaveGenerationCmd_0:
   \   00000016   ....               LDR.N    R2,??DataTable14  ;; 0x40007400
   \   00000018   1268               LDR      R2,[R2, #+0]
   \   0000001A   11FA00F0           LSLS     R0,R1,R0
   \   0000001E   32EA0000           BICS     R0,R2,R0
   \   00000022   ....               LDR.N    R1,??DataTable14  ;; 0x40007400
   \   00000024   0860               STR      R0,[R1, #+0]
    326            }
    327          }
   \                     ??DAC_WaveGenerationCmd_1:
   \   00000026   7047               BX       LR               ;; return
    328          
    329          /**
    330            * @brief  Set the specified data holding register value for DAC channel1.
    331            * @param  DAC_Align: Specifies the data alignement for DAC channel1.
    332            *   This parameter can be one of the following values:
    333            *     @arg DAC_Align_8b_R: 8bit right data alignement selected
    334            *     @arg DAC_Align_12b_L: 12bit left data alignement selected
    335            *     @arg DAC_Align_12b_R: 12bit right data alignement selected
    336            * @param  Data : Data to be loaded in the selected data holding register.
    337            * @retval None
    338            */

   \                                 In section .text, align 2, keep-with-next
    339          void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
    340          {  
   \                     DAC_SetChannel1Data:
   \   00000000   81B0               SUB      SP,SP,#+4
    341            __IO uint32_t tmp = 0;
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   0092               STR      R2,[SP, #+0]
    342            
    343            /* Check the parameters */
    344            assert_param(IS_DAC_ALIGN(DAC_Align));
    345            assert_param(IS_DAC_DATA(Data));
    346            
    347            tmp = (uint32_t)DAC_BASE; 
   \   00000006   ....               LDR.N    R2,??DataTable14  ;; 0x40007400
   \   00000008   0092               STR      R2,[SP, #+0]
    348            tmp += DHR12R1_OFFSET + DAC_Align;
   \   0000000A   009A               LDR      R2,[SP, #+0]
   \   0000000C   0830               ADDS     R0,R0,#+8
   \   0000000E   8018               ADDS     R0,R0,R2
   \   00000010   0090               STR      R0,[SP, #+0]
    349          
    350            /* Set the DAC channel1 selected data holding register */
    351            *(__IO uint32_t *) tmp = Data;
   \   00000012   0098               LDR      R0,[SP, #+0]
   \   00000014   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000016   0160               STR      R1,[R0, #+0]
    352          }
   \   00000018   01B0               ADD      SP,SP,#+4
   \   0000001A   7047               BX       LR               ;; return
    353          
    354          /**
    355            * @brief  Set the specified data holding register value for DAC channel2.
    356            * @param  DAC_Align: Specifies the data alignement for DAC channel2.
    357            *   This parameter can be one of the following values:
    358            *     @arg DAC_Align_8b_R: 8bit right data alignement selected
    359            *     @arg DAC_Align_12b_L: 12bit left data alignement selected
    360            *     @arg DAC_Align_12b_R: 12bit right data alignement selected
    361            * @param  Data : Data to be loaded in the selected data holding register.
    362            * @retval None
    363            */

   \                                 In section .text, align 2, keep-with-next
    364          void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
    365          {
   \                     DAC_SetChannel2Data:
   \   00000000   81B0               SUB      SP,SP,#+4
    366            __IO uint32_t tmp = 0;
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   0092               STR      R2,[SP, #+0]
    367          
    368            /* Check the parameters */
    369            assert_param(IS_DAC_ALIGN(DAC_Align));
    370            assert_param(IS_DAC_DATA(Data));
    371            
    372            tmp = (uint32_t)DAC_BASE;
   \   00000006   ....               LDR.N    R2,??DataTable14  ;; 0x40007400
   \   00000008   0092               STR      R2,[SP, #+0]
    373            tmp += DHR12R2_OFFSET + DAC_Align;
   \   0000000A   009A               LDR      R2,[SP, #+0]
   \   0000000C   1430               ADDS     R0,R0,#+20
   \   0000000E   8018               ADDS     R0,R0,R2
   \   00000010   0090               STR      R0,[SP, #+0]
    374          
    375            /* Set the DAC channel2 selected data holding register */
    376            *(__IO uint32_t *)tmp = Data;
   \   00000012   0098               LDR      R0,[SP, #+0]
   \   00000014   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000016   0160               STR      R1,[R0, #+0]
    377          }
   \   00000018   01B0               ADD      SP,SP,#+4
   \   0000001A   7047               BX       LR               ;; return
    378          
    379          /**
    380            * @brief  Set the specified data holding register value for dual channel
    381            *   DAC.
    382            * @param  DAC_Align: Specifies the data alignement for dual channel DAC.
    383            *   This parameter can be one of the following values:
    384            *     @arg DAC_Align_8b_R: 8bit right data alignement selected
    385            *     @arg DAC_Align_12b_L: 12bit left data alignement selected
    386            *     @arg DAC_Align_12b_R: 12bit right data alignement selected
    387            * @param  Data2: Data for DAC Channel2 to be loaded in the selected data 
    388            *   holding register.
    389            * @param  Data1: Data for DAC Channel1 to be loaded in the selected data 
    390            *   holding register.
    391            * @retval None
    392            */

   \                                 In section .text, align 2, keep-with-next
    393          void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
    394          {
   \                     DAC_SetDualChannelData:
   \   00000000   10B4               PUSH     {R4}
    395            uint32_t data = 0, tmp = 0;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   0024               MOVS     R4,#+0
    396            
    397            /* Check the parameters */
    398            assert_param(IS_DAC_ALIGN(DAC_Align));
    399            assert_param(IS_DAC_DATA(Data1));
    400            assert_param(IS_DAC_DATA(Data2));
    401            
    402            /* Calculate and set dual DAC data holding register value */
    403            if (DAC_Align == DAC_Align_8b_R)
   \   00000006   0828               CMP      R0,#+8
   \   00000008   04D1               BNE.N    ??DAC_SetDualChannelData_0
    404            {
    405              data = ((uint32_t)Data2 << 8) | Data1; 
   \   0000000A   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000E   52EA0123           ORRS     R3,R2,R1, LSL #+8
   \   00000012   03E0               B.N      ??DAC_SetDualChannelData_1
    406            }
    407            else
    408            {
    409              data = ((uint32_t)Data2 << 16) | Data1;
   \                     ??DAC_SetDualChannelData_0:
   \   00000014   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000016   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000018   52EA0143           ORRS     R3,R2,R1, LSL #+16
    410            }
    411            
    412            tmp = (uint32_t)DAC_BASE;
   \                     ??DAC_SetDualChannelData_1:
   \   0000001C   ....               LDR.N    R4,??DataTable14  ;; 0x40007400
    413            tmp += DHR12RD_OFFSET + DAC_Align;
   \   0000001E   2030               ADDS     R0,R0,#+32
   \   00000020   0419               ADDS     R4,R0,R4
    414          
    415            /* Set the dual DAC selected data holding register */
    416            *(__IO uint32_t *)tmp = data;
   \   00000022   2360               STR      R3,[R4, #+0]
    417          }
   \   00000024   10BC               POP      {R4}
   \   00000026   7047               BX       LR               ;; return
    418          
    419          /**
    420            * @brief  Returns the last data output value of the selected DAC cahnnel.
    421            * @param  DAC_Channel: the selected DAC channel. 
    422            *   This parameter can be one of the following values:
    423            *     @arg DAC_Channel_1: DAC Channel1 selected
    424            *     @arg DAC_Channel_2: DAC Channel2 selected
    425            * @retval The selected DAC channel data output value.
    426            */

   \                                 In section .text, align 2, keep-with-next
    427          uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
    428          {
   \                     DAC_GetDataOutputValue:
   \   00000000   81B0               SUB      SP,SP,#+4
    429            __IO uint32_t tmp = 0;
   \   00000002   0021               MOVS     R1,#+0
   \   00000004   0091               STR      R1,[SP, #+0]
    430            
    431            /* Check the parameters */
    432            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    433            
    434            tmp = (uint32_t) DAC_BASE ;
   \   00000006   ....               LDR.N    R1,??DataTable14  ;; 0x40007400
   \   00000008   0091               STR      R1,[SP, #+0]
    435            tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
   \   0000000A   0099               LDR      R1,[SP, #+0]
   \   0000000C   8008               LSRS     R0,R0,#+2
   \   0000000E   2C30               ADDS     R0,R0,#+44
   \   00000010   4018               ADDS     R0,R0,R1
   \   00000012   0090               STR      R0,[SP, #+0]
    436            
    437            /* Returns the DAC channel data output register value */
    438            return (uint16_t) (*(__IO uint32_t*) tmp);
   \   00000014   0098               LDR      R0,[SP, #+0]
   \   00000016   0068               LDR      R0,[R0, #+0]
   \   00000018   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001A   01B0               ADD      SP,SP,#+4
   \   0000001C   7047               BX       LR               ;; return
    439          }
    440          
    441          
    442          /**
    443            * @brief  Checks whether the specified DAC flag is set or not.
    444            * @param  DAC_Channel: thee selected DAC channel. 
    445            *   This parameter can be one of the following values:
    446            *     @arg DAC_Channel_1: DAC Channel1 selected
    447            *     @arg DAC_Channel_2: DAC Channel2 selected
    448            * @param  DAC_FLAG: specifies the flag to check. 
    449            *   This parameter can be only of the following value:
    450            *     @arg DAC_FLAG_DMAUDR: DMA underrun flag                                                 
    451            * @retval The new state of DAC_FLAG (SET or RESET).
    452            */

   \                                 In section .text, align 2, keep-with-next
    453          FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG)
    454          {
    455            FlagStatus bitstatus = RESET;
   \                     DAC_GetFlagStatus:
   \   00000000   0022               MOVS     R2,#+0
    456            /* Check the parameters */
    457            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    458            assert_param(IS_DAC_FLAG(DAC_FLAG));
    459          
    460            /* Check the status of the specified DAC flag */
    461            if ((DAC->SR & (DAC_FLAG << DAC_Channel)) != (uint8_t)RESET)
   \   00000002   ....               LDR.N    R3,??DataTable14_2  ;; 0x40007434
   \   00000004   1B68               LDR      R3,[R3, #+0]
   \   00000006   11FA00F0           LSLS     R0,R1,R0
   \   0000000A   0342               TST      R3,R0
   \   0000000C   01D0               BEQ.N    ??DAC_GetFlagStatus_0
    462            {
    463              /* DAC_FLAG is set */
    464              bitstatus = SET;
   \   0000000E   0122               MOVS     R2,#+1
   \   00000010   00E0               B.N      ??DAC_GetFlagStatus_1
    465            }
    466            else
    467            {
    468              /* DAC_FLAG is reset */
    469              bitstatus = RESET;
   \                     ??DAC_GetFlagStatus_0:
   \   00000012   0022               MOVS     R2,#+0
    470            }
    471            /* Return the DAC_FLAG status */
    472            return  bitstatus;
   \                     ??DAC_GetFlagStatus_1:
   \   00000014   1000               MOVS     R0,R2
   \   00000016   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   7047               BX       LR               ;; return
    473          }
    474          
    475          /**
    476            * @brief  Clears the DAC channelx's pending flags.
    477            * @param  DAC_Channel: the selected DAC channel. 
    478            *   This parameter can be one of the following values:
    479            *     @arg DAC_Channel_1: DAC Channel1 selected
    480            *     @arg DAC_Channel_2: DAC Channel2 selected
    481            * @param  DAC_FLAG: specifies the flag to clear. 
    482            *   This parameter can be of the following value:
    483            *     @arg DAC_FLAG_DMAUDR: DMA underrun flag                           
    484            * @retval None
    485            */

   \                                 In section .text, align 2, keep-with-next
    486          void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG)
    487          {
    488            /* Check the parameters */
    489            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    490            assert_param(IS_DAC_FLAG(DAC_FLAG));
    491          
    492            /* Clear the selected DAC flags */
    493            DAC->SR = (DAC_FLAG << DAC_Channel);
   \                     DAC_ClearFlag:
   \   00000000   11FA00F0           LSLS     R0,R1,R0
   \   00000004   ....               LDR.N    R1,??DataTable14_2  ;; 0x40007434
   \   00000006   0860               STR      R0,[R1, #+0]
    494          }
   \   00000008   7047               BX       LR               ;; return
    495          
    496          /**
    497            * @brief  Checks whether the specified DAC interrupt has occurred or not.
    498            * @param  DAC_Channel: the selected DAC channel. 
    499            *   This parameter can be one of the following values:
    500            *     @arg DAC_Channel_1: DAC Channel1 selected
    501            *     @arg DAC_Channel_2: DAC Channel2 selected
    502            * @param  DAC_IT: specifies the DAC interrupt source to check. 
    503            *   This parameter can be the following values:
    504            *     @arg DAC_IT_DMAUDR: DMA underrun interrupt mask                       
    505            * @retval The new state of DAC_IT (SET or RESET).
    506            */

   \                                 In section .text, align 2, keep-with-next
    507          ITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT)
    508          {
   \                     DAC_GetITStatus:
   \   00000000   30B4               PUSH     {R4,R5}
    509            ITStatus bitstatus = RESET;
   \   00000002   0022               MOVS     R2,#+0
    510            uint32_t enablestatus = 0;
   \   00000004   0023               MOVS     R3,#+0
    511            
    512            /* Check the parameters */
    513            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    514            assert_param(IS_DAC_IT(DAC_IT));
    515          
    516            /* Get the DAC_IT enable bit status */
    517            enablestatus = (DAC->CR & (DAC_IT << DAC_Channel)) ;
   \   00000006   ....               LDR.N    R4,??DataTable14  ;; 0x40007400
   \   00000008   2468               LDR      R4,[R4, #+0]
   \   0000000A   11FA00F5           LSLS     R5,R1,R0
   \   0000000E   2C40               ANDS     R4,R5,R4
   \   00000010   2300               MOVS     R3,R4
    518            
    519            /* Check the status of the specified DAC interrupt */
    520            if (((DAC->SR & (DAC_IT << DAC_Channel)) != (uint32_t)RESET) && enablestatus)
   \   00000012   ....               LDR.N    R4,??DataTable14_2  ;; 0x40007434
   \   00000014   2468               LDR      R4,[R4, #+0]
   \   00000016   11FA00F0           LSLS     R0,R1,R0
   \   0000001A   0442               TST      R4,R0
   \   0000001C   03D0               BEQ.N    ??DAC_GetITStatus_0
   \   0000001E   002B               CMP      R3,#+0
   \   00000020   01D0               BEQ.N    ??DAC_GetITStatus_0
    521            {
    522              /* DAC_IT is set */
    523              bitstatus = SET;
   \   00000022   0122               MOVS     R2,#+1
   \   00000024   00E0               B.N      ??DAC_GetITStatus_1
    524            }
    525            else
    526            {
    527              /* DAC_IT is reset */
    528              bitstatus = RESET;
   \                     ??DAC_GetITStatus_0:
   \   00000026   0022               MOVS     R2,#+0
    529            }
    530            /* Return the DAC_IT status */
    531            return  bitstatus;
   \                     ??DAC_GetITStatus_1:
   \   00000028   1000               MOVS     R0,R2
   \   0000002A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   30BC               POP      {R4,R5}
   \   0000002E   7047               BX       LR               ;; return
    532          }
    533          
    534          /**
    535            * @brief  Clears the DAC channelxs interrupt pending bits.
    536            * @param  DAC_Channel: the selected DAC channel. 
    537            *   This parameter can be one of the following values:
    538            *     @arg DAC_Channel_1: DAC Channel1 selected
    539            *     @arg DAC_Channel_2: DAC Channel2 selected
    540            * @param  DAC_IT: specifies the DAC interrupt pending bit to clear.
    541            *   This parameter can be the following values:
    542            *     @arg DAC_IT_DMAUDR: DMA underrun interrupt mask                         
    543            * @retval None
    544            */

   \                                 In section .text, align 2, keep-with-next
    545          void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT)
    546          {
    547            /* Check the parameters */
    548            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    549            assert_param(IS_DAC_IT(DAC_IT)); 
    550          
    551            /* Clear the selected DAC interrupt pending bits */
    552            DAC->SR = (DAC_IT << DAC_Channel);
   \                     DAC_ClearITPendingBit:
   \   00000000   11FA00F0           LSLS     R0,R1,R0
   \   00000004   ....               LDR.N    R1,??DataTable14_2  ;; 0x40007434
   \   00000006   0860               STR      R0,[R1, #+0]
    553          }
   \   00000008   7047               BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   00740040           DC32     0x40007400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   04740040           DC32     0x40007404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   34740040           DC32     0x40007434
    554          
    555          /**
    556            * @}
    557            */
    558          
    559          /**
    560            * @}
    561            */
    562          
    563          /**
    564            * @}
    565            */
    566          
    567          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                   .cstack
     --------                   -------
     DAC_ClearFlag                   0
     DAC_ClearITPendingBit           0
     DAC_Cmd                         0
     DAC_DMACmd                      0
     DAC_DeInit                      8
     DAC_DualSoftwareTriggerCmd      0
     DAC_GetDataOutputValue          4
     DAC_GetFlagStatus               0
     DAC_GetITStatus                 8
     DAC_ITConfig                    0
     DAC_Init                        8
     DAC_SetChannel1Data             4
     DAC_SetChannel2Data             4
     DAC_SetDualChannelData          4
     DAC_SoftwareTriggerCmd          0
     DAC_StructInit                  0
     DAC_WaveGenerationCmd           0


   Section sizes:

     Function/Label             Bytes
     --------------             -----
     DAC_DeInit                   24
     DAC_Init                     50
     DAC_StructInit               18
     DAC_Cmd                      44
     DAC_ITConfig                 40
     DAC_DMACmd                   48
     DAC_SoftwareTriggerCmd       48
     DAC_DualSoftwareTriggerCmd   34
     DAC_WaveGenerationCmd        40
     DAC_SetChannel1Data          28
     DAC_SetChannel2Data          28
     DAC_SetDualChannelData       40
     DAC_GetDataOutputValue       30
     DAC_GetFlagStatus            26
     DAC_ClearFlag                10
     DAC_GetITStatus              48
     DAC_ClearITPendingBit        10
     ??DataTable14                 4
     ??DataTable14_1               4
     ??DataTable14_2               4

 
 578 bytes in section .text
 
 578 bytes of CODE memory

Errors: none
Warnings: none
