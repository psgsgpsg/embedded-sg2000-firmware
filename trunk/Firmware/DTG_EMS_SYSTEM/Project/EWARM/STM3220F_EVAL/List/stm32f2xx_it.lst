###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     19/Jan/2012  11:08:51 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\stm32f2x #
#                    x_it.c                                                   #
#    Command line =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\stm32f2x #
#                    x_it.c -D USE_STDPERIPH_DRIVER -D STM32F2XX -D           #
#                    USE_STM3220F_EVAL -D USE_USB_OTG_FS -D                   #
#                    RTC_CLOCK_SOURCE_LSE -lC F:\Work\S&G2000\Firmware\DTG_EM #
#                    S_SYSTEM\Project\EWARM\STM3220F_EVAL\List\ -lA           #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\ -o F:\Work\S&G2000\Firmware\DTG_EMS_SY #
#                    STEM\Project\EWARM\STM3220F_EVAL\Obj\ --no_cse           #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Full.h" -I                     #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWA #
#                    RM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I             #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I         #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\ -I                             #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\Common\ -I                      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_OTG_Driver\inc\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Core\inc\ -I      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\msc\inc\    #
#                    -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM #
#                    \..\Usb\ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Proj #
#                    ect\EWARM\..\Usb\Inc\ -I F:\Work\S&G2000\Firmware\DTG_EM #
#                    S_SYSTEM\Project\EWARM\..\Usb\src\ -I                    #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Core\inc\ -I        #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -Ol --use_c++_inline                                     #
#    List file    =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\stm32f2xx_it.lst                        #
#    Object file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\Obj\stm32f2xx_it.o                           #
#                                                                             #
#                                                                             #
###############################################################################

F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\stm32f2xx_it.c
      1          /**
      2          ******************************************************************************
      3          * @file    Project/STM32F2xx_StdPeriph_Template/stm32f2xx_it.c 
      4          * @author  MCD Application Team
      5          * @version V0.0.4
      6          * @date    13-January-2011
      7          * @brief   Main Interrupt Service Routines.
      8          *          This file provides template for all exceptions handler and 
      9          *          peripherals interrupt service routine.
     10          ******************************************************************************
     11          * @attention
     12          *
     13          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     14          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     15          * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     16          * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     17          * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     18          * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     19          *
     20          * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     21          ******************************************************************************
     22          */ 
     23          
     24          /* Includes ------------------------------------------------------------------*/
     25          #include "stm32f2xx_it.h"
     26          #include "main.h"
     27          
     28          /* Private typedef -----------------------------------------------------------*/
     29          /* Private define ------------------------------------------------------------*/
     30          /* Private macro -------------------------------------------------------------*/
     31          /* Private variables ---------------------------------------------------------*/
     32          /* Private function prototypes -----------------------------------------------*/
     33          /* Private functions ---------------------------------------------------------*/

   \                                 In section .bss, align 4
     34          u32 LPGBuffer[10];
   \                     LPGBuffer:
   \   00000000                      DS8 40

   \                                 In section .bss, align 2
     35          u16 LPGRising_Time;
   \                     LPGRising_Time:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     36          u16 LPGFalling_Time;
   \                     LPGFalling_Time:
   \   00000000                      DS8 2
     37          //u8 LPG_PWM_Count;

   \                                 In section .bss, align 1
     38          u8 LPG_Loop;
   \                     LPG_Loop:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     39          u8 LPG_Count;
   \                     LPG_Count:
   \   00000000                      DS8 1
     40          

   \                                 In section .bss, align 2
     41          u16 Timer_1ms;
   \                     Timer_1ms:
   \   00000000                      DS8 2
     42          

   \                                 In section .bss, align 4
     43          u32 RPM_PWM_Count;
   \                     RPM_PWM_Count:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     44          u32 RPM_Count;
   \                     RPM_Count:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     45          u32 RPM_Buffer[MAX_RPM_BUFFERCOUNT];
   \                     RPM_Buffer:
   \   00000000                      DS8 80

   \                                 In section .bss, align 1
     46          u8 RPM_Loop;
   \                     RPM_Loop:
   \   00000000                      DS8 1
     47          

   \                                 In section .bss, align 4
     48          u32 SPEED_PWM_Count;
   \                     SPEED_PWM_Count:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     49          u32 SPEED_Count;
   \                     SPEED_Count:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     50          u32 SPEED_Buffer[MAX_SPEED_BUFFERCOUNT];
   \                     SPEED_Buffer:
   \   00000000                      DS8 40

   \                                 In section .bss, align 1
     51          u8 SPEED_Loop;
   \                     SPEED_Loop:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     52          u8 SPEED_Check;
   \                     SPEED_Check:
   \   00000000                      DS8 1
     53          
     54          extern void USB_OTG_BSP_TimerIRQ (void);
     55          /******************************************************************************/
     56          /*            Cortex-M3 Processor Exceptions Handlers                         */
     57          /******************************************************************************/
     58          
     59          /**
     60          * @brief   This function handles NMI exception.
     61          * @param  None
     62          * @retval None
     63          */

   \                                 In section .text, align 2, keep-with-next
     64          void NMI_Handler(void)
     65          {
     66          }
   \                     NMI_Handler:
   \   00000000   7047               BX       LR               ;; return
     67          
     68          /**
     69          * @brief  This function handles Hard Fault exception.
     70          * @param  None
     71          * @retval None
     72          */

   \                                 In section .text, align 2, keep-with-next
     73          void HardFault_Handler(void)
     74          {
   \                     HardFault_Handler:
   \   00000000   80B5               PUSH     {R7,LR}
     75               /* Go to infinite loop when Hard Fault exception occurs */
     76               printf("SYSTEM DOWN [%d]",SYSTEM_STEP);
   \   00000002   ....               LDR.N    R0,??DataTable6
   \   00000004   0188               LDRH     R1,[R0, #+0]
   \   00000006   ........           ADR.W    R0,`?<Constant "SYSTEM DOWN [%d]">`
   \   0000000A   ........           BL       printf
     77               while (1)
   \                     ??HardFault_Handler_0:
   \   0000000E   FEE7               B.N      ??HardFault_Handler_0
     78               {
     79               }
     80          }
     81          
     82          /**
     83          * @brief  This function handles Memory Manage exception.    
     84          * @param  None
     85          * @retval None
     86          */

   \                                 In section .text, align 2, keep-with-next
     87          void MemManage_Handler(void)
     88          {
     89               /* Go to infinite loop when Memory Manage exception occurs */
     90               while (1)
   \                     MemManage_Handler:
   \                     ??MemManage_Handler_0:
   \   00000000   FEE7               B.N      ??MemManage_Handler_0
     91               {
     92               }
     93          }
     94          
     95          /**
     96          * @brief  This function handles Bus Fault exception.
     97          * @param  None
     98          * @retval None
     99          */

   \                                 In section .text, align 2, keep-with-next
    100          void BusFault_Handler(void)
    101          {
    102               /* Go to infinite loop when Bus Fault exception occurs */
    103               while (1)
   \                     BusFault_Handler:
   \                     ??BusFault_Handler_0:
   \   00000000   FEE7               B.N      ??BusFault_Handler_0
    104               {
    105               }
    106          }
    107          
    108          /**
    109          * @brief  This function handles Usage Fault exception.
    110          * @param  None
    111          * @retval None
    112          */

   \                                 In section .text, align 2, keep-with-next
    113          void UsageFault_Handler(void)
    114          {
    115               /* Go to infinite loop when Usage Fault exception occurs */
    116               while (1)
   \                     UsageFault_Handler:
   \                     ??UsageFault_Handler_0:
   \   00000000   FEE7               B.N      ??UsageFault_Handler_0
    117               {
    118               }
    119          }
    120          
    121          /**
    122          * @brief  This function handles SVCall exception.
    123          * @param  None
    124          * @retval None
    125          */

   \                                 In section .text, align 2, keep-with-next
    126          void SVC_Handler(void)
    127          {
    128          }
   \                     SVC_Handler:
   \   00000000   7047               BX       LR               ;; return
    129          
    130          /**
    131          * @brief  This function handles Debug Monitor exception.
    132          * @param  None
    133          * @retval None
    134          */

   \                                 In section .text, align 2, keep-with-next
    135          void DebugMon_Handler(void)
    136          {
    137          }
   \                     DebugMon_Handler:
   \   00000000   7047               BX       LR               ;; return
    138          
    139          /**
    140          * @brief  This function handles PendSVC exception.
    141          * @param  None
    142          * @retval None
    143          */

   \                                 In section .text, align 2, keep-with-next
    144          void PendSV_Handler(void)
    145          {
    146          }
   \                     PendSV_Handler:
   \   00000000   7047               BX       LR               ;; return
    147          /*void FSMC_IRQHandler(void)
    148          {
    149          
    150          }*/
    151          /**
    152          * @brief  This function handles SysTick Handler.
    153          * @param  None
    154          * @retval None
    155          */
    156          

   \                                 In section .text, align 2, keep-with-next
    157          void WWDG_IRQHandler(void)
    158          {
   \                     WWDG_IRQHandler:
   \   00000000   80B5               PUSH     {R7,LR}
    159              /* Update WWDG counter */
    160              WWDG_SetCounter(0x7F);
   \   00000002   7F20               MOVS     R0,#+127
   \   00000004   ........           BL       WWDG_SetCounter
    161          
    162              /* Clear EWI flag */
    163              WWDG_ClearFlag();
   \   00000008   ........           BL       WWDG_ClearFlag
    164          
    165          }
   \   0000000C   01BD               POP      {R0,PC}          ;; return
    166          

   \                                 In section .text, align 2, keep-with-next
    167          void SysTick_Handler(void)          // 현재 0.1ms
    168          {
    169               Timer_1ms++;     
   \                     SysTick_Handler:
   \   00000000   ....               LDR.N    R0,??DataTable6_1
   \   00000002   0088               LDRH     R0,[R0, #+0]
   \   00000004   401C               ADDS     R0,R0,#+1
   \   00000006   ....               LDR.N    R1,??DataTable6_1
   \   00000008   0880               STRH     R0,[R1, #+0]
    170          }
   \   0000000A   7047               BX       LR               ;; return
    171          //////////////////////////////////////////////////////////////////////////
    172          // 현대와 대우 신형 측정방식
    173          // 100ms 안에 몇개의 데이터가 들어어는가?
    174          // 주파수가 낮을때 사용한다.
    175          // RPM_Count가  OverFlow되는 것을 조심
    176          
    177          
    178          

   \                                 In section .text, align 2, keep-with-next
    179          void EXTI9_5_IRQHandler(void)
    180          {
   \                     EXTI9_5_IRQHandler:
   \   00000000   10B5               PUSH     {R4,LR}
    181             
    182               u32 GapTime;
    183               EXTI_ClearITPendingBit(EXTI_Line6);  
   \   00000002   4020               MOVS     R0,#+64
   \   00000004   ........           BL       EXTI_ClearITPendingBit
    184               GapTime = CheckTimeInterval_100us(  SPEED_PWM_Count );
   \   00000008   ....               LDR.N    R0,??DataTable6_2
   \   0000000A   0068               LDR      R0,[R0, #+0]
   \   0000000C   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000E   ........           BL       CheckTimeInterval_100us
   \   00000012   0400               MOVS     R4,R0
    185               SPEED_PWM_Count = MS_TIMER_100us;     //  초기화  
   \   00000014   ....               LDR.N    R0,??DataTable6_3  ;; 0x40000400
   \   00000016   ........           BL       TIM_GetCounter
   \   0000001A   ....               LDR.N    R1,??DataTable6_2
   \   0000001C   0860               STR      R0,[R1, #+0]
    186               
    187               if(GapTime < 20010)          // 1hz보다 크면          
   \   0000001E   44F62A60           MOVW     R0,#+20010
   \   00000022   8442               CMP      R4,R0
   \   00000024   0AD2               BCS.N    ??EXTI9_5_IRQHandler_0
    188                    SPEED_Buffer[SPEED_Loop++ ] = GapTime;                  // 2.5 (나누기 2.5)
   \   00000026   ....               LDR.N    R0,??DataTable6_4
   \   00000028   0078               LDRB     R0,[R0, #+0]
   \   0000002A   ....               LDR.N    R1,??DataTable6_5
   \   0000002C   41F82040           STR      R4,[R1, R0, LSL #+2]
   \   00000030   ....               LDR.N    R0,??DataTable6_4
   \   00000032   0078               LDRB     R0,[R0, #+0]
   \   00000034   401C               ADDS     R0,R0,#+1
   \   00000036   ....               LDR.N    R1,??DataTable6_4
   \   00000038   0870               STRB     R0,[R1, #+0]
   \   0000003A   04E0               B.N      ??EXTI9_5_IRQHandler_1
    189               else
    190               {          
    191                    SPEED_Count++ ;                                   // 실제 누적된 카운트 값을 계산함
   \                     ??EXTI9_5_IRQHandler_0:
   \   0000003C   ....               LDR.N    R0,??DataTable6_6
   \   0000003E   0068               LDR      R0,[R0, #+0]
   \   00000040   401C               ADDS     R0,R0,#+1
   \   00000042   ....               LDR.N    R1,??DataTable6_6
   \   00000044   0860               STR      R0,[R1, #+0]
    192               }
    193               
    194               SPEED_Loop = SPEED_Loop % MAX_SPEED_BUFFERCOUNT;   // 원형버퍼에 카운터 처리    
   \                     ??EXTI9_5_IRQHandler_1:
   \   00000046   ....               LDR.N    R0,??DataTable6_4
   \   00000048   0078               LDRB     R0,[R0, #+0]
   \   0000004A   0A21               MOVS     R1,#+10
   \   0000004C   90FBF1F2           SDIV     R2,R0,R1
   \   00000050   01FB1200           MLS      R0,R1,R2,R0
   \   00000054   ....               LDR.N    R1,??DataTable6_4
   \   00000056   0870               STRB     R0,[R1, #+0]
    195               SPEED_Check = 1;
   \   00000058   ....               LDR.N    R0,??DataTable6_7
   \   0000005A   0121               MOVS     R1,#+1
   \   0000005C   0170               STRB     R1,[R0, #+0]
    196               //////////////////////////////////////////////////
    197              
    198               ACC_Drive_Value.Total_Drive_PulsCount1++;           // 저장용 펄스 계산
   \   0000005E   ....               LDR.N    R0,??DataTable6_8
   \   00000060   D0F80200           LDR      R0,[R0, #+2]
   \   00000064   401C               ADDS     R0,R0,#+1
   \   00000066   ....               LDR.N    R1,??DataTable6_8
   \   00000068   C1F80200           STR      R0,[R1, #+2]
    199               EMS_Drive_Value.Today_Speed_PulsCount ++;      // 거리 계산용 펄스
   \   0000006C   ....               LDR.N    R0,??DataTable6_9
   \   0000006E   8068               LDR      R0,[R0, #+8]
   \   00000070   401C               ADDS     R0,R0,#+1
   \   00000072   ....               LDR.N    R1,??DataTable6_9
   \   00000074   8860               STR      R0,[R1, #+8]
    200          
    201               SPEED_PWM_Count ++;
   \   00000076   ....               LDR.N    R0,??DataTable6_2
   \   00000078   0068               LDR      R0,[R0, #+0]
   \   0000007A   401C               ADDS     R0,R0,#+1
   \   0000007C   ....               LDR.N    R1,??DataTable6_2
   \   0000007E   0860               STR      R0,[R1, #+0]
    202               
    203          
    204          }
   \   00000080   10BD               POP      {R4,PC}          ;; return
    205          /*
    206          void TIM4_IRQHandler(void)    // 대우 구형 타이머 // 사용하지 않음
    207          { 
    208               // if(TIM_GetITStatus(TIM3, TIM_IT_CC2) == SET) 
    209               {
    210          
    211                    //      GPIO_ToggleBits(GPIOG,GPIO_Pin_14); 
    212                    
    213                          
    214          //          RPM_Buffer[RPM_Count++ ] = ( RPM_PWM_Count * 20) ;  // / 2.5 (나누기 2.5)
    215          //          RPM_Count = RPM_Count % 100;
    216          //          RPM_PWM_Count = 0;     //  초기화
    217                    TIM_ClearITPendingBit(TIM4,TIM_IT_Update);  
    218                    SPEED_Buffer[SPEED_Count++ ] = ( SPEED_PWM_Count * 1000)  ;  // / 2.5 (나누기 2.5)
    219                    SPEED_Count = SPEED_Count % 100;
    220                    SPEED_PWM_Count = 0;     //  초기화    
    221                          
    222                    
    223               }
    224          }
    225          void EXTI9_5_IRQHandler(void)
    226          {
    227          
    228               Info.Total_Drive_PulsCount1++;           // 저장용 펄스 계산
    229               EMS_Drive_Value.Today_Speed_PulsCount ++;      // 거리 계산용 펄스
    230          
    231               SPEED_PWM_Count ++;
    232               
    233               EXTI_ClearITPendingBit(EXTI_Line6);  
    234          }*/

   \                                 In section .text, align 2, keep-with-next
    235          void EXTI1_IRQHandler(void)
    236          {
   \                     EXTI1_IRQHandler:
   \   00000000   80B5               PUSH     {R7,LR}
    237               EXTI_ClearITPendingBit(EXTI_Line1); 
   \   00000002   0220               MOVS     R0,#+2
   \   00000004   ........           BL       EXTI_ClearITPendingBit
    238          }
   \   00000008   01BD               POP      {R0,PC}          ;; return
    239          

   \                                 In section .text, align 2, keep-with-next
    240          void EXTI15_10_IRQHandler(void)
    241          {
   \                     EXTI15_10_IRQHandler:
   \   00000000   10B5               PUSH     {R4,LR}
    242             	u16 Time;
    243          	if(EXTI_GetFlagStatus(EXTI_Line15))
   \   00000002   4FF40040           MOV      R0,#+32768
   \   00000006   ........           BL       EXTI_GetFlagStatus
   \   0000000A   0028               CMP      R0,#+0
   \   0000000C   25D0               BEQ.N    ??EXTI15_10_IRQHandler_0
    244               {
    245                    //      RPM_PWM_Count++;
    246                    RPM_Buffer[RPM_Loop++ ] = CheckTimeInterval_100us( RPM_PWM_Count ) ;  // / 2.5 (나누기 2.5)
   \   0000000E   ....               LDR.N    R0,??DataTable6_10
   \   00000010   0478               LDRB     R4,[R0, #+0]
   \   00000012   601C               ADDS     R0,R4,#+1
   \   00000014   ....               LDR.N    R1,??DataTable6_10
   \   00000016   0870               STRB     R0,[R1, #+0]
   \   00000018   ....               LDR.N    R0,??DataTable6_11
   \   0000001A   0068               LDR      R0,[R0, #+0]
   \   0000001C   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001E   ........           BL       CheckTimeInterval_100us
   \   00000022   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   ....               LDR.N    R1,??DataTable6_12
   \   00000026   41F82400           STR      R0,[R1, R4, LSL #+2]
    247                    RPM_Count ++ ;   // 실제 누적된 카운트 값을 계산함   
   \   0000002A   ....               LDR.N    R0,??DataTable6_13
   \   0000002C   0068               LDR      R0,[R0, #+0]
   \   0000002E   401C               ADDS     R0,R0,#+1
   \   00000030   ....               LDR.N    R1,??DataTable6_13
   \   00000032   0860               STR      R0,[R1, #+0]
    248                    RPM_Loop = RPM_Loop % MAX_RPM_BUFFERCOUNT;   // 원형버퍼에 카운터 처리      
   \   00000034   ....               LDR.N    R0,??DataTable6_10
   \   00000036   0078               LDRB     R0,[R0, #+0]
   \   00000038   1421               MOVS     R1,#+20
   \   0000003A   90FBF1F2           SDIV     R2,R0,R1
   \   0000003E   01FB1200           MLS      R0,R1,R2,R0
   \   00000042   ....               LDR.N    R1,??DataTable6_10
   \   00000044   0870               STRB     R0,[R1, #+0]
    249                    RPM_PWM_Count = MS_TIMER_100us;     //  초기화     
   \   00000046   ....               LDR.N    R0,??DataTable6_3  ;; 0x40000400
   \   00000048   ........           BL       TIM_GetCounter
   \   0000004C   ....               LDR.N    R1,??DataTable6_11
   \   0000004E   0860               STR      R0,[R1, #+0]
    250                    EXTI_ClearITPendingBit(EXTI_Line15);      
   \   00000050   4FF40040           MOV      R0,#+32768
   \   00000054   ........           BL       EXTI_ClearITPendingBit
   \   00000058   4FE0               B.N      ??EXTI15_10_IRQHandler_1
    251               }  
    252               else if(EXTI_GetFlagStatus(EXTI_Line10))
   \                     ??EXTI15_10_IRQHandler_0:
   \   0000005A   4FF48060           MOV      R0,#+1024
   \   0000005E   ........           BL       EXTI_GetFlagStatus
   \   00000062   0028               CMP      R0,#+0
   \   00000064   49D0               BEQ.N    ??EXTI15_10_IRQHandler_1
    253               {
    254                    LPG_Count++ ;
   \   00000066   ....               LDR.N    R0,??DataTable6_14
   \   00000068   0078               LDRB     R0,[R0, #+0]
   \   0000006A   401C               ADDS     R0,R0,#+1
   \   0000006C   ....               LDR.N    R1,??DataTable6_14
   \   0000006E   0870               STRB     R0,[R1, #+0]
    255                    LPG_Count %= 256;
   \   00000070   ....               LDR.N    R0,??DataTable6_14
   \   00000072   0078               LDRB     R0,[R0, #+0]
   \   00000074   4FF48071           MOV      R1,#+256
   \   00000078   90FBF1F2           SDIV     R2,R0,R1
   \   0000007C   02FB1102           MLS      R2,R2,R1,R0
   \   00000080   ....               LDR.N    R0,??DataTable6_14
   \   00000082   0270               STRB     R2,[R0, #+0]
    256                    Time = MS_TIMER_2us;
   \   00000084   ....               LDR.N    R0,??DataTable6_15  ;; 0x40001400
   \   00000086   ........           BL       TIM_GetCounter
   \   0000008A   0400               MOVS     R4,R0
    257                    TIM_SetCounter(TIM7,0);	
   \   0000008C   0021               MOVS     R1,#+0
   \   0000008E   ....               LDR.N    R0,??DataTable6_15  ;; 0x40001400
   \   00000090   ........           BL       TIM_SetCounter
    258                    {   
    259                         if (GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_10) == Bit_SET)
   \   00000094   4FF48061           MOV      R1,#+1024
   \   00000098   ....               LDR.N    R0,??DataTable6_16  ;; 0x40020c00
   \   0000009A   ........           BL       GPIO_ReadInputDataBit
   \   0000009E   0128               CMP      R0,#+1
   \   000000A0   04D1               BNE.N    ??EXTI15_10_IRQHandler_2
    260                         {			
    261                              LPGRising_Time = Time - 75;
   \   000000A2   B4F14B00           SUBS     R0,R4,#+75
   \   000000A6   ....               LDR.N    R1,??DataTable6_17
   \   000000A8   0880               STRH     R0,[R1, #+0]
   \   000000AA   22E0               B.N      ??EXTI15_10_IRQHandler_3
    262                         }
    263                         else
    264                         {
    265                              LPGFalling_Time = Time + 75;
   \                     ??EXTI15_10_IRQHandler_2:
   \   000000AC   14F14B00           ADDS     R0,R4,#+75
   \   000000B0   ....               LDR.N    R1,??DataTable6_18
   \   000000B2   0880               STRH     R0,[R1, #+0]
    266                              //LPGBuffer[LPGCount++] = CheckTimeInterval_1us(LPGRising_Time);
    267                              LPGBuffer[LPG_Loop++] = ( ( LPGFalling_Time*1000 ) / ( LPGFalling_Time + LPGRising_Time ) );
   \   000000B4   ....               LDR.N    R0,??DataTable6_18
   \   000000B6   0088               LDRH     R0,[R0, #+0]
   \   000000B8   4FF47A71           MOV      R1,#+1000
   \   000000BC   4843               MULS     R0,R1,R0
   \   000000BE   ....               LDR.N    R1,??DataTable6_18
   \   000000C0   0988               LDRH     R1,[R1, #+0]
   \   000000C2   ....               LDR.N    R2,??DataTable6_17
   \   000000C4   1288               LDRH     R2,[R2, #+0]
   \   000000C6   5118               ADDS     R1,R2,R1
   \   000000C8   90FBF1F0           SDIV     R0,R0,R1
   \   000000CC   ....               LDR.N    R1,??DataTable6_19
   \   000000CE   0978               LDRB     R1,[R1, #+0]
   \   000000D0   ....               LDR.N    R2,??DataTable6_20
   \   000000D2   42F82100           STR      R0,[R2, R1, LSL #+2]
   \   000000D6   ....               LDR.N    R0,??DataTable6_19
   \   000000D8   0078               LDRB     R0,[R0, #+0]
   \   000000DA   401C               ADDS     R0,R0,#+1
   \   000000DC   ....               LDR.N    R1,??DataTable6_19
   \   000000DE   0870               STRB     R0,[R1, #+0]
    268                              LPG_Loop %= 10;			
   \   000000E0   ....               LDR.N    R0,??DataTable6_19
   \   000000E2   0078               LDRB     R0,[R0, #+0]
   \   000000E4   0A21               MOVS     R1,#+10
   \   000000E6   90FBF1F2           SDIV     R2,R0,R1
   \   000000EA   01FB1200           MLS      R0,R1,R2,R0
   \   000000EE   ....               LDR.N    R1,??DataTable6_19
   \   000000F0   0870               STRB     R0,[R1, #+0]
    269                         }
    270                    }
    271                    EXTI_ClearITPendingBit(EXTI_Line10); 
   \                     ??EXTI15_10_IRQHandler_3:
   \   000000F2   4FF48060           MOV      R0,#+1024
   \   000000F6   ........           BL       EXTI_ClearITPendingBit
    272               }
    273          }
   \                     ??EXTI15_10_IRQHandler_1:
   \   000000FA   10BD               POP      {R4,PC}          ;; return
    274          /*
    275          __IO uint16_t ic3_readvalue1 = 0, ic3_readvalue2 = 0;
    276          __IO uint16_t capture_number = 0;
    277          __IO uint32_t CAPTURE = 0;
    278          __IO uint32_t TIM2_FREQ = 0;
    279          __IO uint16_t IC3ReadValue1 = 0, IC3ReadValue2 = 0;
    280          __IO uint16_t CaptureNumber = 0;
    281          __IO uint32_t Capture = 0;
    282          __IO uint32_t TIM1Freq = 0;
    283          
    284          void TIM1_CC_IRQHandler(void)
    285          { 
    286          if(TIM_GetITStatus(TIM1, TIM_IT_CC2) == SET) 
    287          {
    288          
    289          TIM_ClearITPendingBit(TIM1, TIM_IT_CC2);
    290          if(CaptureNumber == 0)
    291          {
    292          IC3ReadValue1 = TIM_GetCapture2(TIM1);
    293          CaptureNumber = 1;
    294              }
    295              else if(CaptureNumber == 1)
    296          {
    297          
    298          IC3ReadValue2 = TIM_GetCapture2(TIM1); 
    299          
    300          if (IC3ReadValue2 > IC3ReadValue1)
    301          {
    302          Capture = (IC3ReadValue2 - IC3ReadValue1); 
    303                }
    304                else
    305          {
    306          Capture = ((0xFFFF - IC3ReadValue1) + IC3ReadValue2); 
    307                }
    308          // Frequency computation 
    309          TIM1Freq = (uint32_t) SystemCoreClock / Capture;
    310          CaptureNumber = 0;
    311              }
    312            }
    313          }*/
    314          

   \                                 In section .text, align 2, keep-with-next
    315          void TIM2_IRQHandler(void)
    316          { 
   \                     TIM2_IRQHandler:
   \   00000000   80B5               PUSH     {R7,LR}
    317          
    318               USB_OTG_BSP_TimerIRQ();     
   \   00000002   ........           BL       USB_OTG_BSP_TimerIRQ
    319          //     TIM_ClearITPendingBit(TIM2,TIM_IT_Update);  
    320          }
   \   00000006   01BD               POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    321          void TIM3_IRQHandler(void)
    322          { 
   \                     TIM3_IRQHandler:
   \   00000000   80B5               PUSH     {R7,LR}
    323               // if(TIM_GetITStatus(TIM3, TIM_IT_CC2) == SET) 
    324               {
    325                    TIM_ClearITPendingBit(TIM3,TIM_IT_Update);  
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   ....               LDR.N    R0,??DataTable6_3  ;; 0x40000400
   \   00000006   ........           BL       TIM_ClearITPendingBit
    326                    //      LPG_PWM_Count++;
    327                    //      SPEED_PWM_Count++;  
    328                    //      RPM_PWM_Count++;
    329                    //   GPIO_ToggleBits(GPIOG,GPIO_Pin_14);       
    330                    
    331               }
    332          }
   \   0000000A   01BD               POP      {R0,PC}          ;; return
    333          
    334          
    335          /******************************************************************************/
    336          /*                 STM32F2xx Peripherals Interrupt Handlers                   */
    337          /*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
    338          /*  available peripheral interrupt handler's name please refer to the startup */
    339          /*  file (startup_stm32f2xx.s).                                               */
    340          /******************************************************************************/
    341          /**
    342          * @brief  OTG_FS_IRQHandler
    343          *          This function handles USB-On-The-Go FS global interrupt request.
    344          *          requests.
    345          * @param  None
    346          * @retval None
    347          */
    348          #ifdef USE_USB_OTG_FS  

   \                                 In section .text, align 2, keep-with-next
    349          void OTG_FS_IRQHandler(void)
    350          #else
    351          void OTG_HS_IRQHandler(void)
    352          #endif
    353          {
   \                     OTG_FS_IRQHandler:
   \   00000000   80B5               PUSH     {R7,LR}
    354               if(USB_Device == 0)
   \   00000002   ....               LDR.N    R0,??DataTable6_21
   \   00000004   0078               LDRB     R0,[R0, #+0]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   03D1               BNE.N    ??OTG_FS_IRQHandler_0
    355                    USBH_OTG_ISR_Handler(&USB_OTG_Core);
   \   0000000A   ....               LDR.N    R0,??DataTable6_22
   \   0000000C   ........           BL       USBH_OTG_ISR_Handler
   \   00000010   02E0               B.N      ??OTG_FS_IRQHandler_1
    356               else
    357                    USBD_OTG_ISR_Handler (&USB_OTG_dev);
                           ^
Warning[Pe223]: function "USBD_OTG_ISR_Handler" declared implicitly
   \                     ??OTG_FS_IRQHandler_0:
   \   00000012   ....               LDR.N    R0,??DataTable6_23
   \   00000014   ........           BL       USBD_OTG_ISR_Handler
    358               
    359          }
   \                     ??OTG_FS_IRQHandler_1:
   \   00000018   01BD               POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     SYSTEM_STEP

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   ........           DC32     Timer_1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   ........           DC32     SPEED_PWM_Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   00040040           DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   ........           DC32     SPEED_Loop

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   ........           DC32     SPEED_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   ........           DC32     SPEED_Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   ........           DC32     SPEED_Check

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   ........           DC32     ACC_Drive_Value

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   ........           DC32     EMS_Drive_Value

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   ........           DC32     RPM_Loop

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   ........           DC32     RPM_PWM_Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   ........           DC32     RPM_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   ........           DC32     RPM_Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_14:
   \   00000000   ........           DC32     LPG_Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_15:
   \   00000000   00140040           DC32     0x40001400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_16:
   \   00000000   000C0240           DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_17:
   \   00000000   ........           DC32     LPGRising_Time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_18:
   \   00000000   ........           DC32     LPGFalling_Time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_19:
   \   00000000   ........           DC32     LPG_Loop

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_20:
   \   00000000   ........           DC32     LPGBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_21:
   \   00000000   ........           DC32     USB_Device

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_22:
   \   00000000   ........           DC32     USB_OTG_Core

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_23:
   \   00000000   ........           DC32     USB_OTG_dev

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "SYSTEM DOWN [%d]">`:
   \   00000000                      ; Initializer data, 20 bytes
   \   00000000   53595354454D       DC8 83, 89, 83, 84, 69, 77, 32, 68, 79, 87
   \              20444F57    
   \   0000000A   4E205B25645D       DC8 78, 32, 91, 37, 100, 93, 0, 0, 0, 0
   \              00000000    
    360          /**
    361          * @brief  This function handles PPP interrupt request.
    362          * @param  None
    363          * @retval None
    364          */
    365          /*void PPP_IRQHandler(void)
    366          {
    367          }*/
    368          
    369          /**
    370          * @}
    371          */ 
    372          
    373          
    374          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function             .cstack
     --------             -------
     BusFault_Handler          0
     DebugMon_Handler          0
     EXTI15_10_IRQHandler      8
     EXTI1_IRQHandler          8
     EXTI9_5_IRQHandler        8
     HardFault_Handler         8
     MemManage_Handler         0
     NMI_Handler               0
     OTG_FS_IRQHandler         8
     PendSV_Handler            0
     SVC_Handler               0
     SysTick_Handler           0
     TIM2_IRQHandler           8
     TIM3_IRQHandler           8
     UsageFault_Handler        0
     WWDG_IRQHandler           8


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     LPGBuffer                        40
     LPGRising_Time                    2
     LPGFalling_Time                   2
     LPG_Loop                          1
     LPG_Count                         1
     Timer_1ms                         2
     RPM_PWM_Count                     4
     RPM_Count                         4
     RPM_Buffer                       80
     RPM_Loop                          1
     SPEED_PWM_Count                   4
     SPEED_Count                       4
     SPEED_Buffer                     40
     SPEED_Loop                        1
     SPEED_Check                       1
     NMI_Handler                       2
     HardFault_Handler                16
     MemManage_Handler                 2
     BusFault_Handler                  2
     UsageFault_Handler                2
     SVC_Handler                       2
     DebugMon_Handler                  2
     PendSV_Handler                    2
     WWDG_IRQHandler                  14
     SysTick_Handler                  12
     EXTI9_5_IRQHandler              130
     EXTI1_IRQHandler                 10
     EXTI15_10_IRQHandler            252
     TIM2_IRQHandler                   8
     TIM3_IRQHandler                  12
     OTG_FS_IRQHandler                26
     ??DataTable6                      4
     ??DataTable6_1                    4
     ??DataTable6_2                    4
     ??DataTable6_3                    4
     ??DataTable6_4                    4
     ??DataTable6_5                    4
     ??DataTable6_6                    4
     ??DataTable6_7                    4
     ??DataTable6_8                    4
     ??DataTable6_9                    4
     ??DataTable6_10                   4
     ??DataTable6_11                   4
     ??DataTable6_12                   4
     ??DataTable6_13                   4
     ??DataTable6_14                   4
     ??DataTable6_15                   4
     ??DataTable6_16                   4
     ??DataTable6_17                   4
     ??DataTable6_18                   4
     ??DataTable6_19                   4
     ??DataTable6_20                   4
     ??DataTable6_21                   4
     ??DataTable6_22                   4
     ??DataTable6_23                   4
     ?<Constant "SYSTEM DOWN [%d]">   20

 
 187 bytes in section .bss
 610 bytes in section .text
 
 610 bytes of CODE memory
 187 bytes of DATA memory

Errors: none
Warnings: 1
