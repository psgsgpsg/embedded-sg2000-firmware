###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     19/Jan/2012  11:08:51 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32_ #
#                    USB_OTG_Driver\src\usb_dcd_int.c                         #
#    Command line =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32_ #
#                    USB_OTG_Driver\src\usb_dcd_int.c -D                      #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D RTC_CLOCK_SOURCE_LSE -lC            #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\ -lA F:\Work\S&G2000\Firmware\DTG_EMS_S #
#                    YSTEM\Project\EWARM\STM3220F_EVAL\List\ -o               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\Obj\ --no_cse --no_unroll --no_inline        #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\ #
#                    EWARM\..\ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Pro #
#                    ject\EWARM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I     #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I         #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\ -I                             #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\Common\ -I                      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_OTG_Driver\inc\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Core\inc\ -I      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\msc\inc\    #
#                    -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM #
#                    \..\Usb\ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Proj #
#                    ect\EWARM\..\Usb\Inc\ -I F:\Work\S&G2000\Firmware\DTG_EM #
#                    S_SYSTEM\Project\EWARM\..\Usb\src\ -I                    #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Core\inc\ -I        #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -Ol --use_c++_inline                                     #
#    List file    =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\usb_dcd_int.lst                         #
#    Object file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\Obj\usb_dcd_int.o                            #
#                                                                             #
#                                                                             #
###############################################################################

F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32_USB_OTG_Driver\src\usb_dcd_int.c
      1          /**
      2            ******************************************************************************
      3            * @file    usb_dcd_int.c
      4            * @author  MCD Application Team
      5            * @version V2.0.0RC1
      6            * @date    18-March-2011
      7            * @brief   Peripheral Device interrupt subroutines
      8            ******************************************************************************
      9            * @attention 
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "usb_dcd_int.h"
     24          /** @addtogroup USB_OTG_DRIVER
     25          * @{
     26          */
     27          
     28          /** @defgroup USB_DCD_INT 
     29          * @brief This file is the interface between EFSL ans Host mass-storage class
     30          * @{
     31          */
     32          
     33          
     34          /** @defgroup USB_DCD_INT_Private_Defines
     35          * @{
     36          */ 
     37          /**
     38          * @}
     39          */ 
     40          
     41          
     42          /** @defgroup USB_DCD_INT_Private_TypesDefinitions
     43          * @{
     44          */ 
     45          /**
     46          * @}
     47          */ 
     48          
     49          
     50          
     51          /** @defgroup USB_DCD_INT_Private_Macros
     52          * @{
     53          */ 
     54          /**
     55          * @}
     56          */ 
     57          
     58          
     59          /** @defgroup USB_DCD_INT_Private_Variables
     60          * @{
     61          */ 
     62          /**
     63          * @}
     64          */ 
     65          
     66          
     67          /** @defgroup USB_DCD_INT_Private_FunctionPrototypes
     68          * @{
     69          */ 
     70          /* static functions */
     71          static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum);
     72          
     73          /* Interrupt Handlers */
     74          static uint32_t DCD_HandleInEP_ISR(USB_OTG_CORE_HANDLE *pdev);
     75          static uint32_t DCD_HandleOutEP_ISR(USB_OTG_CORE_HANDLE *pdev);
     76          static uint32_t DCD_HandleSof_ISR(USB_OTG_CORE_HANDLE *pdev);
     77          
     78          static uint32_t DCD_HandleRxStatusQueueLevel_ISR(USB_OTG_CORE_HANDLE *pdev);
     79          static uint32_t DCD_WriteEmptyTxFifo(USB_OTG_CORE_HANDLE *pdev , uint32_t epnum);
     80          
     81          static uint32_t DCD_HandleUsbReset_ISR(USB_OTG_CORE_HANDLE *pdev);
     82          static uint32_t DCD_HandleEnumDone_ISR(USB_OTG_CORE_HANDLE *pdev);
     83          static uint32_t DCD_HandleResume_ISR(USB_OTG_CORE_HANDLE *pdev);
     84          static uint32_t DCD_HandleUSBSuspend_ISR(USB_OTG_CORE_HANDLE *pdev);
     85          
     86          /**
     87          * @}
     88          */ 
     89          
     90          
     91          /** @defgroup USB_DCD_INT_Private_Functions
     92          * @{
     93          */ 
     94          
     95          
     96          #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED  
     97          /**
     98          * @brief  USBD_OTG_EP1OUT_ISR_Handler
     99          *         handles all USB Interrupts
    100          * @param  pdev: device instance
    101          * @retval status
    102          */
    103          uint32_t USBD_OTG_EP1OUT_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
    104          {
    105            
    106            USB_OTG_DOEPINTn_TypeDef  doepint;
    107            USB_OTG_DEPXFRSIZ_TypeDef  deptsiz;  
    108            
    109            doepint.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[1]->DOEPINT);
    110            doepint.d32&= USB_OTG_READ_REG32(&pdev->regs.DREGS->DOUTEP1MSK);
    111            
    112            /* Transfer complete */
    113            if ( doepint.b.xfercompl )
    114            {
    115              /* Clear the bit in DOEPINTn for this interrupt */
    116              CLEAR_OUT_EP_INTR(1, xfercompl);
    117              if (pdev->cfg.dma_enable == 1)
    118              {
    119                deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[1]->DOEPTSIZ));
    120                /*ToDo : handle more than one single MPS size packet */
    121                pdev->dev.out_ep[1].xfer_count = pdev->dev.out_ep[1].maxpacket - \
    122                  deptsiz.b.xfersize;
    123              }    
    124              /* Inform upper layer: data ready */
    125              /* RX COMPLETE */
    126              USBD_DCD_INT_fops->DataOutStage(pdev , 1);
    127              
    128            }
    129            
    130            /* Endpoint disable  */
    131            if ( doepint.b.epdisabled )
    132            {
    133              /* Clear the bit in DOEPINTn for this interrupt */
    134              CLEAR_OUT_EP_INTR(1, epdisabled);
    135            }
    136            /* AHB Error */
    137            if ( doepint.b.ahberr )
    138            {
    139              CLEAR_OUT_EP_INTR(1, ahberr);
    140            } 
    141            return 1;
    142          }
    143          
    144          /**
    145          * @brief  USBD_OTG_EP1IN_ISR_Handler
    146          *         handles all USB Interrupts
    147          * @param  pdev: device instance
    148          * @retval status
    149          */
    150          uint32_t USBD_OTG_EP1IN_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
    151          {
    152            
    153            USB_OTG_DIEPINTn_TypeDef  diepint;
    154            uint32_t fifoemptymsk, msk, emp;
    155            
    156            msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DINEP1MSK);
    157            emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
    158            msk |= ((emp >> 1 ) & 0x1) << 7;
    159            diepint.d32  = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[1]->DIEPINT) & msk;  
    160            
    161            if ( diepint.b.xfercompl )
    162            {
    163              fifoemptymsk = 0x1 << 1;
    164              USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
    165              CLEAR_IN_EP_INTR(1, xfercompl);
    166              /* TX COMPLETE */
    167              USBD_DCD_INT_fops->DataInStage(pdev , 1);
    168            }
    169            if ( diepint.b.ahberr )
    170            {
    171              CLEAR_IN_EP_INTR(1, ahberr);
    172            }
    173            if ( diepint.b.timeout )
    174            {
    175              CLEAR_IN_EP_INTR(1, timeout);
    176            }
    177            if (diepint.b.intktxfemp)
    178            {
    179              CLEAR_IN_EP_INTR(1, intktxfemp);
    180            }
    181            if (diepint.b.intknepmis)
    182            {
    183              CLEAR_IN_EP_INTR(1, intknepmis);
    184            }
    185            if (diepint.b.inepnakeff)
    186            {
    187              CLEAR_IN_EP_INTR(1, inepnakeff);
    188            }
    189            if (diepint.b.emptyintr)
    190            {
    191              DCD_WriteEmptyTxFifo(pdev , 1);
    192              CLEAR_IN_EP_INTR(1, emptyintr);
    193            }
    194            return 1;
    195          }
    196          #endif
    197          
    198          /**
    199          * @brief  STM32_USBF_OTG_ISR_Handler
    200          *         handles all USB Interrupts
    201          * @param  pdev: device instance
    202          * @retval status
    203          */

   \                                 In section .text, align 2, keep-with-next
    204          uint32_t USBD_OTG_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
    205          {
   \                     USBD_OTG_ISR_Handler:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
    206            USB_OTG_GINTSTS_TypeDef  gintr_status;
    207            uint32_t retval = 0;
   \   00000004   0026               MOVS     R6,#+0
    208            
    209            if (USB_OTG_IsDeviceMode(pdev)) /* ensure that we are in device mode */
   \   00000006   2000               MOVS     R0,R4
   \   00000008   ........           BL       USB_OTG_IsDeviceMode
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   4ED0               BEQ.N    ??USBD_OTG_ISR_Handler_0
    210            {
    211              gintr_status.d32 = USB_OTG_ReadCoreItr(pdev);
   \   00000010   2000               MOVS     R0,R4
   \   00000012   ........           BL       USB_OTG_ReadCoreItr
   \   00000016   0500               MOVS     R5,R0
    212              if (!gintr_status.d32) /* avoid spurious intrrupt */
   \   00000018   002D               CMP      R5,#+0
   \   0000001A   01D1               BNE.N    ??USBD_OTG_ISR_Handler_1
    213              {
    214                return 0;
   \   0000001C   0020               MOVS     R0,#+0
   \   0000001E   47E0               B.N      ??USBD_OTG_ISR_Handler_2
    215              }
    216              
    217              if (gintr_status.b.outepintr)
   \                     ??USBD_OTG_ISR_Handler_1:
   \   00000020   C5F3C040           UBFX     R0,R5,#+19,#+1
   \   00000024   C007               LSLS     R0,R0,#+31
   \   00000026   03D5               BPL.N    ??USBD_OTG_ISR_Handler_3
    218              {
    219                retval |= DCD_HandleOutEP_ISR(pdev);
   \   00000028   2000               MOVS     R0,R4
   \   0000002A   ........           BL       DCD_HandleOutEP_ISR
   \   0000002E   0643               ORRS     R6,R0,R6
    220              }    
    221              
    222              if (gintr_status.b.inepint)
   \                     ??USBD_OTG_ISR_Handler_3:
   \   00000030   C5F38040           UBFX     R0,R5,#+18,#+1
   \   00000034   C007               LSLS     R0,R0,#+31
   \   00000036   03D5               BPL.N    ??USBD_OTG_ISR_Handler_4
    223              {
    224                retval |= DCD_HandleInEP_ISR(pdev);
   \   00000038   2000               MOVS     R0,R4
   \   0000003A   ........           BL       DCD_HandleInEP_ISR
   \   0000003E   0643               ORRS     R6,R0,R6
    225              }
    226              
    227              if (gintr_status.b.modemismatch)
   \                     ??USBD_OTG_ISR_Handler_4:
   \   00000040   C5F34000           UBFX     R0,R5,#+1,#+1
   \   00000044   C007               LSLS     R0,R0,#+31
   \   00000046   04D5               BPL.N    ??USBD_OTG_ISR_Handler_5
    228              {
    229                USB_OTG_GINTSTS_TypeDef  gintsts;
    230                
    231                /* Clear interrupt */
    232                gintsts.d32 = 0;
   \   00000048   0020               MOVS     R0,#+0
    233                gintsts.b.modemismatch = 1;
   \   0000004A   50F00200           ORRS     R0,R0,#0x2
    234                USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
   \   0000004E   E168               LDR      R1,[R4, #+12]
   \   00000050   4861               STR      R0,[R1, #+20]
    235              }
    236              
    237              if (gintr_status.b.wkupintr)
   \                     ??USBD_OTG_ISR_Handler_5:
   \   00000052   002D               CMP      R5,#+0
   \   00000054   03D5               BPL.N    ??USBD_OTG_ISR_Handler_6
    238              {
    239                retval |= DCD_HandleResume_ISR(pdev);
   \   00000056   2000               MOVS     R0,R4
   \   00000058   ........           BL       DCD_HandleResume_ISR
   \   0000005C   0643               ORRS     R6,R0,R6
    240              }
    241              
    242              if (gintr_status.b.usbsuspend)
   \                     ??USBD_OTG_ISR_Handler_6:
   \   0000005E   C5F3C020           UBFX     R0,R5,#+11,#+1
   \   00000062   C007               LSLS     R0,R0,#+31
   \   00000064   03D5               BPL.N    ??USBD_OTG_ISR_Handler_7
    243              {
    244                retval |= DCD_HandleUSBSuspend_ISR(pdev);
   \   00000066   2000               MOVS     R0,R4
   \   00000068   ........           BL       DCD_HandleUSBSuspend_ISR
   \   0000006C   0643               ORRS     R6,R0,R6
    245              }
    246              if (gintr_status.b.sofintr)
   \                     ??USBD_OTG_ISR_Handler_7:
   \   0000006E   C5F3C000           UBFX     R0,R5,#+3,#+1
   \   00000072   C007               LSLS     R0,R0,#+31
   \   00000074   03D5               BPL.N    ??USBD_OTG_ISR_Handler_8
    247              {
    248                retval |= DCD_HandleSof_ISR(pdev);
   \   00000076   2000               MOVS     R0,R4
   \   00000078   ........           BL       DCD_HandleSof_ISR
   \   0000007C   0643               ORRS     R6,R0,R6
    249                
    250              }
    251              
    252              if (gintr_status.b.rxstsqlvl)
   \                     ??USBD_OTG_ISR_Handler_8:
   \   0000007E   C5F30010           UBFX     R0,R5,#+4,#+1
   \   00000082   C007               LSLS     R0,R0,#+31
   \   00000084   03D5               BPL.N    ??USBD_OTG_ISR_Handler_9
    253              {
    254                retval |= DCD_HandleRxStatusQueueLevel_ISR(pdev);
   \   00000086   2000               MOVS     R0,R4
   \   00000088   ........           BL       DCD_HandleRxStatusQueueLevel_ISR
   \   0000008C   0643               ORRS     R6,R0,R6
    255                
    256              }
    257              
    258              if (gintr_status.b.usbreset)
   \                     ??USBD_OTG_ISR_Handler_9:
   \   0000008E   C5F30030           UBFX     R0,R5,#+12,#+1
   \   00000092   C007               LSLS     R0,R0,#+31
   \   00000094   03D5               BPL.N    ??USBD_OTG_ISR_Handler_10
    259              {
    260                retval |= DCD_HandleUsbReset_ISR(pdev);
   \   00000096   2000               MOVS     R0,R4
   \   00000098   ........           BL       DCD_HandleUsbReset_ISR
   \   0000009C   0643               ORRS     R6,R0,R6
    261                
    262              }
    263              if (gintr_status.b.enumdone)
   \                     ??USBD_OTG_ISR_Handler_10:
   \   0000009E   C5F34030           UBFX     R0,R5,#+13,#+1
   \   000000A2   C007               LSLS     R0,R0,#+31
   \   000000A4   03D5               BPL.N    ??USBD_OTG_ISR_Handler_0
    264              {
    265                retval |= DCD_HandleEnumDone_ISR(pdev);
   \   000000A6   2000               MOVS     R0,R4
   \   000000A8   ........           BL       DCD_HandleEnumDone_ISR
   \   000000AC   0643               ORRS     R6,R0,R6
    266              }
    267            }
    268            return retval;
   \                     ??USBD_OTG_ISR_Handler_0:
   \   000000AE   3000               MOVS     R0,R6
   \                     ??USBD_OTG_ISR_Handler_2:
   \   000000B0   70BD               POP      {R4-R6,PC}       ;; return
    269          }
    270          
    271          /**
    272          * @brief  DCD_HandleResume_ISR
    273          *         Indicates that the USB_OTG controller has detected a resume or
    274          *                 remote wakeup sequence
    275          * @param  pdev: device instance
    276          * @retval status
    277          */

   \                                 In section .text, align 2, keep-with-next
    278          static uint32_t DCD_HandleResume_ISR(USB_OTG_CORE_HANDLE *pdev)
    279          {
   \                     DCD_HandleResume_ISR:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    280            USB_OTG_GINTSTS_TypeDef  gintsts;
    281            USB_OTG_DCTL_TypeDef     devctl;
    282            USB_OTG_PCGCCTL_TypeDef  power;
    283            
    284            if(pdev->cfg.low_power)
   \   00000004   A07A               LDRB     R0,[R4, #+10]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   08D0               BEQ.N    ??DCD_HandleResume_ISR_0
    285            {
    286              /* un-gate USB Core clock */
    287              power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
   \   0000000A   D4F80C01           LDR      R0,[R4, #+268]
    288              power.b.gatehclk = 0;
   \   0000000E   30F00200           BICS     R0,R0,#0x2
    289              power.b.stoppclk = 0;
   \   00000012   4008               LSRS     R0,R0,#+1
   \   00000014   4000               LSLS     R0,R0,#+1
    290              USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
   \   00000016   D4F80C11           LDR      R1,[R4, #+268]
   \   0000001A   0860               STR      R0,[R1, #+0]
    291            }
    292            
    293            /* Clear the Remote Wakeup Signalling */
    294            devctl.d32 = 0;
   \                     ??DCD_HandleResume_ISR_0:
   \   0000001C   0020               MOVS     R0,#+0
    295            devctl.b.rmtwkupsig = 1;
   \   0000001E   50F00100           ORRS     R0,R0,#0x1
    296            USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, devctl.d32, 0);
   \   00000022   2169               LDR      R1,[R4, #+16]
   \   00000024   4968               LDR      R1,[R1, #+4]
   \   00000026   31EA0000           BICS     R0,R1,R0
   \   0000002A   2169               LDR      R1,[R4, #+16]
   \   0000002C   4860               STR      R0,[R1, #+4]
    297            
    298            /* Inform upper layer by the Resume Event */
    299            USBD_DCD_INT_fops->Resume (pdev);
   \   0000002E   2000               MOVS     R0,R4
   \   00000030   ........           LDR.W    R1,??DataTable5
   \   00000034   0968               LDR      R1,[R1, #+0]
   \   00000036   8969               LDR      R1,[R1, #+24]
   \   00000038   8847               BLX      R1
    300            
    301            /* Clear interrupt */
    302            gintsts.d32 = 0;
   \   0000003A   0020               MOVS     R0,#+0
    303            gintsts.b.wkupintr = 1;
   \   0000003C   50F00040           ORRS     R0,R0,#0x80000000
    304            USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
   \   00000040   E168               LDR      R1,[R4, #+12]
   \   00000042   4861               STR      R0,[R1, #+20]
    305            return 1;
   \   00000044   0120               MOVS     R0,#+1
   \   00000046   10BD               POP      {R4,PC}          ;; return
    306          }
    307          
    308          /**
    309          * @brief  USB_OTG_HandleUSBSuspend_ISR
    310          *         Indicates that SUSPEND state has been detected on the USB
    311          * @param  pdev: device instance
    312          * @retval status
    313          */

   \                                 In section .text, align 2, keep-with-next
    314          static uint32_t DCD_HandleUSBSuspend_ISR(USB_OTG_CORE_HANDLE *pdev)
    315          {
   \                     DCD_HandleUSBSuspend_ISR:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    316            USB_OTG_GINTSTS_TypeDef  gintsts;
    317            USB_OTG_PCGCCTL_TypeDef  power;
    318            USB_OTG_DSTS_TypeDef     dsts;
    319            
    320            USBD_DCD_INT_fops->Suspend (pdev);      
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           LDR.W    R1,??DataTable5
   \   0000000A   0968               LDR      R1,[R1, #+0]
   \   0000000C   4969               LDR      R1,[R1, #+20]
   \   0000000E   8847               BLX      R1
    321            
    322            dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
   \   00000010   2069               LDR      R0,[R4, #+16]
   \   00000012   8168               LDR      R1,[R0, #+8]
    323              
    324            /* Clear interrupt */
    325            gintsts.d32 = 0;
   \   00000014   0020               MOVS     R0,#+0
    326            gintsts.b.usbsuspend = 1;
   \   00000016   50F40060           ORRS     R0,R0,#0x800
    327            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
   \   0000001A   E268               LDR      R2,[R4, #+12]
   \   0000001C   5061               STR      R0,[R2, #+20]
    328            
    329            if((pdev->cfg.low_power) && (dsts.b.suspsts == 1))
   \   0000001E   A07A               LDRB     R0,[R4, #+10]
   \   00000020   0028               CMP      R0,#+0
   \   00000022   1FD0               BEQ.N    ??DCD_HandleUSBSuspend_ISR_0
   \   00000024   11F00100           ANDS     R0,R1,#0x1
   \   00000028   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0028               CMP      R0,#+0
   \   0000002C   1AD0               BEQ.N    ??DCD_HandleUSBSuspend_ISR_0
    330            {
    331              power.d32 = 0;
   \   0000002E   0020               MOVS     R0,#+0
    332              power.b.stoppclk = 1;
   \   00000030   50F00100           ORRS     R0,R0,#0x1
    333              USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);  
   \   00000034   D4F80C11           LDR      R1,[R4, #+268]
   \   00000038   0968               LDR      R1,[R1, #+0]
   \   0000003A   0143               ORRS     R1,R0,R1
   \   0000003C   D4F80C21           LDR      R2,[R4, #+268]
   \   00000040   1160               STR      R1,[R2, #+0]
    334              
    335              power.b.gatehclk = 1;
   \   00000042   50F00200           ORRS     R0,R0,#0x2
    336              USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);
   \   00000046   D4F80C11           LDR      R1,[R4, #+268]
   \   0000004A   0968               LDR      R1,[R1, #+0]
   \   0000004C   0843               ORRS     R0,R0,R1
   \   0000004E   D4F80C11           LDR      R1,[R4, #+268]
   \   00000052   0860               STR      R0,[R1, #+0]
    337              
    338              /* switch-off the clocks */
    339              *(uint32_t *)(0xE000ED10) |= 0x00000006 ; // DeepSleepOnExit
   \   00000054   ........           LDR.W    R0,??DataTable5_1  ;; 0xe000ed10
   \   00000058   0068               LDR      R0,[R0, #+0]
   \   0000005A   50F00600           ORRS     R0,R0,#0x6
   \   0000005E   ........           LDR.W    R1,??DataTable5_1  ;; 0xe000ed10
   \   00000062   0860               STR      R0,[R1, #+0]
    340            }
    341            return 1;
   \                     ??DCD_HandleUSBSuspend_ISR_0:
   \   00000064   0120               MOVS     R0,#+1
   \   00000066   10BD               POP      {R4,PC}          ;; return
    342          }
    343          
    344          /**
    345          * @brief  DCD_HandleInEP_ISR
    346          *         Indicates that an IN EP has a pending Interrupt
    347          * @param  pdev: device instance
    348          * @retval status
    349          */

   \                                 In section .text, align 2, keep-with-next
    350          static uint32_t DCD_HandleInEP_ISR(USB_OTG_CORE_HANDLE *pdev)
    351          {
   \                     DCD_HandleInEP_ISR:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0400               MOVS     R4,R0
    352            USB_OTG_DIEPINTn_TypeDef  diepint;
    353            
    354            uint32_t ep_intr;
    355            uint32_t epnum = 0;
   \   00000004   0025               MOVS     R5,#+0
    356            uint32_t fifoemptymsk;
    357            diepint.d32 = 0;
   \   00000006   0027               MOVS     R7,#+0
    358            ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
   \   00000008   2000               MOVS     R0,R4
   \   0000000A   ........           BL       USB_OTG_ReadDevAllInEPItr
   \   0000000E   0600               MOVS     R6,R0
   \   00000010   78E0               B.N      ??DCD_HandleInEP_ISR_0
    359            
    360            while ( ep_intr )
    361            {
    362              if (ep_intr&0x1) /* In ITR */
   \                     ??DCD_HandleInEP_ISR_1:
   \   00000012   3000               MOVS     R0,R6
   \   00000014   C007               LSLS     R0,R0,#+31
   \   00000016   73D5               BPL.N    ??DCD_HandleInEP_ISR_2
    363              {
    364                diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
   \   00000018   2900               MOVS     R1,R5
   \   0000001A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   2000               MOVS     R0,R4
   \   0000001E   ........           BL       DCD_ReadDevInEP
   \   00000022   0700               MOVS     R7,R0
    365                if ( diepint.b.xfercompl )
   \   00000024   17F00100           ANDS     R0,R7,#0x1
   \   00000028   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0028               CMP      R0,#+0
   \   0000002C   22D0               BEQ.N    ??DCD_HandleInEP_ISR_3
    366                {
    367                  fifoemptymsk = 0x1 << epnum;
   \   0000002E   0120               MOVS     R0,#+1
   \   00000030   A840               LSLS     R0,R0,R5
    368                  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
   \   00000032   2169               LDR      R1,[R4, #+16]
   \   00000034   496B               LDR      R1,[R1, #+52]
   \   00000036   31EA0000           BICS     R0,R1,R0
   \   0000003A   2169               LDR      R1,[R4, #+16]
   \   0000003C   4863               STR      R0,[R1, #+52]
    369                  CLEAR_IN_EP_INTR(epnum, xfercompl);
   \   0000003E   0027               MOVS     R7,#+0
   \   00000040   57F00107           ORRS     R7,R7,#0x1
   \   00000044   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   00000048   8069               LDR      R0,[R0, #+24]
   \   0000004A   8760               STR      R7,[R0, #+8]
    370                  /* TX COMPLETE */
    371                  USBD_DCD_INT_fops->DataInStage(pdev , epnum);
   \   0000004C   2900               MOVS     R1,R5
   \   0000004E   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000050   2000               MOVS     R0,R4
   \   00000052   ........           LDR.W    R2,??DataTable5
   \   00000056   1268               LDR      R2,[R2, #+0]
   \   00000058   5268               LDR      R2,[R2, #+4]
   \   0000005A   9047               BLX      R2
    372                  
    373                  if (pdev->cfg.dma_enable == 1)
   \   0000005C   E078               LDRB     R0,[R4, #+3]
   \   0000005E   0128               CMP      R0,#+1
   \   00000060   08D1               BNE.N    ??DCD_HandleInEP_ISR_3
    374                  {
    375                    if((epnum == 0) && (pdev->dev.device_state == USB_OTG_EP0_STATUS_IN))
   \   00000062   002D               CMP      R5,#+0
   \   00000064   06D1               BNE.N    ??DCD_HandleInEP_ISR_3
   \   00000066   94F81101           LDRB     R0,[R4, #+273]
   \   0000006A   0428               CMP      R0,#+4
   \   0000006C   02D1               BNE.N    ??DCD_HandleInEP_ISR_3
    376                    {
    377                      /* prepare to rx more setup packets */
    378                      USB_OTG_EP0_OutStart(pdev);
   \   0000006E   2000               MOVS     R0,R4
   \   00000070   ........           BL       USB_OTG_EP0_OutStart
    379                    }
    380                  }           
    381                }
    382                if ( diepint.b.ahberr )
   \                     ??DCD_HandleInEP_ISR_3:
   \   00000074   C7F38000           UBFX     R0,R7,#+2,#+1
   \   00000078   C007               LSLS     R0,R0,#+31
   \   0000007A   06D5               BPL.N    ??DCD_HandleInEP_ISR_4
    383                {
    384                  CLEAR_IN_EP_INTR(epnum, ahberr);
   \   0000007C   0027               MOVS     R7,#+0
   \   0000007E   57F00407           ORRS     R7,R7,#0x4
   \   00000082   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   00000086   8069               LDR      R0,[R0, #+24]
   \   00000088   8760               STR      R7,[R0, #+8]
    385                }
    386                if ( diepint.b.timeout )
   \                     ??DCD_HandleInEP_ISR_4:
   \   0000008A   C7F3C000           UBFX     R0,R7,#+3,#+1
   \   0000008E   C007               LSLS     R0,R0,#+31
   \   00000090   06D5               BPL.N    ??DCD_HandleInEP_ISR_5
    387                {
    388                  CLEAR_IN_EP_INTR(epnum, timeout);
   \   00000092   0027               MOVS     R7,#+0
   \   00000094   57F00807           ORRS     R7,R7,#0x8
   \   00000098   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   0000009C   8069               LDR      R0,[R0, #+24]
   \   0000009E   8760               STR      R7,[R0, #+8]
    389                }
    390                if (diepint.b.intktxfemp)
   \                     ??DCD_HandleInEP_ISR_5:
   \   000000A0   C7F30010           UBFX     R0,R7,#+4,#+1
   \   000000A4   C007               LSLS     R0,R0,#+31
   \   000000A6   06D5               BPL.N    ??DCD_HandleInEP_ISR_6
    391                {
    392                  CLEAR_IN_EP_INTR(epnum, intktxfemp);
   \   000000A8   0027               MOVS     R7,#+0
   \   000000AA   57F01007           ORRS     R7,R7,#0x10
   \   000000AE   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   000000B2   8069               LDR      R0,[R0, #+24]
   \   000000B4   8760               STR      R7,[R0, #+8]
    393                }
    394                if (diepint.b.intknepmis)
   \                     ??DCD_HandleInEP_ISR_6:
   \   000000B6   C7F34010           UBFX     R0,R7,#+5,#+1
   \   000000BA   C007               LSLS     R0,R0,#+31
   \   000000BC   06D5               BPL.N    ??DCD_HandleInEP_ISR_7
    395                {
    396                  CLEAR_IN_EP_INTR(epnum, intknepmis);
   \   000000BE   0027               MOVS     R7,#+0
   \   000000C0   57F02007           ORRS     R7,R7,#0x20
   \   000000C4   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   000000C8   8069               LDR      R0,[R0, #+24]
   \   000000CA   8760               STR      R7,[R0, #+8]
    397                }
    398                if (diepint.b.inepnakeff)
   \                     ??DCD_HandleInEP_ISR_7:
   \   000000CC   C7F38010           UBFX     R0,R7,#+6,#+1
   \   000000D0   C007               LSLS     R0,R0,#+31
   \   000000D2   06D5               BPL.N    ??DCD_HandleInEP_ISR_8
    399                {
    400                  CLEAR_IN_EP_INTR(epnum, inepnakeff);
   \   000000D4   0027               MOVS     R7,#+0
   \   000000D6   57F04007           ORRS     R7,R7,#0x40
   \   000000DA   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   000000DE   8069               LDR      R0,[R0, #+24]
   \   000000E0   8760               STR      R7,[R0, #+8]
    401                }
    402                if (diepint.b.emptyintr)
   \                     ??DCD_HandleInEP_ISR_8:
   \   000000E2   C7F3C010           UBFX     R0,R7,#+7,#+1
   \   000000E6   C007               LSLS     R0,R0,#+31
   \   000000E8   0AD5               BPL.N    ??DCD_HandleInEP_ISR_2
    403                {
    404                  
    405                  DCD_WriteEmptyTxFifo(pdev , epnum);
   \   000000EA   2900               MOVS     R1,R5
   \   000000EC   2000               MOVS     R0,R4
   \   000000EE   ........           BL       DCD_WriteEmptyTxFifo
    406                  
    407                  CLEAR_IN_EP_INTR(epnum, emptyintr);
   \   000000F2   0027               MOVS     R7,#+0
   \   000000F4   57F08007           ORRS     R7,R7,#0x80
   \   000000F8   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   000000FC   8069               LDR      R0,[R0, #+24]
   \   000000FE   8760               STR      R7,[R0, #+8]
    408                }
    409              }
    410              epnum++;
   \                     ??DCD_HandleInEP_ISR_2:
   \   00000100   6D1C               ADDS     R5,R5,#+1
    411              ep_intr >>= 1;
   \   00000102   7608               LSRS     R6,R6,#+1
    412            }
   \                     ??DCD_HandleInEP_ISR_0:
   \   00000104   002E               CMP      R6,#+0
   \   00000106   84D1               BNE.N    ??DCD_HandleInEP_ISR_1
    413            
    414            return 1;
   \   00000108   0120               MOVS     R0,#+1
   \   0000010A   F2BD               POP      {R1,R4-R7,PC}    ;; return
    415          }
    416          
    417          /**
    418          * @brief  DCD_HandleOutEP_ISR
    419          *         Indicates that an OUT EP has a pending Interrupt
    420          * @param  pdev: device instance
    421          * @retval status
    422          */

   \                                 In section .text, align 2, keep-with-next
    423          static uint32_t DCD_HandleOutEP_ISR(USB_OTG_CORE_HANDLE *pdev)
    424          {
   \                     DCD_HandleOutEP_ISR:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0400               MOVS     R4,R0
    425            uint32_t ep_intr;
    426            USB_OTG_DOEPINTn_TypeDef  doepint;
    427            USB_OTG_DEPXFRSIZ_TypeDef  deptsiz;
    428            uint32_t epnum = 0;
   \   00000004   0025               MOVS     R5,#+0
    429            
    430            doepint.d32 = 0;
   \   00000006   0027               MOVS     R7,#+0
    431            
    432            /* Read in the device interrupt bits */
    433            ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
   \   00000008   2000               MOVS     R0,R4
   \   0000000A   ........           BL       USB_OTG_ReadDevAllOutEp_itr
   \   0000000E   0600               MOVS     R6,R0
   \   00000010   63E0               B.N      ??DCD_HandleOutEP_ISR_0
    434            
    435            while ( ep_intr )
    436            {
    437              if (ep_intr&0x1)
   \                     ??DCD_HandleOutEP_ISR_1:
   \   00000012   3000               MOVS     R0,R6
   \   00000014   C007               LSLS     R0,R0,#+31
   \   00000016   5ED5               BPL.N    ??DCD_HandleOutEP_ISR_2
    438              {
    439                
    440                doepint.d32 = USB_OTG_ReadDevOutEP_itr(pdev, epnum);
   \   00000018   2900               MOVS     R1,R5
   \   0000001A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   2000               MOVS     R0,R4
   \   0000001E   ........           BL       USB_OTG_ReadDevOutEP_itr
   \   00000022   0700               MOVS     R7,R0
    441                
    442                /* Transfer complete */
    443                if ( doepint.b.xfercompl )
   \   00000024   17F00100           ANDS     R0,R7,#0x1
   \   00000028   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0028               CMP      R0,#+0
   \   0000002C   2DD0               BEQ.N    ??DCD_HandleOutEP_ISR_3
    444                {
    445                  /* Clear the bit in DOEPINTn for this interrupt */
    446                  CLEAR_OUT_EP_INTR(epnum, xfercompl);
   \   0000002E   0027               MOVS     R7,#+0
   \   00000030   57F00107           ORRS     R7,R7,#0x1
   \   00000034   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   00000038   406D               LDR      R0,[R0, #+84]
   \   0000003A   8760               STR      R7,[R0, #+8]
    447                  if (pdev->cfg.dma_enable == 1)
   \   0000003C   E078               LDRB     R0,[R4, #+3]
   \   0000003E   0128               CMP      R0,#+1
   \   00000040   10D1               BNE.N    ??DCD_HandleOutEP_ISR_4
    448                  {
    449                    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[epnum]->DOEPTSIZ));
   \   00000042   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   00000046   406D               LDR      R0,[R0, #+84]
   \   00000048   0069               LDR      R0,[R0, #+16]
    450                    /*ToDo : handle more than one single MPS size packet */
    451                    pdev->dev.out_ep[epnum].xfer_count = pdev->dev.out_ep[epnum].maxpacket - \
    452                      deptsiz.b.xfersize;
   \   0000004A   2821               MOVS     R1,#+40
   \   0000004C   01FB0541           MLA      R1,R1,R5,R4
   \   00000050   D1F87813           LDR      R1,[R1, #+888]
   \   00000054   4003               LSLS     R0,R0,#+13
   \   00000056   400B               LSRS     R0,R0,#+13
   \   00000058   081A               SUBS     R0,R1,R0
   \   0000005A   2821               MOVS     R1,#+40
   \   0000005C   01FB0541           MLA      R1,R1,R5,R4
   \   00000060   C1F88803           STR      R0,[R1, #+904]
    453                  }
    454                  /* Inform upper layer: data ready */
    455                  /* RX COMPLETE */
    456                  USBD_DCD_INT_fops->DataOutStage(pdev , epnum);
   \                     ??DCD_HandleOutEP_ISR_4:
   \   00000064   2900               MOVS     R1,R5
   \   00000066   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000068   2000               MOVS     R0,R4
   \   0000006A   ....               LDR.N    R2,??DataTable5
   \   0000006C   1268               LDR      R2,[R2, #+0]
   \   0000006E   1268               LDR      R2,[R2, #+0]
   \   00000070   9047               BLX      R2
    457                  
    458                  if (pdev->cfg.dma_enable == 1)
   \   00000072   E078               LDRB     R0,[R4, #+3]
   \   00000074   0128               CMP      R0,#+1
   \   00000076   08D1               BNE.N    ??DCD_HandleOutEP_ISR_3
    459                  {
    460                    if((epnum == 0) && (pdev->dev.device_state == USB_OTG_EP0_STATUS_OUT))
   \   00000078   002D               CMP      R5,#+0
   \   0000007A   06D1               BNE.N    ??DCD_HandleOutEP_ISR_3
   \   0000007C   94F81101           LDRB     R0,[R4, #+273]
   \   00000080   0528               CMP      R0,#+5
   \   00000082   02D1               BNE.N    ??DCD_HandleOutEP_ISR_3
    461                    {
    462                      /* prepare to rx more setup packets */
    463                      USB_OTG_EP0_OutStart(pdev);
   \   00000084   2000               MOVS     R0,R4
   \   00000086   ........           BL       USB_OTG_EP0_OutStart
    464                    }
    465                  }        
    466                }
    467                /* Endpoint disable  */
    468                if ( doepint.b.epdisabled )
   \                     ??DCD_HandleOutEP_ISR_3:
   \   0000008A   C7F34000           UBFX     R0,R7,#+1,#+1
   \   0000008E   C007               LSLS     R0,R0,#+31
   \   00000090   06D5               BPL.N    ??DCD_HandleOutEP_ISR_5
    469                {
    470                  /* Clear the bit in DOEPINTn for this interrupt */
    471                  CLEAR_OUT_EP_INTR(epnum, epdisabled);
   \   00000092   0027               MOVS     R7,#+0
   \   00000094   57F00207           ORRS     R7,R7,#0x2
   \   00000098   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   0000009C   406D               LDR      R0,[R0, #+84]
   \   0000009E   8760               STR      R7,[R0, #+8]
    472                }
    473                /* AHB Error */
    474                if ( doepint.b.ahberr )
   \                     ??DCD_HandleOutEP_ISR_5:
   \   000000A0   C7F38000           UBFX     R0,R7,#+2,#+1
   \   000000A4   C007               LSLS     R0,R0,#+31
   \   000000A6   06D5               BPL.N    ??DCD_HandleOutEP_ISR_6
    475                {
    476                  CLEAR_OUT_EP_INTR(epnum, ahberr);
   \   000000A8   0027               MOVS     R7,#+0
   \   000000AA   57F00407           ORRS     R7,R7,#0x4
   \   000000AE   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   000000B2   406D               LDR      R0,[R0, #+84]
   \   000000B4   8760               STR      R7,[R0, #+8]
    477                }
    478                /* Setup Phase Done (control EPs) */
    479                if ( doepint.b.setup )
   \                     ??DCD_HandleOutEP_ISR_6:
   \   000000B6   C7F3C000           UBFX     R0,R7,#+3,#+1
   \   000000BA   C007               LSLS     R0,R0,#+31
   \   000000BC   0BD5               BPL.N    ??DCD_HandleOutEP_ISR_2
    480                {
    481                  
    482                  /* inform the upper layer that a setup packet is available */
    483                  /* SETUP COMPLETE */
    484                  USBD_DCD_INT_fops->SetupStage(pdev);
   \   000000BE   2000               MOVS     R0,R4
   \   000000C0   ....               LDR.N    R1,??DataTable5
   \   000000C2   0968               LDR      R1,[R1, #+0]
   \   000000C4   8968               LDR      R1,[R1, #+8]
   \   000000C6   8847               BLX      R1
    485                  CLEAR_OUT_EP_INTR(epnum, setup);
   \   000000C8   0027               MOVS     R7,#+0
   \   000000CA   57F00807           ORRS     R7,R7,#0x8
   \   000000CE   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   000000D2   406D               LDR      R0,[R0, #+84]
   \   000000D4   8760               STR      R7,[R0, #+8]
    486                }
    487              }
    488              epnum++;
   \                     ??DCD_HandleOutEP_ISR_2:
   \   000000D6   6D1C               ADDS     R5,R5,#+1
    489              ep_intr >>= 1;
   \   000000D8   7608               LSRS     R6,R6,#+1
    490            }
   \                     ??DCD_HandleOutEP_ISR_0:
   \   000000DA   002E               CMP      R6,#+0
   \   000000DC   99D1               BNE.N    ??DCD_HandleOutEP_ISR_1
    491            return 1;
   \   000000DE   0120               MOVS     R0,#+1
   \   000000E0   F2BD               POP      {R1,R4-R7,PC}    ;; return
    492          }
    493          
    494          /**
    495          * @brief  DCD_HandleSof_ISR
    496          *         Handles the SOF Interrupts
    497          * @param  pdev: device instance
    498          * @retval status
    499          */

   \                                 In section .text, align 2, keep-with-next
    500          static uint32_t DCD_HandleSof_ISR(USB_OTG_CORE_HANDLE *pdev)
    501          {
   \                     DCD_HandleSof_ISR:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    502            USB_OTG_GINTSTS_TypeDef  GINTSTS;
    503            
    504            
    505            USBD_DCD_INT_fops->SOF(pdev);
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ....               LDR.N    R1,??DataTable5
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   C968               LDR      R1,[R1, #+12]
   \   0000000C   8847               BLX      R1
    506            
    507            /* Clear interrupt */
    508            GINTSTS.d32 = 0;
   \   0000000E   0020               MOVS     R0,#+0
    509            GINTSTS.b.sofintr = 1;
   \   00000010   50F00800           ORRS     R0,R0,#0x8
    510            USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, GINTSTS.d32);
   \   00000014   E168               LDR      R1,[R4, #+12]
   \   00000016   4861               STR      R0,[R1, #+20]
    511            
    512            return 1;
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   10BD               POP      {R4,PC}          ;; return
    513          }
    514          
    515          /**
    516          * @brief  DCD_HandleRxStatusQueueLevel_ISR
    517          *         Handles the Rx Status Queue Level Interrupt
    518          * @param  pdev: device instance
    519          * @retval status
    520          */

   \                                 In section .text, align 2, keep-with-next
    521          static uint32_t DCD_HandleRxStatusQueueLevel_ISR(USB_OTG_CORE_HANDLE *pdev)
    522          {
   \                     DCD_HandleRxStatusQueueLevel_ISR:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0400               MOVS     R4,R0
    523            USB_OTG_GINTMSK_TypeDef  int_mask;
    524            USB_OTG_DRXSTS_TypeDef   status;
    525            USB_OTG_EP *ep;
    526            
    527            /* Disable the Rx Status Queue Level interrupt */
    528            int_mask.d32 = 0;
   \   00000004   0025               MOVS     R5,#+0
    529            int_mask.b.rxstsqlvl = 1;
   \   00000006   55F01005           ORRS     R5,R5,#0x10
    530            USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32, 0);
   \   0000000A   E068               LDR      R0,[R4, #+12]
   \   0000000C   8069               LDR      R0,[R0, #+24]
   \   0000000E   A843               BICS     R0,R0,R5
   \   00000010   E168               LDR      R1,[R4, #+12]
   \   00000012   8861               STR      R0,[R1, #+24]
    531            
    532            /* Get the Status from the top of the FIFO */
    533            status.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRXSTSP );
   \   00000014   E068               LDR      R0,[R4, #+12]
   \   00000016   066A               LDR      R6,[R0, #+32]
    534            
    535            ep = &pdev->dev.out_ep[status.b.epnum];
   \   00000018   16F00F00           ANDS     R0,R6,#0xF
   \   0000001C   2821               MOVS     R1,#+40
   \   0000001E   01FB0040           MLA      R0,R1,R0,R4
   \   00000022   00F27037           ADDW     R7,R0,#+880
    536            
    537            switch (status.b.pktsts)
   \   00000026   700C               LSRS     R0,R6,#+17
   \   00000028   10F00F00           ANDS     R0,R0,#0xF
   \   0000002C   0128               CMP      R0,#+1
   \   0000002E   08D0               BEQ.N    ??DCD_HandleRxStatusQueueLevel_ISR_0
   \   00000030   0228               CMP      R0,#+2
   \   00000032   07D0               BEQ.N    ??DCD_HandleRxStatusQueueLevel_ISR_1
   \   00000034   0328               CMP      R0,#+3
   \   00000036   1DD0               BEQ.N    ??DCD_HandleRxStatusQueueLevel_ISR_2
   \   00000038   0428               CMP      R0,#+4
   \   0000003A   1CD0               BEQ.N    ??DCD_HandleRxStatusQueueLevel_ISR_3
   \   0000003C   0628               CMP      R0,#+6
   \   0000003E   1BD0               BEQ.N    ??DCD_HandleRxStatusQueueLevel_ISR_4
   \   00000040   26E0               B.N      ??DCD_HandleRxStatusQueueLevel_ISR_5
    538            {
    539            case STS_GOUT_NAK:
    540              break;
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_0:
   \   00000042   25E0               B.N      ??DCD_HandleRxStatusQueueLevel_ISR_6
    541            case STS_DATA_UPDT:
    542              if (status.b.bcnt)
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_1:
   \   00000044   3009               LSRS     R0,R6,#+4
   \   00000046   4005               LSLS     R0,R0,#+21
   \   00000048   400D               LSRS     R0,R0,#+21
   \   0000004A   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004C   0028               CMP      R0,#+0
   \   0000004E   10D0               BEQ.N    ??DCD_HandleRxStatusQueueLevel_ISR_7
    543              {
    544                USB_OTG_ReadPacket(pdev,ep->xfer_buff, status.b.bcnt);
   \   00000050   C6F30A12           UBFX     R2,R6,#+4,#+11
   \   00000054   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000056   F968               LDR      R1,[R7, #+12]
   \   00000058   2000               MOVS     R0,R4
   \   0000005A   ........           BL       USB_OTG_ReadPacket
    545                ep->xfer_buff += status.b.bcnt;
   \   0000005E   C6F30A10           UBFX     R0,R6,#+4,#+11
   \   00000062   F968               LDR      R1,[R7, #+12]
   \   00000064   4018               ADDS     R0,R0,R1
   \   00000066   F860               STR      R0,[R7, #+12]
    546                ep->xfer_count += status.b.bcnt;
   \   00000068   B869               LDR      R0,[R7, #+24]
   \   0000006A   C6F30A11           UBFX     R1,R6,#+4,#+11
   \   0000006E   0818               ADDS     R0,R1,R0
   \   00000070   B861               STR      R0,[R7, #+24]
    547              }
    548              break;
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_7:
   \   00000072   0DE0               B.N      ??DCD_HandleRxStatusQueueLevel_ISR_6
    549            case STS_XFER_COMP:
    550              break;
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_2:
   \   00000074   0CE0               B.N      ??DCD_HandleRxStatusQueueLevel_ISR_6
    551            case STS_SETUP_COMP:
    552              break;
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_3:
   \   00000076   0BE0               B.N      ??DCD_HandleRxStatusQueueLevel_ISR_6
    553            case STS_SETUP_UPDT:
    554              /* Copy the setup packet received in Fifo into the setup buffer in RAM */
    555              USB_OTG_ReadPacket(pdev , pdev->dev.setup_packet, 8);
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_4:
   \   00000078   0822               MOVS     R2,#+8
   \   0000007A   14F5B961           ADDS     R1,R4,#+1480
   \   0000007E   2000               MOVS     R0,R4
   \   00000080   ........           BL       USB_OTG_ReadPacket
    556              ep->xfer_count += status.b.bcnt;
   \   00000084   B869               LDR      R0,[R7, #+24]
   \   00000086   C6F30A11           UBFX     R1,R6,#+4,#+11
   \   0000008A   0818               ADDS     R0,R1,R0
   \   0000008C   B861               STR      R0,[R7, #+24]
    557              break;
   \   0000008E   FFE7               B.N      ??DCD_HandleRxStatusQueueLevel_ISR_6
    558            default:
    559              break;
    560            }
    561            
    562            /* Enable the Rx Status Queue Level interrupt */
    563            USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, int_mask.d32);
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_5:
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_6:
   \   00000090   E068               LDR      R0,[R4, #+12]
   \   00000092   8069               LDR      R0,[R0, #+24]
   \   00000094   2843               ORRS     R0,R5,R0
   \   00000096   E168               LDR      R1,[R4, #+12]
   \   00000098   8861               STR      R0,[R1, #+24]
    564            
    565            return 1;
   \   0000009A   0120               MOVS     R0,#+1
   \   0000009C   F2BD               POP      {R1,R4-R7,PC}    ;; return
    566          }
    567          
    568          /**
    569          * @brief  DCD_WriteEmptyTxFifo
    570          *         check Fifo for the next packet to be loaded
    571          * @param  pdev: device instance
    572          * @retval status
    573          */

   \                                 In section .text, align 2, keep-with-next
    574          static uint32_t DCD_WriteEmptyTxFifo(USB_OTG_CORE_HANDLE *pdev, uint32_t epnum)
    575          {
   \                     DCD_WriteEmptyTxFifo:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   0400               MOVS     R4,R0
   \   00000006   0D00               MOVS     R5,R1
    576            USB_OTG_DTXFSTSn_TypeDef  txstatus;
    577            USB_OTG_EP *ep;
    578            uint32_t len = 0;
   \   00000008   0026               MOVS     R6,#+0
    579            uint32_t len32b;
    580            txstatus.d32 = 0;
   \   0000000A   0020               MOVS     R0,#+0
    581            
    582            ep = &pdev->dev.in_ep[epnum];    
   \   0000000C   2821               MOVS     R1,#+40
   \   0000000E   01FB0541           MLA      R1,R1,R5,R4
   \   00000012   01F21817           ADDW     R7,R1,#+280
    583            
    584            len = ep->xfer_len - ep->xfer_count;
   \   00000016   7969               LDR      R1,[R7, #+20]
   \   00000018   BA69               LDR      R2,[R7, #+24]
   \   0000001A   891A               SUBS     R1,R1,R2
   \   0000001C   0E00               MOVS     R6,R1
    585            
    586            if (len > ep->maxpacket)
   \   0000001E   B968               LDR      R1,[R7, #+8]
   \   00000020   B142               CMP      R1,R6
   \   00000022   00D2               BCS.N    ??DCD_WriteEmptyTxFifo_0
    587            {
    588              len = ep->maxpacket;
   \   00000024   BE68               LDR      R6,[R7, #+8]
    589            }
    590            
    591            len32b = (len + 3) / 4;
   \                     ??DCD_WriteEmptyTxFifo_0:
   \   00000026   F01C               ADDS     R0,R6,#+3
   \   00000028   5FEA9008           LSRS     R8,R0,#+2
    592            txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
   \   0000002C   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   00000030   8069               LDR      R0,[R0, #+24]
   \   00000032   8069               LDR      R0,[R0, #+24]
   \   00000034   1BE0               B.N      ??DCD_WriteEmptyTxFifo_1
    593            
    594            
    595            
    596            while  (txstatus.b.txfspcavail > len32b &&
    597                    ep->xfer_count < ep->xfer_len &&
    598                      ep->xfer_len != 0)
    599            {
    600              /* Write the FIFO */
    601              len = ep->xfer_len - ep->xfer_count;
   \                     ??DCD_WriteEmptyTxFifo_2:
   \   00000036   7869               LDR      R0,[R7, #+20]
   \   00000038   B969               LDR      R1,[R7, #+24]
   \   0000003A   461A               SUBS     R6,R0,R1
    602              
    603              if (len > ep->maxpacket)
   \   0000003C   B868               LDR      R0,[R7, #+8]
   \   0000003E   B042               CMP      R0,R6
   \   00000040   00D2               BCS.N    ??DCD_WriteEmptyTxFifo_3
    604              {
    605                len = ep->maxpacket;
   \   00000042   BE68               LDR      R6,[R7, #+8]
    606              }
    607              len32b = (len + 3) / 4;
   \                     ??DCD_WriteEmptyTxFifo_3:
   \   00000044   F01C               ADDS     R0,R6,#+3
   \   00000046   5FEA9008           LSRS     R8,R0,#+2
    608              
    609              USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
   \   0000004A   3300               MOVS     R3,R6
   \   0000004C   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000004E   2A00               MOVS     R2,R5
   \   00000050   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000052   F968               LDR      R1,[R7, #+12]
   \   00000054   2000               MOVS     R0,R4
   \   00000056   ........           BL       USB_OTG_WritePacket
    610              
    611              ep->xfer_buff  += len;
   \   0000005A   F868               LDR      R0,[R7, #+12]
   \   0000005C   3018               ADDS     R0,R6,R0
   \   0000005E   F860               STR      R0,[R7, #+12]
    612              ep->xfer_count += len;
   \   00000060   B869               LDR      R0,[R7, #+24]
   \   00000062   3018               ADDS     R0,R6,R0
   \   00000064   B861               STR      R0,[R7, #+24]
    613              
    614              txstatus.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DTXFSTS);
   \   00000066   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   0000006A   8069               LDR      R0,[R0, #+24]
   \   0000006C   8069               LDR      R0,[R0, #+24]
    615            }
   \                     ??DCD_WriteEmptyTxFifo_1:
   \   0000006E   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000070   8045               CMP      R8,R0
   \   00000072   06D2               BCS.N    ??DCD_WriteEmptyTxFifo_4
   \   00000074   B869               LDR      R0,[R7, #+24]
   \   00000076   7969               LDR      R1,[R7, #+20]
   \   00000078   8842               CMP      R0,R1
   \   0000007A   02D2               BCS.N    ??DCD_WriteEmptyTxFifo_4
   \   0000007C   7869               LDR      R0,[R7, #+20]
   \   0000007E   0028               CMP      R0,#+0
   \   00000080   D9D1               BNE.N    ??DCD_WriteEmptyTxFifo_2
    616            
    617            return 1;
   \                     ??DCD_WriteEmptyTxFifo_4:
   \   00000082   0120               MOVS     R0,#+1
   \   00000084   BDE8F081           POP      {R4-R8,PC}       ;; return
    618          }
    619          
    620          /**
    621          * @brief  DCD_HandleUsbReset_ISR
    622          *         This interrupt occurs when a USB Reset is detected
    623          * @param  pdev: device instance
    624          * @retval status
    625          */

   \                                 In section .text, align 2, keep-with-next
    626          static uint32_t DCD_HandleUsbReset_ISR(USB_OTG_CORE_HANDLE *pdev)
    627          {
   \                     DCD_HandleUsbReset_ISR:
   \   00000000   2DE9F843           PUSH     {R3-R9,LR}
   \   00000004   0400               MOVS     R4,R0
    628            USB_OTG_DAINT_TypeDef    daintmsk;
    629            USB_OTG_DOEPMSK_TypeDef  doepmsk;
    630            USB_OTG_DIEPMSK_TypeDef  diepmsk;
    631            USB_OTG_DCFG_TypeDef     dcfg;
    632            USB_OTG_DCTL_TypeDef     dctl;
    633            USB_OTG_GINTSTS_TypeDef  gintsts;
    634            uint32_t i;
    635            
    636            dctl.d32 = 0;
   \   00000006   0020               MOVS     R0,#+0
    637            daintmsk.d32 = 0;
   \   00000008   0025               MOVS     R5,#+0
    638            doepmsk.d32 = 0;
   \   0000000A   0026               MOVS     R6,#+0
    639            diepmsk.d32 = 0;
   \   0000000C   0027               MOVS     R7,#+0
    640            dcfg.d32 = 0;
   \   0000000E   5FF00008           MOVS     R8,#+0
    641            gintsts.d32 = 0;
   \   00000012   5FF00009           MOVS     R9,#+0
    642            
    643            /* Clear the Remote Wakeup Signalling */
    644            dctl.b.rmtwkupsig = 1;
   \   00000016   50F00100           ORRS     R0,R0,#0x1
    645            USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
   \   0000001A   2169               LDR      R1,[R4, #+16]
   \   0000001C   4968               LDR      R1,[R1, #+4]
   \   0000001E   31EA0000           BICS     R0,R1,R0
   \   00000022   2169               LDR      R1,[R4, #+16]
   \   00000024   4860               STR      R0,[R1, #+4]
    646            
    647            /* Flush the Tx FIFO */
    648            USB_OTG_FlushTxFifo(pdev ,  0 );
   \   00000026   0021               MOVS     R1,#+0
   \   00000028   2000               MOVS     R0,R4
   \   0000002A   ........           BL       USB_OTG_FlushTxFifo
    649            
    650            for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
   \   0000002E   0020               MOVS     R0,#+0
   \   00000030   0AE0               B.N      ??DCD_HandleUsbReset_ISR_0
    651            {
    652              USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
   \                     ??DCD_HandleUsbReset_ISR_1:
   \   00000032   14EB8001           ADDS     R1,R4,R0, LSL #+2
   \   00000036   8969               LDR      R1,[R1, #+24]
   \   00000038   FF22               MOVS     R2,#+255
   \   0000003A   8A60               STR      R2,[R1, #+8]
    653              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
   \   0000003C   14EB8001           ADDS     R1,R4,R0, LSL #+2
   \   00000040   496D               LDR      R1,[R1, #+84]
   \   00000042   FF22               MOVS     R2,#+255
   \   00000044   8A60               STR      R2,[R1, #+8]
    654            }
   \   00000046   401C               ADDS     R0,R0,#+1
   \                     ??DCD_HandleUsbReset_ISR_0:
   \   00000048   6178               LDRB     R1,[R4, #+1]
   \   0000004A   8842               CMP      R0,R1
   \   0000004C   F1D3               BCC.N    ??DCD_HandleUsbReset_ISR_1
    655            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
   \   0000004E   2069               LDR      R0,[R4, #+16]
   \   00000050   5FF0FF31           MOVS     R1,#-1
   \   00000054   8161               STR      R1,[R0, #+24]
    656            
    657            daintmsk.ep.in = 1;
   \   00000056   0120               MOVS     R0,#+1
   \   00000058   60F30F05           BFI      R5,R0,#+0,#+16
    658            daintmsk.ep.out = 1;
   \   0000005C   0120               MOVS     R0,#+1
   \   0000005E   60F31F45           BFI      R5,R0,#+16,#+16
    659            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, daintmsk.d32 );
   \   00000062   2069               LDR      R0,[R4, #+16]
   \   00000064   C561               STR      R5,[R0, #+28]
    660            
    661            doepmsk.b.setup = 1;
   \   00000066   56F00806           ORRS     R6,R6,#0x8
    662            doepmsk.b.xfercompl = 1;
   \   0000006A   56F00106           ORRS     R6,R6,#0x1
    663            doepmsk.b.ahberr = 1;
   \   0000006E   56F00406           ORRS     R6,R6,#0x4
    664            doepmsk.b.epdisabled = 1;
   \   00000072   56F00206           ORRS     R6,R6,#0x2
    665            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, doepmsk.d32 );
   \   00000076   2069               LDR      R0,[R4, #+16]
   \   00000078   4661               STR      R6,[R0, #+20]
    666          #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED   
    667            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOUTEP1MSK, doepmsk.d32 );
    668          #endif
    669            diepmsk.b.xfercompl = 1;
   \   0000007A   57F00107           ORRS     R7,R7,#0x1
    670            diepmsk.b.timeout = 1;
   \   0000007E   57F00807           ORRS     R7,R7,#0x8
    671            diepmsk.b.epdisabled = 1;
   \   00000082   57F00207           ORRS     R7,R7,#0x2
    672            diepmsk.b.ahberr = 1;
   \   00000086   57F00407           ORRS     R7,R7,#0x4
    673            diepmsk.b.intknepmis = 1;
   \   0000008A   57F02007           ORRS     R7,R7,#0x20
    674            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, diepmsk.d32 );
   \   0000008E   2069               LDR      R0,[R4, #+16]
   \   00000090   0761               STR      R7,[R0, #+16]
    675          #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED  
    676            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DINEP1MSK, diepmsk.d32 );
    677          #endif
    678            /* Reset Device Address */
    679            dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
   \   00000092   2069               LDR      R0,[R4, #+16]
   \   00000094   D0F80080           LDR      R8,[R0, #+0]
    680            dcfg.b.devaddr = 0;
   \   00000098   38F4FE68           BICS     R8,R8,#0x7F0
    681            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32);
   \   0000009C   2069               LDR      R0,[R4, #+16]
   \   0000009E   C0F80080           STR      R8,[R0, #+0]
    682            
    683            
    684            /* setup EP0 to receive SETUP packets */
    685            USB_OTG_EP0_OutStart(pdev);
   \   000000A2   2000               MOVS     R0,R4
   \   000000A4   ........           BL       USB_OTG_EP0_OutStart
    686            
    687            /* Clear interrupt */
    688            gintsts.d32 = 0;
   \   000000A8   5FF00009           MOVS     R9,#+0
    689            gintsts.b.usbreset = 1;
   \   000000AC   59F48059           ORRS     R9,R9,#0x1000
    690            USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
   \   000000B0   E068               LDR      R0,[R4, #+12]
   \   000000B2   C0F81490           STR      R9,[R0, #+20]
    691            
    692            /*Reset internal state machine */
    693            USBD_DCD_INT_fops->Reset(pdev);
   \   000000B6   2000               MOVS     R0,R4
   \   000000B8   ....               LDR.N    R1,??DataTable5
   \   000000BA   0968               LDR      R1,[R1, #+0]
   \   000000BC   0969               LDR      R1,[R1, #+16]
   \   000000BE   8847               BLX      R1
    694            return 1;
   \   000000C0   0120               MOVS     R0,#+1
   \   000000C2   BDE8F283           POP      {R1,R4-R9,PC}    ;; return
    695          }
    696          
    697          /**
    698          * @brief  DCD_HandleEnumDone_ISR
    699          *         Read the device status register and set the device speed
    700          * @param  pdev: device instance
    701          * @retval status
    702          */

   \                                 In section .text, align 2, keep-with-next
    703          static uint32_t DCD_HandleEnumDone_ISR(USB_OTG_CORE_HANDLE *pdev)
    704          {
   \                     DCD_HandleEnumDone_ISR:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
    705            USB_OTG_GINTSTS_TypeDef  gintsts;
    706            USB_OTG_GUSBCFG_TypeDef  gusbcfg;
    707            
    708            USB_OTG_EP0Activate(pdev);
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           BL       USB_OTG_EP0Activate
    709            
    710            /* Set USB turnaround time based on device speed and PHY interface. */
    711            gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
   \   0000000A   E068               LDR      R0,[R4, #+12]
   \   0000000C   C568               LDR      R5,[R0, #+12]
    712            
    713            /* Full or High speed */
    714            if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
   \   0000000E   2000               MOVS     R0,R4
   \   00000010   ........           BL       USB_OTG_GetDeviceSpeed
   \   00000014   0328               CMP      R0,#+3
   \   00000016   08D1               BNE.N    ??DCD_HandleEnumDone_ISR_0
    715            {
    716              pdev->cfg.speed            = USB_OTG_SPEED_HIGH;
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   A070               STRB     R0,[R4, #+2]
    717              pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
   \   0000001C   4FF40070           MOV      R0,#+512
   \   00000020   A080               STRH     R0,[R4, #+4]
    718              gusbcfg.b.usbtrdtim = 9;
   \   00000022   0920               MOVS     R0,#+9
   \   00000024   60F38D25           BFI      R5,R0,#+10,#+4
   \   00000028   06E0               B.N      ??DCD_HandleEnumDone_ISR_1
    719            }
    720            else
    721            {
    722              pdev->cfg.speed            = USB_OTG_SPEED_FULL;
   \                     ??DCD_HandleEnumDone_ISR_0:
   \   0000002A   0120               MOVS     R0,#+1
   \   0000002C   A070               STRB     R0,[R4, #+2]
    723              pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;  
   \   0000002E   4020               MOVS     R0,#+64
   \   00000030   A080               STRH     R0,[R4, #+4]
    724              gusbcfg.b.usbtrdtim = 5;
   \   00000032   0520               MOVS     R0,#+5
   \   00000034   60F38D25           BFI      R5,R0,#+10,#+4
    725            }
    726            
    727            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, gusbcfg.d32);
   \                     ??DCD_HandleEnumDone_ISR_1:
   \   00000038   E068               LDR      R0,[R4, #+12]
   \   0000003A   C560               STR      R5,[R0, #+12]
    728            
    729            /* Clear interrupt */
    730            gintsts.d32 = 0;
   \   0000003C   0020               MOVS     R0,#+0
    731            gintsts.b.enumdone = 1;
   \   0000003E   50F40050           ORRS     R0,R0,#0x2000
    732            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, gintsts.d32 );
   \   00000042   E168               LDR      R1,[R4, #+12]
   \   00000044   4861               STR      R0,[R1, #+20]
    733            return 1;
   \   00000046   0120               MOVS     R0,#+1
   \   00000048   32BD               POP      {R1,R4,R5,PC}    ;; return
    734          }
    735          
    736          /**
    737          * @brief  DCD_ReadDevInEP
    738          *         Reads ep flags
    739          * @param  pdev: device instance
    740          * @retval status
    741          */

   \                                 In section .text, align 2, keep-with-next
    742          static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
    743          {
    744            uint32_t v, msk, emp;
    745            msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
   \                     DCD_ReadDevInEP:
   \   00000000   0269               LDR      R2,[R0, #+16]
   \   00000002   1269               LDR      R2,[R2, #+16]
    746            emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
   \   00000004   0369               LDR      R3,[R0, #+16]
   \   00000006   5B6B               LDR      R3,[R3, #+52]
    747            msk |= ((emp >> epnum) & 0x1) << 7;
   \   00000008   CB40               LSRS     R3,R3,R1
   \   0000000A   13F00103           ANDS     R3,R3,#0x1
   \   0000000E   52EAC312           ORRS     R2,R2,R3, LSL #+7
    748            v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
   \   00000012   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   10EB8100           ADDS     R0,R0,R1, LSL #+2
   \   00000018   8069               LDR      R0,[R0, #+24]
   \   0000001A   8068               LDR      R0,[R0, #+8]
   \   0000001C   1040               ANDS     R0,R2,R0
    749            return v;
   \   0000001E   7047               BX       LR               ;; return
    750          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     USBD_DCD_INT_fops

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   10ED00E0           DC32     0xe000ed10
    751          
    752          
    753          
    754          /**
    755          * @}
    756          */ 
    757          
    758          /**
    759          * @}
    760          */ 
    761          
    762          /**
    763          * @}
    764          */
    765          
    766          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     DCD_HandleEnumDone_ISR             16
     DCD_HandleInEP_ISR                 24
     DCD_HandleOutEP_ISR                24
     DCD_HandleResume_ISR                8
     DCD_HandleRxStatusQueueLevel_ISR
                                        24
     DCD_HandleSof_ISR                   8
     DCD_HandleUSBSuspend_ISR            8
     DCD_HandleUsbReset_ISR             32
     DCD_ReadDevInEP                     0
     DCD_WriteEmptyTxFifo               24
     USBD_OTG_ISR_Handler               16


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     USBD_OTG_ISR_Handler            178
     DCD_HandleResume_ISR             72
     DCD_HandleUSBSuspend_ISR        104
     DCD_HandleInEP_ISR              268
     DCD_HandleOutEP_ISR             226
     DCD_HandleSof_ISR                28
     DCD_HandleRxStatusQueueLevel_ISR
                                     158
     DCD_WriteEmptyTxFifo            136
     DCD_HandleUsbReset_ISR          198
     DCD_HandleEnumDone_ISR           74
     DCD_ReadDevInEP                  32
     ??DataTable5                      4
     ??DataTable5_1                    4

 
 1 482 bytes in section .text
 
 1 482 bytes of CODE memory

Errors: none
Warnings: none
