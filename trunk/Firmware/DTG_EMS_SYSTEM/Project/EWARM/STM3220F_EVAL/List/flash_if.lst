###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     19/Jan/2012  11:09:08 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\flash_if #
#                    .c                                                       #
#    Command line =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\flash_if #
#                    .c -D USE_STDPERIPH_DRIVER -D STM32F2XX -D               #
#                    USE_STM3220F_EVAL -D USE_USB_OTG_FS -D                   #
#                    RTC_CLOCK_SOURCE_LSE -lC F:\Work\S&G2000\Firmware\DTG_EM #
#                    S_SYSTEM\Project\EWARM\STM3220F_EVAL\List\ -lA           #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\ -o F:\Work\S&G2000\Firmware\DTG_EMS_SY #
#                    STEM\Project\EWARM\STM3220F_EVAL\Obj\ --no_cse           #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Full.h" -I                     #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWA #
#                    RM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I             #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I         #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\ -I                             #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\Common\ -I                      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_OTG_Driver\inc\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Core\inc\ -I      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\msc\inc\    #
#                    -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM #
#                    \..\Usb\ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Proj #
#                    ect\EWARM\..\Usb\Inc\ -I F:\Work\S&G2000\Firmware\DTG_EM #
#                    S_SYSTEM\Project\EWARM\..\Usb\src\ -I                    #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Core\inc\ -I        #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -Ol --use_c++_inline                                     #
#    List file    =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\flash_if.lst                            #
#    Object file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\Obj\flash_if.o                               #
#                                                                             #
#                                                                             #
###############################################################################

F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\flash_if.c
      1          /**
      2            ******************************************************************************
      3            * @file    STM32F2xx_IAP/src/flash_if.c 
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    02-May-2011
      7            * @brief   This file provides all the memory related operation functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */ 
     21          
     22          /** @addtogroup STM32F2xx_IAP
     23            * @{
     24            */
     25          
     26          /* Includes ------------------------------------------------------------------*/
     27          #include "flash_if.h"
     28          
     29          /* Private typedef -----------------------------------------------------------*/
     30          /* Private define ------------------------------------------------------------*/
     31          /* Private macro -------------------------------------------------------------*/
     32          /* Private variables ---------------------------------------------------------*/
     33          /* Private function prototypes -----------------------------------------------*/
     34          static uint32_t GetSector(uint32_t Address);
     35          
     36          /* Private functions ---------------------------------------------------------*/
     37          
     38          /**
     39            * @brief  Unlocks Flash for write access
     40            * @param  None
     41            * @retval None
     42            */

   \                                 In section .text, align 2, keep-with-next
     43          void FLASH_If_Init(void)
     44          { 
   \                     FLASH_If_Init:
   \   00000000   80B5               PUSH     {R7,LR}
     45            FLASH_Unlock(); 
   \   00000002   ........           BL       FLASH_Unlock
     46          
     47            /* Clear pending flags (if any) */  
     48            FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | 
     49                            FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR|FLASH_FLAG_PGSERR);
   \   00000006   F320               MOVS     R0,#+243
   \   00000008   ........           BL       FLASH_ClearFlag
     50          }
   \   0000000C   01BD               POP      {R0,PC}          ;; return
     51          
     52          /**
     53            * @brief  This function does an erase of all user flash area
     54            * @param  StartSector: start of user flash area
     55            * @retval 0: user flash area successfully erased
     56            *         1: error occurred
     57            */
     58          
     59          static uint32_t cal_erase_sector(uint32_t Address)
                                 ^
Warning[Pe177]: function "cal_erase_sector" was declared but never referenced
     60          {
     61            uint32_t erase_cnt = 0;
     62            
     63            if((Address < ADDR_FLASH_SECTOR_1) && (Address >= ADDR_FLASH_SECTOR_0))
     64            {
     65              erase_cnt = FLASH_Sector_0;  
     66            }
     67            else if((Address < ADDR_FLASH_SECTOR_2) && (Address >= ADDR_FLASH_SECTOR_1))
     68            {
     69              erase_cnt = FLASH_Sector_1;  
     70            }
     71            else if((Address < ADDR_FLASH_SECTOR_3) && (Address >= ADDR_FLASH_SECTOR_2))
     72            {
     73              erase_cnt = FLASH_Sector_2;  
     74            }
     75            else if((Address < ADDR_FLASH_SECTOR_4) && (Address >= ADDR_FLASH_SECTOR_3))
     76            {
     77              erase_cnt = FLASH_Sector_3;  
     78            }
     79            else if((Address < ADDR_FLASH_SECTOR_5) && (Address >= ADDR_FLASH_SECTOR_4))
     80            {
     81              erase_cnt = FLASH_Sector_4;  
     82            }
     83            else if((Address < ADDR_FLASH_SECTOR_6) && (Address >= ADDR_FLASH_SECTOR_5))
     84            {
     85              erase_cnt = FLASH_Sector_5;  
     86            }
     87            else if((Address < ADDR_FLASH_SECTOR_7) && (Address >= ADDR_FLASH_SECTOR_6))
     88            {
     89              erase_cnt = FLASH_Sector_6;  
     90            }
     91            else if((Address < ADDR_FLASH_SECTOR_8) && (Address >= ADDR_FLASH_SECTOR_7))
     92            {
     93              erase_cnt = FLASH_Sector_7;  
     94            }
     95            else if((Address < ADDR_FLASH_SECTOR_9) && (Address >= ADDR_FLASH_SECTOR_8))
     96            {
     97              erase_cnt = FLASH_Sector_8;  
     98            }
     99            else if((Address < ADDR_FLASH_SECTOR_10) && (Address >= ADDR_FLASH_SECTOR_9))
    100            {
    101              erase_cnt = FLASH_Sector_9;  
    102            }
    103            else if((Address < ADDR_FLASH_SECTOR_11) && (Address >= ADDR_FLASH_SECTOR_10))
    104            {
    105              erase_cnt = FLASH_Sector_10;  
    106            }
    107            else/*(Address < FLASH_END_ADDR) && (Address >= ADDR_FLASH_SECTOR_11))*/
    108            {
    109              erase_cnt = FLASH_Sector_11;  
    110            }
    111              return erase_cnt;
    112          }
    113          
    114          /**
    115            * @brief  This function does an erase of all user flash area
    116            * @param  StartSector: start of user flash area
    117            * @retval 0: user flash area successfully erased
    118            *         1: error occurred
    119            */

   \                                 In section .text, align 2, keep-with-next
    120          uint32_t FLASH_If_Erase(uint32_t StartSector,uint32_t length)
    121          {
   \                     FLASH_If_Erase:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0C00               MOVS     R4,R1
    122            uint32_t UserStartSector = FLASH_Sector_1, i = 0, T_erase_sector=0;
   \   00000004   0825               MOVS     R5,#+8
   \   00000006   0026               MOVS     R6,#+0
   \   00000008   0027               MOVS     R7,#+0
    123          
    124            /* Get the sector where start the user flash area */
    125            UserStartSector = GetSector(UPDATE_ADDRESS);
   \   0000000A   ....               LDR.N    R0,??DataTable4  ;; 0x8040000
   \   0000000C   ........           BL       GetSector
   \   00000010   0500               MOVS     R5,R0
    126            T_erase_sector =GetSector(UPDATE_ADDRESS+length);
   \   00000012   ....               LDR.N    R0,??DataTable4  ;; 0x8040000
   \   00000014   0019               ADDS     R0,R0,R4
   \   00000016   ........           BL       GetSector
   \   0000001A   0700               MOVS     R7,R0
    127            
    128            for(i = UserStartSector; i <= T_erase_sector; i += 8)
   \   0000001C   2E00               MOVS     R6,R5
   \   0000001E   00E0               B.N      ??FLASH_If_Erase_0
   \                     ??FLASH_If_Erase_1:
   \   00000020   0836               ADDS     R6,R6,#+8
   \                     ??FLASH_If_Erase_0:
   \   00000022   B742               CMP      R7,R6
   \   00000024   07D3               BCC.N    ??FLASH_If_Erase_2
    129            {
    130              /* Device voltage range supposed to be [2.7V to 3.6V], the operation will
    131                 be done by word */ 
    132              if (FLASH_EraseSector(i, VoltageRange_3) != FLASH_COMPLETE)
   \   00000026   0221               MOVS     R1,#+2
   \   00000028   3000               MOVS     R0,R6
   \   0000002A   ........           BL       FLASH_EraseSector
   \   0000002E   0828               CMP      R0,#+8
   \   00000030   F6D0               BEQ.N    ??FLASH_If_Erase_1
    133              {
    134                /* Error occurred while page erase */
    135                return (1);
   \   00000032   0120               MOVS     R0,#+1
   \   00000034   00E0               B.N      ??FLASH_If_Erase_3
    136              }
    137            }
    138            
    139            return (0);
   \                     ??FLASH_If_Erase_2:
   \   00000036   0020               MOVS     R0,#+0
   \                     ??FLASH_If_Erase_3:
   \   00000038   F2BD               POP      {R1,R4-R7,PC}    ;; return
    140          }
    141          
    142          /**
    143            * @brief  This function writes a data buffer in flash (data are 32-bit aligned).
    144            * @note   After writing data buffer, the flash content is checked.
    145            * @param  FlashAddress: start address for writing data buffer
    146            * @param  Data: pointer on data buffer
    147            * @param  DataLength: length of data buffer (unit is 32-bit word)   
    148            * @retval 0: Data successfully written to Flash memory
    149            *         1: Error occurred while writing data in Flash memory
    150            *         2: Written Data in flash memory is different from expected one
    151            */

   \                                 In section .text, align 2, keep-with-next
    152          uint32_t FLASH_If_Write(__IO uint32_t* FlashAddress, uint32_t* Data ,uint16_t DataLength)
    153          {
   \                     FLASH_If_Write:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    154            uint32_t i = 0;
   \   00000008   0027               MOVS     R7,#+0
    155          
    156            for (i = 0; (i < DataLength) && (*FlashAddress <= (USER_FLASH_END_ADDRESS-4)); i++)
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   0700               MOVS     R7,R0
   \   0000000E   03E0               B.N      ??FLASH_If_Write_0
    157            {
    158              /* Device voltage range supposed to be [2.7V to 3.6V], the operation will
    159                 be done by word */ 
    160              if (FLASH_ProgramWord(*FlashAddress, *(uint32_t*)(Data+i)) == FLASH_COMPLETE)
    161              {
    162               /* Check the written value */
    163                if (*(uint32_t*)*FlashAddress != *(uint32_t*)(Data+i))
    164                {
    165                  /* Flash content doesn't match SRAM content */
    166                  return(2);
    167                }
    168                /* Increment FLASH destination address */
    169                *FlashAddress += 4;
   \                     ??FLASH_If_Write_1:
   \   00000010   2068               LDR      R0,[R4, #+0]
   \   00000012   001D               ADDS     R0,R0,#+4
   \   00000014   2060               STR      R0,[R4, #+0]
   \   00000016   7F1C               ADDS     R7,R7,#+1
   \                     ??FLASH_If_Write_0:
   \   00000018   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001A   B742               CMP      R7,R6
   \   0000001C   14D2               BCS.N    ??FLASH_If_Write_2
   \   0000001E   2068               LDR      R0,[R4, #+0]
   \   00000020   ....               LDR.N    R1,??DataTable4_1  ;; 0x80ffffc
   \   00000022   8842               CMP      R0,R1
   \   00000024   10D2               BCS.N    ??FLASH_If_Write_2
   \   00000026   55F82710           LDR      R1,[R5, R7, LSL #+2]
   \   0000002A   2068               LDR      R0,[R4, #+0]
   \   0000002C   ........           BL       FLASH_ProgramWord
   \   00000030   0828               CMP      R0,#+8
   \   00000032   07D1               BNE.N    ??FLASH_If_Write_3
   \   00000034   2068               LDR      R0,[R4, #+0]
   \   00000036   0068               LDR      R0,[R0, #+0]
   \   00000038   55F82710           LDR      R1,[R5, R7, LSL #+2]
   \   0000003C   8842               CMP      R0,R1
   \   0000003E   E7D0               BEQ.N    ??FLASH_If_Write_1
   \   00000040   0220               MOVS     R0,#+2
   \   00000042   02E0               B.N      ??FLASH_If_Write_4
    170              }
    171              else
    172              {
    173                /* Error occurred while writing data in Flash memory */
    174                return (1);
   \                     ??FLASH_If_Write_3:
   \   00000044   0120               MOVS     R0,#+1
   \   00000046   00E0               B.N      ??FLASH_If_Write_4
    175              }
    176            }
    177          
    178            return (0);
   \                     ??FLASH_If_Write_2:
   \   00000048   0020               MOVS     R0,#+0
   \                     ??FLASH_If_Write_4:
   \   0000004A   F2BD               POP      {R1,R4-R7,PC}    ;; return
    179          }
    180          
    181          /**
    182            * @brief  Returns the write protection status of user flash area.
    183            * @param  None
    184            * @retval 0: No write protected sectors inside the user flash area
    185            *         1: Some sectors inside the user flash area are write protected
    186            */

   \                                 In section .text, align 2, keep-with-next
    187          uint16_t FLASH_If_GetWriteProtectionStatus(void)
    188          {
   \                     FLASH_If_GetWriteProtectionStatus:
   \   00000000   10B5               PUSH     {R4,LR}
    189            uint32_t UserStartSector = FLASH_Sector_1;
   \   00000002   0824               MOVS     R4,#+8
    190          
    191            /* Get the sector where start the user flash area */
    192            UserStartSector = GetSector(APPLICATION_ADDRESS);
   \   00000004   ....               LDR.N    R0,??DataTable4_2  ;; 0x8010000
   \   00000006   ........           BL       GetSector
   \   0000000A   0400               MOVS     R4,R0
    193          
    194            /* Check if there are write protected sectors inside the user flash area */
    195            if ((FLASH_OB_GetWRP() >> (UserStartSector/8)) == (0xFFF >> (UserStartSector/8)))
   \   0000000C   ........           BL       FLASH_OB_GetWRP
   \   00000010   E108               LSRS     R1,R4,#+3
   \   00000012   0841               ASRS     R0,R0,R1
   \   00000014   40F6FF71           MOVW     R1,#+4095
   \   00000018   E208               LSRS     R2,R4,#+3
   \   0000001A   1141               ASRS     R1,R1,R2
   \   0000001C   8842               CMP      R0,R1
   \   0000001E   01D1               BNE.N    ??FLASH_If_GetWriteProtectionStatus_0
    196            { /* No write protected sectors inside the user flash area */
    197              return 1;
   \   00000020   0120               MOVS     R0,#+1
   \   00000022   00E0               B.N      ??FLASH_If_GetWriteProtectionStatus_1
    198            }
    199            else
    200            { /* Some sectors inside the user flash area are write protected */
    201              return 0;
   \                     ??FLASH_If_GetWriteProtectionStatus_0:
   \   00000024   0020               MOVS     R0,#+0
   \                     ??FLASH_If_GetWriteProtectionStatus_1:
   \   00000026   10BD               POP      {R4,PC}          ;; return
    202            }
    203          }
    204          
    205          /**
    206            * @brief  Disables the write protection of user flash area.
    207            * @param  None
    208            * @retval 1: Write Protection successfully disabled
    209            *         2: Error: Flash write unprotection failed
    210            */

   \                                 In section .text, align 2, keep-with-next
    211          uint32_t FLASH_If_DisableWriteProtection(void)
    212          {
   \                     FLASH_If_DisableWriteProtection:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   83B0               SUB      SP,SP,#+12
    213            __IO uint32_t UserStartSector = FLASH_Sector_1, UserWrpSectors = OB_WRP_Sector_1;
   \   00000004   0820               MOVS     R0,#+8
   \   00000006   0190               STR      R0,[SP, #+4]
   \   00000008   0220               MOVS     R0,#+2
   \   0000000A   0090               STR      R0,[SP, #+0]
    214          
    215            /* Get the sector where start the user flash area */
    216            UserStartSector = GetSector(APPLICATION_ADDRESS);
   \   0000000C   ....               LDR.N    R0,??DataTable4_2  ;; 0x8010000
   \   0000000E   ........           BL       GetSector
   \   00000012   0190               STR      R0,[SP, #+4]
    217          
    218            /* Mark all sectors inside the user flash area as non protected */  
    219            UserWrpSectors = 0xFFF-((1 << (UserStartSector/8))-1);
   \   00000014   40F6FF70           MOVW     R0,#+4095
   \   00000018   0121               MOVS     R1,#+1
   \   0000001A   019A               LDR      R2,[SP, #+4]
   \   0000001C   D208               LSRS     R2,R2,#+3
   \   0000001E   9140               LSLS     R1,R1,R2
   \   00000020   401A               SUBS     R0,R0,R1
   \   00000022   401C               ADDS     R0,R0,#+1
   \   00000024   0090               STR      R0,[SP, #+0]
    220             
    221            /* Unlock the Option Bytes */
    222            FLASH_OB_Unlock();
   \   00000026   ........           BL       FLASH_OB_Unlock
    223          
    224            /* Disable the write protection for all sectors inside the user flash area */
    225            FLASH_OB_WRPConfig(UserWrpSectors, DISABLE);
   \   0000002A   0021               MOVS     R1,#+0
   \   0000002C   0098               LDR      R0,[SP, #+0]
   \   0000002E   ........           BL       FLASH_OB_WRPConfig
    226          
    227            /* Start the Option Bytes programming process. */  
    228            if (FLASH_OB_Launch() != FLASH_COMPLETE)
   \   00000032   ........           BL       FLASH_OB_Launch
   \   00000036   0828               CMP      R0,#+8
   \   00000038   01D0               BEQ.N    ??FLASH_If_DisableWriteProtection_0
    229            {
    230              /* Error: Flash write unprotection failed */
    231              return (2);
   \   0000003A   0220               MOVS     R0,#+2
   \   0000003C   00E0               B.N      ??FLASH_If_DisableWriteProtection_1
    232            }
    233          
    234            /* Write Protection successfully disabled */
    235            return (1);
   \                     ??FLASH_If_DisableWriteProtection_0:
   \   0000003E   0120               MOVS     R0,#+1
   \                     ??FLASH_If_DisableWriteProtection_1:
   \   00000040   0EBD               POP      {R1-R3,PC}       ;; return
    236          }
    237          
    238          /**
    239            * @brief  Gets the sector of a given address
    240            * @param  Address: Flash address
    241            * @retval The sector of a given address
    242            */

   \                                 In section .text, align 2, keep-with-next
    243          static uint32_t GetSector(uint32_t Address)
    244          {
    245            uint32_t sector = 0;
   \                     GetSector:
   \   00000000   0021               MOVS     R1,#+0
    246            
    247            if((Address < ADDR_FLASH_SECTOR_1) && (Address >= ADDR_FLASH_SECTOR_0))
   \   00000002   B0F10062           SUBS     R2,R0,#+134217728
   \   00000006   B2F5804F           CMP      R2,#+16384
   \   0000000A   01D2               BCS.N    ??GetSector_0
    248            {
    249              sector = FLASH_Sector_0;  
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   46E0               B.N      ??GetSector_1
    250            }
    251            else if((Address < ADDR_FLASH_SECTOR_2) && (Address >= ADDR_FLASH_SECTOR_1))
   \                     ??GetSector_0:
   \   00000010   ....               LDR.N    R1,??DataTable4_3  ;; 0x8004000
   \   00000012   411A               SUBS     R1,R0,R1
   \   00000014   B1F5804F           CMP      R1,#+16384
   \   00000018   01D2               BCS.N    ??GetSector_2
    252            {
    253              sector = FLASH_Sector_1;  
   \   0000001A   0821               MOVS     R1,#+8
   \   0000001C   3FE0               B.N      ??GetSector_1
    254            }
    255            else if((Address < ADDR_FLASH_SECTOR_3) && (Address >= ADDR_FLASH_SECTOR_2))
   \                     ??GetSector_2:
   \   0000001E   ....               LDR.N    R1,??DataTable4_4  ;; 0x8008000
   \   00000020   411A               SUBS     R1,R0,R1
   \   00000022   B1F5804F           CMP      R1,#+16384
   \   00000026   01D2               BCS.N    ??GetSector_3
    256            {
    257              sector = FLASH_Sector_2;  
   \   00000028   1021               MOVS     R1,#+16
   \   0000002A   38E0               B.N      ??GetSector_1
    258            }
    259            else if((Address < ADDR_FLASH_SECTOR_4) && (Address >= ADDR_FLASH_SECTOR_3))
   \                     ??GetSector_3:
   \   0000002C   ....               LDR.N    R1,??DataTable4_5  ;; 0x800c000
   \   0000002E   411A               SUBS     R1,R0,R1
   \   00000030   B1F5804F           CMP      R1,#+16384
   \   00000034   01D2               BCS.N    ??GetSector_4
    260            {
    261              sector = FLASH_Sector_3;  
   \   00000036   1821               MOVS     R1,#+24
   \   00000038   31E0               B.N      ??GetSector_1
    262            }
    263            else if((Address < ADDR_FLASH_SECTOR_5) && (Address >= ADDR_FLASH_SECTOR_4))
   \                     ??GetSector_4:
   \   0000003A   ....               LDR.N    R1,??DataTable4_2  ;; 0x8010000
   \   0000003C   411A               SUBS     R1,R0,R1
   \   0000003E   B1F5803F           CMP      R1,#+65536
   \   00000042   01D2               BCS.N    ??GetSector_5
    264            {
    265              sector = FLASH_Sector_4;  
   \   00000044   2021               MOVS     R1,#+32
   \   00000046   2AE0               B.N      ??GetSector_1
    266            }
    267            else if((Address < ADDR_FLASH_SECTOR_6) && (Address >= ADDR_FLASH_SECTOR_5))
   \                     ??GetSector_5:
   \   00000048   ....               LDR.N    R1,??DataTable4_6  ;; 0x8020000
   \   0000004A   411A               SUBS     R1,R0,R1
   \   0000004C   B1F5003F           CMP      R1,#+131072
   \   00000050   01D2               BCS.N    ??GetSector_6
    268            {
    269              sector = FLASH_Sector_5;  
   \   00000052   2821               MOVS     R1,#+40
   \   00000054   23E0               B.N      ??GetSector_1
    270            }
    271            else if((Address < ADDR_FLASH_SECTOR_7) && (Address >= ADDR_FLASH_SECTOR_6))
   \                     ??GetSector_6:
   \   00000056   ....               LDR.N    R1,??DataTable4  ;; 0x8040000
   \   00000058   411A               SUBS     R1,R0,R1
   \   0000005A   B1F5003F           CMP      R1,#+131072
   \   0000005E   01D2               BCS.N    ??GetSector_7
    272            {
    273              sector = FLASH_Sector_6;  
   \   00000060   3021               MOVS     R1,#+48
   \   00000062   1CE0               B.N      ??GetSector_1
    274            }
    275            else if((Address < ADDR_FLASH_SECTOR_8) && (Address >= ADDR_FLASH_SECTOR_7))
   \                     ??GetSector_7:
   \   00000064   ....               LDR.N    R1,??DataTable4_7  ;; 0x8060000
   \   00000066   411A               SUBS     R1,R0,R1
   \   00000068   B1F5003F           CMP      R1,#+131072
   \   0000006C   01D2               BCS.N    ??GetSector_8
    276            {
    277              sector = FLASH_Sector_7;  
   \   0000006E   3821               MOVS     R1,#+56
   \   00000070   15E0               B.N      ??GetSector_1
    278            }
    279            else if((Address < ADDR_FLASH_SECTOR_9) && (Address >= ADDR_FLASH_SECTOR_8))
   \                     ??GetSector_8:
   \   00000072   ....               LDR.N    R1,??DataTable4_8  ;; 0x8080000
   \   00000074   411A               SUBS     R1,R0,R1
   \   00000076   B1F5003F           CMP      R1,#+131072
   \   0000007A   01D2               BCS.N    ??GetSector_9
    280            {
    281              sector = FLASH_Sector_8;  
   \   0000007C   4021               MOVS     R1,#+64
   \   0000007E   0EE0               B.N      ??GetSector_1
    282            }
    283            else if((Address < ADDR_FLASH_SECTOR_10) && (Address >= ADDR_FLASH_SECTOR_9))
   \                     ??GetSector_9:
   \   00000080   ....               LDR.N    R1,??DataTable4_9  ;; 0x80a0000
   \   00000082   411A               SUBS     R1,R0,R1
   \   00000084   B1F5003F           CMP      R1,#+131072
   \   00000088   01D2               BCS.N    ??GetSector_10
    284            {
    285              sector = FLASH_Sector_9;  
   \   0000008A   4821               MOVS     R1,#+72
   \   0000008C   07E0               B.N      ??GetSector_1
    286            }
    287            else if((Address < ADDR_FLASH_SECTOR_11) && (Address >= ADDR_FLASH_SECTOR_10))
   \                     ??GetSector_10:
   \   0000008E   ....               LDR.N    R1,??DataTable4_10  ;; 0x80c0000
   \   00000090   401A               SUBS     R0,R0,R1
   \   00000092   B0F5003F           CMP      R0,#+131072
   \   00000096   01D2               BCS.N    ??GetSector_11
    288            {
    289              sector = FLASH_Sector_10;  
   \   00000098   5021               MOVS     R1,#+80
   \   0000009A   00E0               B.N      ??GetSector_1
    290            }
    291            else/*(Address < FLASH_END_ADDR) && (Address >= ADDR_FLASH_SECTOR_11))*/
    292            {
    293              sector = FLASH_Sector_11;  
   \                     ??GetSector_11:
   \   0000009C   5821               MOVS     R1,#+88
    294            }
    295              return sector;
   \                     ??GetSector_1:
   \   0000009E   0800               MOVS     R0,R1
   \   000000A0   7047               BX       LR               ;; return
    296          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   00000408           DC32     0x8040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   FCFF0F08           DC32     0x80ffffc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   00000108           DC32     0x8010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   00400008           DC32     0x8004000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   00800008           DC32     0x8008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   00C00008           DC32     0x800c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   00000208           DC32     0x8020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   00000608           DC32     0x8060000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   00000808           DC32     0x8080000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   00000A08           DC32     0x80a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   00000C08           DC32     0x80c0000
    297          
    298          /**
    299            * @}
    300            */
    301          
    302          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     FLASH_If_DisableWriteProtection
                                        16
     FLASH_If_Erase                     24
     FLASH_If_GetWriteProtectionStatus
                                         8
     FLASH_If_Init                       8
     FLASH_If_Write                     24
     GetSector                           0


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     FLASH_If_Init                    14
     FLASH_If_Erase                   58
     FLASH_If_Write                   76
     FLASH_If_GetWriteProtectionStatus
                                      40
     FLASH_If_DisableWriteProtection
                                      66
     GetSector                       162
     ??DataTable4                      4
     ??DataTable4_1                    4
     ??DataTable4_2                    4
     ??DataTable4_3                    4
     ??DataTable4_4                    4
     ??DataTable4_5                    4
     ??DataTable4_6                    4
     ??DataTable4_7                    4
     ??DataTable4_8                    4
     ??DataTable4_9                    4
     ??DataTable4_10                   4

 
 460 bytes in section .text
 
 460 bytes of CODE memory

Errors: none
Warnings: 1
