###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     19/Jan/2012  11:09:12 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32F #
#                    2xx_StdPeriph_Driver\src\stm32f2xx_rtc.c                 #
#    Command line =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32F #
#                    2xx_StdPeriph_Driver\src\stm32f2xx_rtc.c -D              #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D RTC_CLOCK_SOURCE_LSE -lC            #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\ -lA F:\Work\S&G2000\Firmware\DTG_EMS_S #
#                    YSTEM\Project\EWARM\STM3220F_EVAL\List\ -o               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\Obj\ --no_cse --no_unroll --no_inline        #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\ #
#                    EWARM\..\ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Pro #
#                    ject\EWARM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I     #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I         #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\ -I                             #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\Common\ -I                      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_OTG_Driver\inc\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Core\inc\ -I      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\msc\inc\    #
#                    -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM #
#                    \..\Usb\ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Proj #
#                    ect\EWARM\..\Usb\Inc\ -I F:\Work\S&G2000\Firmware\DTG_EM #
#                    S_SYSTEM\Project\EWARM\..\Usb\src\ -I                    #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Core\inc\ -I        #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -Ol --use_c++_inline                                     #
#    List file    =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\stm32f2xx_rtc.lst                       #
#    Object file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\Obj\stm32f2xx_rtc.o                          #
#                                                                             #
#                                                                             #
###############################################################################

F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_rtc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_rtc.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    18-April-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Real-Time Clock (RTC) peripheral:
      9            *           - Initialization
     10            *           - Calendar (Time and Date) configuration
     11            *           - Alarms (Alarm A and Alarm B) configuration
     12            *           - WakeUp Timer configuration
     13            *           - Daylight Saving configuration
     14            *           - Output pin Configuration
     15            *           - Coarse Calibration configuration
     16            *           - TimeStamp configuration
     17            *           - Tampers configuration
     18            *           - Backup Data Registers configuration
     19            *           - RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration
     20            *           - Interrupts and flags management
     21            *
     22            *  @verbatim
     23            *
     24            *          ===================================================================
     25            *                               Backup Domain Operating Condition
     26            *          ===================================================================
     27            *          The real-time clock (RTC), the RTC backup registers, and the backup 
     28            *          SRAM (BKP SRAM) can be powered from the VBAT voltage when the main 
     29            *          VDD supply is powered off.
     30            *          To retain the content of the RTC backup registers, backup SRAM, 
     31            *          and supply the RTC when VDD is turned off, VBAT pin can be connected 
     32            *          to an optional standby voltage supplied by a battery or by another 
     33            *          source.
     34            *
     35            *          To allow the RTC to operate even when the main digital supply (VDD) 
     36            *          is turned off, the VBAT pin powers the following blocks:
     37            *            1 - The RTC
     38            *            2 - The LSE oscillator
     39            *            3 - The backup SRAM when the low power backup regulator is enabled
     40            *            4 - PC13 to PC15 I/Os, plus PI8 I/O (when available)
     41            *
     42            *          When the backup domain is supplied by VDD (analog switch connected 
     43            *          to VDD), the following functions are available:
     44            *            1 - PC14 and PC15 can be used as either GPIO or LSE pins
     45            *            2 - PC13 can be used as a GPIO or as the RTC_AF1 pin
     46            *            3 - PI8 can be used as a GPIO or as the RTC_AF2 pin
     47            *
     48            *          When the backup domain is supplied by VBAT (analog switch connected 
     49            *          to VBAT because VDD is not present), the following functions are available:
     50            *            1 - PC14 and PC15 can be used as LSE pins only
     51            *            2 - PC13 can be used as the RTC_AF1 pin 
     52            *            3 - PI8 can be used as the RTC_AF2 pin
     53            *
     54            *          ===================================================================
     55            *                                    Backup Domain Reset
     56            *          ===================================================================
     57            *          The backup domain reset sets all RTC registers and the RCC_BDCR 
     58            *          register to their reset values. The BKPSRAM is not affected by this
     59            *          reset. The only way of resetting the BKPSRAM is through the Flash 
     60            *          interface by requesting a protection level change from 1 to 0.
     61            *          A backup domain reset is generated when one of the following events
     62            *          occurs:
     63            *            1 - Software reset, triggered by setting the BDRST bit in the 
     64            *                RCC Backup domain control register (RCC_BDCR). You can use the
     65            *                RCC_BackupResetCmd().
     66            *            2 - VDD or VBAT power on, if both supplies have previously been
     67            *                powered off.
     68            *
     69            *          ===================================================================
     70            *                                   Backup Domain Access
     71            *          ===================================================================
     72            *          After reset, the backup domain (RTC registers, RTC backup data 
     73            *          registers and backup SRAM) is protected against possible unwanted 
     74            *          write accesses. 
     75            *          To enable access to the RTC Domain and RTC registers, proceed as follows:
     76            *            - Enable the Power Controller (PWR) APB1 interface clock using the
     77            *              RCC_APB1PeriphClockCmd() function.
     78            *            - Enable access to RTC domain using the PWR_BackupAccessCmd() function.
     79            *            - Select the RTC clock source using the RCC_RTCCLKConfig() function.
     80            *            - Enable RTC Clock using the RCC_RTCCLKCmd() function.
     81            *
     82            *          ===================================================================
     83            *                                   RTC Driver: how to use it
     84            *          ===================================================================
     85            *            - Enable the RTC domain access (see description in the section above)
     86            *            - Configure the RTC Prescaler (Asynchronous and Synchronous) and
     87            *              RTC hour format using the RTC_Init() function.
     88            *
     89            *          Time and Date configuration
     90            *          ===========================
     91            *            - To configure the RTC Calendar (Time and Date) use the RTC_SetTime()
     92            *              and RTC_SetDate() functions.
     93            *            - To read the RTC Calendar, use the RTC_GetTime() and RTC_GetDate()
     94            *              functions.
     95            *            - Use the RTC_DayLightSavingConfig() function to add or sub one
     96            *              hour to the RTC Calendar.    
     97            *
     98            *          Alarm configuration
     99            *          ===================
    100            *            - To configure the RTC Alarm use the RTC_SetAlarm() function.
    101            *            - Enable the selected RTC Alarm using the RTC_AlarmCmd() function
    102            *            - To read the RTC Alarm, use the RTC_GetAlarm() function.
    103            *
    104            *          RTC Wakeup configuration
    105            *          ========================
    106            *            - Configure the RTC Wakeup Clock source use the RTC_WakeUpClockConfig()
    107            *              function.
    108            *            - Configure the RTC WakeUp Counter using the RTC_SetWakeUpCounter() 
    109            *              function  
    110            *            - Enable the RTC WakeUp using the RTC_WakeUpCmd() function  
    111            *            - To read the RTC WakeUp Counter register, use the RTC_GetWakeUpCounter() 
    112            *              function.
    113            *
    114            *          Outputs configuration
    115            *          =====================
    116            *          The RTC has 2 different outputs:
    117            *            - AFO_ALARM: this output is used to manage the RTC Alarm A, Alarm B
    118            *              and WaKeUp signals.          
    119            *              To output the selected RTC signal on RTC_AF1 pin, use the 
    120            *              RTC_OutputConfig() function.                
    121            *            - AFO_CALIB: this output is used to manage the RTC Clock divided 
    122            *              by 64 (512Hz) signal.
    123            *              To output the RTC Clock on RTC_AF1 pin, use the RTC_CalibOutputCmd()
    124            *              function.
    125            *
    126            *          Coarse Calibration configuration
    127            *          =================================
    128            *            - Configure the RTC Coarse Calibration Value and the corresponding
    129            *              sign using the RTC_CoarseCalibConfig() function.
    130            *            - Enable the RTC Coarse Calibration using the RTC_CoarseCalibCmd() 
    131            *              function  
    132            *
    133            *          TimeStamp configuration
    134            *          =======================
    135            *            - Configure the RTC_AF1 trigger and enables the RTC TimeStamp 
    136            *              using the RTC_TimeStampCmd() function.
    137            *            - To read the RTC TimeStamp Time and Date register, use the 
    138            *              RTC_GetTimeStamp() function.
    139            *            - The TAMPER1 alternate function can be mapped either to RTC_AF1(PC13)
    140            *              or RTC_AF2 (PI8) depending on the value of TAMP1INSEL bit in 
    141            *              RTC_TAFCR register. You can use the  RTC_TamperPinSelection()
    142            *              function to select the corresponding pin.     
    143            *
    144            *          Tamper configuration
    145            *          ====================
    146            *            - Configure the RTC Tamper trigger using the RTC_TamperConfig() 
    147            *              function.
    148            *            - Enable the RTC Tamper using the RTC_TamperCmd() function.
    149            *            - The TIMESTAMP alternate function can be mapped to either RTC_AF1 
    150            *              or RTC_AF2 depending on the value of the TSINSEL bit in the 
    151            *              RTC_TAFCR register. You can use the  RTC_TimeStampPinSelection()
    152            *              function to select the corresponding pin.   
    153            *
    154            *          Backup Data Registers configuration
    155            *          ===================================
    156            *            - To write to the RTC Backup Data registers, use the RTC_WriteBackupRegister()
    157            *              function.  
    158            *            - To read the RTC Backup Data registers, use the RTC_ReadBackupRegister()
    159            *              function.
    160            * 
    161            *          ===================================================================
    162            *                                  RTC and low power modes
    163            *          ===================================================================
    164            *           The MCU can be woken up from a low power mode by an RTC alternate 
    165            *           function.
    166            *           The RTC alternate functions are the RTC alarms (Alarm A and Alarm B), 
    167            *           RTC wakeup, RTC tamper event detection and RTC time stamp event detection.
    168            *           These RTC alternate functions can wake up the system from the Stop 
    169            *           and Standby lowpower modes.
    170            *           The system can also wake up from low power modes without depending 
    171            *           on an external interrupt (Auto-wakeup mode), by using the RTC alarm 
    172            *           or the RTC wakeup events.
    173            *           The RTC provides a programmable time base for waking up from the 
    174            *           Stop or Standby mode at regular intervals.
    175            *           Wakeup from STOP and Standby modes is possible only when the RTC 
    176            *           clock source is LSE or LSI.
    177            *
    178            *          ===================================================================
    179            *                            Selection of RTC_AF1 alternate functions
    180            *          ===================================================================
    181            *          The RTC_AF1 pin (PC13) can be used for the following purposes:
    182            *            - AFO_ALARM output
    183            *            - AFO_CALIB output
    184            *            - AFI_TAMPER
    185            *            - AFI_TIMESTAMP
    186            *
    187            * +-------------------------------------------------------------------------------------------------------------+
    188            * |     Pin         |AFO_ALARM |AFO_CALIB |AFI_TAMPER |AFI_TIMESTAMP | TAMP1INSEL |   TSINSEL    |ALARMOUTTYPE  |
    189            * |  configuration  | ENABLED  | ENABLED  |  ENABLED  |   ENABLED    |TAMPER1 pin |TIMESTAMP pin |  AFO_ALARM   |
    190            * |  and function   |          |          |           |              | selection  |  selection   |Configuration |
    191            * |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    192            * |   Alarm out     |          |          |           |              |    Don't   |     Don't    |              |
    193            * |   output OD     |     1    |Don't care|Don't care | Don't care   |    care    |     care     |      0       |
    194            * |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    195            * |   Alarm out     |          |          |           |              |    Don't   |     Don't    |              |
    196            * |   output PP     |     1    |Don't care|Don't care | Don't care   |    care    |     care     |      1       |
    197            * |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    198            * | Calibration out |          |          |           |              |    Don't   |     Don't    |              |
    199            * |   output PP     |     0    |    1     |Don't care | Don't care   |    care    |     care     |  Don't care  |
    200            * |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    201            * |  TAMPER input   |          |          |           |              |            |     Don't    |              |
    202            * |   floating      |     0    |    0     |     1     |      0       |      0     |     care     |  Don't care  |
    203            * |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    204            * |  TIMESTAMP and  |          |          |           |              |            |              |              |
    205            * |  TAMPER input   |     0    |    0     |     1     |      1       |      0     |      0       |  Don't care  |
    206            * |   floating      |          |          |           |              |            |              |              |
    207            * |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    208            * | TIMESTAMP input |          |          |           |              |    Don't   |              |              |
    209            * |    floating     |     0    |    0     |     0     |      1       |    care    |      0       |  Don't care  |
    210            * |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    211            * |  Standard GPIO  |     0    |    0     |     0     |      0       | Don't care |  Don't care  |  Don't care  |
    212            * +-------------------------------------------------------------------------------------------------------------+
    213            *
    214            *
    215            *          ===================================================================
    216            *                            Selection of RTC_AF2 alternate functions
    217            *          ===================================================================
    218            *          The RTC_AF2 pin (PI8) can be used for the following purposes:
    219            *            - AFI_TAMPER
    220            *            - AFI_TIMESTAMP
    221            *
    222            * +---------------------------------------------------------------------------------------+
    223            * |     Pin         |AFI_TAMPER |AFI_TIMESTAMP | TAMP1INSEL |   TSINSEL    |ALARMOUTTYPE  |
    224            * |  configuration  |  ENABLED  |   ENABLED    |TAMPER1 pin |TIMESTAMP pin |  AFO_ALARM   |
    225            * |  and function   |           |              | selection  |  selection   |Configuration |
    226            * |-----------------|-----------|--------------|------------|--------------|--------------|
    227            * |  TAMPER input   |           |              |            |     Don't    |              |
    228            * |   floating      |     1     |      0       |      1     |     care     |  Don't care  |
    229            * |-----------------|-----------|--------------|------------|--------------|--------------|
    230            * |  TIMESTAMP and  |           |              |            |              |              |
    231            * |  TAMPER input   |     1     |      1       |      1     |      1       |  Don't care  |
    232            * |   floating      |           |              |            |              |              |
    233            * |-----------------|-----------|--------------|------------|--------------|--------------|
    234            * | TIMESTAMP input |           |              |    Don't   |              |              |
    235            * |    floating     |     0     |      1       |    care    |      1       |  Don't care  |
    236            * |-----------------|-----------|--------------|------------|--------------|--------------|
    237            * |  Standard GPIO  |     0     |      0       | Don't care |  Don't care  |  Don't care  |
    238            * +---------------------------------------------------------------------------------------+
    239            * 
    240            *
    241            *  @endverbatim
    242            *
    243            ******************************************************************************
    244            * @attention
    245            *
    246            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
    247            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
    248            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
    249            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
    250            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
    251            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
    252            *
    253            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
    254            ******************************************************************************
    255            */ 
    256          
    257          /* Includes ------------------------------------------------------------------*/
    258          #include "stm32f2xx_rtc.h"
    259          #include "stm32f2xx_rcc.h"
    260          
    261          /** @addtogroup STM32F2xx_StdPeriph_Driver
    262            * @{
    263            */
    264          
    265          /** @defgroup RTC 
    266            * @brief RTC driver modules
    267            * @{
    268            */
    269          
    270          /* Private typedef -----------------------------------------------------------*/
    271          /* Private define ------------------------------------------------------------*/
    272          
    273          /* Masks Definition */
    274          #define RTC_TR_RESERVED_MASK    ((uint32_t)0x007F7F7F)
    275          #define RTC_DR_RESERVED_MASK    ((uint32_t)0x00FFFF3F) 
    276          #define RTC_INIT_MASK           ((uint32_t)0xFFFFFFFF)  
    277          #define RTC_RSF_MASK            ((uint32_t)0xFFFFFF5F)
    278          #define RTC_FLAGS_MASK          ((uint32_t)(RTC_FLAG_TSOVF | RTC_FLAG_TSF | RTC_FLAG_WUTF | \
    279                                                      RTC_FLAG_ALRBF | RTC_FLAG_ALRAF | RTC_FLAG_INITF | \
    280                                                      RTC_FLAG_RSF | RTC_FLAG_INITS | RTC_FLAG_WUTWF | \
    281                                                      RTC_FLAG_ALRBWF | RTC_FLAG_ALRAWF | RTC_FLAG_TAMP1F ))
    282          
    283          #define INITMODE_TIMEOUT         ((uint32_t) 0x00010000)
    284          #define SYNCHRO_TIMEOUT          ((uint32_t) 0x00008000)
    285          
    286          /* Private macro -------------------------------------------------------------*/
    287          /* Private variables ---------------------------------------------------------*/
    288          /* Private function prototypes -----------------------------------------------*/
    289          static uint8_t RTC_ByteToBcd2(uint8_t Value);
    290          static uint8_t RTC_Bcd2ToByte(uint8_t Value);
    291          
    292          /* Private functions ---------------------------------------------------------*/
    293          
    294          /** @defgroup RTC_Private_Functions
    295            * @{
    296            */ 
    297          
    298          /** @defgroup RTC_Group1 Initialization and Configuration functions
    299           *  @brief   Initialization and Configuration functions 
    300           *
    301          @verbatim   
    302           ===============================================================================
    303                           Initialization and Configuration functions
    304           ===============================================================================
    305          
    306            This section provide functions allowing to initialize and configure the RTC
    307            Prescaler (Synchronous and Asynchronous), RTC Hour format, disable RTC registers
    308            Write protection, enter and exit the RTC initialization mode, RTC registers
    309            synchronization check and reference clock detection enable.
    310            
    311            1. The RTC Prescaler is programmed to generate the RTC 1Hz time base. It is
    312               split into 2 programmable prescalers to minimize power consumption.
    313               - A 7-bit asynchronous prescaler and A 13-bit synchronous prescaler.
    314               - When both prescalers are used, it is recommended to configure the asynchronous
    315                 prescaler to a high value to minimize consumption.
    316          
    317            2. All RTC registers are Write protected. Writing to the RTC registers
    318               is enabled by writing a key into the Write Protection register, RTC_WPR.
    319          
    320            3. To Configure the RTC Calendar, user application should enter initialization
    321               mode. In this mode, the calendar counter is stopped and its value can be 
    322               updated. When the initialization sequence is complete, the calendar restarts 
    323               counting after 4 RTCCLK cycles.
    324          
    325            4. To read the calendar through the shadow registers after Calendar initialization,
    326               calendar update or after wakeup from low power modes the software must first 
    327               clear the RSF flag. The software must then wait until it is set again before 
    328               reading the calendar, which means that the calendar registers have been 
    329               correctly copied into the RTC_TR and RTC_DR shadow registers.
    330               The RTC_WaitForSynchro() function implements the above software sequence 
    331               (RSF clear and RSF check).
    332          
    333          @endverbatim
    334            * @{
    335            */
    336          
    337          /**
    338            * @brief  Deinitializes the RTC registers to their default reset values.
    339            * @note   This function doesn't reset the RTC Clock source and RTC Backup Data
    340            *         registers.       
    341            * @param  None
    342            * @retval An ErrorStatus enumeration value:
    343            *          - SUCCESS: RTC registers are deinitialized
    344            *          - ERROR: RTC registers are not deinitialized
    345            */

   \                                 In section .text, align 2, keep-with-next
    346          ErrorStatus RTC_DeInit(void)
    347          {
   \                     RTC_DeInit:
   \   00000000   38B5               PUSH     {R3-R5,LR}
    348            __IO uint32_t wutcounter = 0x00;
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   0090               STR      R0,[SP, #+0]
    349            uint32_t wutwfstatus = 0x00;
   \   00000006   0024               MOVS     R4,#+0
    350            ErrorStatus status = ERROR;
   \   00000008   0025               MOVS     R5,#+0
    351            
    352            /* Disable the write protection for RTC registers */
    353            RTC->WPR = 0xCA;
   \   0000000A   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   0000000E   CA21               MOVS     R1,#+202
   \   00000010   0160               STR      R1,[R0, #+0]
    354            RTC->WPR = 0x53;
   \   00000012   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   00000016   5321               MOVS     R1,#+83
   \   00000018   0160               STR      R1,[R0, #+0]
    355          
    356            /* Set Initialization mode */
    357            if (RTC_EnterInitMode() == ERROR)
   \   0000001A   ........           BL       RTC_EnterInitMode
   \   0000001E   0028               CMP      R0,#+0
   \   00000020   01D1               BNE.N    ??RTC_DeInit_0
    358            {
    359              status = ERROR;
   \   00000022   0025               MOVS     R5,#+0
   \   00000024   51E0               B.N      ??RTC_DeInit_1
    360            }  
    361            else
    362            {
    363              /* Reset TR, DR and CR registers */
    364              RTC->TR = (uint32_t)0x00000000;
   \                     ??RTC_DeInit_0:
   \   00000026   ........           LDR.W    R0,??DataTable37_1  ;; 0x40002800
   \   0000002A   0021               MOVS     R1,#+0
   \   0000002C   0160               STR      R1,[R0, #+0]
    365              RTC->DR = (uint32_t)0x00002101;
   \   0000002E   ........           LDR.W    R0,??DataTable37_2  ;; 0x40002804
   \   00000032   42F20111           MOVW     R1,#+8449
   \   00000036   0160               STR      R1,[R0, #+0]
    366              /* Reset All CR bits except CR[2:0] */
    367              RTC->CR &= (uint32_t)0x00000007;
   \   00000038   ........           LDR.W    R0,??DataTable37_3  ;; 0x40002808
   \   0000003C   0068               LDR      R0,[R0, #+0]
   \   0000003E   10F00700           ANDS     R0,R0,#0x7
   \   00000042   ........           LDR.W    R1,??DataTable37_3  ;; 0x40002808
   \   00000046   0860               STR      R0,[R1, #+0]
    368            
    369              /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    370              do
    371              {
    372                wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
   \                     ??RTC_DeInit_2:
   \   00000048   ........           LDR.W    R0,??DataTable37_4  ;; 0x4000280c
   \   0000004C   0068               LDR      R0,[R0, #+0]
   \   0000004E   10F00404           ANDS     R4,R0,#0x4
    373                wutcounter++;  
   \   00000052   0098               LDR      R0,[SP, #+0]
   \   00000054   401C               ADDS     R0,R0,#+1
   \   00000056   0090               STR      R0,[SP, #+0]
    374              } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
   \   00000058   0098               LDR      R0,[SP, #+0]
   \   0000005A   B0F5803F           CMP      R0,#+65536
   \   0000005E   01D0               BEQ.N    ??RTC_DeInit_3
   \   00000060   002C               CMP      R4,#+0
   \   00000062   F1D0               BEQ.N    ??RTC_DeInit_2
    375              
    376              if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
   \                     ??RTC_DeInit_3:
   \   00000064   ........           LDR.W    R0,??DataTable37_4  ;; 0x4000280c
   \   00000068   0068               LDR      R0,[R0, #+0]
   \   0000006A   4007               LSLS     R0,R0,#+29
   \   0000006C   01D4               BMI.N    ??RTC_DeInit_4
    377              {
    378                status = ERROR;
   \   0000006E   0025               MOVS     R5,#+0
   \   00000070   2BE0               B.N      ??RTC_DeInit_1
    379              }
    380              else
    381              {
    382                /* Reset all RTC CR register bits */
    383                RTC->CR &= (uint32_t)0x00000000;
   \                     ??RTC_DeInit_4:
   \   00000072   ........           LDR.W    R0,??DataTable37_3  ;; 0x40002808
   \   00000076   0468               LDR      R4,[R0, #+0]
   \   00000078   ........           LDR.W    R0,??DataTable37_3  ;; 0x40002808
   \   0000007C   0021               MOVS     R1,#+0
   \   0000007E   0160               STR      R1,[R0, #+0]
    384                RTC->WUTR = (uint32_t)0x0000FFFF;
   \   00000080   ........           LDR.W    R0,??DataTable37_5  ;; 0x40002814
   \   00000084   4FF6FF71           MOVW     R1,#+65535
   \   00000088   0160               STR      R1,[R0, #+0]
    385                RTC->PRER = (uint32_t)0x007F00FF;
   \   0000008A   ........           LDR.W    R0,??DataTable37_6  ;; 0x40002810
   \   0000008E   ........           LDR.W    R1,??DataTable37_7  ;; 0x7f00ff
   \   00000092   0160               STR      R1,[R0, #+0]
    386                RTC->CALIBR = (uint32_t)0x00000000;
   \   00000094   ........           LDR.W    R0,??DataTable37_8  ;; 0x40002818
   \   00000098   0021               MOVS     R1,#+0
   \   0000009A   0160               STR      R1,[R0, #+0]
    387                RTC->ALRMAR = (uint32_t)0x00000000;        
   \   0000009C   ........           LDR.W    R0,??DataTable37_9  ;; 0x4000281c
   \   000000A0   0021               MOVS     R1,#+0
   \   000000A2   0160               STR      R1,[R0, #+0]
    388                RTC->ALRMBR = (uint32_t)0x00000000;
   \   000000A4   ........           LDR.W    R0,??DataTable37_10  ;; 0x40002820
   \   000000A8   0021               MOVS     R1,#+0
   \   000000AA   0160               STR      R1,[R0, #+0]
    389                
    390                /* Reset ISR register and exit initialization mode */
    391                RTC->ISR = (uint32_t)0x00000000;
   \   000000AC   ........           LDR.W    R0,??DataTable37_4  ;; 0x4000280c
   \   000000B0   0021               MOVS     R1,#+0
   \   000000B2   0160               STR      R1,[R0, #+0]
    392                
    393                /* Reset Tamper and alternate functions configuration register */
    394                RTC->TAFCR = 0x00000000;
   \   000000B4   ........           LDR.W    R0,??DataTable37_11  ;; 0x40002840
   \   000000B8   0021               MOVS     R1,#+0
   \   000000BA   0160               STR      R1,[R0, #+0]
    395            
    396                if(RTC_WaitForSynchro() == ERROR)
   \   000000BC   ........           BL       RTC_WaitForSynchro
   \   000000C0   0028               CMP      R0,#+0
   \   000000C2   01D1               BNE.N    ??RTC_DeInit_5
    397                {
    398                  status = ERROR;
   \   000000C4   0025               MOVS     R5,#+0
   \   000000C6   00E0               B.N      ??RTC_DeInit_1
    399                }
    400                else
    401                {
    402                  status = SUCCESS;      
   \                     ??RTC_DeInit_5:
   \   000000C8   0125               MOVS     R5,#+1
    403                }
    404              }
    405            }
    406            
    407            /* Enable the write protection for RTC registers */
    408            RTC->WPR = 0xFF;  
   \                     ??RTC_DeInit_1:
   \   000000CA   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   000000CE   FF21               MOVS     R1,#+255
   \   000000D0   0160               STR      R1,[R0, #+0]
    409            
    410            return status;
   \   000000D2   2800               MOVS     R0,R5
   \   000000D4   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D6   32BD               POP      {R1,R4,R5,PC}    ;; return
    411          }
    412          
    413          /**
    414            * @brief  Initializes the RTC registers according to the specified parameters 
    415            *         in RTC_InitStruct.
    416            * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure that contains 
    417            *         the configuration information for the RTC peripheral.
    418            * @note   The RTC Prescaler register is write protected and can be written in 
    419            *         initialization mode only.  
    420            * @retval An ErrorStatus enumeration value:
    421            *          - SUCCESS: RTC registers are initialized
    422            *          - ERROR: RTC registers are not initialized  
    423            */

   \                                 In section .text, align 2, keep-with-next
    424          ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
    425          {
   \                     RTC_Init:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
    426            ErrorStatus status = ERROR;
   \   00000004   0025               MOVS     R5,#+0
    427            
    428            /* Check the parameters */
    429            assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
    430            assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
    431            assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
    432          
    433            /* Disable the write protection for RTC registers */
    434            RTC->WPR = 0xCA;
   \   00000006   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   0000000A   CA21               MOVS     R1,#+202
   \   0000000C   0160               STR      R1,[R0, #+0]
    435            RTC->WPR = 0x53;
   \   0000000E   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   00000012   5321               MOVS     R1,#+83
   \   00000014   0160               STR      R1,[R0, #+0]
    436          
    437            /* Set Initialization mode */
    438            if (RTC_EnterInitMode() == ERROR)
   \   00000016   ........           BL       RTC_EnterInitMode
   \   0000001A   0028               CMP      R0,#+0
   \   0000001C   01D1               BNE.N    ??RTC_Init_0
    439            {
    440              status = ERROR;
   \   0000001E   0025               MOVS     R5,#+0
   \   00000020   1FE0               B.N      ??RTC_Init_1
    441            } 
    442            else
    443            {
    444              /* Clear RTC CR FMT Bit */
    445              RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
   \                     ??RTC_Init_0:
   \   00000022   ........           LDR.W    R0,??DataTable37_3  ;; 0x40002808
   \   00000026   0068               LDR      R0,[R0, #+0]
   \   00000028   30F04000           BICS     R0,R0,#0x40
   \   0000002C   ........           LDR.W    R1,??DataTable37_3  ;; 0x40002808
   \   00000030   0860               STR      R0,[R1, #+0]
    446              /* Set RTC_CR register */
    447              RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
   \   00000032   ........           LDR.W    R0,??DataTable37_3  ;; 0x40002808
   \   00000036   0068               LDR      R0,[R0, #+0]
   \   00000038   2168               LDR      R1,[R4, #+0]
   \   0000003A   0843               ORRS     R0,R1,R0
   \   0000003C   ........           LDR.W    R1,??DataTable37_3  ;; 0x40002808
   \   00000040   0860               STR      R0,[R1, #+0]
    448            
    449              /* Configure the RTC PRER */
    450              RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
   \   00000042   A068               LDR      R0,[R4, #+8]
   \   00000044   ........           LDR.W    R1,??DataTable37_6  ;; 0x40002810
   \   00000048   0860               STR      R0,[R1, #+0]
    451              RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
   \   0000004A   ........           LDR.W    R0,??DataTable37_6  ;; 0x40002810
   \   0000004E   0068               LDR      R0,[R0, #+0]
   \   00000050   6168               LDR      R1,[R4, #+4]
   \   00000052   50EA0140           ORRS     R0,R0,R1, LSL #+16
   \   00000056   ........           LDR.W    R1,??DataTable37_6  ;; 0x40002810
   \   0000005A   0860               STR      R0,[R1, #+0]
    452          
    453              /* Exit Initialization mode */
    454              RTC_ExitInitMode();
   \   0000005C   ........           BL       RTC_ExitInitMode
    455          
    456              status = SUCCESS;    
   \   00000060   0125               MOVS     R5,#+1
    457            }
    458            /* Enable the write protection for RTC registers */
    459            RTC->WPR = 0xFF; 
   \                     ??RTC_Init_1:
   \   00000062   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   00000066   FF21               MOVS     R1,#+255
   \   00000068   0160               STR      R1,[R0, #+0]
    460            
    461            return status;
   \   0000006A   2800               MOVS     R0,R5
   \   0000006C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   32BD               POP      {R1,R4,R5,PC}    ;; return
    462          }
    463          
    464          /**
    465            * @brief  Fills each RTC_InitStruct member with its default value.
    466            * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure which will be 
    467            *         initialized.
    468            * @retval None
    469            */

   \                                 In section .text, align 2, keep-with-next
    470          void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
    471          {
    472            /* Initialize the RTC_HourFormat member */
    473            RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
   \                     RTC_StructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0160               STR      R1,[R0, #+0]
    474              
    475            /* Initialize the RTC_AsynchPrediv member */
    476            RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
   \   00000004   7F21               MOVS     R1,#+127
   \   00000006   4160               STR      R1,[R0, #+4]
    477          
    478            /* Initialize the RTC_SynchPrediv member */
    479            RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
   \   00000008   FF21               MOVS     R1,#+255
   \   0000000A   8160               STR      R1,[R0, #+8]
    480          }
   \   0000000C   7047               BX       LR               ;; return
    481          
    482          /**
    483            * @brief  Enables or disables the RTC registers write protection.
    484            * @note   All the RTC registers are write protected except for RTC_ISR[13:8], 
    485            *         RTC_TAFCR and RTC_BKPxR.
    486            * @note   Writing a wrong key reactivates the write protection.
    487            * @note   The protection mechanism is not affected by system reset.  
    488            * @param  NewState: new state of the write protection.
    489            *          This parameter can be: ENABLE or DISABLE.
    490            * @retval None
    491            */

   \                                 In section .text, align 2, keep-with-next
    492          void RTC_WriteProtectionCmd(FunctionalState NewState)
    493          {
    494            /* Check the parameters */
    495            assert_param(IS_FUNCTIONAL_STATE(NewState));
    496              
    497            if (NewState != DISABLE)
   \                     RTC_WriteProtectionCmd:
   \   00000000   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0028               CMP      R0,#+0
   \   00000004   04D0               BEQ.N    ??RTC_WriteProtectionCmd_0
    498            {
    499              /* Enable the write protection for RTC registers */
    500              RTC->WPR = 0xFF;   
   \   00000006   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   0000000A   FF21               MOVS     R1,#+255
   \   0000000C   0160               STR      R1,[R0, #+0]
   \   0000000E   07E0               B.N      ??RTC_WriteProtectionCmd_1
    501            }
    502            else
    503            {
    504              /* Disable the write protection for RTC registers */
    505              RTC->WPR = 0xCA;
   \                     ??RTC_WriteProtectionCmd_0:
   \   00000010   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   00000014   CA21               MOVS     R1,#+202
   \   00000016   0160               STR      R1,[R0, #+0]
    506              RTC->WPR = 0x53;    
   \   00000018   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   0000001C   5321               MOVS     R1,#+83
   \   0000001E   0160               STR      R1,[R0, #+0]
    507            }
    508          }
   \                     ??RTC_WriteProtectionCmd_1:
   \   00000020   7047               BX       LR               ;; return
    509          
    510          /**
    511            * @brief  Enters the RTC Initialization mode.
    512            * @note   The RTC Initialization mode is write protected, use the 
    513            *         RTC_WriteProtectionCmd(DISABLE) before calling this function.    
    514            * @param  None
    515            * @retval An ErrorStatus enumeration value:
    516            *          - SUCCESS: RTC is in Init mode
    517            *          - ERROR: RTC is not in Init mode  
    518            */

   \                                 In section .text, align 2, keep-with-next
    519          ErrorStatus RTC_EnterInitMode(void)
    520          {
   \                     RTC_EnterInitMode:
   \   00000000   81B0               SUB      SP,SP,#+4
    521            __IO uint32_t initcounter = 0x00;
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   0090               STR      R0,[SP, #+0]
    522            ErrorStatus status = ERROR;
   \   00000006   0020               MOVS     R0,#+0
    523            uint32_t initstatus = 0x00;
   \   00000008   0021               MOVS     R1,#+0
    524               
    525            /* Check if the Initialization mode is set */
    526            if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
   \   0000000A   ........           LDR.W    R2,??DataTable37_4  ;; 0x4000280c
   \   0000000E   1268               LDR      R2,[R2, #+0]
   \   00000010   5206               LSLS     R2,R2,#+25
   \   00000012   1BD4               BMI.N    ??RTC_EnterInitMode_0
    527            {
    528              /* Set the Initialization mode */
    529              RTC->ISR = (uint32_t)RTC_INIT_MASK;
   \   00000014   ........           LDR.W    R0,??DataTable37_4  ;; 0x4000280c
   \   00000018   5FF0FF31           MOVS     R1,#-1
   \   0000001C   0160               STR      R1,[R0, #+0]
    530              
    531              /* Wait till RTC is in INIT state and if Time out is reached exit */
    532              do
    533              {
    534                initstatus = RTC->ISR & RTC_ISR_INITF;
   \                     ??RTC_EnterInitMode_1:
   \   0000001E   ........           LDR.W    R0,??DataTable37_4  ;; 0x4000280c
   \   00000022   0068               LDR      R0,[R0, #+0]
   \   00000024   10F04001           ANDS     R1,R0,#0x40
    535                initcounter++;  
   \   00000028   0098               LDR      R0,[SP, #+0]
   \   0000002A   401C               ADDS     R0,R0,#+1
   \   0000002C   0090               STR      R0,[SP, #+0]
    536              } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
   \   0000002E   0098               LDR      R0,[SP, #+0]
   \   00000030   B0F5803F           CMP      R0,#+65536
   \   00000034   01D0               BEQ.N    ??RTC_EnterInitMode_2
   \   00000036   0029               CMP      R1,#+0
   \   00000038   F1D0               BEQ.N    ??RTC_EnterInitMode_1
    537              
    538              if ((RTC->ISR & RTC_ISR_INITF) != RESET)
   \                     ??RTC_EnterInitMode_2:
   \   0000003A   ........           LDR.W    R0,??DataTable37_4  ;; 0x4000280c
   \   0000003E   0068               LDR      R0,[R0, #+0]
   \   00000040   4006               LSLS     R0,R0,#+25
   \   00000042   01D5               BPL.N    ??RTC_EnterInitMode_3
    539              {
    540                status = SUCCESS;
   \   00000044   0120               MOVS     R0,#+1
   \   00000046   02E0               B.N      ??RTC_EnterInitMode_4
    541              }
    542              else
    543              {
    544                status = ERROR;
   \                     ??RTC_EnterInitMode_3:
   \   00000048   0020               MOVS     R0,#+0
   \   0000004A   00E0               B.N      ??RTC_EnterInitMode_4
    545              }        
    546            }
    547            else
    548            {
    549              status = SUCCESS;  
   \                     ??RTC_EnterInitMode_0:
   \   0000004C   0120               MOVS     R0,#+1
    550            } 
    551              
    552            return (status);  
   \                     ??RTC_EnterInitMode_4:
   \   0000004E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   01B0               ADD      SP,SP,#+4
   \   00000052   7047               BX       LR               ;; return
    553          }
    554          
    555          /**
    556            * @brief  Exits the RTC Initialization mode.
    557            * @note   When the initialization sequence is complete, the calendar restarts 
    558            *         counting after 4 RTCCLK cycles.  
    559            * @note   The RTC Initialization mode is write protected, use the 
    560            *         RTC_WriteProtectionCmd(DISABLE) before calling this function.      
    561            * @param  None
    562            * @retval None
    563            */

   \                                 In section .text, align 2, keep-with-next
    564          void RTC_ExitInitMode(void)
    565          { 
    566            /* Exit Initialization mode */
    567            RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
   \                     RTC_ExitInitMode:
   \   00000000   ........           LDR.W    R0,??DataTable37_4  ;; 0x4000280c
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   30F08000           BICS     R0,R0,#0x80
   \   0000000A   ........           LDR.W    R1,??DataTable37_4  ;; 0x4000280c
   \   0000000E   0860               STR      R0,[R1, #+0]
    568          }
   \   00000010   7047               BX       LR               ;; return
    569          
    570          /**
    571            * @brief  Waits until the RTC Time and Date registers (RTC_TR and RTC_DR) are 
    572            *         synchronized with RTC APB clock.
    573            * @note   The RTC Resynchronization mode is write protected, use the 
    574            *         RTC_WriteProtectionCmd(DISABLE) before calling this function. 
    575            * @note   To read the calendar through the shadow registers after Calendar 
    576            *         initialization, calendar update or after wakeup from low power modes 
    577            *         the software must first clear the RSF flag. 
    578            *         The software must then wait until it is set again before reading 
    579            *         the calendar, which means that the calendar registers have been 
    580            *         correctly copied into the RTC_TR and RTC_DR shadow registers.   
    581            * @param  None
    582            * @retval An ErrorStatus enumeration value:
    583            *          - SUCCESS: RTC registers are synchronised
    584            *          - ERROR: RTC registers are not synchronised
    585            */

   \                                 In section .text, align 2, keep-with-next
    586          ErrorStatus RTC_WaitForSynchro(void)
    587          {
   \                     RTC_WaitForSynchro:
   \   00000000   81B0               SUB      SP,SP,#+4
    588            __IO uint32_t synchrocounter = 0;
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   0090               STR      R0,[SP, #+0]
    589            ErrorStatus status = ERROR;
   \   00000006   0020               MOVS     R0,#+0
    590            uint32_t synchrostatus = 0x00;
   \   00000008   0021               MOVS     R1,#+0
    591          
    592            /* Disable the write protection for RTC registers */
    593            RTC->WPR = 0xCA;
   \   0000000A   ........           LDR.W    R2,??DataTable37  ;; 0x40002824
   \   0000000E   CA23               MOVS     R3,#+202
   \   00000010   1360               STR      R3,[R2, #+0]
    594            RTC->WPR = 0x53;
   \   00000012   ........           LDR.W    R2,??DataTable37  ;; 0x40002824
   \   00000016   5323               MOVS     R3,#+83
   \   00000018   1360               STR      R3,[R2, #+0]
    595              
    596            /* Clear RSF flag */
    597            RTC->ISR &= (uint32_t)RTC_RSF_MASK;
   \   0000001A   ........           LDR.W    R2,??DataTable37_4  ;; 0x4000280c
   \   0000001E   1268               LDR      R2,[R2, #+0]
   \   00000020   32F0A002           BICS     R2,R2,#0xA0
   \   00000024   ........           LDR.W    R3,??DataTable37_4  ;; 0x4000280c
   \   00000028   1A60               STR      R2,[R3, #+0]
    598              
    599            /* Wait the registers to be synchronised */
    600            do
    601            {
    602              synchrostatus = RTC->ISR & RTC_ISR_RSF;
   \                     ??RTC_WaitForSynchro_0:
   \   0000002A   ........           LDR.W    R0,??DataTable37_4  ;; 0x4000280c
   \   0000002E   0068               LDR      R0,[R0, #+0]
   \   00000030   10F02001           ANDS     R1,R0,#0x20
    603              synchrocounter++;  
   \   00000034   0098               LDR      R0,[SP, #+0]
   \   00000036   401C               ADDS     R0,R0,#+1
   \   00000038   0090               STR      R0,[SP, #+0]
    604            } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
   \   0000003A   0098               LDR      R0,[SP, #+0]
   \   0000003C   B0F5004F           CMP      R0,#+32768
   \   00000040   01D0               BEQ.N    ??RTC_WaitForSynchro_1
   \   00000042   0029               CMP      R1,#+0
   \   00000044   F1D0               BEQ.N    ??RTC_WaitForSynchro_0
    605              
    606            if ((RTC->ISR & RTC_ISR_RSF) != RESET)
   \                     ??RTC_WaitForSynchro_1:
   \   00000046   ........           LDR.W    R0,??DataTable37_4  ;; 0x4000280c
   \   0000004A   0068               LDR      R0,[R0, #+0]
   \   0000004C   8006               LSLS     R0,R0,#+26
   \   0000004E   01D5               BPL.N    ??RTC_WaitForSynchro_2
    607            {
    608              status = SUCCESS;
   \   00000050   0120               MOVS     R0,#+1
   \   00000052   00E0               B.N      ??RTC_WaitForSynchro_3
    609            }
    610            else
    611            {
    612              status = ERROR;
   \                     ??RTC_WaitForSynchro_2:
   \   00000054   0020               MOVS     R0,#+0
    613            }        
    614          
    615            /* Enable the write protection for RTC registers */
    616            RTC->WPR = 0xFF; 
   \                     ??RTC_WaitForSynchro_3:
   \   00000056   ........           LDR.W    R1,??DataTable37  ;; 0x40002824
   \   0000005A   FF22               MOVS     R2,#+255
   \   0000005C   0A60               STR      R2,[R1, #+0]
    617              
    618            return (status); 
   \   0000005E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   01B0               ADD      SP,SP,#+4
   \   00000062   7047               BX       LR               ;; return
    619          }
    620          
    621          /**
    622            * @brief  Enables or disables the RTC reference clock detection.
    623            * @param  NewState: new state of the RTC reference clock.
    624            *          This parameter can be: ENABLE or DISABLE.
    625            * @retval An ErrorStatus enumeration value:
    626            *          - SUCCESS: RTC reference clock detection is enabled
    627            *          - ERROR: RTC reference clock detection is disabled  
    628            */

   \                                 In section .text, align 2, keep-with-next
    629          ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
    630          { 
   \                     RTC_RefClockCmd:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
    631            ErrorStatus status = ERROR;
   \   00000004   0025               MOVS     R5,#+0
    632            
    633            /* Check the parameters */
    634            assert_param(IS_FUNCTIONAL_STATE(NewState));
    635            
    636            /* Disable the write protection for RTC registers */
    637            RTC->WPR = 0xCA;
   \   00000006   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   0000000A   CA21               MOVS     R1,#+202
   \   0000000C   0160               STR      R1,[R0, #+0]
    638            RTC->WPR = 0x53;
   \   0000000E   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   00000012   5321               MOVS     R1,#+83
   \   00000014   0160               STR      R1,[R0, #+0]
    639              
    640            /* Set Initialization mode */
    641            if (RTC_EnterInitMode() == ERROR)
   \   00000016   ........           BL       RTC_EnterInitMode
   \   0000001A   0028               CMP      R0,#+0
   \   0000001C   01D1               BNE.N    ??RTC_RefClockCmd_0
    642            {
    643              status = ERROR;
   \   0000001E   0025               MOVS     R5,#+0
   \   00000020   16E0               B.N      ??RTC_RefClockCmd_1
    644            } 
    645            else
    646            {  
    647              if (NewState != DISABLE)
   \                     ??RTC_RefClockCmd_0:
   \   00000022   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   002C               CMP      R4,#+0
   \   00000026   08D0               BEQ.N    ??RTC_RefClockCmd_2
    648              {
    649                /* Enable the RTC reference clock detection */
    650                RTC->CR |= RTC_CR_REFCKON;   
   \   00000028   ........           LDR.W    R0,??DataTable37_3  ;; 0x40002808
   \   0000002C   0068               LDR      R0,[R0, #+0]
   \   0000002E   50F01000           ORRS     R0,R0,#0x10
   \   00000032   ........           LDR.W    R1,??DataTable37_3  ;; 0x40002808
   \   00000036   0860               STR      R0,[R1, #+0]
   \   00000038   07E0               B.N      ??RTC_RefClockCmd_3
    651              }
    652              else
    653              {
    654                /* Disable the RTC reference clock detection */
    655                RTC->CR &= ~RTC_CR_REFCKON;    
   \                     ??RTC_RefClockCmd_2:
   \   0000003A   ........           LDR.W    R0,??DataTable37_3  ;; 0x40002808
   \   0000003E   0068               LDR      R0,[R0, #+0]
   \   00000040   30F01000           BICS     R0,R0,#0x10
   \   00000044   ........           LDR.W    R1,??DataTable37_3  ;; 0x40002808
   \   00000048   0860               STR      R0,[R1, #+0]
    656              }
    657              /* Exit Initialization mode */
    658              RTC_ExitInitMode();
   \                     ??RTC_RefClockCmd_3:
   \   0000004A   ........           BL       RTC_ExitInitMode
    659              
    660              status = SUCCESS;
   \   0000004E   0125               MOVS     R5,#+1
    661            }
    662            
    663            /* Enable the write protection for RTC registers */
    664            RTC->WPR = 0xFF;  
   \                     ??RTC_RefClockCmd_1:
   \   00000050   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   00000054   FF21               MOVS     R1,#+255
   \   00000056   0160               STR      R1,[R0, #+0]
    665            
    666            return status; 
   \   00000058   2800               MOVS     R0,R5
   \   0000005A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005C   32BD               POP      {R1,R4,R5,PC}    ;; return
    667          }
    668          
    669          /**
    670            * @}
    671            */
    672          
    673          /** @defgroup RTC_Group2 Time and Date configuration functions
    674           *  @brief   Time and Date configuration functions 
    675           *
    676          @verbatim   
    677           ===============================================================================
    678                             Time and Date configuration functions
    679           ===============================================================================  
    680          
    681            This section provide functions allowing to program and read the RTC Calendar
    682            (Time and Date).
    683          
    684          @endverbatim
    685            * @{
    686            */
    687          
    688          /**
    689            * @brief  Set the RTC current time.
    690            * @param  RTC_Format: specifies the format of the entered parameters.
    691            *          This parameter can be  one of the following values:
    692            *            @arg RTC_Format_BIN:  Binary data format 
    693            *            @arg RTC_Format_BCD:  BCD data format
    694            * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that contains 
    695            *                        the time configuration information for the RTC.     
    696            * @retval An ErrorStatus enumeration value:
    697            *          - SUCCESS: RTC Time register is configured
    698            *          - ERROR: RTC Time register is not configured
    699            */

   \                                 In section .text, align 2, keep-with-next
    700          ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
    701          {
   \                     RTC_SetTime:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0500               MOVS     R5,R0
   \   00000004   0C00               MOVS     R4,R1
    702            uint32_t tmpreg = 0;
   \   00000006   0026               MOVS     R6,#+0
    703            ErrorStatus status = ERROR;
   \   00000008   0020               MOVS     R0,#+0
    704              
    705            /* Check the parameters */
    706            assert_param(IS_RTC_FORMAT(RTC_Format));
    707            
    708            if (RTC_Format == RTC_Format_BIN)
   \   0000000A   002D               CMP      R5,#+0
   \   0000000C   07D1               BNE.N    ??RTC_SetTime_0
    709            {
    710              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \   0000000E   ........           LDR.W    R0,??DataTable37_3  ;; 0x40002808
   \   00000012   0068               LDR      R0,[R0, #+0]
   \   00000014   4006               LSLS     R0,R0,#+25
   \   00000016   01D4               BMI.N    ??RTC_SetTime_1
    711              {
    712                assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
    713                assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
    714              } 
    715              else
    716              {
    717                RTC_TimeStruct->RTC_H12 = 0x00;
   \                     ??RTC_SetTime_2:
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   E070               STRB     R0,[R4, #+3]
    718                assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
    719              }
    720              assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
    721              assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
   \                     ??RTC_SetTime_1:
   \   0000001C   0BE0               B.N      ??RTC_SetTime_3
    722            }
    723            else
    724            {
    725              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \                     ??RTC_SetTime_0:
   \   0000001E   ........           LDR.W    R0,??DataTable37_3  ;; 0x40002808
   \   00000022   0068               LDR      R0,[R0, #+0]
   \   00000024   4006               LSLS     R0,R0,#+25
   \   00000026   04D5               BPL.N    ??RTC_SetTime_4
    726              {
    727                tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
   \   00000028   2078               LDRB     R0,[R4, #+0]
   \   0000002A   ........           BL       RTC_Bcd2ToByte
   \   0000002E   0600               MOVS     R6,R0
    728                assert_param(IS_RTC_HOUR12(tmpreg));
    729                assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
   \   00000030   01E0               B.N      ??RTC_SetTime_5
    730              } 
    731              else
    732              {
    733                RTC_TimeStruct->RTC_H12 = 0x00;
   \                     ??RTC_SetTime_4:
   \   00000032   0020               MOVS     R0,#+0
   \   00000034   E070               STRB     R0,[R4, #+3]
    734                assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
    735              }
    736              assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
    737              assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
    738            }
    739            
    740            /* Check the input parameters format */
    741            if (RTC_Format != RTC_Format_BIN)
   \                     ??RTC_SetTime_5:
   \                     ??RTC_SetTime_3:
   \   00000036   002D               CMP      R5,#+0
   \   00000038   0AD0               BEQ.N    ??RTC_SetTime_6
    742            {
    743              tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
    744                       ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
    745                       ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
    746                       ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
   \   0000003A   2078               LDRB     R0,[R4, #+0]
   \   0000003C   6178               LDRB     R1,[R4, #+1]
   \   0000003E   0902               LSLS     R1,R1,#+8
   \   00000040   51EA0040           ORRS     R0,R1,R0, LSL #+16
   \   00000044   A178               LDRB     R1,[R4, #+2]
   \   00000046   0843               ORRS     R0,R1,R0
   \   00000048   E178               LDRB     R1,[R4, #+3]
   \   0000004A   50EA0146           ORRS     R6,R0,R1, LSL #+16
   \   0000004E   12E0               B.N      ??RTC_SetTime_7
    747            }  
    748            else
    749            {
    750              tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
    751                             ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
    752                             ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
    753                             (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
   \                     ??RTC_SetTime_6:
   \   00000050   2078               LDRB     R0,[R4, #+0]
   \   00000052   ........           BL       RTC_ByteToBcd2
   \   00000056   0500               MOVS     R5,R0
   \   00000058   6078               LDRB     R0,[R4, #+1]
   \   0000005A   ........           BL       RTC_ByteToBcd2
   \   0000005E   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000060   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0002               LSLS     R0,R0,#+8
   \   00000064   50EA0545           ORRS     R5,R0,R5, LSL #+16
   \   00000068   A078               LDRB     R0,[R4, #+2]
   \   0000006A   ........           BL       RTC_ByteToBcd2
   \   0000006E   2843               ORRS     R0,R0,R5
   \   00000070   E178               LDRB     R1,[R4, #+3]
   \   00000072   50EA0146           ORRS     R6,R0,R1, LSL #+16
    754            }  
    755          
    756            /* Disable the write protection for RTC registers */
    757            RTC->WPR = 0xCA;
   \                     ??RTC_SetTime_7:
   \   00000076   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   0000007A   CA21               MOVS     R1,#+202
   \   0000007C   0160               STR      R1,[R0, #+0]
    758            RTC->WPR = 0x53;
   \   0000007E   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   00000082   5321               MOVS     R1,#+83
   \   00000084   0160               STR      R1,[R0, #+0]
    759          
    760            /* Set Initialization mode */
    761            if (RTC_EnterInitMode() == ERROR)
   \   00000086   ........           BL       RTC_EnterInitMode
   \   0000008A   0028               CMP      R0,#+0
   \   0000008C   01D1               BNE.N    ??RTC_SetTime_8
    762            {
    763              status = ERROR;
   \   0000008E   0020               MOVS     R0,#+0
   \   00000090   0EE0               B.N      ??RTC_SetTime_9
    764            } 
    765            else
    766            {
    767              /* Set the RTC_TR register */
    768              RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
   \                     ??RTC_SetTime_8:
   \   00000092   ........           LDR.W    R0,??DataTable37_12  ;; 0x7f7f7f
   \   00000096   3040               ANDS     R0,R0,R6
   \   00000098   ........           LDR.W    R1,??DataTable37_1  ;; 0x40002800
   \   0000009C   0860               STR      R0,[R1, #+0]
    769          
    770              /* Exit Initialization mode */
    771              RTC_ExitInitMode(); 
   \   0000009E   ........           BL       RTC_ExitInitMode
    772          
    773              if(RTC_WaitForSynchro() == ERROR)
   \   000000A2   ........           BL       RTC_WaitForSynchro
   \   000000A6   0028               CMP      R0,#+0
   \   000000A8   01D1               BNE.N    ??RTC_SetTime_10
    774              {
    775                status = ERROR;
   \   000000AA   0020               MOVS     R0,#+0
   \   000000AC   00E0               B.N      ??RTC_SetTime_9
    776              }
    777              else
    778              {
    779                status = SUCCESS;
   \                     ??RTC_SetTime_10:
   \   000000AE   0120               MOVS     R0,#+1
    780              }
    781            
    782            }
    783            /* Enable the write protection for RTC registers */
    784            RTC->WPR = 0xFF; 
   \                     ??RTC_SetTime_9:
   \   000000B0   ........           LDR.W    R1,??DataTable37  ;; 0x40002824
   \   000000B4   FF22               MOVS     R2,#+255
   \   000000B6   0A60               STR      R2,[R1, #+0]
    785              
    786            return status;
   \   000000B8   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BA   70BD               POP      {R4-R6,PC}       ;; return
    787          }
    788          
    789          /**
    790            * @brief  Fills each RTC_TimeStruct member with its default value
    791            *         (Time = 00h:00min:00sec).
    792            * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure which will be 
    793            *         initialized.
    794            * @retval None
    795            */

   \                                 In section .text, align 2, keep-with-next
    796          void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
    797          {
    798            /* Time = 00h:00min:00sec */
    799            RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
   \                     RTC_TimeStructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   C170               STRB     R1,[R0, #+3]
    800            RTC_TimeStruct->RTC_Hours = 0;
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   0170               STRB     R1,[R0, #+0]
    801            RTC_TimeStruct->RTC_Minutes = 0;
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   4170               STRB     R1,[R0, #+1]
    802            RTC_TimeStruct->RTC_Seconds = 0; 
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   8170               STRB     R1,[R0, #+2]
    803          }
   \   00000010   7047               BX       LR               ;; return
    804          
    805          /**
    806            * @brief  Get the RTC current Time.
    807            * @param  RTC_Format: specifies the format of the returned parameters.
    808            *          This parameter can be  one of the following values:
    809            *            @arg RTC_Format_BIN:  Binary data format 
    810            *            @arg RTC_Format_BCD:  BCD data format
    811            * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that will 
    812            *                        contain the returned current time configuration.     
    813            * @retval None
    814            */

   \                                 In section .text, align 2, keep-with-next
    815          void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
    816          {
   \                     RTC_GetTime:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0C00               MOVS     R4,R1
    817            uint32_t tmpreg = 0;
   \   00000004   0021               MOVS     R1,#+0
    818          
    819            /* Check the parameters */
    820            assert_param(IS_RTC_FORMAT(RTC_Format));
    821          
    822            /* Get the RTC_TR register */
    823            tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
   \   00000006   ........           LDR.W    R2,??DataTable37_1  ;; 0x40002800
   \   0000000A   1268               LDR      R2,[R2, #+0]
   \   0000000C   ........           LDR.W    R3,??DataTable37_12  ;; 0x7f7f7f
   \   00000010   1A40               ANDS     R2,R3,R2
   \   00000012   1100               MOVS     R1,R2
    824            
    825            /* Fill the structure fields with the read parameters */
    826            RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
   \   00000014   0A0C               LSRS     R2,R1,#+16
   \   00000016   12F03F02           ANDS     R2,R2,#0x3F
   \   0000001A   2270               STRB     R2,[R4, #+0]
    827            RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
   \   0000001C   0A0A               LSRS     R2,R1,#+8
   \   0000001E   12F07F02           ANDS     R2,R2,#0x7F
   \   00000022   6270               STRB     R2,[R4, #+1]
    828            RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
   \   00000024   11F07F02           ANDS     R2,R1,#0x7F
   \   00000028   A270               STRB     R2,[R4, #+2]
    829            RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
   \   0000002A   090C               LSRS     R1,R1,#+16
   \   0000002C   11F04001           ANDS     R1,R1,#0x40
   \   00000030   E170               STRB     R1,[R4, #+3]
    830          
    831            /* Check the input parameters format */
    832            if (RTC_Format == RTC_Format_BIN)
   \   00000032   0028               CMP      R0,#+0
   \   00000034   0BD1               BNE.N    ??RTC_GetTime_0
    833            {
    834              /* Convert the structure parameters to Binary format */
    835              RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
   \   00000036   2078               LDRB     R0,[R4, #+0]
   \   00000038   ........           BL       RTC_Bcd2ToByte
   \   0000003C   2070               STRB     R0,[R4, #+0]
    836              RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
   \   0000003E   6078               LDRB     R0,[R4, #+1]
   \   00000040   ........           BL       RTC_Bcd2ToByte
   \   00000044   6070               STRB     R0,[R4, #+1]
    837              RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
   \   00000046   A078               LDRB     R0,[R4, #+2]
   \   00000048   ........           BL       RTC_Bcd2ToByte
   \   0000004C   A070               STRB     R0,[R4, #+2]
    838            }
    839          }
   \                     ??RTC_GetTime_0:
   \   0000004E   10BD               POP      {R4,PC}          ;; return
    840          
    841          /**
    842            * @brief  Set the RTC current date.
    843            * @param  RTC_Format: specifies the format of the entered parameters.
    844            *          This parameter can be  one of the following values:
    845            *            @arg RTC_Format_BIN:  Binary data format 
    846            *            @arg RTC_Format_BCD:  BCD data format
    847            * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure that contains 
    848            *                         the date configuration information for the RTC.
    849            * @retval An ErrorStatus enumeration value:
    850            *          - SUCCESS: RTC Date register is configured
    851            *          - ERROR: RTC Date register is not configured
    852            */

   \                                 In section .text, align 2, keep-with-next
    853          ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
    854          {
   \                     RTC_SetDate:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0500               MOVS     R5,R0
   \   00000004   0C00               MOVS     R4,R1
    855            uint32_t tmpreg = 0;
   \   00000006   0026               MOVS     R6,#+0
    856            ErrorStatus status = ERROR;
   \   00000008   0020               MOVS     R0,#+0
    857            
    858            /* Check the parameters */
    859            assert_param(IS_RTC_FORMAT(RTC_Format));
    860          
    861            if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
   \   0000000A   002D               CMP      R5,#+0
   \   0000000C   07D1               BNE.N    ??RTC_SetDate_0
   \   0000000E   6078               LDRB     R0,[R4, #+1]
   \   00000010   C006               LSLS     R0,R0,#+27
   \   00000012   04D5               BPL.N    ??RTC_SetDate_0
    862            {
    863              RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
   \   00000014   6078               LDRB     R0,[R4, #+1]
   \   00000016   10F0EF00           ANDS     R0,R0,#0xEF
   \   0000001A   0A30               ADDS     R0,R0,#+10
   \   0000001C   6070               STRB     R0,[R4, #+1]
    864            }  
    865            if (RTC_Format == RTC_Format_BIN)
   \                     ??RTC_SetDate_0:
   \   0000001E   002D               CMP      R5,#+0
   \   00000020   07D0               BEQ.N    ??RTC_SetDate_1
    866            {
    867              assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
    868              assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
    869              assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
    870            }
    871            else
    872            {
    873              assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
    874              tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
   \                     ??RTC_SetDate_2:
   \   00000022   6078               LDRB     R0,[R4, #+1]
   \   00000024   ........           BL       RTC_Bcd2ToByte
   \   00000028   0600               MOVS     R6,R0
    875              assert_param(IS_RTC_MONTH(tmpreg));
    876              tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
   \   0000002A   A078               LDRB     R0,[R4, #+2]
   \   0000002C   ........           BL       RTC_Bcd2ToByte
   \   00000030   0600               MOVS     R6,R0
    877              assert_param(IS_RTC_DATE(tmpreg));
    878            }
    879            assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
    880          
    881            /* Check the input parameters format */
    882            if (RTC_Format != RTC_Format_BIN)
   \                     ??RTC_SetDate_1:
   \   00000032   002D               CMP      R5,#+0
   \   00000034   0AD0               BEQ.N    ??RTC_SetDate_3
    883            {
    884              tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
    885                        (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
    886                        ((uint32_t)RTC_DateStruct->RTC_Date) | \
    887                        (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
   \   00000036   E078               LDRB     R0,[R4, #+3]
   \   00000038   6178               LDRB     R1,[R4, #+1]
   \   0000003A   0902               LSLS     R1,R1,#+8
   \   0000003C   51EA0040           ORRS     R0,R1,R0, LSL #+16
   \   00000040   A178               LDRB     R1,[R4, #+2]
   \   00000042   0843               ORRS     R0,R1,R0
   \   00000044   2178               LDRB     R1,[R4, #+0]
   \   00000046   50EA4136           ORRS     R6,R0,R1, LSL #+13
   \   0000004A   12E0               B.N      ??RTC_SetDate_4
    888            }  
    889            else
    890            {
    891              tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
    892                        ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
    893                        ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
    894                        ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
   \                     ??RTC_SetDate_3:
   \   0000004C   E078               LDRB     R0,[R4, #+3]
   \   0000004E   ........           BL       RTC_ByteToBcd2
   \   00000052   0500               MOVS     R5,R0
   \   00000054   6078               LDRB     R0,[R4, #+1]
   \   00000056   ........           BL       RTC_ByteToBcd2
   \   0000005A   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0002               LSLS     R0,R0,#+8
   \   00000060   50EA0545           ORRS     R5,R0,R5, LSL #+16
   \   00000064   A078               LDRB     R0,[R4, #+2]
   \   00000066   ........           BL       RTC_ByteToBcd2
   \   0000006A   2843               ORRS     R0,R0,R5
   \   0000006C   2178               LDRB     R1,[R4, #+0]
   \   0000006E   50EA4136           ORRS     R6,R0,R1, LSL #+13
    895            }
    896          
    897            /* Disable the write protection for RTC registers */
    898            RTC->WPR = 0xCA;
   \                     ??RTC_SetDate_4:
   \   00000072   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   00000076   CA21               MOVS     R1,#+202
   \   00000078   0160               STR      R1,[R0, #+0]
    899            RTC->WPR = 0x53;
   \   0000007A   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   0000007E   5321               MOVS     R1,#+83
   \   00000080   0160               STR      R1,[R0, #+0]
    900          
    901            /* Set Initialization mode */
    902            if (RTC_EnterInitMode() == ERROR)
   \   00000082   ........           BL       RTC_EnterInitMode
   \   00000086   0028               CMP      R0,#+0
   \   00000088   01D1               BNE.N    ??RTC_SetDate_5
    903            {
    904              status = ERROR;
   \   0000008A   0020               MOVS     R0,#+0
   \   0000008C   0EE0               B.N      ??RTC_SetDate_6
    905            } 
    906            else
    907            {
    908              /* Set the RTC_DR register */
    909              RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
   \                     ??RTC_SetDate_5:
   \   0000008E   ........           LDR.W    R0,??DataTable37_13  ;; 0xffff3f
   \   00000092   3040               ANDS     R0,R0,R6
   \   00000094   ........           LDR.W    R1,??DataTable37_2  ;; 0x40002804
   \   00000098   0860               STR      R0,[R1, #+0]
    910          
    911              /* Exit Initialization mode */
    912              RTC_ExitInitMode(); 
   \   0000009A   ........           BL       RTC_ExitInitMode
    913          
    914              if(RTC_WaitForSynchro() == ERROR)
   \   0000009E   ........           BL       RTC_WaitForSynchro
   \   000000A2   0028               CMP      R0,#+0
   \   000000A4   01D1               BNE.N    ??RTC_SetDate_7
    915              {
    916                status = ERROR;
   \   000000A6   0020               MOVS     R0,#+0
   \   000000A8   00E0               B.N      ??RTC_SetDate_6
    917              }
    918              else
    919              {
    920                status = SUCCESS;
   \                     ??RTC_SetDate_7:
   \   000000AA   0120               MOVS     R0,#+1
    921              }
    922            }
    923            /* Enable the write protection for RTC registers */
    924            RTC->WPR = 0xFF;   
   \                     ??RTC_SetDate_6:
   \   000000AC   ........           LDR.W    R1,??DataTable37  ;; 0x40002824
   \   000000B0   FF22               MOVS     R2,#+255
   \   000000B2   0A60               STR      R2,[R1, #+0]
    925            
    926            return status;
   \   000000B4   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   70BD               POP      {R4-R6,PC}       ;; return
    927          }
    928          
    929          /**
    930            * @brief  Fills each RTC_DateStruct member with its default value
    931            *         (Monday, January 01 xx00).
    932            * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure which will be 
    933            *         initialized.
    934            * @retval None
    935            */

   \                                 In section .text, align 2, keep-with-next
    936          void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
    937          {
    938            /* Monday, January 01 xx00 */
    939            RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
   \                     RTC_DateStructInit:
   \   00000000   0121               MOVS     R1,#+1
   \   00000002   0170               STRB     R1,[R0, #+0]
    940            RTC_DateStruct->RTC_Date = 1;
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   8170               STRB     R1,[R0, #+2]
    941            RTC_DateStruct->RTC_Month = RTC_Month_January;
   \   00000008   0121               MOVS     R1,#+1
   \   0000000A   4170               STRB     R1,[R0, #+1]
    942            RTC_DateStruct->RTC_Year = 0;
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   C170               STRB     R1,[R0, #+3]
    943          }
   \   00000010   7047               BX       LR               ;; return
    944          
    945          /**
    946            * @brief  Get the RTC current date. 
    947            * @param  RTC_Format: specifies the format of the returned parameters.
    948            *          This parameter can be one of the following values:
    949            *            @arg RTC_Format_BIN: Binary data format 
    950            *            @arg RTC_Format_BCD: BCD data format
    951            * @param RTC_DateStruct: pointer to a RTC_DateTypeDef structure that will 
    952            *                        contain the returned current date configuration.     
    953            * @retval None
    954            */

   \                                 In section .text, align 2, keep-with-next
    955          void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
    956          {
   \                     RTC_GetDate:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0C00               MOVS     R4,R1
    957            uint32_t tmpreg = 0;
   \   00000004   0021               MOVS     R1,#+0
    958          
    959            /* Check the parameters */
    960            assert_param(IS_RTC_FORMAT(RTC_Format));
    961            
    962            /* Get the RTC_TR register */
    963            tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
   \   00000006   ........           LDR.W    R2,??DataTable37_2  ;; 0x40002804
   \   0000000A   1268               LDR      R2,[R2, #+0]
   \   0000000C   ........           LDR.W    R3,??DataTable37_13  ;; 0xffff3f
   \   00000010   1A40               ANDS     R2,R3,R2
   \   00000012   1100               MOVS     R1,R2
    964          
    965            /* Fill the structure fields with the read parameters */
    966            RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
   \   00000014   0A0C               LSRS     R2,R1,#+16
   \   00000016   E270               STRB     R2,[R4, #+3]
    967            RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
   \   00000018   0A0A               LSRS     R2,R1,#+8
   \   0000001A   12F01F02           ANDS     R2,R2,#0x1F
   \   0000001E   6270               STRB     R2,[R4, #+1]
    968            RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
   \   00000020   11F03F02           ANDS     R2,R1,#0x3F
   \   00000024   A270               STRB     R2,[R4, #+2]
    969            RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);  
   \   00000026   490B               LSRS     R1,R1,#+13
   \   00000028   11F00701           ANDS     R1,R1,#0x7
   \   0000002C   2170               STRB     R1,[R4, #+0]
    970          
    971            /* Check the input parameters format */
    972            if (RTC_Format == RTC_Format_BIN)
   \   0000002E   0028               CMP      R0,#+0
   \   00000030   0DD1               BNE.N    ??RTC_GetDate_0
    973            {
    974              /* Convert the structure parameters to Binary format */
    975              RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
   \   00000032   E078               LDRB     R0,[R4, #+3]
   \   00000034   ........           BL       RTC_Bcd2ToByte
   \   00000038   E070               STRB     R0,[R4, #+3]
    976              RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
   \   0000003A   6078               LDRB     R0,[R4, #+1]
   \   0000003C   ........           BL       RTC_Bcd2ToByte
   \   00000040   6070               STRB     R0,[R4, #+1]
    977              RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
   \   00000042   A078               LDRB     R0,[R4, #+2]
   \   00000044   ........           BL       RTC_Bcd2ToByte
   \   00000048   A070               STRB     R0,[R4, #+2]
    978              RTC_DateStruct->RTC_WeekDay = (uint8_t)(RTC_DateStruct->RTC_WeekDay);   
   \   0000004A   2078               LDRB     R0,[R4, #+0]
   \   0000004C   2070               STRB     R0,[R4, #+0]
    979            }
    980          }
   \                     ??RTC_GetDate_0:
   \   0000004E   10BD               POP      {R4,PC}          ;; return
    981          
    982          /**
    983            * @}
    984            */
    985          
    986          /** @defgroup RTC_Group3 Alarms configuration functions
    987           *  @brief   Alarms (Alarm A and Alarm B) configuration functions 
    988           *
    989          @verbatim   
    990           ===============================================================================
    991                        Alarms (Alarm A and Alarm B) configuration functions
    992           ===============================================================================  
    993          
    994            This section provide functions allowing to program and read the RTC Alarms.
    995          
    996          @endverbatim
    997            * @{
    998            */
    999          
   1000          /**
   1001            * @brief  Set the specified RTC Alarm.
   1002            * @note   The Alarm register can only be written when the corresponding Alarm
   1003            *         is disabled (Use the RTC_AlarmCmd(DISABLE)).    
   1004            * @param  RTC_Format: specifies the format of the returned parameters.
   1005            *          This parameter can be one of the following values:
   1006            *            @arg RTC_Format_BIN: Binary data format 
   1007            *            @arg RTC_Format_BCD: BCD data format
   1008            * @param  RTC_Alarm: specifies the alarm to be configured.
   1009            *          This parameter can be one of the following values:
   1010            *            @arg RTC_Alarm_A: to select Alarm A
   1011            *            @arg RTC_Alarm_B: to select Alarm B  
   1012            * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that 
   1013            *                          contains the alarm configuration parameters.     
   1014            * @retval None
   1015            */

   \                                 In section .text, align 2, keep-with-next
   1016          void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
   1017          {
   \                     RTC_SetAlarm:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0600               MOVS     R6,R0
   \   00000004   0C00               MOVS     R4,R1
   \   00000006   1500               MOVS     R5,R2
   1018            uint32_t tmpreg = 0;
   \   00000008   0020               MOVS     R0,#+0
   1019            
   1020            /* Check the parameters */
   1021            assert_param(IS_RTC_FORMAT(RTC_Format));
   1022            assert_param(IS_RTC_ALARM(RTC_Alarm));
   1023            assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
   1024            assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
   1025          
   1026            if (RTC_Format == RTC_Format_BIN)
   \   0000000A   002E               CMP      R6,#+0
   \   0000000C   0AD1               BNE.N    ??RTC_SetAlarm_0
   1027            {
   1028              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \   0000000E   ........           LDR.W    R0,??DataTable37_3  ;; 0x40002808
   \   00000012   0068               LDR      R0,[R0, #+0]
   \   00000014   4006               LSLS     R0,R0,#+25
   \   00000016   01D4               BMI.N    ??RTC_SetAlarm_1
   1029              {
   1030                assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   1031                assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
   1032              } 
   1033              else
   1034              {
   1035                RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
   \                     ??RTC_SetAlarm_2:
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   E870               STRB     R0,[R5, #+3]
   1036                assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   1037              }
   1038              assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
   1039              assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
   1040              
   1041              if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
   \                     ??RTC_SetAlarm_1:
   \   0000001C   A868               LDR      R0,[R5, #+8]
   \   0000001E   0028               CMP      R0,#+0
   \   00000020   15D0               BEQ.N    ??RTC_SetAlarm_3
   1042              {
   1043                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   1044              }
   1045              else
   1046              {
   1047                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   \                     ??RTC_SetAlarm_4:
   \   00000022   14E0               B.N      ??RTC_SetAlarm_3
   1048              }
   1049            }
   1050            else
   1051            {
   1052              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \                     ??RTC_SetAlarm_0:
   \   00000024   ........           LDR.W    R0,??DataTable37_3  ;; 0x40002808
   \   00000028   0068               LDR      R0,[R0, #+0]
   \   0000002A   4006               LSLS     R0,R0,#+25
   \   0000002C   03D5               BPL.N    ??RTC_SetAlarm_5
   1053              {
   1054                tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
   \   0000002E   2878               LDRB     R0,[R5, #+0]
   \   00000030   ........           BL       RTC_Bcd2ToByte
   1055                assert_param(IS_RTC_HOUR12(tmpreg));
   1056                assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
   \   00000034   01E0               B.N      ??RTC_SetAlarm_6
   1057              } 
   1058              else
   1059              {
   1060                RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
   \                     ??RTC_SetAlarm_5:
   \   00000036   0020               MOVS     R0,#+0
   \   00000038   E870               STRB     R0,[R5, #+3]
   1061                assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
   1062              }
   1063              
   1064              assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
   1065              assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
   1066              
   1067              if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
   \                     ??RTC_SetAlarm_6:
   \   0000003A   A868               LDR      R0,[R5, #+8]
   \   0000003C   0028               CMP      R0,#+0
   \   0000003E   03D1               BNE.N    ??RTC_SetAlarm_7
   1068              {
   1069                tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   \   00000040   287B               LDRB     R0,[R5, #+12]
   \   00000042   ........           BL       RTC_Bcd2ToByte
   1070                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
   \   00000046   02E0               B.N      ??RTC_SetAlarm_3
   1071              }
   1072              else
   1073              {
   1074                tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   \                     ??RTC_SetAlarm_7:
   \   00000048   287B               LDRB     R0,[R5, #+12]
   \   0000004A   ........           BL       RTC_Bcd2ToByte
   1075                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
   1076              }    
   1077            }
   1078          
   1079            /* Check the input parameters format */
   1080            if (RTC_Format != RTC_Format_BIN)
   \                     ??RTC_SetAlarm_3:
   \   0000004E   002E               CMP      R6,#+0
   \   00000050   11D0               BEQ.N    ??RTC_SetAlarm_8
   1081            {
   1082              tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
   1083                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
   1084                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
   1085                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
   1086                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
   1087                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
   1088                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
   \   00000052   2878               LDRB     R0,[R5, #+0]
   \   00000054   6978               LDRB     R1,[R5, #+1]
   \   00000056   0902               LSLS     R1,R1,#+8
   \   00000058   51EA0040           ORRS     R0,R1,R0, LSL #+16
   \   0000005C   A978               LDRB     R1,[R5, #+2]
   \   0000005E   0843               ORRS     R0,R1,R0
   \   00000060   E978               LDRB     R1,[R5, #+3]
   \   00000062   50EA0140           ORRS     R0,R0,R1, LSL #+16
   \   00000066   297B               LDRB     R1,[R5, #+12]
   \   00000068   50EA0160           ORRS     R0,R0,R1, LSL #+24
   \   0000006C   A968               LDR      R1,[R5, #+8]
   \   0000006E   0843               ORRS     R0,R1,R0
   \   00000070   6968               LDR      R1,[R5, #+4]
   \   00000072   0843               ORRS     R0,R1,R0
   \   00000074   1DE0               B.N      ??RTC_SetAlarm_9
   1089            }  
   1090            else
   1091            {
   1092              tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
   1093                        ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
   1094                        ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
   1095                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
   1096                        ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
   1097                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
   1098                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
   \                     ??RTC_SetAlarm_8:
   \   00000076   2878               LDRB     R0,[R5, #+0]
   \   00000078   ........           BL       RTC_ByteToBcd2
   \   0000007C   0600               MOVS     R6,R0
   \   0000007E   6878               LDRB     R0,[R5, #+1]
   \   00000080   ........           BL       RTC_ByteToBcd2
   \   00000084   0700               MOVS     R7,R0
   \   00000086   A878               LDRB     R0,[R5, #+2]
   \   00000088   ........           BL       RTC_ByteToBcd2
   \   0000008C   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000008E   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000090   3902               LSLS     R1,R7,#+8
   \   00000092   51EA0641           ORRS     R1,R1,R6, LSL #+16
   \   00000096   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000098   0843               ORRS     R0,R0,R1
   \   0000009A   E978               LDRB     R1,[R5, #+3]
   \   0000009C   50EA0146           ORRS     R6,R0,R1, LSL #+16
   \   000000A0   287B               LDRB     R0,[R5, #+12]
   \   000000A2   ........           BL       RTC_ByteToBcd2
   \   000000A6   56EA0060           ORRS     R0,R6,R0, LSL #+24
   \   000000AA   A968               LDR      R1,[R5, #+8]
   \   000000AC   0843               ORRS     R0,R1,R0
   \   000000AE   6968               LDR      R1,[R5, #+4]
   \   000000B0   0843               ORRS     R0,R1,R0
   1099            } 
   1100          
   1101            /* Disable the write protection for RTC registers */
   1102            RTC->WPR = 0xCA;
   \                     ??RTC_SetAlarm_9:
   \   000000B2   ........           LDR.W    R1,??DataTable37  ;; 0x40002824
   \   000000B6   CA22               MOVS     R2,#+202
   \   000000B8   0A60               STR      R2,[R1, #+0]
   1103            RTC->WPR = 0x53;
   \   000000BA   ........           LDR.W    R1,??DataTable37  ;; 0x40002824
   \   000000BE   5322               MOVS     R2,#+83
   \   000000C0   0A60               STR      R2,[R1, #+0]
   1104          
   1105            /* Configure the Alarm register */
   1106            if (RTC_Alarm == RTC_Alarm_A)
   \   000000C2   4FF48071           MOV      R1,#+256
   \   000000C6   8C42               CMP      R4,R1
   \   000000C8   03D1               BNE.N    ??RTC_SetAlarm_10
   1107            {
   1108              RTC->ALRMAR = (uint32_t)tmpreg;
   \   000000CA   ........           LDR.W    R1,??DataTable37_9  ;; 0x4000281c
   \   000000CE   0860               STR      R0,[R1, #+0]
   \   000000D0   02E0               B.N      ??RTC_SetAlarm_11
   1109            }
   1110            else
   1111            {
   1112              RTC->ALRMBR = (uint32_t)tmpreg;
   \                     ??RTC_SetAlarm_10:
   \   000000D2   ........           LDR.W    R1,??DataTable37_10  ;; 0x40002820
   \   000000D6   0860               STR      R0,[R1, #+0]
   1113            }
   1114          
   1115            /* Enable the write protection for RTC registers */
   1116            RTC->WPR = 0xFF;   
   \                     ??RTC_SetAlarm_11:
   \   000000D8   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   000000DC   FF21               MOVS     R1,#+255
   \   000000DE   0160               STR      R1,[R0, #+0]
   1117          }
   \   000000E0   F1BD               POP      {R0,R4-R7,PC}    ;; return
   1118          
   1119          /**
   1120            * @brief  Fills each RTC_AlarmStruct member with its default value
   1121            *         (Time = 00h:00mn:00sec / Date = 1st day of the month/Mask =
   1122            *         all fields are masked).
   1123            * @param  RTC_AlarmStruct: pointer to a @ref RTC_AlarmTypeDef structure which
   1124            *         will be initialized.
   1125            * @retval None
   1126            */

   \                                 In section .text, align 2, keep-with-next
   1127          void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
   1128          {
   1129            /* Alarm Time Settings : Time = 00h:00mn:00sec */
   1130            RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
   \                     RTC_AlarmStructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   C170               STRB     R1,[R0, #+3]
   1131            RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   0170               STRB     R1,[R0, #+0]
   1132            RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   4170               STRB     R1,[R0, #+1]
   1133            RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   8170               STRB     R1,[R0, #+2]
   1134          
   1135            /* Alarm Date Settings : Date = 1st day of the month */
   1136            RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   8160               STR      R1,[R0, #+8]
   1137            RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
   \   00000014   0121               MOVS     R1,#+1
   \   00000016   0173               STRB     R1,[R0, #+12]
   1138          
   1139            /* Alarm Masks Settings : Mask =  all fields are not masked */
   1140            RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
   \   00000018   0021               MOVS     R1,#+0
   \   0000001A   4160               STR      R1,[R0, #+4]
   1141          }
   \   0000001C   7047               BX       LR               ;; return
   1142          
   1143          /**
   1144            * @brief  Get the RTC Alarm value and masks.
   1145            * @param  RTC_Format: specifies the format of the output parameters.
   1146            *          This parameter can be one of the following values:
   1147            *            @arg RTC_Format_BIN: Binary data format 
   1148            *            @arg RTC_Format_BCD: BCD data format
   1149            * @param  RTC_Alarm: specifies the alarm to be read.
   1150            *          This parameter can be one of the following values:
   1151            *            @arg RTC_Alarm_A: to select Alarm A
   1152            *            @arg RTC_Alarm_B: to select Alarm B  
   1153            * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that will 
   1154            *                          contains the output alarm configuration values.     
   1155            * @retval None
   1156            */

   \                                 In section .text, align 2, keep-with-next
   1157          void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
   1158          {
   \                     RTC_GetAlarm:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   1400               MOVS     R4,R2
   1159            uint32_t tmpreg = 0;
   \   00000004   0022               MOVS     R2,#+0
   1160          
   1161            /* Check the parameters */
   1162            assert_param(IS_RTC_FORMAT(RTC_Format));
   1163            assert_param(IS_RTC_ALARM(RTC_Alarm)); 
   1164          
   1165            /* Get the RTC_ALRMxR register */
   1166            if (RTC_Alarm == RTC_Alarm_A)
   \   00000006   4FF48073           MOV      R3,#+256
   \   0000000A   9942               CMP      R1,R3
   \   0000000C   03D1               BNE.N    ??RTC_GetAlarm_0
   1167            {
   1168              tmpreg = (uint32_t)(RTC->ALRMAR);
   \   0000000E   ........           LDR.W    R1,??DataTable37_9  ;; 0x4000281c
   \   00000012   0A68               LDR      R2,[R1, #+0]
   \   00000014   02E0               B.N      ??RTC_GetAlarm_1
   1169            }
   1170            else
   1171            {
   1172              tmpreg = (uint32_t)(RTC->ALRMBR);
   \                     ??RTC_GetAlarm_0:
   \   00000016   ........           LDR.W    R1,??DataTable37_10  ;; 0x40002820
   \   0000001A   0A68               LDR      R2,[R1, #+0]
   1173            }
   1174          
   1175            /* Fill the structure with the read parameters */
   1176            RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
   1177                                                               RTC_ALRMAR_HU)) >> 16);
   \                     ??RTC_GetAlarm_1:
   \   0000001C   110C               LSRS     R1,R2,#+16
   \   0000001E   11F03F01           ANDS     R1,R1,#0x3F
   \   00000022   2170               STRB     R1,[R4, #+0]
   1178            RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
   1179                                                               RTC_ALRMAR_MNU)) >> 8);
   \   00000024   110A               LSRS     R1,R2,#+8
   \   00000026   11F07F01           ANDS     R1,R1,#0x7F
   \   0000002A   6170               STRB     R1,[R4, #+1]
   1180            RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
   1181                                                               RTC_ALRMAR_SU));
   \   0000002C   12F07F01           ANDS     R1,R2,#0x7F
   \   00000030   A170               STRB     R1,[R4, #+2]
   1182            RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
   \   00000032   110C               LSRS     R1,R2,#+16
   \   00000034   11F04001           ANDS     R1,R1,#0x40
   \   00000038   E170               STRB     R1,[R4, #+3]
   1183            RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
   \   0000003A   110E               LSRS     R1,R2,#+24
   \   0000003C   11F03F01           ANDS     R1,R1,#0x3F
   \   00000040   2173               STRB     R1,[R4, #+12]
   1184            RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
   \   00000042   12F08041           ANDS     R1,R2,#0x40000000
   \   00000046   A160               STR      R1,[R4, #+8]
   1185            RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
   \   00000048   32F07F31           BICS     R1,R2,#0x7F7F7F7F
   \   0000004C   6160               STR      R1,[R4, #+4]
   1186          
   1187            if (RTC_Format == RTC_Format_BIN)
   \   0000004E   0028               CMP      R0,#+0
   \   00000050   0FD1               BNE.N    ??RTC_GetAlarm_2
   1188            {
   1189              RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
   1190                                                                  RTC_AlarmTime.RTC_Hours);
   \   00000052   2078               LDRB     R0,[R4, #+0]
   \   00000054   ........           BL       RTC_Bcd2ToByte
   \   00000058   2070               STRB     R0,[R4, #+0]
   1191              RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
   1192                                                                  RTC_AlarmTime.RTC_Minutes);
   \   0000005A   6078               LDRB     R0,[R4, #+1]
   \   0000005C   ........           BL       RTC_Bcd2ToByte
   \   00000060   6070               STRB     R0,[R4, #+1]
   1193              RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
   1194                                                                  RTC_AlarmTime.RTC_Seconds);
   \   00000062   A078               LDRB     R0,[R4, #+2]
   \   00000064   ........           BL       RTC_Bcd2ToByte
   \   00000068   A070               STRB     R0,[R4, #+2]
   1195              RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   \   0000006A   207B               LDRB     R0,[R4, #+12]
   \   0000006C   ........           BL       RTC_Bcd2ToByte
   \   00000070   2073               STRB     R0,[R4, #+12]
   1196            }  
   1197          }
   \                     ??RTC_GetAlarm_2:
   \   00000072   10BD               POP      {R4,PC}          ;; return
   1198          
   1199          /**
   1200            * @brief  Enables or disables the specified RTC Alarm.
   1201            * @param  RTC_Alarm: specifies the alarm to be configured.
   1202            *          This parameter can be any combination of the following values:
   1203            *            @arg RTC_Alarm_A: to select Alarm A
   1204            *            @arg RTC_Alarm_B: to select Alarm B  
   1205            * @param  NewState: new state of the specified alarm.
   1206            *          This parameter can be: ENABLE or DISABLE.
   1207            * @retval An ErrorStatus enumeration value:
   1208            *          - SUCCESS: RTC Alarm is enabled/disabled
   1209            *          - ERROR: RTC Alarm is not enabled/disabled  
   1210            */

   \                                 In section .text, align 2, keep-with-next
   1211          ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
   1212          {
   \                     RTC_AlarmCmd:
   \   00000000   38B4               PUSH     {R3-R5}
   1213            __IO uint32_t alarmcounter = 0x00;
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   0092               STR      R2,[SP, #+0]
   1214            uint32_t alarmstatus = 0x00;
   \   00000006   0023               MOVS     R3,#+0
   1215            ErrorStatus status = ERROR;
   \   00000008   0022               MOVS     R2,#+0
   1216              
   1217            /* Check the parameters */
   1218            assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
   1219            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1220          
   1221            /* Disable the write protection for RTC registers */
   1222            RTC->WPR = 0xCA;
   \   0000000A   ........           LDR.W    R4,??DataTable37  ;; 0x40002824
   \   0000000E   CA25               MOVS     R5,#+202
   \   00000010   2560               STR      R5,[R4, #+0]
   1223            RTC->WPR = 0x53;
   \   00000012   ........           LDR.W    R4,??DataTable37  ;; 0x40002824
   \   00000016   5325               MOVS     R5,#+83
   \   00000018   2560               STR      R5,[R4, #+0]
   1224          
   1225            /* Configure the Alarm state */
   1226            if (NewState != DISABLE)
   \   0000001A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0029               CMP      R1,#+0
   \   0000001E   08D0               BEQ.N    ??RTC_AlarmCmd_0
   1227            {
   1228              RTC->CR |= (uint32_t)RTC_Alarm;
   \   00000020   ........           LDR.W    R1,??DataTable37_3  ;; 0x40002808
   \   00000024   0968               LDR      R1,[R1, #+0]
   \   00000026   0843               ORRS     R0,R0,R1
   \   00000028   ........           LDR.W    R1,??DataTable37_3  ;; 0x40002808
   \   0000002C   0860               STR      R0,[R1, #+0]
   1229          
   1230              status = SUCCESS;    
   \   0000002E   0122               MOVS     R2,#+1
   \   00000030   1DE0               B.N      ??RTC_AlarmCmd_1
   1231            }
   1232            else
   1233            { 
   1234              /* Disable the Alarm in RTC_CR register */
   1235              RTC->CR &= (uint32_t)~RTC_Alarm;
   \                     ??RTC_AlarmCmd_0:
   \   00000032   ........           LDR.W    R1,??DataTable37_3  ;; 0x40002808
   \   00000036   0968               LDR      R1,[R1, #+0]
   \   00000038   8143               BICS     R1,R1,R0
   \   0000003A   ........           LDR.W    R2,??DataTable37_3  ;; 0x40002808
   \   0000003E   1160               STR      R1,[R2, #+0]
   1236             
   1237              /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
   1238              do
   1239              {
   1240                alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
   \                     ??RTC_AlarmCmd_2:
   \   00000040   ........           LDR.W    R1,??DataTable37_4  ;; 0x4000280c
   \   00000044   0968               LDR      R1,[R1, #+0]
   \   00000046   11EA1023           ANDS     R3,R1,R0, LSR #+8
   1241                alarmcounter++;  
   \   0000004A   0099               LDR      R1,[SP, #+0]
   \   0000004C   491C               ADDS     R1,R1,#+1
   \   0000004E   0091               STR      R1,[SP, #+0]
   1242              } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
   \   00000050   0099               LDR      R1,[SP, #+0]
   \   00000052   B1F5803F           CMP      R1,#+65536
   \   00000056   01D0               BEQ.N    ??RTC_AlarmCmd_3
   \   00000058   002B               CMP      R3,#+0
   \   0000005A   F1D0               BEQ.N    ??RTC_AlarmCmd_2
   1243              
   1244              if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
   \                     ??RTC_AlarmCmd_3:
   \   0000005C   ........           LDR.W    R1,??DataTable37_4  ;; 0x4000280c
   \   00000060   0968               LDR      R1,[R1, #+0]
   \   00000062   11EA102F           TST      R1,R0, LSR #+8
   \   00000066   01D1               BNE.N    ??RTC_AlarmCmd_4
   1245              {
   1246                status = ERROR;
   \   00000068   0022               MOVS     R2,#+0
   \   0000006A   00E0               B.N      ??RTC_AlarmCmd_1
   1247              } 
   1248              else
   1249              {
   1250                status = SUCCESS;
   \                     ??RTC_AlarmCmd_4:
   \   0000006C   0122               MOVS     R2,#+1
   1251              }        
   1252            } 
   1253          
   1254            /* Enable the write protection for RTC registers */
   1255            RTC->WPR = 0xFF; 
   \                     ??RTC_AlarmCmd_1:
   \   0000006E   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   00000072   FF21               MOVS     R1,#+255
   \   00000074   0160               STR      R1,[R0, #+0]
   1256            
   1257            return status;
   \   00000076   1000               MOVS     R0,R2
   \   00000078   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   32BC               POP      {R1,R4,R5}
   \   0000007C   7047               BX       LR               ;; return
   1258          }
   1259          
   1260          /**
   1261            * @}
   1262            */
   1263          
   1264          /** @defgroup RTC_Group4 WakeUp Timer configuration functions
   1265           *  @brief   WakeUp Timer configuration functions 
   1266           *
   1267          @verbatim   
   1268           ===============================================================================
   1269                               WakeUp Timer configuration functions
   1270           ===============================================================================  
   1271          
   1272            This section provide functions allowing to program and read the RTC WakeUp.
   1273          
   1274          @endverbatim
   1275            * @{
   1276            */
   1277          
   1278          /**
   1279            * @brief  Configures the RTC Wakeup clock source.
   1280            * @note   The WakeUp Clock source can only be changed when the RTC WakeUp
   1281            *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).      
   1282            * @param  RTC_WakeUpClock: Wakeup Clock source.
   1283            *          This parameter can be one of the following values:
   1284            *            @arg RTC_WakeUpClock_RTCCLK_Div16: RTC Wakeup Counter Clock = RTCCLK/16
   1285            *            @arg RTC_WakeUpClock_RTCCLK_Div8: RTC Wakeup Counter Clock = RTCCLK/8
   1286            *            @arg RTC_WakeUpClock_RTCCLK_Div4: RTC Wakeup Counter Clock = RTCCLK/4
   1287            *            @arg RTC_WakeUpClock_RTCCLK_Div2: RTC Wakeup Counter Clock = RTCCLK/2
   1288            *            @arg RTC_WakeUpClock_CK_SPRE_16bits: RTC Wakeup Counter Clock = CK_SPRE
   1289            *            @arg RTC_WakeUpClock_CK_SPRE_17bits: RTC Wakeup Counter Clock = CK_SPRE
   1290            * @retval None
   1291            */

   \                                 In section .text, align 2, keep-with-next
   1292          void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
   1293          {
   1294            /* Check the parameters */
   1295            assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
   1296          
   1297            /* Disable the write protection for RTC registers */
   1298            RTC->WPR = 0xCA;
   \                     RTC_WakeUpClockConfig:
   \   00000000   ........           LDR.W    R1,??DataTable37  ;; 0x40002824
   \   00000004   CA22               MOVS     R2,#+202
   \   00000006   0A60               STR      R2,[R1, #+0]
   1299            RTC->WPR = 0x53;
   \   00000008   ........           LDR.W    R1,??DataTable37  ;; 0x40002824
   \   0000000C   5322               MOVS     R2,#+83
   \   0000000E   0A60               STR      R2,[R1, #+0]
   1300          
   1301            /* Clear the Wakeup Timer clock source bits in CR register */
   1302            RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
   \   00000010   ........           LDR.W    R1,??DataTable37_3  ;; 0x40002808
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   C908               LSRS     R1,R1,#+3
   \   00000018   C900               LSLS     R1,R1,#+3
   \   0000001A   ........           LDR.W    R2,??DataTable37_3  ;; 0x40002808
   \   0000001E   1160               STR      R1,[R2, #+0]
   1303          
   1304            /* Configure the clock source */
   1305            RTC->CR |= (uint32_t)RTC_WakeUpClock;
   \   00000020   ........           LDR.W    R1,??DataTable37_3  ;; 0x40002808
   \   00000024   0968               LDR      R1,[R1, #+0]
   \   00000026   0843               ORRS     R0,R0,R1
   \   00000028   ........           LDR.W    R1,??DataTable37_3  ;; 0x40002808
   \   0000002C   0860               STR      R0,[R1, #+0]
   1306            
   1307            /* Enable the write protection for RTC registers */
   1308            RTC->WPR = 0xFF; 
   \   0000002E   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   00000032   FF21               MOVS     R1,#+255
   \   00000034   0160               STR      R1,[R0, #+0]
   1309          }
   \   00000036   7047               BX       LR               ;; return
   1310          
   1311          /**
   1312            * @brief  Configures the RTC Wakeup counter.
   1313            * @note   The RTC WakeUp counter can only be written when the RTC WakeUp
   1314            *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).        
   1315            * @param  RTC_WakeUpCounter: specifies the WakeUp counter.
   1316            *          This parameter can be a value from 0x0000 to 0xFFFF. 
   1317            * @retval None
   1318            */

   \                                 In section .text, align 2, keep-with-next
   1319          void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
   1320          {
   1321            /* Check the parameters */
   1322            assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
   1323            
   1324            /* Disable the write protection for RTC registers */
   1325            RTC->WPR = 0xCA;
   \                     RTC_SetWakeUpCounter:
   \   00000000   ........           LDR.W    R1,??DataTable37  ;; 0x40002824
   \   00000004   CA22               MOVS     R2,#+202
   \   00000006   0A60               STR      R2,[R1, #+0]
   1326            RTC->WPR = 0x53;
   \   00000008   ........           LDR.W    R1,??DataTable37  ;; 0x40002824
   \   0000000C   5322               MOVS     R2,#+83
   \   0000000E   0A60               STR      R2,[R1, #+0]
   1327            
   1328            /* Configure the Wakeup Timer counter */
   1329            RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
   \   00000010   ........           LDR.W    R1,??DataTable37_5  ;; 0x40002814
   \   00000014   0860               STR      R0,[R1, #+0]
   1330            
   1331            /* Enable the write protection for RTC registers */
   1332            RTC->WPR = 0xFF; 
   \   00000016   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   0000001A   FF21               MOVS     R1,#+255
   \   0000001C   0160               STR      R1,[R0, #+0]
   1333          }
   \   0000001E   7047               BX       LR               ;; return
   1334          
   1335          /**
   1336            * @brief  Returns the RTC WakeUp timer counter value.
   1337            * @param  None
   1338            * @retval The RTC WakeUp Counter value.
   1339            */

   \                                 In section .text, align 2, keep-with-next
   1340          uint32_t RTC_GetWakeUpCounter(void)
   1341          {
   1342            /* Get the counter value */
   1343            return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
   \                     RTC_GetWakeUpCounter:
   \   00000000   ........           LDR.W    R0,??DataTable37_5  ;; 0x40002814
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000008   7047               BX       LR               ;; return
   1344          }
   1345          
   1346          /**
   1347            * @brief  Enables or Disables the RTC WakeUp timer.
   1348            * @param  NewState: new state of the WakeUp timer.
   1349            *          This parameter can be: ENABLE or DISABLE.
   1350            * @retval None
   1351            */

   \                                 In section .text, align 2, keep-with-next
   1352          ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
   1353          {
   \                     RTC_WakeUpCmd:
   \   00000000   18B4               PUSH     {R3,R4}
   1354            __IO uint32_t wutcounter = 0x00;
   \   00000002   0021               MOVS     R1,#+0
   \   00000004   0091               STR      R1,[SP, #+0]
   1355            uint32_t wutwfstatus = 0x00;
   \   00000006   0022               MOVS     R2,#+0
   1356            ErrorStatus status = ERROR;
   \   00000008   0021               MOVS     R1,#+0
   1357            
   1358            /* Check the parameters */
   1359            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1360          
   1361            /* Disable the write protection for RTC registers */
   1362            RTC->WPR = 0xCA;
   \   0000000A   ........           LDR.W    R3,??DataTable37  ;; 0x40002824
   \   0000000E   CA24               MOVS     R4,#+202
   \   00000010   1C60               STR      R4,[R3, #+0]
   1363            RTC->WPR = 0x53;
   \   00000012   ........           LDR.W    R3,??DataTable37  ;; 0x40002824
   \   00000016   5324               MOVS     R4,#+83
   \   00000018   1C60               STR      R4,[R3, #+0]
   1364          
   1365            if (NewState != DISABLE)
   \   0000001A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   09D0               BEQ.N    ??RTC_WakeUpCmd_0
   1366            {
   1367              /* Enable the Wakeup Timer */
   1368              RTC->CR |= (uint32_t)RTC_CR_WUTE;
   \   00000020   ........           LDR.W    R0,??DataTable37_3  ;; 0x40002808
   \   00000024   0068               LDR      R0,[R0, #+0]
   \   00000026   50F48060           ORRS     R0,R0,#0x400
   \   0000002A   ........           LDR.W    R1,??DataTable37_3  ;; 0x40002808
   \   0000002E   0860               STR      R0,[R1, #+0]
   1369              status = SUCCESS;    
   \   00000030   0121               MOVS     R1,#+1
   \   00000032   1DE0               B.N      ??RTC_WakeUpCmd_1
   1370            }
   1371            else
   1372            {
   1373              /* Disable the Wakeup Timer */
   1374              RTC->CR &= (uint32_t)~RTC_CR_WUTE;
   \                     ??RTC_WakeUpCmd_0:
   \   00000034   ........           LDR.W    R0,??DataTable37_3  ;; 0x40002808
   \   00000038   0068               LDR      R0,[R0, #+0]
   \   0000003A   30F48060           BICS     R0,R0,#0x400
   \   0000003E   ........           LDR.W    R1,??DataTable37_3  ;; 0x40002808
   \   00000042   0860               STR      R0,[R1, #+0]
   1375              /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
   1376              do
   1377              {
   1378                wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
   \                     ??RTC_WakeUpCmd_2:
   \   00000044   ........           LDR.W    R0,??DataTable37_4  ;; 0x4000280c
   \   00000048   0068               LDR      R0,[R0, #+0]
   \   0000004A   10F00402           ANDS     R2,R0,#0x4
   1379                wutcounter++;  
   \   0000004E   0098               LDR      R0,[SP, #+0]
   \   00000050   401C               ADDS     R0,R0,#+1
   \   00000052   0090               STR      R0,[SP, #+0]
   1380              } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
   \   00000054   0098               LDR      R0,[SP, #+0]
   \   00000056   B0F5803F           CMP      R0,#+65536
   \   0000005A   01D0               BEQ.N    ??RTC_WakeUpCmd_3
   \   0000005C   002A               CMP      R2,#+0
   \   0000005E   F1D0               BEQ.N    ??RTC_WakeUpCmd_2
   1381              
   1382              if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
   \                     ??RTC_WakeUpCmd_3:
   \   00000060   ........           LDR.W    R0,??DataTable37_4  ;; 0x4000280c
   \   00000064   0068               LDR      R0,[R0, #+0]
   \   00000066   4007               LSLS     R0,R0,#+29
   \   00000068   01D4               BMI.N    ??RTC_WakeUpCmd_4
   1383              {
   1384                status = ERROR;
   \   0000006A   0021               MOVS     R1,#+0
   \   0000006C   00E0               B.N      ??RTC_WakeUpCmd_1
   1385              }
   1386              else
   1387              {
   1388                status = SUCCESS;
   \                     ??RTC_WakeUpCmd_4:
   \   0000006E   0121               MOVS     R1,#+1
   1389              }    
   1390            }
   1391          
   1392            /* Enable the write protection for RTC registers */
   1393            RTC->WPR = 0xFF; 
   \                     ??RTC_WakeUpCmd_1:
   \   00000070   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   00000074   FF22               MOVS     R2,#+255
   \   00000076   0260               STR      R2,[R0, #+0]
   1394            
   1395            return status;
   \   00000078   0800               MOVS     R0,R1
   \   0000007A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   12BC               POP      {R1,R4}
   \   0000007E   7047               BX       LR               ;; return
   1396          }
   1397          
   1398          /**
   1399            * @}
   1400            */
   1401          
   1402          /** @defgroup RTC_Group5 Daylight Saving configuration functions
   1403           *  @brief   Daylight Saving configuration functions 
   1404           *
   1405          @verbatim   
   1406           ===============================================================================
   1407                              Daylight Saving configuration functions
   1408           ===============================================================================  
   1409          
   1410            This section provide functions allowing to configure the RTC DayLight Saving.
   1411          
   1412          @endverbatim
   1413            * @{
   1414            */
   1415          
   1416          /**
   1417            * @brief  Adds or substract one hour from the current time.
   1418            * @param  RTC_DayLightSaveOperation: the value of hour adjustment. 
   1419            *          This parameter can be one of the following values:
   1420            *            @arg RTC_DayLightSaving_SUB1H: Substract one hour (winter time)
   1421            *            @arg RTC_DayLightSaving_ADD1H: Add one hour (summer time)
   1422            * @param  RTC_StoreOperation: Specifies the value to be written in the BCK bit 
   1423            *                            in CR register to store the operation.
   1424            *          This parameter can be one of the following values:
   1425            *            @arg RTC_StoreOperation_Reset: BCK Bit Reset
   1426            *            @arg RTC_StoreOperation_Set: BCK Bit Set
   1427            * @retval None
   1428            */

   \                                 In section .text, align 2, keep-with-next
   1429          void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
   1430          {
   1431            /* Check the parameters */
   1432            assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
   1433            assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
   1434          
   1435            /* Disable the write protection for RTC registers */
   1436            RTC->WPR = 0xCA;
   \                     RTC_DayLightSavingConfig:
   \   00000000   ........           LDR.W    R2,??DataTable37  ;; 0x40002824
   \   00000004   CA23               MOVS     R3,#+202
   \   00000006   1360               STR      R3,[R2, #+0]
   1437            RTC->WPR = 0x53;
   \   00000008   ........           LDR.W    R2,??DataTable37  ;; 0x40002824
   \   0000000C   5323               MOVS     R3,#+83
   \   0000000E   1360               STR      R3,[R2, #+0]
   1438          
   1439            /* Clear the bits to be configured */
   1440            RTC->CR &= (uint32_t)~(RTC_CR_BCK);
   \   00000010   ........           LDR.W    R2,??DataTable37_3  ;; 0x40002808
   \   00000014   1268               LDR      R2,[R2, #+0]
   \   00000016   32F48022           BICS     R2,R2,#0x40000
   \   0000001A   ........           LDR.W    R3,??DataTable37_3  ;; 0x40002808
   \   0000001E   1A60               STR      R2,[R3, #+0]
   1441          
   1442            /* Configure the RTC_CR register */
   1443            RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
   \   00000020   ........           LDR.W    R2,??DataTable37_3  ;; 0x40002808
   \   00000024   1268               LDR      R2,[R2, #+0]
   \   00000026   0843               ORRS     R0,R1,R0
   \   00000028   1043               ORRS     R0,R0,R2
   \   0000002A   ........           LDR.W    R1,??DataTable37_3  ;; 0x40002808
   \   0000002E   0860               STR      R0,[R1, #+0]
   1444          
   1445            /* Enable the write protection for RTC registers */
   1446            RTC->WPR = 0xFF; 
   \   00000030   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   00000034   FF21               MOVS     R1,#+255
   \   00000036   0160               STR      R1,[R0, #+0]
   1447          }
   \   00000038   7047               BX       LR               ;; return
   1448          
   1449          /**
   1450            * @brief  Returns the RTC Day Light Saving stored operation.
   1451            * @param  None
   1452            * @retval RTC Day Light Saving stored operation.
   1453            *          - RTC_StoreOperation_Reset
   1454            *          - RTC_StoreOperation_Set       
   1455            */

   \                                 In section .text, align 2, keep-with-next
   1456          uint32_t RTC_GetStoreOperation(void)
   1457          {
   1458            return (RTC->CR & RTC_CR_BCK);
   \                     RTC_GetStoreOperation:
   \   00000000   ........           LDR.W    R0,??DataTable37_3  ;; 0x40002808
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   10F48020           ANDS     R0,R0,#0x40000
   \   0000000A   7047               BX       LR               ;; return
   1459          }
   1460          
   1461          /**
   1462            * @}
   1463            */
   1464          
   1465          /** @defgroup RTC_Group6 Output pin Configuration function
   1466           *  @brief   Output pin Configuration function 
   1467           *
   1468          @verbatim   
   1469           ===============================================================================
   1470                                   Output pin Configuration function
   1471           ===============================================================================  
   1472          
   1473            This section provide functions allowing to configure the RTC Output source.
   1474          
   1475          @endverbatim
   1476            * @{
   1477            */
   1478          
   1479          /**
   1480            * @brief  Configures the RTC output source (AFO_ALARM).
   1481            * @param  RTC_Output: Specifies which signal will be routed to the RTC output. 
   1482            *          This parameter can be one of the following values:
   1483            *            @arg RTC_Output_Disable: No output selected
   1484            *            @arg RTC_Output_AlarmA: signal of AlarmA mapped to output
   1485            *            @arg RTC_Output_AlarmB: signal of AlarmB mapped to output
   1486            *            @arg RTC_Output_WakeUp: signal of WakeUp mapped to output
   1487            * @param  RTC_OutputPolarity: Specifies the polarity of the output signal. 
   1488            *          This parameter can be one of the following:
   1489            *            @arg RTC_OutputPolarity_High: The output pin is high when the 
   1490            *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
   1491            *            @arg RTC_OutputPolarity_Low: The output pin is low when the 
   1492            *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
   1493            * @retval None
   1494            */

   \                                 In section .text, align 2, keep-with-next
   1495          void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
   1496          {
   1497            /* Check the parameters */
   1498            assert_param(IS_RTC_OUTPUT(RTC_Output));
   1499            assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
   1500          
   1501            /* Disable the write protection for RTC registers */
   1502            RTC->WPR = 0xCA;
   \                     RTC_OutputConfig:
   \   00000000   ........           LDR.W    R2,??DataTable37  ;; 0x40002824
   \   00000004   CA23               MOVS     R3,#+202
   \   00000006   1360               STR      R3,[R2, #+0]
   1503            RTC->WPR = 0x53;
   \   00000008   ........           LDR.W    R2,??DataTable37  ;; 0x40002824
   \   0000000C   5323               MOVS     R3,#+83
   \   0000000E   1360               STR      R3,[R2, #+0]
   1504          
   1505            /* Clear the bits to be configured */
   1506            RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
   \   00000010   ........           LDR.W    R2,??DataTable37_3  ;; 0x40002808
   \   00000014   1268               LDR      R2,[R2, #+0]
   \   00000016   32F4E002           BICS     R2,R2,#0x700000
   \   0000001A   ........           LDR.W    R3,??DataTable37_3  ;; 0x40002808
   \   0000001E   1A60               STR      R2,[R3, #+0]
   1507          
   1508            /* Configure the output selection and polarity */
   1509            RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
   \   00000020   ........           LDR.W    R2,??DataTable37_3  ;; 0x40002808
   \   00000024   1268               LDR      R2,[R2, #+0]
   \   00000026   0843               ORRS     R0,R1,R0
   \   00000028   1043               ORRS     R0,R0,R2
   \   0000002A   ........           LDR.W    R1,??DataTable37_3  ;; 0x40002808
   \   0000002E   0860               STR      R0,[R1, #+0]
   1510          
   1511            /* Enable the write protection for RTC registers */
   1512            RTC->WPR = 0xFF; 
   \   00000030   ........           LDR.W    R0,??DataTable37  ;; 0x40002824
   \   00000034   FF21               MOVS     R1,#+255
   \   00000036   0160               STR      R1,[R0, #+0]
   1513          }
   \   00000038   7047               BX       LR               ;; return
   1514          
   1515          /**
   1516            * @}
   1517            */
   1518          
   1519          /** @defgroup RTC_Group7 Coarse Calibration configuration functions
   1520           *  @brief   Coarse Calibration configuration functions 
   1521           *
   1522          @verbatim   
   1523           ===============================================================================
   1524                            Coarse Calibration configuration functions
   1525           ===============================================================================  
   1526          
   1527          @endverbatim
   1528            * @{
   1529            */
   1530          
   1531          /**
   1532            * @brief  Configures the Coarse calibration parameters.
   1533            * @param  RTC_CalibSign: specifies the sign of the coarse calibration value.
   1534            *          This parameter can be  one of the following values:
   1535            *            @arg RTC_CalibSign_Positive: The value sign is positive 
   1536            *            @arg RTC_CalibSign_Negative: The value sign is negative
   1537            * @param  Value: value of coarse calibration expressed in ppm (coded on 5 bits).
   1538            *    
   1539            * @note   This Calibration value should be between 0 and 63 when using negative
   1540            *         sign with a 2-ppm step.
   1541            *           
   1542            * @note   This Calibration value should be between 0 and 126 when using positive
   1543            *         sign with a 4-ppm step.
   1544            *           
   1545            * @retval An ErrorStatus enumeration value:
   1546            *          - SUCCESS: RTC Coarse calibration are initialized
   1547            *          - ERROR: RTC Coarse calibration are not initialized     
   1548            */

   \                                 In section .text, align 2, keep-with-next
   1549          ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
   1550          {
   \                     RTC_CoarseCalibConfig:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0500               MOVS     R5,R0
   \   00000004   0E00               MOVS     R6,R1
   1551            ErrorStatus status = ERROR;
   \   00000006   0024               MOVS     R4,#+0
   1552             
   1553            /* Check the parameters */
   1554            assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
   1555            assert_param(IS_RTC_CALIB_VALUE(Value)); 
   1556          
   1557            /* Disable the write protection for RTC registers */
   1558            RTC->WPR = 0xCA;
   \   00000008   ....               LDR.N    R0,??DataTable37  ;; 0x40002824
   \   0000000A   CA21               MOVS     R1,#+202
   \   0000000C   0160               STR      R1,[R0, #+0]
   1559            RTC->WPR = 0x53;
   \   0000000E   ....               LDR.N    R0,??DataTable37  ;; 0x40002824
   \   00000010   5321               MOVS     R1,#+83
   \   00000012   0160               STR      R1,[R0, #+0]
   1560          
   1561            /* Set Initialization mode */
   1562            if (RTC_EnterInitMode() == ERROR)
   \   00000014   ........           BL       RTC_EnterInitMode
   \   00000018   0028               CMP      R0,#+0
   \   0000001A   01D1               BNE.N    ??RTC_CoarseCalibConfig_0
   1563            {
   1564              status = ERROR;
   \   0000001C   0024               MOVS     R4,#+0
   \   0000001E   06E0               B.N      ??RTC_CoarseCalibConfig_1
   1565            } 
   1566            else
   1567            {
   1568              /* Set the coarse calibration value */
   1569              RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
   \                     ??RTC_CoarseCalibConfig_0:
   \   00000020   56EA0500           ORRS     R0,R6,R5
   \   00000024   ....               LDR.N    R1,??DataTable37_8  ;; 0x40002818
   \   00000026   0860               STR      R0,[R1, #+0]
   1570              /* Exit Initialization mode */
   1571              RTC_ExitInitMode();
   \   00000028   ........           BL       RTC_ExitInitMode
   1572              
   1573              status = SUCCESS;
   \   0000002C   0124               MOVS     R4,#+1
   1574            } 
   1575          
   1576            /* Enable the write protection for RTC registers */
   1577            RTC->WPR = 0xFF; 
   \                     ??RTC_CoarseCalibConfig_1:
   \   0000002E   ....               LDR.N    R0,??DataTable37  ;; 0x40002824
   \   00000030   FF21               MOVS     R1,#+255
   \   00000032   0160               STR      R1,[R0, #+0]
   1578            
   1579            return status;
   \   00000034   2000               MOVS     R0,R4
   \   00000036   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   70BD               POP      {R4-R6,PC}       ;; return
   1580          }
   1581          
   1582          /**
   1583            * @brief  Enables or disables the Coarse calibration process.
   1584            * @param  NewState: new state of the Coarse calibration.
   1585            *          This parameter can be: ENABLE or DISABLE.
   1586            * @retval An ErrorStatus enumeration value:
   1587            *          - SUCCESS: RTC Coarse calibration are enabled/disabled
   1588            *          - ERROR: RTC Coarse calibration are not enabled/disabled    
   1589            */

   \                                 In section .text, align 2, keep-with-next
   1590          ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
   1591          {
   \                     RTC_CoarseCalibCmd:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
   1592            ErrorStatus status = ERROR;
   \   00000004   0025               MOVS     R5,#+0
   1593            
   1594            /* Check the parameters */
   1595            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1596          
   1597            /* Disable the write protection for RTC registers */
   1598            RTC->WPR = 0xCA;
   \   00000006   ....               LDR.N    R0,??DataTable37  ;; 0x40002824
   \   00000008   CA21               MOVS     R1,#+202
   \   0000000A   0160               STR      R1,[R0, #+0]
   1599            RTC->WPR = 0x53;
   \   0000000C   ....               LDR.N    R0,??DataTable37  ;; 0x40002824
   \   0000000E   5321               MOVS     R1,#+83
   \   00000010   0160               STR      R1,[R0, #+0]
   1600            
   1601            /* Set Initialization mode */
   1602            if (RTC_EnterInitMode() == ERROR)
   \   00000012   ........           BL       RTC_EnterInitMode
   \   00000016   0028               CMP      R0,#+0
   \   00000018   01D1               BNE.N    ??RTC_CoarseCalibCmd_0
   1603            {
   1604              status =  ERROR;
   \   0000001A   0025               MOVS     R5,#+0
   \   0000001C   12E0               B.N      ??RTC_CoarseCalibCmd_1
   1605            }
   1606            else
   1607            {
   1608              if (NewState != DISABLE)
   \                     ??RTC_CoarseCalibCmd_0:
   \   0000001E   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   002C               CMP      R4,#+0
   \   00000022   06D0               BEQ.N    ??RTC_CoarseCalibCmd_2
   1609              {
   1610                /* Enable the Coarse Calibration */
   1611                RTC->CR |= (uint32_t)RTC_CR_DCE;
   \   00000024   ....               LDR.N    R0,??DataTable37_3  ;; 0x40002808
   \   00000026   0068               LDR      R0,[R0, #+0]
   \   00000028   50F08000           ORRS     R0,R0,#0x80
   \   0000002C   ....               LDR.N    R1,??DataTable37_3  ;; 0x40002808
   \   0000002E   0860               STR      R0,[R1, #+0]
   \   00000030   05E0               B.N      ??RTC_CoarseCalibCmd_3
   1612              }
   1613              else
   1614              { 
   1615                /* Disable the Coarse Calibration */
   1616                RTC->CR &= (uint32_t)~RTC_CR_DCE;
   \                     ??RTC_CoarseCalibCmd_2:
   \   00000032   ....               LDR.N    R0,??DataTable37_3  ;; 0x40002808
   \   00000034   0068               LDR      R0,[R0, #+0]
   \   00000036   30F08000           BICS     R0,R0,#0x80
   \   0000003A   ....               LDR.N    R1,??DataTable37_3  ;; 0x40002808
   \   0000003C   0860               STR      R0,[R1, #+0]
   1617              }
   1618              /* Exit Initialization mode */
   1619              RTC_ExitInitMode();
   \                     ??RTC_CoarseCalibCmd_3:
   \   0000003E   ........           BL       RTC_ExitInitMode
   1620              
   1621              status = SUCCESS;
   \   00000042   0125               MOVS     R5,#+1
   1622            } 
   1623            
   1624            /* Enable the write protection for RTC registers */
   1625            RTC->WPR = 0xFF; 
   \                     ??RTC_CoarseCalibCmd_1:
   \   00000044   ....               LDR.N    R0,??DataTable37  ;; 0x40002824
   \   00000046   FF21               MOVS     R1,#+255
   \   00000048   0160               STR      R1,[R0, #+0]
   1626            
   1627            return status;
   \   0000004A   2800               MOVS     R0,R5
   \   0000004C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   32BD               POP      {R1,R4,R5,PC}    ;; return
   1628          }
   1629          
   1630          /**
   1631            * @brief  Enables or disables the RTC clock to be output through the relative pin.
   1632            * @param  NewState: new state of the digital calibration Output.
   1633            *          This parameter can be: ENABLE or DISABLE.
   1634            * @retval None
   1635            */

   \                                 In section .text, align 2, keep-with-next
   1636          void RTC_CalibOutputCmd(FunctionalState NewState)
   1637          {
   1638            /* Check the parameters */
   1639            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1640            
   1641            /* Disable the write protection for RTC registers */
   1642            RTC->WPR = 0xCA;
   \                     RTC_CalibOutputCmd:
   \   00000000   ....               LDR.N    R1,??DataTable37  ;; 0x40002824
   \   00000002   CA22               MOVS     R2,#+202
   \   00000004   0A60               STR      R2,[R1, #+0]
   1643            RTC->WPR = 0x53;
   \   00000006   ....               LDR.N    R1,??DataTable37  ;; 0x40002824
   \   00000008   5322               MOVS     R2,#+83
   \   0000000A   0A60               STR      R2,[R1, #+0]
   1644            
   1645            if (NewState != DISABLE)
   \   0000000C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   06D0               BEQ.N    ??RTC_CalibOutputCmd_0
   1646            {
   1647              /* Enable the RTC clock output */
   1648              RTC->CR |= (uint32_t)RTC_CR_COE;
   \   00000012   ....               LDR.N    R0,??DataTable37_3  ;; 0x40002808
   \   00000014   0068               LDR      R0,[R0, #+0]
   \   00000016   50F40000           ORRS     R0,R0,#0x800000
   \   0000001A   ....               LDR.N    R1,??DataTable37_3  ;; 0x40002808
   \   0000001C   0860               STR      R0,[R1, #+0]
   \   0000001E   05E0               B.N      ??RTC_CalibOutputCmd_1
   1649            }
   1650            else
   1651            { 
   1652              /* Disable the RTC clock output */
   1653              RTC->CR &= (uint32_t)~RTC_CR_COE;
   \                     ??RTC_CalibOutputCmd_0:
   \   00000020   ....               LDR.N    R0,??DataTable37_3  ;; 0x40002808
   \   00000022   0068               LDR      R0,[R0, #+0]
   \   00000024   30F40000           BICS     R0,R0,#0x800000
   \   00000028   ....               LDR.N    R1,??DataTable37_3  ;; 0x40002808
   \   0000002A   0860               STR      R0,[R1, #+0]
   1654            }
   1655            
   1656            /* Enable the write protection for RTC registers */
   1657            RTC->WPR = 0xFF; 
   \                     ??RTC_CalibOutputCmd_1:
   \   0000002C   ....               LDR.N    R0,??DataTable37  ;; 0x40002824
   \   0000002E   FF21               MOVS     R1,#+255
   \   00000030   0160               STR      R1,[R0, #+0]
   1658          }
   \   00000032   7047               BX       LR               ;; return
   1659          
   1660          /**
   1661            * @}
   1662            */
   1663          
   1664          
   1665          /** @defgroup RTC_Group8 TimeStamp configuration functions
   1666           *  @brief   TimeStamp configuration functions 
   1667           *
   1668          @verbatim   
   1669           ===============================================================================
   1670                                 TimeStamp configuration functions
   1671           ===============================================================================  
   1672          
   1673          @endverbatim
   1674            * @{
   1675            */
   1676          
   1677          /**
   1678            * @brief  Enables or Disables the RTC TimeStamp functionality with the 
   1679            *         specified time stamp pin stimulating edge.
   1680            * @param  RTC_TimeStampEdge: Specifies the pin edge on which the TimeStamp is 
   1681            *         activated.
   1682            *          This parameter can be one of the following:
   1683            *            @arg RTC_TimeStampEdge_Rising: the Time stamp event occurs on the rising 
   1684            *                                    edge of the related pin.
   1685            *            @arg RTC_TimeStampEdge_Falling: the Time stamp event occurs on the 
   1686            *                                     falling edge of the related pin.
   1687            * @param  NewState: new state of the TimeStamp.
   1688            *          This parameter can be: ENABLE or DISABLE.
   1689            * @retval None
   1690            */

   \                                 In section .text, align 2, keep-with-next
   1691          void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
   1692          {
   \                     RTC_TimeStampCmd:
   \   00000000   10B4               PUSH     {R4}
   1693            uint32_t tmpreg = 0;
   \   00000002   0022               MOVS     R2,#+0
   1694          
   1695            /* Check the parameters */
   1696            assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
   1697            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1698          
   1699            /* Get the RTC_CR register and clear the bits to be configured */
   1700            tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
   \   00000004   ....               LDR.N    R3,??DataTable37_3  ;; 0x40002808
   \   00000006   1B68               LDR      R3,[R3, #+0]
   \   00000008   ....               LDR.N    R4,??DataTable37_14  ;; 0xfffff7f7
   \   0000000A   2340               ANDS     R3,R4,R3
   \   0000000C   1A00               MOVS     R2,R3
   1701          
   1702            /* Get the new configuration */
   1703            if (NewState != DISABLE)
   \   0000000E   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0029               CMP      R1,#+0
   \   00000012   03D0               BEQ.N    ??RTC_TimeStampCmd_0
   1704            {
   1705              tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
   \   00000014   50F40060           ORRS     R0,R0,#0x800
   \   00000018   0243               ORRS     R2,R0,R2
   \   0000001A   00E0               B.N      ??RTC_TimeStampCmd_1
   1706            }
   1707            else
   1708            {
   1709              tmpreg |= (uint32_t)(RTC_TimeStampEdge);
   \                     ??RTC_TimeStampCmd_0:
   \   0000001C   0243               ORRS     R2,R0,R2
   1710            }
   1711          
   1712            /* Disable the write protection for RTC registers */
   1713            RTC->WPR = 0xCA;
   \                     ??RTC_TimeStampCmd_1:
   \   0000001E   ....               LDR.N    R0,??DataTable37  ;; 0x40002824
   \   00000020   CA21               MOVS     R1,#+202
   \   00000022   0160               STR      R1,[R0, #+0]
   1714            RTC->WPR = 0x53;
   \   00000024   ....               LDR.N    R0,??DataTable37  ;; 0x40002824
   \   00000026   5321               MOVS     R1,#+83
   \   00000028   0160               STR      R1,[R0, #+0]
   1715          
   1716            /* Configure the Time Stamp TSEDGE and Enable bits */
   1717            RTC->CR = (uint32_t)tmpreg;
   \   0000002A   ....               LDR.N    R0,??DataTable37_3  ;; 0x40002808
   \   0000002C   0260               STR      R2,[R0, #+0]
   1718          
   1719            /* Enable the write protection for RTC registers */
   1720            RTC->WPR = 0xFF; 
   \   0000002E   ....               LDR.N    R0,??DataTable37  ;; 0x40002824
   \   00000030   FF21               MOVS     R1,#+255
   \   00000032   0160               STR      R1,[R0, #+0]
   1721          }
   \   00000034   10BC               POP      {R4}
   \   00000036   7047               BX       LR               ;; return
   1722          
   1723          /**
   1724            * @brief  Get the RTC TimeStamp value and masks.
   1725            * @param  RTC_Format: specifies the format of the output parameters.
   1726            *          This parameter can be one of the following values:
   1727            *            @arg RTC_Format_BIN: Binary data format 
   1728            *            @arg RTC_Format_BCD: BCD data format
   1729            * @param RTC_StampTimeStruct: pointer to a RTC_TimeTypeDef structure that will 
   1730            *                             contains the TimeStamp time values. 
   1731            * @param RTC_StampDateStruct: pointer to a RTC_DateTypeDef structure that will 
   1732            *                             contains the TimeStamp date values.     
   1733            * @retval None
   1734            */

   \                                 In section .text, align 2, keep-with-next
   1735          void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
   1736                                                RTC_DateTypeDef* RTC_StampDateStruct)
   1737          {
   \                     RTC_GetTimeStamp:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0C00               MOVS     R4,R1
   \   00000004   1500               MOVS     R5,R2
   1738            uint32_t tmptime = 0, tmpdate = 0;
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   0022               MOVS     R2,#+0
   1739          
   1740            /* Check the parameters */
   1741            assert_param(IS_RTC_FORMAT(RTC_Format));
   1742          
   1743            /* Get the TimeStamp time and date registers values */
   1744            tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
   \   0000000A   ....               LDR.N    R3,??DataTable37_15  ;; 0x40002830
   \   0000000C   1B68               LDR      R3,[R3, #+0]
   \   0000000E   ....               LDR.N    R6,??DataTable37_12  ;; 0x7f7f7f
   \   00000010   3340               ANDS     R3,R6,R3
   \   00000012   1900               MOVS     R1,R3
   1745            tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
   \   00000014   ....               LDR.N    R3,??DataTable37_16  ;; 0x40002834
   \   00000016   1B68               LDR      R3,[R3, #+0]
   \   00000018   ....               LDR.N    R6,??DataTable37_13  ;; 0xffff3f
   \   0000001A   3340               ANDS     R3,R6,R3
   \   0000001C   1A00               MOVS     R2,R3
   1746          
   1747            /* Fill the Time structure fields with the read parameters */
   1748            RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
   \   0000001E   0B0C               LSRS     R3,R1,#+16
   \   00000020   13F03F03           ANDS     R3,R3,#0x3F
   \   00000024   2370               STRB     R3,[R4, #+0]
   1749            RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
   \   00000026   0B0A               LSRS     R3,R1,#+8
   \   00000028   13F07F03           ANDS     R3,R3,#0x7F
   \   0000002C   6370               STRB     R3,[R4, #+1]
   1750            RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
   \   0000002E   11F07F03           ANDS     R3,R1,#0x7F
   \   00000032   A370               STRB     R3,[R4, #+2]
   1751            RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
   \   00000034   090C               LSRS     R1,R1,#+16
   \   00000036   11F04001           ANDS     R1,R1,#0x40
   \   0000003A   E170               STRB     R1,[R4, #+3]
   1752          
   1753            /* Fill the Date structure fields with the read parameters */
   1754            RTC_StampDateStruct->RTC_Year = 0;
   \   0000003C   0021               MOVS     R1,#+0
   \   0000003E   E970               STRB     R1,[R5, #+3]
   1755            RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
   \   00000040   110A               LSRS     R1,R2,#+8
   \   00000042   11F01F01           ANDS     R1,R1,#0x1F
   \   00000046   6970               STRB     R1,[R5, #+1]
   1756            RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
   \   00000048   12F03F01           ANDS     R1,R2,#0x3F
   \   0000004C   A970               STRB     R1,[R5, #+2]
   1757            RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
   \   0000004E   510B               LSRS     R1,R2,#+13
   \   00000050   11F00701           ANDS     R1,R1,#0x7
   \   00000054   2970               STRB     R1,[R5, #+0]
   1758          
   1759            /* Check the input parameters format */
   1760            if (RTC_Format == RTC_Format_BIN)
   \   00000056   0028               CMP      R0,#+0
   \   00000058   17D1               BNE.N    ??RTC_GetTimeStamp_0
   1761            {
   1762              /* Convert the Time structure parameters to Binary format */
   1763              RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
   \   0000005A   2078               LDRB     R0,[R4, #+0]
   \   0000005C   ........           BL       RTC_Bcd2ToByte
   \   00000060   2070               STRB     R0,[R4, #+0]
   1764              RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
   \   00000062   6078               LDRB     R0,[R4, #+1]
   \   00000064   ........           BL       RTC_Bcd2ToByte
   \   00000068   6070               STRB     R0,[R4, #+1]
   1765              RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
   \   0000006A   A078               LDRB     R0,[R4, #+2]
   \   0000006C   ........           BL       RTC_Bcd2ToByte
   \   00000070   A070               STRB     R0,[R4, #+2]
   1766          
   1767              /* Convert the Date structure parameters to Binary format */
   1768              RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
   \   00000072   6878               LDRB     R0,[R5, #+1]
   \   00000074   ........           BL       RTC_Bcd2ToByte
   \   00000078   6870               STRB     R0,[R5, #+1]
   1769              RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
   \   0000007A   A878               LDRB     R0,[R5, #+2]
   \   0000007C   ........           BL       RTC_Bcd2ToByte
   \   00000080   A870               STRB     R0,[R5, #+2]
   1770              RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
   \   00000082   2878               LDRB     R0,[R5, #+0]
   \   00000084   ........           BL       RTC_Bcd2ToByte
   \   00000088   2870               STRB     R0,[R5, #+0]
   1771            }
   1772          }
   \                     ??RTC_GetTimeStamp_0:
   \   0000008A   70BD               POP      {R4-R6,PC}       ;; return
   1773          
   1774          /**
   1775            * @}
   1776            */
   1777          
   1778          /** @defgroup RTC_Group9 Tampers configuration functions
   1779           *  @brief   Tampers configuration functions 
   1780           *
   1781          @verbatim   
   1782           ===============================================================================
   1783                                 Tampers configuration functions
   1784           ===============================================================================  
   1785          
   1786          @endverbatim
   1787            * @{
   1788            */
   1789          
   1790          /**
   1791            * @brief  Configures the select Tamper pin edge.
   1792            * @param  RTC_Tamper: Selected tamper pin.
   1793            *          This parameter can be RTC_Tamper_1.
   1794            * @param  RTC_TamperTrigger: Specifies the trigger on the tamper pin that 
   1795            *         stimulates tamper event. 
   1796            *          This parameter can be one of the following values:
   1797            *            @arg RTC_TamperTrigger_RisingEdge: Rising Edge of the tamper pin causes tamper event.
   1798            *            @arg RTC_TamperTrigger_FallingEdge: Falling Edge of the tamper pin causes tamper event.                         
   1799            * @retval None
   1800            */

   \                                 In section .text, align 2, keep-with-next
   1801          void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
   1802          {
   1803            /* Check the parameters */
   1804            assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
   1805            assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
   1806           
   1807            if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
   \                     RTC_TamperTriggerConfig:
   \   00000000   0029               CMP      R1,#+0
   \   00000002   06D1               BNE.N    ??RTC_TamperTriggerConfig_0
   1808            {  
   1809              /* Configure the RTC_TAFCR register */
   1810              RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
   \   00000004   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   00000006   0968               LDR      R1,[R1, #+0]
   \   00000008   31EA4000           BICS     R0,R1,R0, LSL #+1
   \   0000000C   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   0000000E   0860               STR      R0,[R1, #+0]
   \   00000010   05E0               B.N      ??RTC_TamperTriggerConfig_1
   1811            }
   1812            else
   1813            { 
   1814              /* Configure the RTC_TAFCR register */
   1815              RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
   \                     ??RTC_TamperTriggerConfig_0:
   \   00000012   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   51EA4000           ORRS     R0,R1,R0, LSL #+1
   \   0000001A   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   0000001C   0860               STR      R0,[R1, #+0]
   1816            }  
   1817          }
   \                     ??RTC_TamperTriggerConfig_1:
   \   0000001E   7047               BX       LR               ;; return
   1818          
   1819          /**
   1820            * @brief  Enables or Disables the Tamper detection.
   1821            * @param  RTC_Tamper: Selected tamper pin.
   1822            *          This parameter can be RTC_Tamper_1.
   1823            * @param  NewState: new state of the tamper pin.
   1824            *          This parameter can be: ENABLE or DISABLE.                   
   1825            * @retval None
   1826            */

   \                                 In section .text, align 2, keep-with-next
   1827          void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
   1828          {
   1829            /* Check the parameters */
   1830            assert_param(IS_RTC_TAMPER(RTC_Tamper));  
   1831            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1832            
   1833            if (NewState != DISABLE)
   \                     RTC_TamperCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   05D0               BEQ.N    ??RTC_TamperCmd_0
   1834            {
   1835              /* Enable the selected Tamper pin */
   1836              RTC->TAFCR |= (uint32_t)RTC_Tamper;
   \   00000006   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   0843               ORRS     R0,R0,R1
   \   0000000C   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   0000000E   0860               STR      R0,[R1, #+0]
   \   00000010   05E0               B.N      ??RTC_TamperCmd_1
   1837            }
   1838            else
   1839            {
   1840              /* Disable the selected Tamper pin */
   1841              RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
   \                     ??RTC_TamperCmd_0:
   \   00000012   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   31EA0000           BICS     R0,R1,R0
   \   0000001A   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   0000001C   0860               STR      R0,[R1, #+0]
   1842            }  
   1843          }
   \                     ??RTC_TamperCmd_1:
   \   0000001E   7047               BX       LR               ;; return
   1844          
   1845          /**
   1846            * @}
   1847            */
   1848          
   1849          /** @defgroup RTC_Group10 Backup Data Registers configuration functions
   1850           *  @brief   Backup Data Registers configuration functions  
   1851           *
   1852          @verbatim   
   1853           ===============================================================================
   1854                                 Backup Data Registers configuration functions 
   1855           ===============================================================================  
   1856          
   1857          @endverbatim
   1858            * @{
   1859            */
   1860          
   1861          /**
   1862            * @brief  Writes a data in a specified RTC Backup data register.
   1863            * @param  RTC_BKP_DR: RTC Backup data Register number.
   1864            *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
   1865            *                          specify the register.
   1866            * @param  Data: Data to be written in the specified RTC Backup data register.                     
   1867            * @retval None
   1868            */

   \                                 In section .text, align 2, keep-with-next
   1869          void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
   1870          {
   \                     RTC_WriteBackupRegister:
   \   00000000   81B0               SUB      SP,SP,#+4
   1871            __IO uint32_t tmp = 0;
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   0092               STR      R2,[SP, #+0]
   1872            
   1873            /* Check the parameters */
   1874            assert_param(IS_RTC_BKP(RTC_BKP_DR));
   1875          
   1876            tmp = RTC_BASE + 0x50;
   \   00000006   ....               LDR.N    R2,??DataTable37_17  ;; 0x40002850
   \   00000008   0092               STR      R2,[SP, #+0]
   1877            tmp += (RTC_BKP_DR * 4);
   \   0000000A   009A               LDR      R2,[SP, #+0]
   \   0000000C   12EB8000           ADDS     R0,R2,R0, LSL #+2
   \   00000010   0090               STR      R0,[SP, #+0]
   1878          
   1879            /* Write the specified register */
   1880            *(__IO uint32_t *)tmp = (uint32_t)Data;
   \   00000012   0098               LDR      R0,[SP, #+0]
   \   00000014   0160               STR      R1,[R0, #+0]
   1881          }
   \   00000016   01B0               ADD      SP,SP,#+4
   \   00000018   7047               BX       LR               ;; return
   1882          
   1883          /**
   1884            * @brief  Reads data from the specified RTC Backup data Register.
   1885            * @param  RTC_BKP_DR: RTC Backup data Register number.
   1886            *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
   1887            *                          specify the register.                   
   1888            * @retval None
   1889            */

   \                                 In section .text, align 2, keep-with-next
   1890          uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
   1891          {
   \                     RTC_ReadBackupRegister:
   \   00000000   81B0               SUB      SP,SP,#+4
   1892            __IO uint32_t tmp = 0;
   \   00000002   0021               MOVS     R1,#+0
   \   00000004   0091               STR      R1,[SP, #+0]
   1893            
   1894            /* Check the parameters */
   1895            assert_param(IS_RTC_BKP(RTC_BKP_DR));
   1896          
   1897            tmp = RTC_BASE + 0x50;
   \   00000006   ....               LDR.N    R1,??DataTable37_17  ;; 0x40002850
   \   00000008   0091               STR      R1,[SP, #+0]
   1898            tmp += (RTC_BKP_DR * 4);
   \   0000000A   0099               LDR      R1,[SP, #+0]
   \   0000000C   11EB8000           ADDS     R0,R1,R0, LSL #+2
   \   00000010   0090               STR      R0,[SP, #+0]
   1899            
   1900            /* Read the specified register */
   1901            return (*(__IO uint32_t *)tmp);
   \   00000012   0098               LDR      R0,[SP, #+0]
   \   00000014   0068               LDR      R0,[R0, #+0]
   \   00000016   01B0               ADD      SP,SP,#+4
   \   00000018   7047               BX       LR               ;; return
   1902          }
   1903          
   1904          /**
   1905            * @}
   1906            */
   1907          
   1908          /** @defgroup RTC_Group11 RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration functions
   1909           *  @brief   RTC Tamper and TimeStamp Pins Selection and Output Type Config 
   1910           *           configuration functions  
   1911           *
   1912          @verbatim   
   1913           ===============================================================================
   1914            RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration 
   1915            functions 
   1916           ===============================================================================  
   1917          
   1918          @endverbatim
   1919            * @{
   1920            */
   1921          
   1922          /**
   1923            * @brief  Selects the RTC Tamper Pin.
   1924            * @param  RTC_TamperPin: specifies the RTC Tamper Pin.
   1925            *          This parameter can be one of the following values:
   1926            *            @arg RTC_TamperPin_PC13: PC13 is selected as RTC Tamper Pin.
   1927            *            @arg RTC_TamperPin_PI8: PI8 is selected as RTC Tamper Pin.    
   1928            * @retval None
   1929            */

   \                                 In section .text, align 2, keep-with-next
   1930          void RTC_TamperPinSelection(uint32_t RTC_TamperPin)
   1931          {
   1932            /* Check the parameters */
   1933            assert_param(IS_RTC_TAMPER_PIN(RTC_TamperPin));
   1934            
   1935            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPINSEL);
   \                     RTC_TamperPinSelection:
   \   00000000   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   00000002   0968               LDR      R1,[R1, #+0]
   \   00000004   31F48031           BICS     R1,R1,#0x10000
   \   00000008   ....               LDR.N    R2,??DataTable37_11  ;; 0x40002840
   \   0000000A   1160               STR      R1,[R2, #+0]
   1936            RTC->TAFCR |= (uint32_t)(RTC_TamperPin);  
   \   0000000C   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   0000000E   0968               LDR      R1,[R1, #+0]
   \   00000010   0843               ORRS     R0,R0,R1
   \   00000012   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   00000014   0860               STR      R0,[R1, #+0]
   1937          }
   \   00000016   7047               BX       LR               ;; return
   1938          
   1939          /**
   1940            * @brief  Selects the RTC TimeStamp Pin.
   1941            * @param  RTC_TimeStampPin: specifies the RTC TimeStamp Pin.
   1942            *          This parameter can be one of the following values:
   1943            *            @arg RTC_TimeStampPin_PC13: PC13 is selected as RTC TimeStamp Pin.
   1944            *            @arg RTC_TimeStampPin_PI8: PI8 is selected as RTC TimeStamp Pin.    
   1945            * @retval None
   1946            */

   \                                 In section .text, align 2, keep-with-next
   1947          void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin)
   1948          {
   1949            /* Check the parameters */
   1950            assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
   1951            
   1952            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TSINSEL);
   \                     RTC_TimeStampPinSelection:
   \   00000000   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   00000002   0968               LDR      R1,[R1, #+0]
   \   00000004   31F40031           BICS     R1,R1,#0x20000
   \   00000008   ....               LDR.N    R2,??DataTable37_11  ;; 0x40002840
   \   0000000A   1160               STR      R1,[R2, #+0]
   1953            RTC->TAFCR |= (uint32_t)(RTC_TimeStampPin);  
   \   0000000C   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   0000000E   0968               LDR      R1,[R1, #+0]
   \   00000010   0843               ORRS     R0,R0,R1
   \   00000012   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   00000014   0860               STR      R0,[R1, #+0]
   1954          }
   \   00000016   7047               BX       LR               ;; return
   1955          
   1956          /**
   1957            * @brief  Configures the RTC Output Pin mode. 
   1958            * @param  RTC_OutputType: specifies the RTC Output (PC13) pin mode.
   1959            *          This parameter can be one of the following values:
   1960            *            @arg RTC_OutputType_OpenDrain: RTC Output (PC13) is configured in 
   1961            *                                    Open Drain mode.
   1962            *            @arg RTC_OutputType_PushPull:  RTC Output (PC13) is configured in 
   1963            *                                    Push Pull mode.    
   1964            * @retval None
   1965            */

   \                                 In section .text, align 2, keep-with-next
   1966          void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
   1967          {
   1968            /* Check the parameters */
   1969            assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
   1970            
   1971            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
   \                     RTC_OutputTypeConfig:
   \   00000000   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   00000002   0968               LDR      R1,[R1, #+0]
   \   00000004   31F48021           BICS     R1,R1,#0x40000
   \   00000008   ....               LDR.N    R2,??DataTable37_11  ;; 0x40002840
   \   0000000A   1160               STR      R1,[R2, #+0]
   1972            RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
   \   0000000C   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   0000000E   0968               LDR      R1,[R1, #+0]
   \   00000010   0843               ORRS     R0,R0,R1
   \   00000012   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   00000014   0860               STR      R0,[R1, #+0]
   1973          }
   \   00000016   7047               BX       LR               ;; return
   1974          
   1975          /**
   1976            * @}
   1977            */
   1978          
   1979          /** @defgroup RTC_Group12 Interrupts and flags management functions
   1980           *  @brief   Interrupts and flags management functions  
   1981           *
   1982          @verbatim   
   1983           ===============================================================================
   1984                                 Interrupts and flags management functions
   1985           ===============================================================================  
   1986           All RTC interrupts are connected to the EXTI controller.
   1987           
   1988           - To enable the RTC Alarm interrupt, the following sequence is required:
   1989             - Configure and enable the EXTI Line 17 in interrupt mode and select the rising 
   1990               edge sensitivity using the EXTI_Init() function.
   1991             - Configure and enable the RTC_Alarm IRQ channel in the NVIC using the NVIC_Init()
   1992               function.
   1993             - Configure the RTC to generate RTC alarms (Alarm A and/or Alarm B) using
   1994               the RTC_SetAlarm() and RTC_AlarmCmd() functions.
   1995          
   1996           - To enable the RTC Wakeup interrupt, the following sequence is required:
   1997             - Configure and enable the EXTI Line 22 in interrupt mode and select the rising 
   1998               edge sensitivity using the EXTI_Init() function.
   1999             - Configure and enable the RTC_WKUP IRQ channel in the NVIC using the NVIC_Init()
   2000               function.
   2001             - Configure the RTC to generate the RTC wakeup timer event using the 
   2002               RTC_WakeUpClockConfig(), RTC_SetWakeUpCounter() and RTC_WakeUpCmd() functions.
   2003          
   2004           - To enable the RTC Tamper interrupt, the following sequence is required:
   2005             - Configure and enable the EXTI Line 21 in interrupt mode and select the rising 
   2006               edge sensitivity using the EXTI_Init() function.
   2007             - Configure and enable the TAMP_STAMP IRQ channel in the NVIC using the NVIC_Init()
   2008               function.
   2009             - Configure the RTC to detect the RTC tamper event using the 
   2010               RTC_TamperTriggerConfig() and RTC_TamperCmd() functions.
   2011          
   2012           - To enable the RTC TimeStamp interrupt, the following sequence is required:
   2013             - Configure and enable the EXTI Line 21 in interrupt mode and select the rising 
   2014               edge sensitivity using the EXTI_Init() function.
   2015             - Configure and enable the TAMP_STAMP IRQ channel in the NVIC using the NVIC_Init()
   2016               function.
   2017             - Configure the RTC to detect the RTC time-stamp event using the 
   2018               RTC_TimeStampCmd() functions.
   2019          
   2020          @endverbatim
   2021            * @{
   2022            */
   2023          
   2024          /**
   2025            * @brief  Enables or disables the specified RTC interrupts.
   2026            * @param  RTC_IT: specifies the RTC interrupt sources to be enabled or disabled. 
   2027            *          This parameter can be any combination of the following values:
   2028            *            @arg RTC_IT_TS:  Time Stamp interrupt mask
   2029            *            @arg RTC_IT_WUT:  WakeUp Timer interrupt mask
   2030            *            @arg RTC_IT_ALRB:  Alarm B interrupt mask
   2031            *            @arg RTC_IT_ALRA:  Alarm A interrupt mask
   2032            *            @arg RTC_IT_TAMP: Tamper event interrupt mask
   2033            * @param  NewState: new state of the specified RTC interrupts.
   2034            *          This parameter can be: ENABLE or DISABLE.
   2035            * @retval None
   2036            */

   \                                 In section .text, align 2, keep-with-next
   2037          void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
   2038          {
   2039            /* Check the parameters */
   2040            assert_param(IS_RTC_CONFIG_IT(RTC_IT));
   2041            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2042          
   2043            /* Disable the write protection for RTC registers */
   2044            RTC->WPR = 0xCA;
   \                     RTC_ITConfig:
   \   00000000   ....               LDR.N    R2,??DataTable37  ;; 0x40002824
   \   00000002   CA23               MOVS     R3,#+202
   \   00000004   1360               STR      R3,[R2, #+0]
   2045            RTC->WPR = 0x53;
   \   00000006   ....               LDR.N    R2,??DataTable37  ;; 0x40002824
   \   00000008   5323               MOVS     R3,#+83
   \   0000000A   1360               STR      R3,[R2, #+0]
   2046          
   2047            if (NewState != DISABLE)
   \   0000000C   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0029               CMP      R1,#+0
   \   00000010   0ED0               BEQ.N    ??RTC_ITConfig_0
   2048            {
   2049              /* Configure the Interrupts in the RTC_CR register */
   2050              RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
   \   00000012   ....               LDR.N    R1,??DataTable37_3  ;; 0x40002808
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   30F00402           BICS     R2,R0,#0x4
   \   0000001A   1143               ORRS     R1,R2,R1
   \   0000001C   ....               LDR.N    R2,??DataTable37_3  ;; 0x40002808
   \   0000001E   1160               STR      R1,[R2, #+0]
   2051              /* Configure the Tamper Interrupt in the RTC_TAFCR */
   2052              RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
   \   00000020   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   00000022   0968               LDR      R1,[R1, #+0]
   \   00000024   10F00400           ANDS     R0,R0,#0x4
   \   00000028   0843               ORRS     R0,R0,R1
   \   0000002A   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   0000002C   0860               STR      R0,[R1, #+0]
   \   0000002E   0EE0               B.N      ??RTC_ITConfig_1
   2053            }
   2054            else
   2055            {
   2056              /* Configure the Interrupts in the RTC_CR register */
   2057              RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
   \                     ??RTC_ITConfig_0:
   \   00000030   ....               LDR.N    R1,??DataTable37_3  ;; 0x40002808
   \   00000032   0968               LDR      R1,[R1, #+0]
   \   00000034   30F00402           BICS     R2,R0,#0x4
   \   00000038   9143               BICS     R1,R1,R2
   \   0000003A   ....               LDR.N    R2,??DataTable37_3  ;; 0x40002808
   \   0000003C   1160               STR      R1,[R2, #+0]
   2058              /* Configure the Tamper Interrupt in the RTC_TAFCR */
   2059              RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
   \   0000003E   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   00000040   0968               LDR      R1,[R1, #+0]
   \   00000042   10F00400           ANDS     R0,R0,#0x4
   \   00000046   31EA0000           BICS     R0,R1,R0
   \   0000004A   ....               LDR.N    R1,??DataTable37_11  ;; 0x40002840
   \   0000004C   0860               STR      R0,[R1, #+0]
   2060            }
   2061            /* Enable the write protection for RTC registers */
   2062            RTC->WPR = 0xFF; 
   \                     ??RTC_ITConfig_1:
   \   0000004E   ....               LDR.N    R0,??DataTable37  ;; 0x40002824
   \   00000050   FF21               MOVS     R1,#+255
   \   00000052   0160               STR      R1,[R0, #+0]
   2063          }
   \   00000054   7047               BX       LR               ;; return
   2064          
   2065          /**
   2066            * @brief  Checks whether the specified RTC flag is set or not.
   2067            * @param  RTC_FLAG: specifies the flag to check.
   2068            *          This parameter can be one of the following values:
   2069            *            @arg RTC_FLAG_TAMP1F: Tamper 1 event flag
   2070            *            @arg RTC_FLAG_TSOVF: Time Stamp OverFlow flag
   2071            *            @arg RTC_FLAG_TSF: Time Stamp event flag
   2072            *            @arg RTC_FLAG_WUTF: WakeUp Timer flag
   2073            *            @arg RTC_FLAG_ALRBF: Alarm B flag
   2074            *            @arg RTC_FLAG_ALRAF: Alarm A flag
   2075            *            @arg RTC_FLAG_INITF: Initialization mode flag
   2076            *            @arg RTC_FLAG_RSF: Registers Synchronized flag
   2077            *            @arg RTC_FLAG_INITS: Registers Configured flag
   2078            *            @arg RTC_FLAG_WUTWF: WakeUp Timer Write flag
   2079            *            @arg RTC_FLAG_ALRBWF: Alarm B Write flag
   2080            *            @arg RTC_FLAG_ALRAWF: Alarm A write flag
   2081            * @retval The new state of RTC_FLAG (SET or RESET).
   2082            */

   \                                 In section .text, align 2, keep-with-next
   2083          FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
   2084          {
   \                     RTC_GetFlagStatus:
   \   00000000   10B4               PUSH     {R4}
   2085            FlagStatus bitstatus = RESET;
   \   00000002   0021               MOVS     R1,#+0
   2086            uint32_t tmpreg = 0;
   \   00000004   0022               MOVS     R2,#+0
   2087            
   2088            /* Check the parameters */
   2089            assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
   2090            
   2091            /* Get all the flags */
   2092            tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
   \   00000006   ....               LDR.N    R3,??DataTable37_4  ;; 0x4000280c
   \   00000008   1B68               LDR      R3,[R3, #+0]
   \   0000000A   43F67774           MOVW     R4,#+16247
   \   0000000E   2340               ANDS     R3,R4,R3
   \   00000010   1A00               MOVS     R2,R3
   2093            
   2094            /* Return the status of the flag */
   2095            if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
   \   00000012   0242               TST      R2,R0
   \   00000014   01D0               BEQ.N    ??RTC_GetFlagStatus_0
   2096            {
   2097              bitstatus = SET;
   \   00000016   0121               MOVS     R1,#+1
   \   00000018   00E0               B.N      ??RTC_GetFlagStatus_1
   2098            }
   2099            else
   2100            {
   2101              bitstatus = RESET;
   \                     ??RTC_GetFlagStatus_0:
   \   0000001A   0021               MOVS     R1,#+0
   2102            }
   2103            return bitstatus;
   \                     ??RTC_GetFlagStatus_1:
   \   0000001C   0800               MOVS     R0,R1
   \   0000001E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   10BC               POP      {R4}
   \   00000022   7047               BX       LR               ;; return
   2104          }
   2105          
   2106          /**
   2107            * @brief  Clears the RTC's pending flags.
   2108            * @param  RTC_FLAG: specifies the RTC flag to clear.
   2109            *          This parameter can be any combination of the following values:
   2110            *            @arg RTC_FLAG_TAMP1F: Tamper 1 event flag
   2111            *            @arg RTC_FLAG_TSOVF: Time Stamp Overflow flag 
   2112            *            @arg RTC_FLAG_TSF: Time Stamp event flag
   2113            *            @arg RTC_FLAG_WUTF: WakeUp Timer flag
   2114            *            @arg RTC_FLAG_ALRBF: Alarm B flag
   2115            *            @arg RTC_FLAG_ALRAF: Alarm A flag
   2116            *            @arg RTC_FLAG_RSF: Registers Synchronized flag
   2117            * @retval None
   2118            */

   \                                 In section .text, align 2, keep-with-next
   2119          void RTC_ClearFlag(uint32_t RTC_FLAG)
   2120          {
   2121            /* Check the parameters */
   2122            assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
   2123          
   2124            /* Clear the Flags in the RTC_ISR register */
   2125            RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
   \                     RTC_ClearFlag:
   \   00000000   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000002   50F08000           ORRS     R0,R0,#0x80
   \   00000006   ....               LDR.N    R1,??DataTable37_4  ;; 0x4000280c
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   11F08001           ANDS     R1,R1,#0x80
   \   0000000E   71EA0000           ORNS     R0,R1,R0
   \   00000012   ....               LDR.N    R1,??DataTable37_4  ;; 0x4000280c
   \   00000014   0860               STR      R0,[R1, #+0]
   2126          }
   \   00000016   7047               BX       LR               ;; return
   2127          
   2128          /**
   2129            * @brief  Checks whether the specified RTC interrupt has occurred or not.
   2130            * @param  RTC_IT: specifies the RTC interrupt source to check.
   2131            *          This parameter can be one of the following values:
   2132            *            @arg RTC_IT_TS: Time Stamp interrupt 
   2133            *            @arg RTC_IT_WUT: WakeUp Timer interrupt 
   2134            *            @arg RTC_IT_ALRB: Alarm B interrupt 
   2135            *            @arg RTC_IT_ALRA: Alarm A interrupt 
   2136            *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
   2137            * @retval The new state of RTC_IT (SET or RESET).
   2138            */

   \                                 In section .text, align 2, keep-with-next
   2139          ITStatus RTC_GetITStatus(uint32_t RTC_IT)
   2140          {
   \                     RTC_GetITStatus:
   \   00000000   10B4               PUSH     {R4}
   2141            ITStatus bitstatus = RESET;
   \   00000002   0021               MOVS     R1,#+0
   2142            uint32_t tmpreg = 0, enablestatus = 0;
   \   00000004   0022               MOVS     R2,#+0
   \   00000006   0023               MOVS     R3,#+0
   2143           
   2144            /* Check the parameters */
   2145            assert_param(IS_RTC_GET_IT(RTC_IT));
   2146            
   2147            /* Get the TAMPER Interrupt enable bit and pending bit */
   2148            tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
   \   00000008   ....               LDR.N    R4,??DataTable37_11  ;; 0x40002840
   \   0000000A   2468               LDR      R4,[R4, #+0]
   \   0000000C   14F00404           ANDS     R4,R4,#0x4
   \   00000010   2200               MOVS     R2,R4
   2149           
   2150            /* Get the Interrupt enable Status */
   2151            enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
   \   00000012   ....               LDR.N    R4,??DataTable37_3  ;; 0x40002808
   \   00000014   2468               LDR      R4,[R4, #+0]
   \   00000016   0440               ANDS     R4,R0,R4
   \   00000018   12EAD032           ANDS     R2,R2,R0, LSR #+15
   \   0000001C   2243               ORRS     R2,R2,R4
   \   0000001E   1300               MOVS     R3,R2
   2152            
   2153            /* Get the Interrupt pending bit */
   2154            tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
   \   00000020   ....               LDR.N    R2,??DataTable37_4  ;; 0x4000280c
   \   00000022   1268               LDR      R2,[R2, #+0]
   \   00000024   12EA1012           ANDS     R2,R2,R0, LSR #+4
   2155            
   2156            /* Get the status of the Interrupt */
   2157            if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
   \   00000028   002B               CMP      R3,#+0
   \   0000002A   03D0               BEQ.N    ??RTC_GetITStatus_0
   \   0000002C   1004               LSLS     R0,R2,#+16
   \   0000002E   01D0               BEQ.N    ??RTC_GetITStatus_0
   2158            {
   2159              bitstatus = SET;
   \   00000030   0121               MOVS     R1,#+1
   \   00000032   00E0               B.N      ??RTC_GetITStatus_1
   2160            }
   2161            else
   2162            {
   2163              bitstatus = RESET;
   \                     ??RTC_GetITStatus_0:
   \   00000034   0021               MOVS     R1,#+0
   2164            }
   2165            return bitstatus;
   \                     ??RTC_GetITStatus_1:
   \   00000036   0800               MOVS     R0,R1
   \   00000038   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   10BC               POP      {R4}
   \   0000003C   7047               BX       LR               ;; return
   2166          }
   2167          
   2168          /**
   2169            * @brief  Clears the RTC's interrupt pending bits.
   2170            * @param  RTC_IT: specifies the RTC interrupt pending bit to clear.
   2171            *          This parameter can be any combination of the following values:
   2172            *            @arg RTC_IT_TS: Time Stamp interrupt 
   2173            *            @arg RTC_IT_WUT: WakeUp Timer interrupt 
   2174            *            @arg RTC_IT_ALRB: Alarm B interrupt 
   2175            *            @arg RTC_IT_ALRA: Alarm A interrupt 
   2176            *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
   2177            * @retval None
   2178            */

   \                                 In section .text, align 2, keep-with-next
   2179          void RTC_ClearITPendingBit(uint32_t RTC_IT)
   2180          {
   2181            uint32_t tmpreg = 0;
   \                     RTC_ClearITPendingBit:
   \   00000000   0021               MOVS     R1,#+0
   2182          
   2183            /* Check the parameters */
   2184            assert_param(IS_RTC_CLEAR_IT(RTC_IT));
   2185          
   2186            /* Get the RTC_ISR Interrupt pending bits mask */
   2187            tmpreg = (uint32_t)(RTC_IT >> 4);
   \   00000002   0009               LSRS     R0,R0,#+4
   \   00000004   0100               MOVS     R1,R0
   2188          
   2189            /* Clear the interrupt pending bits in the RTC_ISR register */
   2190            RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
   \   00000006   88B2               UXTH     R0,R1            ;; ZeroExt  R0,R1,#+16,#+16
   \   00000008   50F08000           ORRS     R0,R0,#0x80
   \   0000000C   ....               LDR.N    R1,??DataTable37_4  ;; 0x4000280c
   \   0000000E   0968               LDR      R1,[R1, #+0]
   \   00000010   11F08001           ANDS     R1,R1,#0x80
   \   00000014   71EA0000           ORNS     R0,R1,R0
   \   00000018   ....               LDR.N    R1,??DataTable37_4  ;; 0x4000280c
   \   0000001A   0860               STR      R0,[R1, #+0]
   2191          }
   \   0000001C   7047               BX       LR               ;; return
   2192          
   2193          /**
   2194            * @}
   2195            */
   2196          
   2197          /**
   2198            * @brief  Converts a 2 digit decimal to BCD format.
   2199            * @param  Value: Byte to be converted.
   2200            * @retval Converted byte
   2201            */

   \                                 In section .text, align 2, keep-with-next
   2202          static uint8_t RTC_ByteToBcd2(uint8_t Value)
   2203          {
   2204            uint8_t bcdhigh = 0;
   \                     RTC_ByteToBcd2:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   01E0               B.N      ??RTC_ByteToBcd2_0
   2205            
   2206            while (Value >= 10)
   2207            {
   2208              bcdhigh++;
   \                     ??RTC_ByteToBcd2_1:
   \   00000004   491C               ADDS     R1,R1,#+1
   2209              Value -= 10;
   \   00000006   0A38               SUBS     R0,R0,#+10
   2210            }
   \                     ??RTC_ByteToBcd2_0:
   \   00000008   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0A28               CMP      R0,#+10
   \   0000000C   FAD2               BCS.N    ??RTC_ByteToBcd2_1
   2211            
   2212            return  ((uint8_t)(bcdhigh << 4) | Value);
   \   0000000E   50EA0110           ORRS     R0,R0,R1, LSL #+4
   \   00000012   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   7047               BX       LR               ;; return
   2213          }
   2214          
   2215          /**
   2216            * @brief  Convert from 2 digit BCD to Binary.
   2217            * @param  Value: BCD value to be converted.
   2218            * @retval Converted word
   2219            */

   \                                 In section .text, align 2, keep-with-next
   2220          static uint8_t RTC_Bcd2ToByte(uint8_t Value)
   2221          {
   2222            uint8_t tmp = 0;
   \                     RTC_Bcd2ToByte:
   \   00000000   0021               MOVS     R1,#+0
   2223            tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
   \   00000002   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0209               LSRS     R2,R0,#+4
   \   00000006   0A23               MOVS     R3,#+10
   \   00000008   5A43               MULS     R2,R3,R2
   \   0000000A   1100               MOVS     R1,R2
   2224            return (tmp + (Value & (uint8_t)0x0F));
   \   0000000C   10F00F00           ANDS     R0,R0,#0xF
   \   00000010   4018               ADDS     R0,R0,R1
   \   00000012   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   7047               BX       LR               ;; return
   2225          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \   00000000   24280040           DC32     0x40002824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_1:
   \   00000000   00280040           DC32     0x40002800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_2:
   \   00000000   04280040           DC32     0x40002804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_3:
   \   00000000   08280040           DC32     0x40002808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_4:
   \   00000000   0C280040           DC32     0x4000280c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_5:
   \   00000000   14280040           DC32     0x40002814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_6:
   \   00000000   10280040           DC32     0x40002810

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_7:
   \   00000000   FF007F00           DC32     0x7f00ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_8:
   \   00000000   18280040           DC32     0x40002818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_9:
   \   00000000   1C280040           DC32     0x4000281c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_10:
   \   00000000   20280040           DC32     0x40002820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_11:
   \   00000000   40280040           DC32     0x40002840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_12:
   \   00000000   7F7F7F00           DC32     0x7f7f7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_13:
   \   00000000   3FFFFF00           DC32     0xffff3f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_14:
   \   00000000   F7F7FFFF           DC32     0xfffff7f7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_15:
   \   00000000   30280040           DC32     0x40002830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_16:
   \   00000000   34280040           DC32     0x40002834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_17:
   \   00000000   50280040           DC32     0x40002850
   2226          
   2227          /**
   2228            * @}
   2229            */ 
   2230          
   2231          /**
   2232            * @}
   2233            */ 
   2234          
   2235          /**
   2236            * @}
   2237            */ 
   2238          
   2239          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                  .cstack
     --------                  -------
     RTC_AlarmCmd                  12
     RTC_AlarmStructInit            0
     RTC_Bcd2ToByte                 0
     RTC_ByteToBcd2                 0
     RTC_CalibOutputCmd             0
     RTC_ClearFlag                  0
     RTC_ClearITPendingBit          0
     RTC_CoarseCalibCmd            16
     RTC_CoarseCalibConfig         16
     RTC_DateStructInit             0
     RTC_DayLightSavingConfig       0
     RTC_DeInit                    16
     RTC_EnterInitMode              4
     RTC_ExitInitMode               0
     RTC_GetAlarm                   8
     RTC_GetDate                    8
     RTC_GetFlagStatus              4
     RTC_GetITStatus                4
     RTC_GetStoreOperation          0
     RTC_GetTime                    8
     RTC_GetTimeStamp              16
     RTC_GetWakeUpCounter           0
     RTC_ITConfig                   0
     RTC_Init                      16
     RTC_OutputConfig               0
     RTC_OutputTypeConfig           0
     RTC_ReadBackupRegister         4
     RTC_RefClockCmd               16
     RTC_SetAlarm                  24
     RTC_SetDate                   16
     RTC_SetTime                   16
     RTC_SetWakeUpCounter           0
     RTC_StructInit                 0
     RTC_TamperCmd                  0
     RTC_TamperPinSelection         0
     RTC_TamperTriggerConfig        0
     RTC_TimeStampCmd               4
     RTC_TimeStampPinSelection      0
     RTC_TimeStructInit             0
     RTC_WaitForSynchro             4
     RTC_WakeUpClockConfig          0
     RTC_WakeUpCmd                  8
     RTC_WriteBackupRegister        4
     RTC_WriteProtectionCmd         0


   Section sizes:

     Function/Label            Bytes
     --------------            -----
     RTC_DeInit                 216
     RTC_Init                   112
     RTC_StructInit              14
     RTC_WriteProtectionCmd      34
     RTC_EnterInitMode           84
     RTC_ExitInitMode            18
     RTC_WaitForSynchro         100
     RTC_RefClockCmd             94
     RTC_SetTime                188
     RTC_TimeStructInit          18
     RTC_GetTime                 80
     RTC_SetDate                184
     RTC_DateStructInit          18
     RTC_GetDate                 80
     RTC_SetAlarm               226
     RTC_AlarmStructInit         30
     RTC_GetAlarm               116
     RTC_AlarmCmd               126
     RTC_WakeUpClockConfig       56
     RTC_SetWakeUpCounter        32
     RTC_GetWakeUpCounter        10
     RTC_WakeUpCmd              128
     RTC_DayLightSavingConfig    58
     RTC_GetStoreOperation       12
     RTC_OutputConfig            58
     RTC_CoarseCalibConfig       58
     RTC_CoarseCalibCmd          80
     RTC_CalibOutputCmd          52
     RTC_TimeStampCmd            56
     RTC_GetTimeStamp           140
     RTC_TamperTriggerConfig     32
     RTC_TamperCmd               32
     RTC_WriteBackupRegister     26
     RTC_ReadBackupRegister      26
     RTC_TamperPinSelection      24
     RTC_TimeStampPinSelection   24
     RTC_OutputTypeConfig        24
     RTC_ITConfig                86
     RTC_GetFlagStatus           36
     RTC_ClearFlag               24
     RTC_GetITStatus             62
     RTC_ClearITPendingBit       30
     RTC_ByteToBcd2              22
     RTC_Bcd2ToByte              22
     ??DataTable37                4
     ??DataTable37_1              4
     ??DataTable37_2              4
     ??DataTable37_3              4
     ??DataTable37_4              4
     ??DataTable37_5              4
     ??DataTable37_6              4
     ??DataTable37_7              4
     ??DataTable37_8              4
     ??DataTable37_9              4
     ??DataTable37_10             4
     ??DataTable37_11             4
     ??DataTable37_12             4
     ??DataTable37_13             4
     ??DataTable37_14             4
     ??DataTable37_15             4
     ??DataTable37_16             4
     ??DataTable37_17             4

 
 3 020 bytes in section .text
 
 3 020 bytes of CODE memory

Errors: none
Warnings: none
