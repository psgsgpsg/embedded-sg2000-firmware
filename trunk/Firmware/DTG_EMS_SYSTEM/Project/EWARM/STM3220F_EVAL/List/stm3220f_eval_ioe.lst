###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     09/May/2011  20:41:43 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4 #
#                    \STM32F2xx_StdPeriph_Lib_V0.0.4\Utilities\STM32_EVAL\STM #
#                    3220F_EVAL\stm3220f_eval_ioe.c                           #
#    Command line =  "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Utilities\STM32_EVAL\ST #
#                    M3220F_EVAL\stm3220f_eval_ioe.c" -D                      #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -lC "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V #
#                    0.0.4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_S #
#                    tdPeriph_Template\EWARM\STM3220F_EVAL\List\" -lA         #
#                    "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\STM3220F_EVAL\List\" -o              #
#                    "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\STM3220F_EVAL\Obj\" --no_cse         #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Full.h" -I "D:\¹¬ÀÛ¾÷\[        #
#                    NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_S #
#                    tdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template #
#                    \EWARM\..\" -I "D:\¹¬ÀÛ¾÷\[ NewDTG                       #
#                    ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\..\..\Libraries\CMSIS\CM3\CoreSupport\" -I            #
#                    "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Libraries\CMSIS\CM3\DeviceS #
#                    upport\ST\STM32F2xx\" -I "D:\¹¬ÀÛ¾÷\[ NewDTG             #
#                    ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I   #
#                    "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Utilities\STM32_EVAL\" -I   #
#                    "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Utilities\STM32_EVAL\Common #
#                    \" -I "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib #
#                    _V0.0.4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx #
#                    _StdPeriph_Template\EWARM\..\..\..\Utilities\STM32_EVAL\ #
#                    STM3220F_EVAL\" -Ol --use_c++_inline                     #
#    List file    =  D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4 #
#                    \STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPer #
#                    iph_Template\EWARM\STM3220F_EVAL\List\stm3220f_eval_ioe. #
#                    lst                                                      #
#    Object file  =  D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4 #
#                    \STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPer #
#                    iph_Template\EWARM\STM3220F_EVAL\Obj\stm3220f_eval_ioe.o #
#                                                                             #
#                                                                             #
###############################################################################

D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPeriph_Lib_V0.0.4\Utilities\STM32_EVAL\STM3220F_EVAL\stm3220f_eval_ioe.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm3220f_eval_ioe.c
      4            * @author  MCD Application Team
      5            * @version V4.X.0RC13
      6            * @date    13-January-2011
      7            * @brief   This file includes the IO Expander driver for STMPE811 IO Expander 
      8            *          devices.
      9            ******************************************************************************
     10            * @attention
     11            *
     12            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     13            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     14            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     15            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     16            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     17            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     18            *
     19            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     20            ******************************************************************************  
     21            */ 
     22          
     23            /* File Info : ---------------------------------------------------------------
     24            
     25              Note:
     26              -----
     27              - This driver uses the DMA method for sending and receiving data on I2C bus
     28                which allow higher efficiency and reliability of the communication.  
     29            
     30              SUPPORTED FEATURES:
     31                - IO Read/write : Set/Reset and Read (Polling/Interrupt)
     32                - Joystick: config and Read (Polling/Interrupt)
     33                - Touch Screen Features: Single point mode (Polling/Interrupt)
     34                - TempSensor Feature: accuracy not determined (Polling).
     35          
     36              UNSUPPORTED FEATURES:
     37                - Row ADC Feature is not supported (not implemented on STM3220F_EVAL board)
     38            ----------------------------------------------------------------------------*/
     39          
     40          /* Includes ------------------------------------------------------------------*/
     41          #include "stm3220f_eval_ioe.h"
     42          
     43          /** @addtogroup Utilities
     44            * @{
     45            */
     46          
     47          /** @addtogroup STM32_EVAL
     48            * @{
     49            */ 
     50          
     51          /** @addtogroup STM3220F_EVAL
     52            * @{
     53            */
     54              
     55          /** @defgroup STM3220F_EVAL_IOE 
     56            * @brief  This file includes the IO Expander driver for STMPE811 IO Expander 
     57            *         devices.
     58            * @{
     59            */ 
     60            
     61          
     62          /** @defgroup STM3220F_EVAL_IOE_Private_TypesDefinitions
     63            * @{
     64            */ 
     65          /**
     66            * @}
     67            */ 
     68          
     69          
     70          /** @defgroup STM3220F_EVAL_IOE_Private_Defines
     71            * @{
     72            */ 
     73          #define TIMEOUT_MAX    0x3000; /*<! The value of the maximal timeout for I2C waiting loops */
     74          /**
     75            * @}
     76            */ 
     77          
     78          
     79          /** @defgroup STM3220F_EVAL_IOE_Private_Macros
     80            * @{
     81            */ 
     82          /**
     83            * @}
     84            */ 
     85          
     86          
     87          /** @defgroup STM3220F_EVAL_IOE_Private_Variables
     88            * @{
     89            */ 

   \                                 In section .bss, align 4
     90          TS_STATE TS_State;              /*<! The global structure holding the TS state */
   \                     TS_State:
   \   00000000                      DS8 8
     91          

   \                                 In section .data, align 4
     92          uint32_t IOE_TimeOut = TIMEOUT_MAX; /*<! Value of Timeout when I2C communication fails */
   \                     IOE_TimeOut:
   \   00000000   00300000           DC32 12288
     93          /**
     94            * @}
     95            */ 
     96          
     97          
     98          /** @defgroup STM3220F_EVAL_IOE_Private_FunctionPrototypes
     99            * @{
    100            */ 
    101          static uint16_t IOE_TS_Read_X(void);
    102          static uint16_t IOE_TS_Read_Y(void);
    103          static uint16_t IOE_TS_Read_Z(void);
    104          
    105          static void IOE_GPIO_Config(void);
    106          static void IOE_I2C_Config(void);
    107          static void IOE_DMA_Config(IOE_DMADirection_TypeDef Direction, uint8_t* buffer);
    108          static void IOE_EXTI_Config(void);
    109          
    110          #ifndef USE_Delay
    111          static void delay(__IO uint32_t nCount);
    112          #endif /* USE_Delay*/
    113          /**
    114            * @}
    115            */ 
    116          
    117          
    118          /** @defgroup STM3220F_EVAL_IOE_Private_Functions
    119            * @{
    120            */ 
    121          
    122          
    123          /**
    124            * @brief  Initializes and Configures the two IO_Expanders Functionalities 
    125            *         (IOs, Touch Screen ..) and configures all STM3220F_EVAL necessary
    126            *         hardware (GPIOs, APB clocks ..).
    127            * @param  None
    128            * @retval IOE_OK if all initializations done correctly. Other value if error.
    129            */

   \                                 In section .text, align 2, keep-with-next
    130          uint8_t IOE_Config(void)
    131          {
   \                     IOE_Config:
   \   00000000   80B5               PUSH     {R7,LR}
    132            /* Configure the needed pins */
    133            IOE_GPIO_Config(); 
   \   00000002   ........           BL       IOE_GPIO_Config
    134            
    135            IOE_I2C_Config();
   \   00000006   ........           BL       IOE_I2C_Config
    136              
    137            /* Read IO Expander 1 ID  */
    138            if(IOE_IsOperational(IOE_1_ADDR))
   \   0000000A   8220               MOVS     R0,#+130
   \   0000000C   ........           BL       IOE_IsOperational
   \   00000010   0028               CMP      R0,#+0
   \   00000012   01D0               BEQ.N    ??IOE_Config_0
    139            {
    140              return IOE1_NOT_OPERATIONAL;
   \   00000014   0420               MOVS     R0,#+4
   \   00000016   5EE0               B.N      ??IOE_Config_1
    141            }
    142            if(IOE_IsOperational(IOE_2_ADDR))
   \                     ??IOE_Config_0:
   \   00000018   8820               MOVS     R0,#+136
   \   0000001A   ........           BL       IOE_IsOperational
   \   0000001E   0028               CMP      R0,#+0
   \   00000020   01D0               BEQ.N    ??IOE_Config_2
    143            {
    144              return IOE2_NOT_OPERATIONAL;
   \   00000022   0520               MOVS     R0,#+5
   \   00000024   57E0               B.N      ??IOE_Config_1
    145            }
    146            
    147            /* Generate IOExpander Software reset */
    148            IOE_Reset(IOE_1_ADDR); 
   \                     ??IOE_Config_2:
   \   00000026   8220               MOVS     R0,#+130
   \   00000028   ........           BL       IOE_Reset
    149            IOE_Reset(IOE_2_ADDR);
   \   0000002C   8820               MOVS     R0,#+136
   \   0000002E   ........           BL       IOE_Reset
    150            
    151            /* ---------------------- IO Expander 1 configuration --------------------- */
    152            /* Enable the GPIO, Touch Screen and ADC functionalities */
    153            IOE_FnctCmd(IOE_1_ADDR, IOE_IO_FCT | IOE_TS_FCT | IOE_ADC_FCT, ENABLE);
   \   00000032   0122               MOVS     R2,#+1
   \   00000034   0721               MOVS     R1,#+7
   \   00000036   8220               MOVS     R0,#+130
   \   00000038   ........           BL       IOE_FnctCmd
    154            /* Configure the VBAT pin in output mode pin*/
    155            IOE_IOPinConfig(IOE_1_ADDR, VBAT_DIV_PIN , Direction_OUT);  
   \   0000003C   0122               MOVS     R2,#+1
   \   0000003E   0121               MOVS     R1,#+1
   \   00000040   8220               MOVS     R0,#+130
   \   00000042   ........           BL       IOE_IOPinConfig
    156            /* ENABLE the alternate function for IN1 pin */
    157            IOE_IOAFConfig(IOE_1_ADDR, VBAT_DIV_PIN, ENABLE);
   \   00000046   0122               MOVS     R2,#+1
   \   00000048   0121               MOVS     R1,#+1
   \   0000004A   8220               MOVS     R0,#+130
   \   0000004C   ........           BL       IOE_IOAFConfig
    158            
    159            /* Apply the default state for the out pins */
    160            IOE_WriteIOPin(VBAT_DIV_PIN, BitReset);
   \   00000050   0021               MOVS     R1,#+0
   \   00000052   0120               MOVS     R0,#+1
   \   00000054   ........           BL       IOE_WriteIOPin
    161            /* Configure the MEMS interrupt pins in Input mode */
    162            IOE_IOPinConfig(IOE_2_ADDR, (uint32_t)(MEMS_INT1_PIN | MEMS_INT2_PIN), Direction_IN); 
   \   00000058   0022               MOVS     R2,#+0
   \   0000005A   0C21               MOVS     R1,#+12
   \   0000005C   8820               MOVS     R0,#+136
   \   0000005E   ........           BL       IOE_IOPinConfig
    163            
    164            /* ENABLE the alternate function for the Joystick pins */
    165            IOE_IOAFConfig(IOE_2_ADDR, (uint32_t)(MEMS_INT1_PIN | MEMS_INT2_PIN), ENABLE);
   \   00000062   0122               MOVS     R2,#+1
   \   00000064   0C21               MOVS     R1,#+12
   \   00000066   8820               MOVS     R0,#+136
   \   00000068   ........           BL       IOE_IOAFConfig
    166            /* Configure the IOs to detect Falling and Rising Edges */
    167            IOE_IOEdgeConfig(IOE_2_ADDR, (uint32_t)(MEMS_INT1_PIN | MEMS_INT2_PIN), (uint32_t)(EDGE_FALLING | EDGE_RISING));
   \   0000006C   0322               MOVS     R2,#+3
   \   0000006E   0C21               MOVS     R1,#+12
   \   00000070   8820               MOVS     R0,#+136
   \   00000072   ........           BL       IOE_IOEdgeConfig
    168            /* Touch Screen controller configuration */
    169            IOE_TS_Config();
   \   00000076   ........           BL       IOE_TS_Config
    170            
    171            /* ------------------------------------------------------------------------ */
    172            
    173            /* ---------------------- IO Expander 2 configuration --------------------- */
    174            /* Enable the GPIO, Temperature Sensor and ADC functionalities */
    175            IOE_FnctCmd(IOE_2_ADDR, IOE_IO_FCT | IOE_TEMPSENS_FCT | IOE_ADC_FCT, ENABLE);
   \   0000007A   0122               MOVS     R2,#+1
   \   0000007C   0D21               MOVS     R1,#+13
   \   0000007E   8820               MOVS     R0,#+136
   \   00000080   ........           BL       IOE_FnctCmd
    176            
    177            /* Configure the Audio Codec Reset pin in output mode pin*/
    178            IOE_IOPinConfig(IOE_2_ADDR, (uint32_t)(AUDIO_RESET_PIN), Direction_OUT);
   \   00000084   0122               MOVS     R2,#+1
   \   00000086   0421               MOVS     R1,#+4
   \   00000088   8820               MOVS     R0,#+136
   \   0000008A   ........           BL       IOE_IOPinConfig
    179            IOE_IOPinConfig(IOE_2_ADDR, (uint32_t)(MII_INT_PIN), Direction_IN);
   \   0000008E   0022               MOVS     R2,#+0
   \   00000090   0121               MOVS     R1,#+1
   \   00000092   8820               MOVS     R0,#+136
   \   00000094   ........           BL       IOE_IOPinConfig
    180                
    181            /* ENABLE the alternate function for IN1 pin */
    182            IOE_IOAFConfig(IOE_2_ADDR, (uint32_t)(AUDIO_RESET_PIN | MII_INT_PIN), ENABLE);
   \   00000098   0122               MOVS     R2,#+1
   \   0000009A   0521               MOVS     R1,#+5
   \   0000009C   8820               MOVS     R0,#+136
   \   0000009E   ........           BL       IOE_IOAFConfig
    183              
    184            /* Apply the default state for the out pins */
    185            IOE_WriteIOPin(AUDIO_RESET_PIN, BitReset);
   \   000000A2   0021               MOVS     R1,#+0
   \   000000A4   0420               MOVS     R0,#+4
   \   000000A6   ........           BL       IOE_WriteIOPin
    186            IOE_WriteIOPin(MII_INT_PIN, BitReset);
   \   000000AA   0021               MOVS     R1,#+0
   \   000000AC   0120               MOVS     R0,#+1
   \   000000AE   ........           BL       IOE_WriteIOPin
    187            /* Configure the Joystick pins in Input mode */
    188            IOE_IOPinConfig(IOE_2_ADDR, JOY_IO_PINS , Direction_IN); 
   \   000000B2   0022               MOVS     R2,#+0
   \   000000B4   F821               MOVS     R1,#+248
   \   000000B6   8820               MOVS     R0,#+136
   \   000000B8   ........           BL       IOE_IOPinConfig
    189            
    190            /* ENABLE the alternate function for the Joystick pins */
    191            IOE_IOAFConfig(IOE_2_ADDR, JOY_IO_PINS, ENABLE);
   \   000000BC   0122               MOVS     R2,#+1
   \   000000BE   F821               MOVS     R1,#+248
   \   000000C0   8820               MOVS     R0,#+136
   \   000000C2   ........           BL       IOE_IOAFConfig
    192            /* Configure the IOs to detect Falling and Rising Edges */
    193            IOE_IOEdgeConfig(IOE_2_ADDR, JOY_IO_PINS, (uint8_t)(EDGE_FALLING | EDGE_RISING));
   \   000000C6   0322               MOVS     R2,#+3
   \   000000C8   F821               MOVS     R1,#+248
   \   000000CA   8820               MOVS     R0,#+136
   \   000000CC   ........           BL       IOE_IOEdgeConfig
    194            
    195            /* Temperature Sensor module configuration */
    196            IOE_TempSens_Config();
   \   000000D0   ........           BL       IOE_TempSens_Config
    197            /* ------------------------------------------------------------------------ */
    198            
    199            /* Configuration is OK */
    200            return IOE_OK; 
   \   000000D4   0020               MOVS     R0,#+0
   \                     ??IOE_Config_1:
   \   000000D6   02BD               POP      {R1,PC}          ;; return
    201          }
    202          
    203          /**
    204            * @brief  Configures The selected interrupts on the IO Expanders.
    205            * @param  IOE_ITSRC_Source: the source of the interrupts. Could be one or a 
    206            *         combination of the following parameters:
    207            *   @arg  IOE_ITSRC_JOYSTICK: Joystick IO intputs.
    208            *   @arg  IOE_ITSRC_TSC: Touch Screen interrupts.
    209            *   @arg  IOE_ITSRC_INMEMS: MEMS interrupt lines.
    210            * @retval IOE_OK: if all initializations are OK. Other value if error.
    211            */

   \                                 In section .text, align 2, keep-with-next
    212          uint8_t IOE_ITConfig(uint32_t IOE_ITSRC_Source)
    213          {   
   \                     IOE_ITConfig:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    214            /* Configure the Interrupt output pin to generate low level (INT_CTRL) */
    215            IOE_ITOutConfig(Polarity_High, Type_Level);  
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   0420               MOVS     R0,#+4
   \   00000008   ........           BL       IOE_ITOutConfig
    216            
    217            /* Manage the Joystick Interrupts */  
    218            if (IOE_ITSRC_Source & IOE_ITSRC_JOYSTICK)
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   4007               LSLS     R0,R0,#+29
   \   00000010   1AD5               BPL.N    ??IOE_ITConfig_0
    219            {   
    220              /* Enable the Global interrupt */  
    221              IOE_GITCmd(IOE_2_ADDR, ENABLE);     
   \   00000012   0121               MOVS     R1,#+1
   \   00000014   8820               MOVS     R0,#+136
   \   00000016   ........           BL       IOE_GITCmd
    222                  
    223              /* Enable the Joystick pins to generate interrupt (GPIO_INT_EN) */
    224              IOE_IOITConfig(IOE_2_ADDR, IOE_JOY_IT, ENABLE);   
   \   0000001A   0122               MOVS     R2,#+1
   \   0000001C   F821               MOVS     R1,#+248
   \   0000001E   8820               MOVS     R0,#+136
   \   00000020   ........           BL       IOE_IOITConfig
    225              
    226              /* Enable the Global GPIO Interrupt */
    227              IOE_GITConfig(IOE_2_ADDR, IOE_GIT_GPIO, ENABLE);    
   \   00000024   0122               MOVS     R2,#+1
   \   00000026   8021               MOVS     R1,#+128
   \   00000028   8820               MOVS     R0,#+136
   \   0000002A   ........           BL       IOE_GITConfig
    228              
    229              /* Read the GPIO_IT_STA to clear all pending bits if any */
    230              I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_GPIO_INT_STA);    
   \   0000002E   0D21               MOVS     R1,#+13
   \   00000030   8820               MOVS     R0,#+136
   \   00000032   ........           BL       I2C_ReadDeviceRegister
    231              
    232              /* Enable the Joystick pins to generate interrupt */
    233              IOE_IOITConfig(IOE_2_ADDR, IOE_JOY_IT, ENABLE);  
   \   00000036   0122               MOVS     R2,#+1
   \   00000038   F821               MOVS     R1,#+248
   \   0000003A   8820               MOVS     R0,#+136
   \   0000003C   ........           BL       IOE_IOITConfig
    234              
    235              /* Read the GPIO_IT_STA to clear all pending bits if any */
    236              I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_GPIO_INT_STA);     
   \   00000040   0D21               MOVS     R1,#+13
   \   00000042   8820               MOVS     R0,#+136
   \   00000044   ........           BL       I2C_ReadDeviceRegister
    237            }
    238          
    239            /* Manage the MEMS Interrupts lines  */  
    240            if (IOE_ITSRC_Source & IOE_ITSRC_INMEMS)
   \                     ??IOE_ITConfig_0:
   \   00000048   2000               MOVS     R0,R4
   \   0000004A   8007               LSLS     R0,R0,#+30
   \   0000004C   1AD5               BPL.N    ??IOE_ITConfig_1
    241            {   
    242              /* Enable the Global interrupt */  
    243              IOE_GITCmd(IOE_1_ADDR, ENABLE);     
   \   0000004E   0121               MOVS     R1,#+1
   \   00000050   8220               MOVS     R0,#+130
   \   00000052   ........           BL       IOE_GITCmd
    244                  
    245              /* Enable the pins to generate interrupt (GPIO_INT_EN) */
    246              IOE_IOITConfig(IOE_1_ADDR, IOE_INMEMS_IT, ENABLE);   
   \   00000056   0122               MOVS     R2,#+1
   \   00000058   0C21               MOVS     R1,#+12
   \   0000005A   8220               MOVS     R0,#+130
   \   0000005C   ........           BL       IOE_IOITConfig
    247              
    248              /* Enable the Global GPIO Interrupt */
    249              IOE_GITConfig(IOE_1_ADDR, IOE_GIT_GPIO, ENABLE);    
   \   00000060   0122               MOVS     R2,#+1
   \   00000062   8021               MOVS     R1,#+128
   \   00000064   8220               MOVS     R0,#+130
   \   00000066   ........           BL       IOE_GITConfig
    250              
    251              /* Read the GPIO_IT_STA to clear all pending bits if any */
    252              I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_GPIO_INT_STA);    
   \   0000006A   0D21               MOVS     R1,#+13
   \   0000006C   8220               MOVS     R0,#+130
   \   0000006E   ........           BL       I2C_ReadDeviceRegister
    253              
    254              /* Enable the pins to generate interrupt */
    255              IOE_IOITConfig(IOE_1_ADDR, IOE_INMEMS_IT, ENABLE);  
   \   00000072   0122               MOVS     R2,#+1
   \   00000074   0C21               MOVS     R1,#+12
   \   00000076   8220               MOVS     R0,#+130
   \   00000078   ........           BL       IOE_IOITConfig
    256              
    257              /* Read the GPIO_IT_STA to clear all pending bits if any */
    258              I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_GPIO_INT_STA);     
   \   0000007C   0D21               MOVS     R1,#+13
   \   0000007E   8220               MOVS     R0,#+130
   \   00000080   ........           BL       I2C_ReadDeviceRegister
    259            }  
    260            
    261            /* Manage the Touch Screen Interrupts */  
    262            if (IOE_ITSRC_Source & IOE_ITSRC_TSC)
   \                     ??IOE_ITConfig_1:
   \   00000084   E007               LSLS     R0,R4,#+31
   \   00000086   0CD5               BPL.N    ??IOE_ITConfig_2
    263            {   
    264              /* Enable the Global interrupt */  
    265              IOE_GITCmd(IOE_1_ADDR, ENABLE);     
   \   00000088   0121               MOVS     R1,#+1
   \   0000008A   8220               MOVS     R0,#+130
   \   0000008C   ........           BL       IOE_GITCmd
    266                     
    267              /* Enable the Global GPIO Interrupt */
    268              IOE_GITConfig(IOE_1_ADDR, (uint8_t)(IOE_GIT_TOUCH | IOE_GIT_FTH | IOE_GIT_FOV), ENABLE);    
   \   00000090   0122               MOVS     R2,#+1
   \   00000092   0721               MOVS     R1,#+7
   \   00000094   8220               MOVS     R0,#+130
   \   00000096   ........           BL       IOE_GITConfig
    269              
    270              /* Read the GPIO_IT_STA to clear all pending bits if any */
    271              I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_GPIO_INT_STA); 
   \   0000009A   0D21               MOVS     R1,#+13
   \   0000009C   8220               MOVS     R0,#+130
   \   0000009E   ........           BL       I2C_ReadDeviceRegister
    272            }
    273            
    274            /* Configure the Interrupt line as EXTI source */
    275            IOE_EXTI_Config();    
   \                     ??IOE_ITConfig_2:
   \   000000A2   ........           BL       IOE_EXTI_Config
    276            
    277            /* If all OK return IOE_OK */
    278            return IOE_OK;
   \   000000A6   0020               MOVS     R0,#+0
   \   000000A8   10BD               POP      {R4,PC}          ;; return
    279          }
    280          
    281          /**
    282            * @brief  Writes a bit value to an output IO pin.
    283            * @param IO_Pin: The output pin to be set or reset. This parameter can be one 
    284            *        of the following values:
    285            *   @arg  AUDIO_RESET_PIN: Audio codec reset pin
    286            *   @arg  MII_INT_PIN: Ethernet Phy MII interrupt pin
    287            *   @arg  VBAT_DIV_PIN: Battery devider pin
    288            * @param BitVal: The value to be set. This parameter can be one of the
    289            *        following values: BitSet or BitReset. See IOE_BitVal_TypeDef.
    290            * @retval IOE_OK or PARAM_ERROR
    291            */

   \                                 In section .text, align 2, keep-with-next
    292          uint8_t IOE_WriteIOPin(uint8_t IO_Pin, IOE_BitValue_TypeDef BitVal)
    293          {
   \                     IOE_WriteIOPin:
   \   00000000   80B5               PUSH     {R7,LR}
    294            uint8_t DeviceAddr = 0;
   \   00000002   0023               MOVS     R3,#+0
    295            
    296            /* Get the IO expander Address according to which pin is to be controlled */
    297            if (IO_Pin & IO1_OUT_ALL_PINS)
   \   00000004   C207               LSLS     R2,R0,#+31
   \   00000006   0BD5               BPL.N    ??IOE_WriteIOPin_0
    298            {
    299              DeviceAddr = IOE_1_ADDR;
   \   00000008   8223               MOVS     R3,#+130
    300            }
    301            else if (IO_Pin & IO2_OUT_ALL_PINS)
    302            {
    303              DeviceAddr = IOE_2_ADDR;
    304            }
    305            else
    306            {
    307              return PARAM_ERROR;
    308            }
    309            
    310            /* Apply the bit value to the selected pin */
    311            if (BitVal == BitReset)
   \                     ??IOE_WriteIOPin_1:
   \   0000000A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0029               CMP      R1,#+0
   \   0000000E   0ED1               BNE.N    ??IOE_WriteIOPin_2
    312            {
    313              /* Set the register */
    314              I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_CLR_PIN, IO_Pin);
   \   00000010   0200               MOVS     R2,R0
   \   00000012   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000014   1121               MOVS     R1,#+17
   \   00000016   1800               MOVS     R0,R3
   \   00000018   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   ........           BL       I2C_WriteDeviceRegister
   \   0000001E   0DE0               B.N      ??IOE_WriteIOPin_3
    315            }
   \                     ??IOE_WriteIOPin_0:
   \   00000020   0522               MOVS     R2,#+5
   \   00000022   1042               TST      R0,R2
   \   00000024   01D0               BEQ.N    ??IOE_WriteIOPin_4
   \   00000026   8823               MOVS     R3,#+136
   \   00000028   EFE7               B.N      ??IOE_WriteIOPin_1
   \                     ??IOE_WriteIOPin_4:
   \   0000002A   0320               MOVS     R0,#+3
   \   0000002C   07E0               B.N      ??IOE_WriteIOPin_5
    316            else
    317            {
    318              /* Set the register */
    319              I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_SET_PIN, IO_Pin);
   \                     ??IOE_WriteIOPin_2:
   \   0000002E   0200               MOVS     R2,R0
   \   00000030   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000032   1021               MOVS     R1,#+16
   \   00000034   1800               MOVS     R0,R3
   \   00000036   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   ........           BL       I2C_WriteDeviceRegister
    320            }
    321            
    322            return IOE_OK;
   \                     ??IOE_WriteIOPin_3:
   \   0000003C   0020               MOVS     R0,#+0
   \                     ??IOE_WriteIOPin_5:
   \   0000003E   02BD               POP      {R1,PC}          ;; return
    323          }
    324          
    325          
    326          /**
    327            * @brief  Returns the status of the selected input IO pin.
    328            * @param IO_Pin: The input pin to be read. This parameter can be one 
    329            *  of the following values:
    330            *   @arg  MEMS_INT1_PIN: MEMS interrupt line 1.
    331            *   @arg  MEMS_INT2_PIN: MEMS interrupt line 2.
    332            *   @arg  JOY_IO_PINS: Joystick IO pins (use IOE_JoyStickGetState for these pins)  
    333            * @retval None
    334            */

   \                                 In section .text, align 2, keep-with-next
    335          uint8_t IOE_ReadIOPin(uint32_t IO_Pin)
    336          {
   \                     IOE_ReadIOPin:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    337            uint8_t DeviceAddr = 0;
   \   00000004   0020               MOVS     R0,#+0
    338            uint8_t tmp = 0;  
   \   00000006   0021               MOVS     R1,#+0
    339            if (IO_Pin & IO1_IN_ALL_PINS)
   \   00000008   14F00C02           ANDS     R2,R4,#0xC
   \   0000000C   002A               CMP      R2,#+0
   \   0000000E   0BD0               BEQ.N    ??IOE_ReadIOPin_0
    340            {
    341              DeviceAddr = IOE_1_ADDR;
   \   00000010   8220               MOVS     R0,#+130
    342            }
    343            else if (IO_Pin & IO2_IN_ALL_PINS)
    344            {
    345              DeviceAddr = IOE_2_ADDR;
    346            }
    347            else 
    348            {
    349              return PARAM_ERROR;
    350            }
    351            
    352            /* Get all the Pins status */
    353            tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_MP_STA);
   \                     ??IOE_ReadIOPin_1:
   \   00000012   1221               MOVS     R1,#+18
   \   00000014   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   ........           BL       I2C_ReadDeviceRegister
   \   0000001A   0100               MOVS     R1,R0
    354            if ((tmp & (uint8_t)IO_Pin) != 0)
   \   0000001C   0800               MOVS     R0,R1
   \   0000001E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   2042               TST      R0,R4
   \   00000022   09D0               BEQ.N    ??IOE_ReadIOPin_2
    355            {
    356              return BitSet;
   \   00000024   0120               MOVS     R0,#+1
   \   00000026   08E0               B.N      ??IOE_ReadIOPin_3
    357            }  
   \                     ??IOE_ReadIOPin_0:
   \   00000028   14F0F800           ANDS     R0,R4,#0xF8
   \   0000002C   0028               CMP      R0,#+0
   \   0000002E   01D0               BEQ.N    ??IOE_ReadIOPin_4
   \   00000030   8820               MOVS     R0,#+136
   \   00000032   EEE7               B.N      ??IOE_ReadIOPin_1
   \                     ??IOE_ReadIOPin_4:
   \   00000034   0320               MOVS     R0,#+3
   \   00000036   00E0               B.N      ??IOE_ReadIOPin_3
    358            else 
    359            {
    360              return BitReset;
   \                     ??IOE_ReadIOPin_2:
   \   00000038   0020               MOVS     R0,#+0
   \                     ??IOE_ReadIOPin_3:
   \   0000003A   10BD               POP      {R4,PC}          ;; return
    361            }
    362          }
    363          
    364          
    365          /**
    366            * @brief  Returns the current Joystick status.
    367            * @param  None
    368            * @retval The code of the Joystick key pressed: 
    369            *   @arg  JOY_NONE
    370            *   @arg  JOY_SEL
    371            *   @arg  JOY_DOWN
    372            *   @arg  JOY_LEFT
    373            *   @arg  JOY_RIGHT
    374            *   @arg  JOY_UP
    375            */

   \                                 In section .text, align 2, keep-with-next
    376          JOYState_TypeDef
    377           IOE_JoyStickGetState(void)
    378          {
   \                     IOE_JoyStickGetState:
   \   00000000   10B5               PUSH     {R4,LR}
    379            uint8_t tmp = 0;
   \   00000002   0024               MOVS     R4,#+0
    380            /* Read the status of all pins */
    381            tmp = (uint32_t)I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_GPIO_MP_STA);
   \   00000004   1221               MOVS     R1,#+18
   \   00000006   8820               MOVS     R0,#+136
   \   00000008   ........           BL       I2C_ReadDeviceRegister
   \   0000000C   0400               MOVS     R4,R0
    382             
    383            /* Check the pressed keys */
    384            if ((tmp & JOY_IO_NONE) == JOY_IO_NONE)
   \   0000000E   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   14F0F800           ANDS     R0,R4,#0xF8
   \   00000014   F828               CMP      R0,#+248
   \   00000016   01D1               BNE.N    ??IOE_JoyStickGetState_0
    385            {
    386              return (JOYState_TypeDef) JOY_NONE;
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   14E0               B.N      ??IOE_JoyStickGetState_1
    387            }
    388            else if (!(tmp & JOY_IO_SEL))
   \                     ??IOE_JoyStickGetState_0:
   \   0000001C   2006               LSLS     R0,R4,#+24
   \   0000001E   01D4               BMI.N    ??IOE_JoyStickGetState_2
    389            {
    390              return (JOYState_TypeDef) JOY_SEL;
   \   00000020   0120               MOVS     R0,#+1
   \   00000022   10E0               B.N      ??IOE_JoyStickGetState_1
    391            }
    392            else if (!(tmp & JOY_IO_DOWN))
   \                     ??IOE_JoyStickGetState_2:
   \   00000024   6006               LSLS     R0,R4,#+25
   \   00000026   01D4               BMI.N    ??IOE_JoyStickGetState_3
    393            {
    394              return (JOYState_TypeDef) JOY_DOWN;
   \   00000028   0220               MOVS     R0,#+2
   \   0000002A   0CE0               B.N      ??IOE_JoyStickGetState_1
    395            }
    396            else if (!(tmp & JOY_IO_LEFT))
   \                     ??IOE_JoyStickGetState_3:
   \   0000002C   A006               LSLS     R0,R4,#+26
   \   0000002E   01D4               BMI.N    ??IOE_JoyStickGetState_4
    397            {
    398              return (JOYState_TypeDef) JOY_LEFT;
   \   00000030   0320               MOVS     R0,#+3
   \   00000032   08E0               B.N      ??IOE_JoyStickGetState_1
    399            }
    400            else if (!(tmp & JOY_IO_RIGHT))
   \                     ??IOE_JoyStickGetState_4:
   \   00000034   E006               LSLS     R0,R4,#+27
   \   00000036   01D4               BMI.N    ??IOE_JoyStickGetState_5
    401            {
    402              return (JOYState_TypeDef) JOY_RIGHT;
   \   00000038   0420               MOVS     R0,#+4
   \   0000003A   04E0               B.N      ??IOE_JoyStickGetState_1
    403            }
    404            else if (!(tmp & JOY_IO_UP))
   \                     ??IOE_JoyStickGetState_5:
   \   0000003C   2007               LSLS     R0,R4,#+28
   \   0000003E   01D4               BMI.N    ??IOE_JoyStickGetState_6
    405            {
    406              return (JOYState_TypeDef) JOY_UP;
   \   00000040   0520               MOVS     R0,#+5
   \   00000042   00E0               B.N      ??IOE_JoyStickGetState_1
    407            }
    408            else
    409            { 
    410              return (JOYState_TypeDef) JOY_NONE;
   \                     ??IOE_JoyStickGetState_6:
   \   00000044   0020               MOVS     R0,#+0
   \                     ??IOE_JoyStickGetState_1:
   \   00000046   10BD               POP      {R4,PC}          ;; return
    411            }
    412          }
    413          
    414          /**
    415            * @brief  Returns Status and positions of the Touch screen.
    416            * @param  None
    417            * @retval Pointer to TS_STATE structure holding Touch Screen information.
    418            */

   \                                 In section .text, align 2, keep-with-next
    419          TS_STATE* IOE_TS_GetState(void)
    420          {
   \                     IOE_TS_GetState:
   \   00000000   10B5               PUSH     {R4,LR}
    421            uint32_t xDiff, yDiff , x , y;
    422            static uint32_t _x = 0, _y = 0;
    423            
    424            /* Check if the Touch detect event happenned */
    425            TS_State.TouchDetected = (I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_TSC_CTRL) & 0x80);
   \   00000002   4021               MOVS     R1,#+64
   \   00000004   8220               MOVS     R0,#+130
   \   00000006   ........           BL       I2C_ReadDeviceRegister
   \   0000000A   10F08000           ANDS     R0,R0,#0x80
   \   0000000E   ........           LDR.W    R1,??DataTable13
   \   00000012   0880               STRH     R0,[R1, #+0]
    426            if(TS_State.TouchDetected) 
   \   00000014   ........           LDR.W    R0,??DataTable13
   \   00000018   0088               LDRH     R0,[R0, #+0]
   \   0000001A   0028               CMP      R0,#+0
   \   0000001C   29D0               BEQ.N    ??IOE_TS_GetState_0
    427            {
    428              x = IOE_TS_Read_X();
   \   0000001E   ........           BL       IOE_TS_Read_X
   \   00000022   0400               MOVS     R4,R0
    429              y = IOE_TS_Read_Y();
   \   00000024   ........           BL       IOE_TS_Read_Y
    430              xDiff = x > _x? (x - _x): (_x - x);
   \   00000028   ........           LDR.W    R1,??DataTable13_1
   \   0000002C   0968               LDR      R1,[R1, #+0]
   \   0000002E   A142               CMP      R1,R4
   \   00000030   04D2               BCS.N    ??IOE_TS_GetState_1
   \   00000032   ........           LDR.W    R1,??DataTable13_1
   \   00000036   0968               LDR      R1,[R1, #+0]
   \   00000038   611A               SUBS     R1,R4,R1
   \   0000003A   03E0               B.N      ??IOE_TS_GetState_2
   \                     ??IOE_TS_GetState_1:
   \   0000003C   ........           LDR.W    R1,??DataTable13_1
   \   00000040   0968               LDR      R1,[R1, #+0]
   \   00000042   091B               SUBS     R1,R1,R4
    431              yDiff = y > _y? (y - _y): (_y - y);       
   \                     ??IOE_TS_GetState_2:
   \   00000044   ........           LDR.W    R2,??DataTable13_2
   \   00000048   1268               LDR      R2,[R2, #+0]
   \   0000004A   8242               CMP      R2,R0
   \   0000004C   04D2               BCS.N    ??IOE_TS_GetState_3
   \   0000004E   ........           LDR.W    R2,??DataTable13_2
   \   00000052   1268               LDR      R2,[R2, #+0]
   \   00000054   821A               SUBS     R2,R0,R2
   \   00000056   03E0               B.N      ??IOE_TS_GetState_4
   \                     ??IOE_TS_GetState_3:
   \   00000058   ........           LDR.W    R2,??DataTable13_2
   \   0000005C   1268               LDR      R2,[R2, #+0]
   \   0000005E   121A               SUBS     R2,R2,R0
    432              if (xDiff + yDiff > 5)
   \                     ??IOE_TS_GetState_4:
   \   00000060   5118               ADDS     R1,R2,R1
   \   00000062   0629               CMP      R1,#+6
   \   00000064   05D3               BCC.N    ??IOE_TS_GetState_0
    433              {
    434                _x = x;
   \   00000066   ........           LDR.W    R1,??DataTable13_1
   \   0000006A   0C60               STR      R4,[R1, #+0]
    435                _y = y;       
   \   0000006C   ........           LDR.W    R1,??DataTable13_2
   \   00000070   0860               STR      R0,[R1, #+0]
    436              }
    437            }  
    438            /* Update the X position */
    439            TS_State.X = _x;
   \                     ??IOE_TS_GetState_0:
   \   00000072   ........           LDR.W    R0,??DataTable13
   \   00000076   ........           LDR.W    R1,??DataTable13_1
   \   0000007A   0968               LDR      R1,[R1, #+0]
   \   0000007C   4180               STRH     R1,[R0, #+2]
    440              
    441            /* Update the Y position */  
    442            TS_State.Y = _y;
   \   0000007E   ........           LDR.W    R0,??DataTable13
   \   00000082   ........           LDR.W    R1,??DataTable13_2
   \   00000086   0968               LDR      R1,[R1, #+0]
   \   00000088   8180               STRH     R1,[R0, #+4]
    443            /* Update the Z Pression index */  
    444            TS_State.Z = IOE_TS_Read_Z();  
   \   0000008A   ........           BL       IOE_TS_Read_Z
   \   0000008E   ........           LDR.W    R1,??DataTable13
   \   00000092   C880               STRH     R0,[R1, #+6]
    445            
    446            /* Clear the interrupt pending bit and enable the FIFO again */
    447            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_FIFO_STA, 0x01);
   \   00000094   0122               MOVS     R2,#+1
   \   00000096   4B21               MOVS     R1,#+75
   \   00000098   8220               MOVS     R0,#+130
   \   0000009A   ........           BL       I2C_WriteDeviceRegister
    448            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_FIFO_STA, 0x00);
   \   0000009E   0022               MOVS     R2,#+0
   \   000000A0   4B21               MOVS     R1,#+75
   \   000000A2   8220               MOVS     R0,#+130
   \   000000A4   ........           BL       I2C_WriteDeviceRegister
    449            
    450            /* Return pointer to the updated structure */
    451            return &TS_State; 
   \   000000A8   ........           LDR.W    R0,??DataTable13
   \   000000AC   10BD               POP      {R4,PC}          ;; return
    452          }

   \                                 In section .bss, align 4
   \                     ??_x:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     ??_y:
   \   00000000                      DS8 4
    453          
    454          /**
    455            * @brief  Returns the temperature row value (in 16 bit format).
    456            * @param  None
    457            * @retval The temperature row value.
    458            */

   \                                 In section .text, align 2, keep-with-next
    459          uint32_t IOE_TempSens_GetData(void)
    460          {  
   \                     IOE_TempSens_GetData:
   \   00000000   80B5               PUSH     {R7,LR}
    461            static __IO uint32_t tmp = 0;  
    462              
    463            /* Aquire data enable */
    464            I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_TEMP_CTRL, 0x03);
   \   00000002   0322               MOVS     R2,#+3
   \   00000004   6021               MOVS     R1,#+96
   \   00000006   8820               MOVS     R0,#+136
   \   00000008   ........           BL       I2C_WriteDeviceRegister
    465            
    466            /* Enable the TEMPSENS module */
    467            tmp = (uint32_t)((I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_TEMP_DATA) & 0x03) << 8); 
   \   0000000C   6121               MOVS     R1,#+97
   \   0000000E   8820               MOVS     R0,#+136
   \   00000010   ........           BL       I2C_ReadDeviceRegister
   \   00000014   10F00300           ANDS     R0,R0,#0x3
   \   00000018   0002               LSLS     R0,R0,#+8
   \   0000001A   ........           LDR.W    R1,??DataTable13_3
   \   0000001E   0860               STR      R0,[R1, #+0]
    468            tmp |= (uint32_t)I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_TEMP_DATA + 1); 
   \   00000020   6221               MOVS     R1,#+98
   \   00000022   8820               MOVS     R0,#+136
   \   00000024   ........           BL       I2C_ReadDeviceRegister
   \   00000028   ........           LDR.W    R1,??DataTable13_3
   \   0000002C   0968               LDR      R1,[R1, #+0]
   \   0000002E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0843               ORRS     R0,R0,R1
   \   00000032   ........           LDR.W    R1,??DataTable13_3
   \   00000036   0860               STR      R0,[R1, #+0]
    469            
    470            tmp = (uint32_t)((33 * tmp * 100) / 751);
   \   00000038   ........           LDR.W    R0,??DataTable13_3
   \   0000003C   0068               LDR      R0,[R0, #+0]
   \   0000003E   40F6E441           MOVW     R1,#+3300
   \   00000042   4843               MULS     R0,R1,R0
   \   00000044   40F2EF21           MOVW     R1,#+751
   \   00000048   B0FBF1F0           UDIV     R0,R0,R1
   \   0000004C   ........           LDR.W    R1,??DataTable13_3
   \   00000050   0860               STR      R0,[R1, #+0]
    471            tmp = (uint32_t)((tmp + 5) / 10);
   \   00000052   ........           LDR.W    R0,??DataTable13_3
   \   00000056   0068               LDR      R0,[R0, #+0]
   \   00000058   401D               ADDS     R0,R0,#+5
   \   0000005A   0A21               MOVS     R1,#+10
   \   0000005C   B0FBF1F0           UDIV     R0,R0,R1
   \   00000060   ........           LDR.W    R1,??DataTable13_3
   \   00000064   0860               STR      R0,[R1, #+0]
    472            
    473            /* return the temprature row value */
    474            return tmp;
   \   00000066   ........           LDR.W    R0,??DataTable13_3
   \   0000006A   0068               LDR      R0,[R0, #+0]
   \   0000006C   02BD               POP      {R1,PC}          ;; return
    475          }

   \                                 In section .bss, align 4
   \                     ??tmp:
   \   00000000                      DS8 4
    476          
    477          /**
    478            * @brief  Checks the selected Global interrupt source pending bit
    479            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    480            *         or IOE_2_ADDR.
    481            * @param  Global_IT: the Global interrupt source to be checked, could be:
    482            *   @arg  Global_IT_GPIO : All IOs interrupt
    483            *   @arg  Global_IT_ADC : ADC interrupt
    484            *   @arg  Global_IT_TEMP : Temperature Sensor interrupts      
    485            *   @arg  Global_IT_FE : Touch Screen Controller FIFO Error interrupt
    486            *   @arg  Global_IT_FF : Touch Screen Controller FIFO Full interrupt      
    487            *   @arg  Global_IT_FOV : Touch Screen Controller FIFO Overrun interrupt     
    488            *   @arg  Global_IT_FTH : Touch Screen Controller FIFO Threshold interrupt   
    489            *   @arg  Global_IT_TOUCH : Touch Screen Controller Touch Detected interrupt      
    490            * @retval Status of the checked flag. Could be SET or RESET.
    491            */

   \                                 In section .text, align 2, keep-with-next
    492          FlagStatus IOE_GetGITStatus(uint8_t DeviceAddr, uint8_t Global_IT)
    493          {
   \                     IOE_GetGITStatus:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   \   00000004   0C00               MOVS     R4,R1
    494            __IO uint8_t tmp = 0;
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   8DF80010           STRB     R1,[SP, #+0]
    495           
    496            /* get the Interrupt status */
    497            tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_INT_STA);
   \   0000000C   0B21               MOVS     R1,#+11
   \   0000000E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   ........           BL       I2C_ReadDeviceRegister
   \   00000014   8DF80000           STRB     R0,[SP, #+0]
    498            
    499            if ((tmp & (uint8_t)Global_IT) != 0)
   \   00000018   9DF80000           LDRB     R0,[SP, #+0]
   \   0000001C   2042               TST      R0,R4
   \   0000001E   01D0               BEQ.N    ??IOE_GetGITStatus_0
    500            {
    501              return SET;
   \   00000020   0120               MOVS     R0,#+1
   \   00000022   00E0               B.N      ??IOE_GetGITStatus_1
    502            }
    503            else
    504            {
    505              return RESET;
   \                     ??IOE_GetGITStatus_0:
   \   00000024   0020               MOVS     R0,#+0
   \                     ??IOE_GetGITStatus_1:
   \   00000026   16BD               POP      {R1,R2,R4,PC}    ;; return
    506            }
    507          }
    508          
    509          /**
    510            * @brief  Clears the selected Global interrupt pending bit(s)
    511            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    512            *         or IOE_2_ADDR.
    513            * @param  Global_IT: the Global interrupt to be cleared, could be any combination
    514            *         of the following values:   
    515            *   @arg  Global_IT_GPIO : All IOs interrupt
    516            *   @arg  Global_IT_ADC : ADC interrupt
    517            *   @arg  Global_IT_TEMP : Temperature Sensor interrupts      
    518            *   @arg  Global_IT_FE : Touch Screen Controller FIFO Error interrupt
    519            *   @arg  Global_IT_FF : Touch Screen Controller FIFO Full interrupt      
    520            *   @arg  Global_IT_FOV : Touch Screen Controller FIFO Overrun interrupt     
    521            *   @arg  Global_IT_FTH : Touch Screen Controller FIFO Threshold interrupt   
    522            *   @arg  Global_IT_TOUCH : Touch Screen Controller Touch Detected interrupt 
    523            * @retval IOE_OK: if all initializations are OK. Other value if error.
    524            */

   \                                 In section .text, align 2, keep-with-next
    525          uint8_t IOE_ClearGITPending(uint8_t DeviceAddr, uint8_t Global_IT)
    526          {
   \                     IOE_ClearGITPending:
   \   00000000   80B5               PUSH     {R7,LR}
    527            /* Write 1 to the bits that have to be cleared */
    528            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_INT_STA, Global_IT); 
   \   00000002   0A00               MOVS     R2,R1
   \   00000004   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000006   0B21               MOVS     R1,#+11
   \   00000008   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   ........           BL       I2C_WriteDeviceRegister
    529          
    530            /* If all OK return IOE_OK */
    531            return IOE_OK;
   \   0000000E   0020               MOVS     R0,#+0
   \   00000010   02BD               POP      {R1,PC}          ;; return
    532          }
    533          
    534          /**
    535            * @brief  Checks the status of the selected IO interrupt pending bit
    536            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    537            *         or IOE_2_ADDR.
    538            * @param  IO_IT: the IO interrupt to be checked could be IO_ITx Where x can be 
    539            *         from 0 to 7.             
    540            * @retval Status of the checked flag. Could be SET or RESET.
    541            */

   \                                 In section .text, align 2, keep-with-next
    542          FlagStatus IOE_GetIOITStatus(uint8_t DeviceAddr, uint8_t IO_IT)
    543          {
   \                     IOE_GetIOITStatus:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0C00               MOVS     R4,R1
    544            uint8_t tmp = 0;
   \   00000004   0025               MOVS     R5,#+0
    545           
    546            /* get the Interrupt status */
    547            tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_INT_STA);
   \   00000006   0D21               MOVS     R1,#+13
   \   00000008   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   ........           BL       I2C_ReadDeviceRegister
   \   0000000E   0500               MOVS     R5,R0
    548            
    549            if ((tmp & (uint8_t)IO_IT) != 0)
   \   00000010   2800               MOVS     R0,R5
   \   00000012   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   2042               TST      R0,R4
   \   00000016   01D0               BEQ.N    ??IOE_GetIOITStatus_0
    550            {
    551              return SET;
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   00E0               B.N      ??IOE_GetIOITStatus_1
    552            }
    553            else
    554            {
    555              return RESET;
   \                     ??IOE_GetIOITStatus_0:
   \   0000001C   0020               MOVS     R0,#+0
   \                     ??IOE_GetIOITStatus_1:
   \   0000001E   32BD               POP      {R1,R4,R5,PC}    ;; return
    556            }
    557          }
    558          
    559          /**
    560            * @brief  Clears the selected IO interrupt pending bit(s).
    561            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    562            *         or IOE_2_ADDR.
    563            * @param  IO_IT: the IO interrupt to be checked could be IO_ITx Where x can be 
    564            *         from 0 to 7.              
    565            * @retval IOE_OK: if all initializations are OK. Other value if error.
    566            */

   \                                 In section .text, align 2, keep-with-next
    567          uint8_t IOE_ClearIOITPending(uint8_t DeviceAddr, uint8_t IO_IT)
    568          {
   \                     IOE_ClearIOITPending:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0C00               MOVS     R4,R1
    569            /* Write 1 to the bits that have to be cleared */
    570            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_INT_STA, IO_IT);  
   \   00000004   2200               MOVS     R2,R4
   \   00000006   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0D21               MOVS     R1,#+13
   \   0000000A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   ........           BL       I2C_WriteDeviceRegister
    571          
    572            /* Clear the Edge detection pending bit*/
    573            I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_GPIO_ED, IO_IT);
   \   00000010   2200               MOVS     R2,R4
   \   00000012   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000014   1421               MOVS     R1,#+20
   \   00000016   8820               MOVS     R0,#+136
   \   00000018   ........           BL       I2C_WriteDeviceRegister
    574          
    575            /* Clear the Rising edge pending bit */
    576            I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_GPIO_RE, IO_IT);
   \   0000001C   2200               MOVS     R2,R4
   \   0000001E   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000020   1521               MOVS     R1,#+21
   \   00000022   8820               MOVS     R0,#+136
   \   00000024   ........           BL       I2C_WriteDeviceRegister
    577          
    578            /* Clear the Falling edge pending bit */
    579            I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_GPIO_FE, IO_IT);  
   \   00000028   2200               MOVS     R2,R4
   \   0000002A   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002C   1621               MOVS     R1,#+22
   \   0000002E   8820               MOVS     R0,#+136
   \   00000030   ........           BL       I2C_WriteDeviceRegister
    580          
    581            /* If all OK return IOE_OK */
    582            return IOE_OK;
   \   00000034   0020               MOVS     R0,#+0
   \   00000036   10BD               POP      {R4,PC}          ;; return
    583          }
    584          
    585          /**
    586            * @brief  Checks if the selected device is correctly configured and 
    587            *         communicates correctly ont the I2C bus.
    588            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    589            *         or IOE_2_ADDR.
    590            * @retval IOE_OK if IOE is operational. Other value if failure.
    591            */

   \                                 In section .text, align 2, keep-with-next
    592          uint8_t IOE_IsOperational(uint8_t DeviceAddr)
    593          {
   \                     IOE_IsOperational:
   \   00000000   80B5               PUSH     {R7,LR}
    594            /* Return Error if the ID is not correct */
    595            if( IOE_ReadID(DeviceAddr) != (uint16_t)STMPE811_ID )
   \   00000002   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   ........           BL       IOE_ReadID
   \   00000008   40F61101           MOVW     R1,#+2065
   \   0000000C   8842               CMP      R0,R1
   \   0000000E   08D0               BEQ.N    ??IOE_IsOperational_0
    596            {
    597              /* Check if a Timeout occured */
    598              if (IOE_TimeOut == 0)
   \   00000010   ........           LDR.W    R0,??DataTable13_4
   \   00000014   0068               LDR      R0,[R0, #+0]
   \   00000016   0028               CMP      R0,#+0
   \   00000018   01D1               BNE.N    ??IOE_IsOperational_1
    599              {
    600                return(IOE_TimeoutUserCallback());
   \   0000001A   0220               MOVS     R0,#+2
   \   0000001C   02E0               B.N      ??IOE_IsOperational_2
    601              }
    602              else
    603              {
    604                return IOE_FAILURE; /* ID is not Correct */
   \                     ??IOE_IsOperational_1:
   \   0000001E   0120               MOVS     R0,#+1
   \   00000020   00E0               B.N      ??IOE_IsOperational_2
    605              }
    606            } 
    607            else 
    608            {
    609              return IOE_OK; /* ID is correct */
   \                     ??IOE_IsOperational_0:
   \   00000022   0020               MOVS     R0,#+0
   \                     ??IOE_IsOperational_2:
   \   00000024   02BD               POP      {R1,PC}          ;; return
    610            }
    611          }
    612          
    613          /**
    614            * @brief  Resets the IO Expander by Software (SYS_CTRL1, RESET bit).
    615            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    616            *         or IOE_2_ADDR.
    617            * @retval IOE_OK: if all initializations are OK. Other value if error.
    618            */

   \                                 In section .text, align 2, keep-with-next
    619          uint8_t IOE_Reset(uint8_t DeviceAddr)
    620          {
   \                     IOE_Reset:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    621            /* Power Down the IO_Expander */
    622            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_SYS_CTRL1, 0x02);
   \   00000004   0222               MOVS     R2,#+2
   \   00000006   0321               MOVS     R1,#+3
   \   00000008   2000               MOVS     R0,R4
   \   0000000A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   ........           BL       I2C_WriteDeviceRegister
    623          
    624            /* wait for a delay to insure registers erasing */
    625            _delay_(2); 
   \   00000010   0220               MOVS     R0,#+2
   \   00000012   ........           BL       delay
    626            
    627            /* Power On the Codec after the power off => all registers are reinitialized*/
    628            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_SYS_CTRL1, 0x00);
   \   00000016   0022               MOVS     R2,#+0
   \   00000018   0321               MOVS     R1,#+3
   \   0000001A   2000               MOVS     R0,R4
   \   0000001C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   ........           BL       I2C_WriteDeviceRegister
    629            
    630            /* If all OK return IOE_OK */
    631            return IOE_OK;    
   \   00000022   0020               MOVS     R0,#+0
   \   00000024   10BD               POP      {R4,PC}          ;; return
    632          }
    633          
    634          /**
    635            * @brief  Reads the selected device's ID.
    636            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    637            *         or IOE_2_ADDR.
    638            * @retval The Device ID (two bytes).
    639            */

   \                                 In section .text, align 2, keep-with-next
    640          uint16_t IOE_ReadID(uint8_t DeviceAddr)
    641          {
   \                     IOE_ReadID:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
    642            uint16_t tmp = 0;
   \   00000004   0025               MOVS     R5,#+0
    643          
    644            /* Read device ID  */
    645            tmp = I2C_ReadDeviceRegister(DeviceAddr, 0);
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   2000               MOVS     R0,R4
   \   0000000A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   ........           BL       I2C_ReadDeviceRegister
   \   00000010   0500               MOVS     R5,R0
    646            tmp = (uint32_t)(tmp << 8);
   \   00000012   2D02               LSLS     R5,R5,#+8
    647            tmp |= (uint32_t)I2C_ReadDeviceRegister(DeviceAddr, 1);
   \   00000014   0121               MOVS     R1,#+1
   \   00000016   2000               MOVS     R0,R4
   \   00000018   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   ........           BL       I2C_ReadDeviceRegister
   \   0000001E   0543               ORRS     R5,R0,R5
    648            
    649            /* Return the ID */
    650            return (uint16_t)tmp;
   \   00000020   2800               MOVS     R0,R5
   \   00000022   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   32BD               POP      {R1,R4,R5,PC}    ;; return
    651          }
    652          
    653          /**
    654            * @brief  Configures the selcted IO Expander functionalities.
    655            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    656            *         or IOE_2_ADDR.
    657            * @param  IOE_TEMPSENS_FCT: the functions to be configured. could be any 
    658            *         combination of the following values:
    659            *   @arg  IOE_IO_FCT : IO function
    660            *   @arg  IOE_TS_FCT : Touch Screen function
    661            *   @arg  IOE_ADC_FCT : ADC function
    662            *   @arg  IOE_TEMPSENS_FCT : Tempreature Sensor function
    663            * @retval IOE_OK: if all initializations are OK. Other value if error.
    664            */

   \                                 In section .text, align 2, keep-with-next
    665          uint8_t IOE_FnctCmd(uint8_t DeviceAddr, uint8_t Fct, FunctionalState NewState)
    666          {
   \                     IOE_FnctCmd:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    667            uint8_t tmp = 0;
   \   00000008   0027               MOVS     R7,#+0
    668            
    669            /* Get the register value */
    670            tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_SYS_CTRL2);
   \   0000000A   0421               MOVS     R1,#+4
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   ........           BL       I2C_ReadDeviceRegister
   \   00000014   0700               MOVS     R7,R0
    671            
    672            if (NewState != DISABLE)
   \   00000016   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   002E               CMP      R6,#+0
   \   0000001A   01D0               BEQ.N    ??IOE_FnctCmd_0
    673            {
    674              /* Set the Functionalities to be Enabled */    
    675              tmp &= ~(uint8_t)Fct;
   \   0000001C   AF43               BICS     R7,R7,R5
   \   0000001E   00E0               B.N      ??IOE_FnctCmd_1
    676            }
    677            else
    678            {
    679              /* Set the Functionalities to be Disabled */    
    680              tmp |= (uint8_t)Fct;  
   \                     ??IOE_FnctCmd_0:
   \   00000020   2F43               ORRS     R7,R5,R7
    681            }
    682            
    683            /* Set the register value */
    684            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_SYS_CTRL2, tmp);
   \                     ??IOE_FnctCmd_1:
   \   00000022   3A00               MOVS     R2,R7
   \   00000024   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000026   0421               MOVS     R1,#+4
   \   00000028   2000               MOVS     R0,R4
   \   0000002A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   ........           BL       I2C_WriteDeviceRegister
    685            
    686            /* If all OK return IOE_OK */
    687            return IOE_OK;    
   \   00000030   0020               MOVS     R0,#+0
   \   00000032   F2BD               POP      {R1,R4-R7,PC}    ;; return
    688          }
    689          
    690          /**
    691            * @brief  Configures the selected pin direction (to be an input or an output)
    692            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    693            *         or IOE_2_ADDR.
    694            * @param  IO_Pin: IO_Pin_x: Where x can be from 0 to 7.   
    695            * @param  Direction: could be Direction_IN or Direction_OUT.      
    696            * @retval IOE_OK: if all initializations are OK. Other value if error.
    697            */

   \                                 In section .text, align 2, keep-with-next
    698          uint8_t IOE_IOPinConfig(uint8_t DeviceAddr, uint8_t IO_Pin, uint8_t Direction)
    699          {
   \                     IOE_IOPinConfig:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    700            uint8_t tmp = 0;   
   \   00000008   0027               MOVS     R7,#+0
    701            
    702            /* Get all the Pins direction */
    703            tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_DIR);
   \   0000000A   1321               MOVS     R1,#+19
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   ........           BL       I2C_ReadDeviceRegister
   \   00000014   0700               MOVS     R7,R0
    704            
    705            if (Direction != Direction_IN)
   \   00000016   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   002E               CMP      R6,#+0
   \   0000001A   01D0               BEQ.N    ??IOE_IOPinConfig_0
    706            {
    707              tmp |= (uint8_t)IO_Pin;
   \   0000001C   2F43               ORRS     R7,R5,R7
   \   0000001E   00E0               B.N      ??IOE_IOPinConfig_1
    708            }  
    709            else 
    710            {
    711              tmp &= ~(uint8_t)IO_Pin;
   \                     ??IOE_IOPinConfig_0:
   \   00000020   AF43               BICS     R7,R7,R5
    712            }
    713            
    714            /* Write the register new value */
    715            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_DIR, tmp);
   \                     ??IOE_IOPinConfig_1:
   \   00000022   3A00               MOVS     R2,R7
   \   00000024   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000026   1321               MOVS     R1,#+19
   \   00000028   2000               MOVS     R0,R4
   \   0000002A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   ........           BL       I2C_WriteDeviceRegister
    716            
    717            /* If all OK return IOE_OK */
    718            return IOE_OK;      
   \   00000030   0020               MOVS     R0,#+0
   \   00000032   F2BD               POP      {R1,R4-R7,PC}    ;; return
    719          }
    720          
    721          /**
    722            * @brief  Enables or disables the Global interrupt.
    723            * @param  DeviceAddr: The address of the IOExpander, could be :I OE_1_ADDR
    724            *         or IOE_2_ADDR.
    725            * @param  NewState: could be ENABLE or DISABLE.        
    726            * @retval IOE_OK: if all initializations are OK. Other value if error.
    727            */

   \                                 In section .text, align 2, keep-with-next
    728          uint8_t IOE_GITCmd(uint8_t DeviceAddr, FunctionalState NewState)
    729          {
   \                     IOE_GITCmd:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    730            uint8_t tmp = 0;
   \   00000006   0026               MOVS     R6,#+0
    731            
    732            /* Read the Interrupt Control register  */
    733            I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_INT_CTRL);
   \   00000008   0921               MOVS     R1,#+9
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   ........           BL       I2C_ReadDeviceRegister
    734            
    735            if (NewState != DISABLE)
   \   00000012   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   002D               CMP      R5,#+0
   \   00000016   02D0               BEQ.N    ??IOE_GITCmd_0
    736            {
    737              /* Set the global interrupts to be Enabled */    
    738              tmp |= (uint8_t)IOE_GIT_EN;
   \   00000018   56F00106           ORRS     R6,R6,#0x1
   \   0000001C   01E0               B.N      ??IOE_GITCmd_1
    739            }
    740            else
    741            {
    742              /* Set the global interrupts to be Disabled */    
    743              tmp &= ~(uint8_t)IOE_GIT_EN;
   \                     ??IOE_GITCmd_0:
   \   0000001E   16F0FE06           ANDS     R6,R6,#0xFE
    744            }  
    745            
    746            /* Write Back the Interrupt Control register */
    747            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_INT_CTRL, tmp);
   \                     ??IOE_GITCmd_1:
   \   00000022   3200               MOVS     R2,R6
   \   00000024   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000026   0921               MOVS     R1,#+9
   \   00000028   2000               MOVS     R0,R4
   \   0000002A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   ........           BL       I2C_WriteDeviceRegister
    748          
    749            /* If all OK return IOE_OK */
    750            return IOE_OK;     
   \   00000030   0020               MOVS     R0,#+0
   \   00000032   70BD               POP      {R4-R6,PC}       ;; return
    751          }
    752          
    753          /**
    754            * @brief  Configures the selected source to generate or not a global interrupt
    755            * @param DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    756            *        or IOE_2_ADDR.
    757            * @param Global_IT: the interrupt source to be configured, could be:
    758            *   @arg  Global_IT_GPIO : All IOs interrupt
    759            *   @arg  Global_IT_ADC : ADC interrupt
    760            *   @arg  Global_IT_TEMP : Temperature Sensor interrupts      
    761            *   @arg  Global_IT_FE : Touch Screen Controller FIFO Error interrupt
    762            *   @arg  Global_IT_FF : Touch Screen Controller FIFO Full interrupt      
    763            *   @arg  Global_IT_FOV : Touch Screen Controller FIFO Overrun interrupt     
    764            *   @arg  Global_IT_FTH : Touch Screen Controller FIFO Threshold interrupt   
    765            *   @arg  Global_IT_TOUCH : Touch Screen Controller Touch Detected interrupt 
    766            * @retval IOE_OK: if all initializations are OK. Other value if error.
    767            */

   \                                 In section .text, align 2, keep-with-next
    768          uint8_t IOE_GITConfig(uint8_t DeviceAddr, uint8_t Global_IT, FunctionalState NewState)
    769          {
   \                     IOE_GITConfig:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    770            uint8_t tmp = 0;
   \   00000008   0027               MOVS     R7,#+0
    771            
    772            /* Get the current value of the INT_EN register */
    773            tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_INT_EN);
   \   0000000A   0A21               MOVS     R1,#+10
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   ........           BL       I2C_ReadDeviceRegister
   \   00000014   0700               MOVS     R7,R0
    774            
    775            if (NewState != DISABLE)
   \   00000016   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   002E               CMP      R6,#+0
   \   0000001A   01D0               BEQ.N    ??IOE_GITConfig_0
    776            {
    777              /* Set the interrupts to be Enabled */    
    778              tmp |= (uint8_t)Global_IT;  
   \   0000001C   2F43               ORRS     R7,R5,R7
   \   0000001E   00E0               B.N      ??IOE_GITConfig_1
    779            }
    780            else
    781            {
    782              /* Set the interrupts to be Disabled */    
    783              tmp &= ~(uint8_t)Global_IT;
   \                     ??IOE_GITConfig_0:
   \   00000020   AF43               BICS     R7,R7,R5
    784            }
    785            /* Set the register */
    786            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_INT_EN, tmp);
   \                     ??IOE_GITConfig_1:
   \   00000022   3A00               MOVS     R2,R7
   \   00000024   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000026   0A21               MOVS     R1,#+10
   \   00000028   2000               MOVS     R0,R4
   \   0000002A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   ........           BL       I2C_WriteDeviceRegister
    787            
    788            /* If all OK return IOE_OK */
    789            return IOE_OK;  
   \   00000030   0020               MOVS     R0,#+0
   \   00000032   F2BD               POP      {R1,R4-R7,PC}    ;; return
    790          }
    791          
    792          /**
    793            * @brief  Configures the selected pins to generate an interrupt or not.
    794            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    795            *         or IOE_2_ADDR.
    796            * @param  IO_IT: The IO interrupt to be configured. This parameter could be any
    797            *         combination of the following values:
    798            *   @arg  IO_IT_x: where x can be from 0 to 7.
    799            * @param  NewState: could be ENABLE or DISABLE.  
    800            * @retval IOE_OK: if all initializations are OK. Other value if error.
    801            */

   \                                 In section .text, align 2, keep-with-next
    802          uint8_t IOE_IOITConfig(uint8_t DeviceAddr, uint8_t IO_IT, FunctionalState NewState)
    803          {
   \                     IOE_IOITConfig:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    804            uint8_t tmp = 0;
   \   00000008   0027               MOVS     R7,#+0
    805           
    806            tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_INT_EN);
   \   0000000A   0C21               MOVS     R1,#+12
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   ........           BL       I2C_ReadDeviceRegister
   \   00000014   0700               MOVS     R7,R0
    807            
    808            if (NewState != DISABLE)
   \   00000016   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   002E               CMP      R6,#+0
   \   0000001A   01D0               BEQ.N    ??IOE_IOITConfig_0
    809            {
    810              /* Set the interrupts to be Enabled */    
    811              tmp |= (uint8_t)IO_IT;
   \   0000001C   2F43               ORRS     R7,R5,R7
   \   0000001E   00E0               B.N      ??IOE_IOITConfig_1
    812            }
    813            else
    814            {
    815              /* Set the interrupts to be Disabled */    
    816              tmp &= ~(uint8_t)IO_IT;
   \                     ??IOE_IOITConfig_0:
   \   00000020   AF43               BICS     R7,R7,R5
    817            }
    818            
    819            /* Set the register */
    820            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_INT_EN, tmp);
   \                     ??IOE_IOITConfig_1:
   \   00000022   3A00               MOVS     R2,R7
   \   00000024   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000026   0C21               MOVS     R1,#+12
   \   00000028   2000               MOVS     R0,R4
   \   0000002A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   ........           BL       I2C_WriteDeviceRegister
    821            
    822            /* If all OK return IOE_OK */
    823            return IOE_OK;   
   \   00000030   0020               MOVS     R0,#+0
   \   00000032   F2BD               POP      {R1,R4-R7,PC}    ;; return
    824          }
    825          
    826          /**
    827            * @brief  Configures the touch Screen Controller (Single point detection)
    828            * @param  None
    829            * @retval IOE_OK if all initializations are OK. Other value if error.
    830            */

   \                                 In section .text, align 2, keep-with-next
    831          uint8_t IOE_TS_Config(void)
    832          {
   \                     IOE_TS_Config:
   \   00000000   10B5               PUSH     {R4,LR}
    833            uint8_t tmp = 0;  
   \   00000002   0024               MOVS     R4,#+0
    834            
    835            /* Enable TSC Fct: already done in IOE_Config */
    836            tmp = I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_SYS_CTRL2);
   \   00000004   0421               MOVS     R1,#+4
   \   00000006   8220               MOVS     R0,#+130
   \   00000008   ........           BL       I2C_ReadDeviceRegister
   \   0000000C   0400               MOVS     R4,R0
    837            tmp &= ~(uint32_t)(IOE_TS_FCT | IOE_ADC_FCT);
   \   0000000E   14F0FC04           ANDS     R4,R4,#0xFC
    838            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_SYS_CTRL2, tmp); 
   \   00000012   2200               MOVS     R2,R4
   \   00000014   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000016   0421               MOVS     R1,#+4
   \   00000018   8220               MOVS     R0,#+130
   \   0000001A   ........           BL       I2C_WriteDeviceRegister
    839            
    840            /* Enable the TSC gloabl interrupts */
    841            tmp = I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_INT_EN);
   \   0000001E   0A21               MOVS     R1,#+10
   \   00000020   8220               MOVS     R0,#+130
   \   00000022   ........           BL       I2C_ReadDeviceRegister
   \   00000026   0400               MOVS     R4,R0
    842            tmp |= (uint32_t)(IOE_GIT_TOUCH | IOE_GIT_FTH | IOE_GIT_FOV);
   \   00000028   54F00704           ORRS     R4,R4,#0x7
    843            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_INT_EN, tmp); 
   \   0000002C   2200               MOVS     R2,R4
   \   0000002E   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000030   0A21               MOVS     R1,#+10
   \   00000032   8220               MOVS     R0,#+130
   \   00000034   ........           BL       I2C_WriteDeviceRegister
    844            
    845            /* Select Sample Time, bit number and ADC Reference */
    846            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_ADC_CTRL1, 0x49);
   \   00000038   4922               MOVS     R2,#+73
   \   0000003A   2021               MOVS     R1,#+32
   \   0000003C   8220               MOVS     R0,#+130
   \   0000003E   ........           BL       I2C_WriteDeviceRegister
    847            
    848            /* Wait for ~20 ms */
    849            _delay_(2);  
   \   00000042   0220               MOVS     R0,#+2
   \   00000044   ........           BL       delay
    850            
    851            /* Select the ADC clock speed: 3.25 MHz */
    852            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_ADC_CTRL2, 0x01);
   \   00000048   0122               MOVS     R2,#+1
   \   0000004A   2121               MOVS     R1,#+33
   \   0000004C   8220               MOVS     R0,#+130
   \   0000004E   ........           BL       I2C_WriteDeviceRegister
    853            
    854            /* Select TSC pins in non default mode */  
    855            tmp = I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_GPIO_AF);
   \   00000052   1721               MOVS     R1,#+23
   \   00000054   8220               MOVS     R0,#+130
   \   00000056   ........           BL       I2C_ReadDeviceRegister
   \   0000005A   0400               MOVS     R4,R0
    856            tmp &= ~(uint8_t)TOUCH_IO_ALL;
   \   0000005C   14F0E104           ANDS     R4,R4,#0xE1
    857            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_GPIO_AF, tmp); 
   \   00000060   2200               MOVS     R2,R4
   \   00000062   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000064   1721               MOVS     R1,#+23
   \   00000066   8220               MOVS     R0,#+130
   \   00000068   ........           BL       I2C_WriteDeviceRegister
    858            
    859            /* Select 2 nF filter capacitor */
    860            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_TSC_CFG, 0x9A);   
   \   0000006C   9A22               MOVS     R2,#+154
   \   0000006E   4121               MOVS     R1,#+65
   \   00000070   8220               MOVS     R0,#+130
   \   00000072   ........           BL       I2C_WriteDeviceRegister
    861            
    862            /* Select single point reading  */
    863            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_FIFO_TH, 0x01);
   \   00000076   0122               MOVS     R2,#+1
   \   00000078   4A21               MOVS     R1,#+74
   \   0000007A   8220               MOVS     R0,#+130
   \   0000007C   ........           BL       I2C_WriteDeviceRegister
    864            
    865            /* Write 0x01 to clear the FIFO memory content. */
    866            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_FIFO_STA, 0x01);
   \   00000080   0122               MOVS     R2,#+1
   \   00000082   4B21               MOVS     R1,#+75
   \   00000084   8220               MOVS     R0,#+130
   \   00000086   ........           BL       I2C_WriteDeviceRegister
    867            
    868            /* Write 0x00 to put the FIFO back into operation mode  */
    869            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_FIFO_STA, 0x00);
   \   0000008A   0022               MOVS     R2,#+0
   \   0000008C   4B21               MOVS     R1,#+75
   \   0000008E   8220               MOVS     R0,#+130
   \   00000090   ........           BL       I2C_WriteDeviceRegister
    870            
    871            /* set the data format for Z value: 7 fractional part and 1 whole part */
    872            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_TSC_FRACT_XYZ, 0x01);
   \   00000094   0122               MOVS     R2,#+1
   \   00000096   5621               MOVS     R1,#+86
   \   00000098   8220               MOVS     R0,#+130
   \   0000009A   ........           BL       I2C_WriteDeviceRegister
    873            
    874            /* set the driving capability of the device for TSC pins: 50mA */
    875            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_TSC_I_DRIVE, 0x01);
   \   0000009E   0122               MOVS     R2,#+1
   \   000000A0   5821               MOVS     R1,#+88
   \   000000A2   8220               MOVS     R0,#+130
   \   000000A4   ........           BL       I2C_WriteDeviceRegister
    876            
    877            /* Use no tracking index, touchscreen controller operation mode (XYZ) and 
    878               enable the TSC */
    879            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_TSC_CTRL, 0x01);
   \   000000A8   0122               MOVS     R2,#+1
   \   000000AA   4021               MOVS     R1,#+64
   \   000000AC   8220               MOVS     R0,#+130
   \   000000AE   ........           BL       I2C_WriteDeviceRegister
    880            
    881            /*  Clear all the status pending bits */
    882            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_INT_STA, 0xFF); 
   \   000000B2   FF22               MOVS     R2,#+255
   \   000000B4   0B21               MOVS     R1,#+11
   \   000000B6   8220               MOVS     R0,#+130
   \   000000B8   ........           BL       I2C_WriteDeviceRegister
    883            
    884            /* Initialize the TS structure to their default values */ 
    885            TS_State.TouchDetected = TS_State.X = TS_State.Y = TS_State.Z = 0;
   \   000000BC   0020               MOVS     R0,#+0
   \   000000BE   ........           LDR.W    R1,??DataTable13
   \   000000C2   C880               STRH     R0,[R1, #+6]
   \   000000C4   ........           LDR.W    R1,??DataTable13
   \   000000C8   8880               STRH     R0,[R1, #+4]
   \   000000CA   ........           LDR.W    R1,??DataTable13
   \   000000CE   4880               STRH     R0,[R1, #+2]
   \   000000D0   ........           LDR.W    R1,??DataTable13
   \   000000D4   0880               STRH     R0,[R1, #+0]
    886            
    887            /* All configuration done */
    888            return IOE_OK;  
   \   000000D6   0020               MOVS     R0,#+0
   \   000000D8   10BD               POP      {R4,PC}          ;; return
    889          }
    890          
    891          /**
    892            * @brief  Configures and enables the Temperature sensor module.
    893            * @param  None
    894            * @retval IOE_OK if all initializations are OK. Other value if error.
    895            */

   \                                 In section .text, align 2, keep-with-next
    896          uint8_t IOE_TempSens_Config(void)
    897          {
   \                     IOE_TempSens_Config:
   \   00000000   80B5               PUSH     {R7,LR}
    898            __IO uint8_t tmp = 0;
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   8DF80000           STRB     R0,[SP, #+0]
    899            
    900            /* Enable Temperature Sensor Fct: already done in IOE_Config */
    901            tmp = I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_SYS_CTRL2);
   \   00000008   0421               MOVS     R1,#+4
   \   0000000A   8820               MOVS     R0,#+136
   \   0000000C   ........           BL       I2C_ReadDeviceRegister
   \   00000010   8DF80000           STRB     R0,[SP, #+0]
    902            tmp &= ~(uint32_t)(IOE_TEMPSENS_FCT | IOE_ADC_FCT);
   \   00000014   9DF80000           LDRB     R0,[SP, #+0]
   \   00000018   10F0F600           ANDS     R0,R0,#0xF6
   \   0000001C   8DF80000           STRB     R0,[SP, #+0]
    903            I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_SYS_CTRL2, tmp);  
   \   00000020   9DF80020           LDRB     R2,[SP, #+0]
   \   00000024   0421               MOVS     R1,#+4
   \   00000026   8820               MOVS     R0,#+136
   \   00000028   ........           BL       I2C_WriteDeviceRegister
    904            
    905            /* Enable the TEMPSENS module */
    906            I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_TEMP_CTRL, 0x01);
   \   0000002C   0122               MOVS     R2,#+1
   \   0000002E   6021               MOVS     R1,#+96
   \   00000030   8820               MOVS     R0,#+136
   \   00000032   ........           BL       I2C_WriteDeviceRegister
    907            
    908            /* Aquire data enable */
    909            I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_TEMP_CTRL, 0x3);
   \   00000036   0322               MOVS     R2,#+3
   \   00000038   6021               MOVS     R1,#+96
   \   0000003A   8820               MOVS     R0,#+136
   \   0000003C   ........           BL       I2C_WriteDeviceRegister
    910            
    911            /* All configuration done */
    912            return IOE_OK;
   \   00000040   0020               MOVS     R0,#+0
   \   00000042   02BD               POP      {R1,PC}          ;; return
    913          }
    914          
    915          /**
    916            * @brief  Configures the selected pin to be in Alternate function or not
    917            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    918            *         or IOE_2_ADDR.
    919            * @param  IO_Pin: IO_Pin_x, Where x can be from 0 to 7.   
    920            * @param  NewState: State of the AF for the selected pin, could be 
    921            *         ENABLE or DISABLE.       
    922            * @retval IOE_OK: if all initializations are OK. Other value if error.
    923            */

   \                                 In section .text, align 2, keep-with-next
    924          uint8_t IOE_IOAFConfig(uint8_t DeviceAddr, uint8_t IO_Pin, FunctionalState NewState)
    925          {
   \                     IOE_IOAFConfig:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    926            uint8_t tmp = 0;
   \   00000008   0027               MOVS     R7,#+0
    927            
    928            /* Get the current state of the GPIO_AF register */
    929            tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_AF);
   \   0000000A   1721               MOVS     R1,#+23
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   ........           BL       I2C_ReadDeviceRegister
   \   00000014   0700               MOVS     R7,R0
    930            
    931            if (NewState != DISABLE)
   \   00000016   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   002E               CMP      R6,#+0
   \   0000001A   01D0               BEQ.N    ??IOE_IOAFConfig_0
    932            {
    933              /* Enable the selected pins alternate function */
    934              tmp |= (uint8_t)IO_Pin;
   \   0000001C   2F43               ORRS     R7,R5,R7
   \   0000001E   00E0               B.N      ??IOE_IOAFConfig_1
    935            }
    936            else
    937            {
    938              /* Disable the selected pins alternate function */   
    939              tmp &= ~(uint8_t)IO_Pin;   
   \                     ??IOE_IOAFConfig_0:
   \   00000020   AF43               BICS     R7,R7,R5
    940            }
    941            
    942            /* Write back the new valu in GPIO_AF register */  
    943            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_AF, tmp);  
   \                     ??IOE_IOAFConfig_1:
   \   00000022   3A00               MOVS     R2,R7
   \   00000024   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000026   1721               MOVS     R1,#+23
   \   00000028   2000               MOVS     R0,R4
   \   0000002A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   ........           BL       I2C_WriteDeviceRegister
    944          
    945            /* If all OK return IOE_OK */
    946            return IOE_OK;
   \   00000030   0020               MOVS     R0,#+0
   \   00000032   F2BD               POP      {R1,R4-R7,PC}    ;; return
    947          }
    948          
    949          /**
    950            * @brief  Configures the Edge for which a transition is detectable for the
    951            *         the selected pin.
    952            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
    953            *         or IOE_2_ADDR.
    954            * @param  IO_Pin: IO_Pin_x, Where x can be from 0 to 7.   
    955            * @param  Edge: The edge which will be detected. This parameter can be one or a
    956            *         a combination of follwing values: EDGE_FALLING and EDGE_RISING .
    957            * @retval IOE_OK: if all initializations are OK. Other value if error.
    958            */

   \                                 In section .text, align 2, keep-with-next
    959          uint8_t IOE_IOEdgeConfig(uint8_t DeviceAddr, uint8_t IO_Pin, uint8_t Edge)
    960          {
   \                     IOE_IOEdgeConfig:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   0400               MOVS     R4,R0
   \   00000006   0D00               MOVS     R5,R1
   \   00000008   1600               MOVS     R6,R2
    961            uint8_t tmp1 = 0, tmp2 = 0;   
   \   0000000A   0027               MOVS     R7,#+0
   \   0000000C   5FF00008           MOVS     R8,#+0
    962            
    963            /* Get the registers values */
    964            tmp1 = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_FE);
   \   00000010   1621               MOVS     R1,#+22
   \   00000012   2000               MOVS     R0,R4
   \   00000014   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   ........           BL       I2C_ReadDeviceRegister
   \   0000001A   0700               MOVS     R7,R0
    965            tmp2 = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_RE);
   \   0000001C   1521               MOVS     R1,#+21
   \   0000001E   2000               MOVS     R0,R4
   \   00000020   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   ........           BL       I2C_ReadDeviceRegister
   \   00000026   8046               MOV      R8,R0
    966          
    967            /* Disable the Falling Edge */
    968            tmp1 &= ~(uint8_t)IO_Pin;
   \   00000028   AF43               BICS     R7,R7,R5
    969            /* Disable the Falling Edge */
    970            tmp2 &= ~(uint8_t)IO_Pin;
   \   0000002A   38EA0508           BICS     R8,R8,R5
    971          
    972            /* Enable the Falling edge if selected */
    973            if (Edge & EDGE_FALLING)
   \   0000002E   F007               LSLS     R0,R6,#+31
   \   00000030   00D5               BPL.N    ??IOE_IOEdgeConfig_0
    974            {
    975              tmp1 |= (uint8_t)IO_Pin;
   \   00000032   2F43               ORRS     R7,R5,R7
    976            }
    977          
    978            /* Enable the Rising edge if selected */
    979            if (Edge & EDGE_RISING)
   \                     ??IOE_IOEdgeConfig_0:
   \   00000034   B007               LSLS     R0,R6,#+30
   \   00000036   01D5               BPL.N    ??IOE_IOEdgeConfig_1
    980            {
    981              tmp2 |= (uint8_t)IO_Pin;
   \   00000038   55EA0808           ORRS     R8,R5,R8
    982            }
    983          
    984            /* Write back the registers values */
    985            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_FE, tmp1);
   \                     ??IOE_IOEdgeConfig_1:
   \   0000003C   3A00               MOVS     R2,R7
   \   0000003E   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000040   1621               MOVS     R1,#+22
   \   00000042   2000               MOVS     R0,R4
   \   00000044   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   ........           BL       I2C_WriteDeviceRegister
    986            I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_RE, tmp2);
   \   0000004A   4246               MOV      R2,R8
   \   0000004C   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004E   1521               MOVS     R1,#+21
   \   00000050   2000               MOVS     R0,R4
   \   00000052   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   ........           BL       I2C_WriteDeviceRegister
    987            
    988            /* if OK return 0 */
    989            return IOE_OK;
   \   00000058   0020               MOVS     R0,#+0
   \   0000005A   BDE8F081           POP      {R4-R8,PC}       ;; return
    990          }
    991          
    992          /**
    993            * @brief  Configures the Interrupt line active state and format (level/edge)
    994            * @param  Polarity: could be
    995            *   @arg  Polarity_Low: Interrupt line is active Low/Falling edge      
    996            *   @arg  Polarity_High: Interrupt line is active High/Rising edge      
    997            * @param  Type: Interrupt line activity type, could be one of the following values
    998            *   @arg  Type_Level: Interrupt line is active in level model         
    999            *   @arg  Type_Edge: Interrupt line is active in edge model           
   1000            * @retval IOE_OK: if all initializations are OK. Other value if error.
   1001            */

   \                                 In section .text, align 2, keep-with-next
   1002          uint8_t IOE_ITOutConfig(uint8_t Polarity, uint8_t Type)
   1003          {
   \                     IOE_ITOutConfig:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   1004            uint8_t tmp = 0;
   \   00000006   0026               MOVS     R6,#+0
   1005            
   1006            /*  Get the register IOE_REG_INT_CTRL value */ 
   1007            tmp = I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_INT_CTRL);
   \   00000008   0921               MOVS     R1,#+9
   \   0000000A   8220               MOVS     R0,#+130
   \   0000000C   ........           BL       I2C_ReadDeviceRegister
   \   00000010   0600               MOVS     R6,R0
   1008            
   1009            /* Mask the polarity and type bits */
   1010            tmp &= ~(uint8_t)0x06;
   \   00000012   16F0F906           ANDS     R6,R6,#0xF9
   1011              
   1012            /* Modify the Interrupt Output line configuration */
   1013            tmp |= (uint8_t)(Polarity | Type);
   \   00000016   55EA0400           ORRS     R0,R5,R4
   \   0000001A   0643               ORRS     R6,R0,R6
   1014            
   1015            /* Set the register */
   1016            I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_INT_CTRL, tmp);
   \   0000001C   3200               MOVS     R2,R6
   \   0000001E   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000020   0921               MOVS     R1,#+9
   \   00000022   8220               MOVS     R0,#+130
   \   00000024   ........           BL       I2C_WriteDeviceRegister
   1017            
   1018            
   1019            /*  Get the register IOE_REG_INT_CTRL value */ 
   1020            tmp = I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_INT_CTRL);
   \   00000028   0921               MOVS     R1,#+9
   \   0000002A   8820               MOVS     R0,#+136
   \   0000002C   ........           BL       I2C_ReadDeviceRegister
   \   00000030   0600               MOVS     R6,R0
   1021            /* Mask the polarity and type bits */
   1022            tmp &= ~(uint8_t)0x06;
   \   00000032   16F0F906           ANDS     R6,R6,#0xF9
   1023              
   1024            /* Modify the Interrupt Output line configuration */
   1025            tmp |= (uint8_t)(Polarity | Type);
   \   00000036   55EA0400           ORRS     R0,R5,R4
   \   0000003A   0643               ORRS     R6,R0,R6
   1026            
   1027            /* Set the register */
   1028            I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_INT_CTRL, tmp);  
   \   0000003C   3200               MOVS     R2,R6
   \   0000003E   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000040   0921               MOVS     R1,#+9
   \   00000042   8820               MOVS     R0,#+136
   \   00000044   ........           BL       I2C_WriteDeviceRegister
   1029            
   1030            /* If all OK return IOE_OK */
   1031            return IOE_OK;  
   \   00000048   0020               MOVS     R0,#+0
   \   0000004A   70BD               POP      {R4-R6,PC}       ;; return
   1032          }
   1033          
   1034          /**
   1035            * @brief  Writes a value in a register of the device through I2C.
   1036            * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
   1037            *         or IOE_2_ADDR. 
   1038            * @param  RegisterAddr: The target register adress
   1039            * @param  RegisterValue: The target register value to be written 
   1040            * @retval IOE_OK: if all operations are OK. Other value if error.
   1041            */

   \                                 In section .text, align 2, keep-with-next
   1042          uint8_t I2C_WriteDeviceRegister(uint8_t DeviceAddr, uint8_t RegisterAddr, uint8_t RegisterValue)
   1043          {
   \                     I2C_WriteDeviceRegister:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   \   00000004   0600               MOVS     R6,R0
   \   00000006   0D00               MOVS     R5,R1
   1044            uint32_t read_verif = 0;  
   \   00000008   0024               MOVS     R4,#+0
   1045            uint8_t IOE_BufferTX = 0;
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   8DF80000           STRB     R0,[SP, #+0]
   1046            
   1047            /* Get Value to be written */
   1048            IOE_BufferTX = RegisterValue;
   \   00000010   8DF80020           STRB     R2,[SP, #+0]
   1049            
   1050            /* Configure DMA Peripheral */
   1051            IOE_DMA_Config(IOE_DMA_TX, (uint8_t*)(&IOE_BufferTX));
   \   00000014   00A9               ADD      R1,SP,#+0
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   ........           BL       IOE_DMA_Config
   1052            
   1053            /* Enable the I2C peripheral */
   1054            I2C_GenerateSTART(IOE_I2C, ENABLE);
   \   0000001C   0121               MOVS     R1,#+1
   \   0000001E   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   00000022   ........           BL       I2C_GenerateSTART
   1055            
   1056            /* Test on SB Flag */
   1057            IOE_TimeOut = TIMEOUT_MAX;
   \   00000026   ........           LDR.W    R0,??DataTable13_4
   \   0000002A   4FF44051           MOV      R1,#+12288
   \   0000002E   0160               STR      R1,[R0, #+0]
   1058            while (I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB) == RESET) 
   \                     ??I2C_WriteDeviceRegister_0:
   \   00000030   ........           LDR.W    R1,??DataTable13_6  ;; 0x10000001
   \   00000034   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   00000038   ........           BL       I2C_GetFlagStatus
   \   0000003C   0028               CMP      R0,#+0
   \   0000003E   0AD1               BNE.N    ??I2C_WriteDeviceRegister_1
   1059            {
   1060              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000040   ........           LDR.W    R0,??DataTable13_4
   \   00000044   0068               LDR      R0,[R0, #+0]
   \   00000046   411E               SUBS     R1,R0,#+1
   \   00000048   ........           LDR.W    R2,??DataTable13_4
   \   0000004C   1160               STR      R1,[R2, #+0]
   \   0000004E   0028               CMP      R0,#+0
   \   00000050   EED1               BNE.N    ??I2C_WriteDeviceRegister_0
   \   00000052   0220               MOVS     R0,#+2
   \   00000054   8AE0               B.N      ??I2C_WriteDeviceRegister_2
   1061            }
   1062            
   1063            /* Transmit the slave address and enable writing operation */
   1064            I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Transmitter);
   \                     ??I2C_WriteDeviceRegister_1:
   \   00000056   0022               MOVS     R2,#+0
   \   00000058   3100               MOVS     R1,R6
   \   0000005A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005C   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   00000060   ........           BL       I2C_Send7bitAddress
   1065            
   1066            /* Test on ADDR Flag */
   1067            IOE_TimeOut = TIMEOUT_MAX;
   \   00000064   ........           LDR.W    R0,??DataTable13_4
   \   00000068   4FF44051           MOV      R1,#+12288
   \   0000006C   0160               STR      R1,[R0, #+0]
   1068            while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
   \                     ??I2C_WriteDeviceRegister_3:
   \   0000006E   ........           LDR.W    R1,??DataTable13_7  ;; 0x70082
   \   00000072   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   00000076   ........           BL       I2C_CheckEvent
   \   0000007A   0028               CMP      R0,#+0
   \   0000007C   0AD1               BNE.N    ??I2C_WriteDeviceRegister_4
   1069            {
   1070              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   0000007E   ........           LDR.W    R0,??DataTable13_4
   \   00000082   0068               LDR      R0,[R0, #+0]
   \   00000084   411E               SUBS     R1,R0,#+1
   \   00000086   ........           LDR.W    R2,??DataTable13_4
   \   0000008A   1160               STR      R1,[R2, #+0]
   \   0000008C   0028               CMP      R0,#+0
   \   0000008E   EED1               BNE.N    ??I2C_WriteDeviceRegister_3
   \   00000090   0220               MOVS     R0,#+2
   \   00000092   6BE0               B.N      ??I2C_WriteDeviceRegister_2
   1071            }
   1072            
   1073            /* Transmit the first address for r/w operations */
   1074            I2C_SendData(IOE_I2C, RegisterAddr);
   \                     ??I2C_WriteDeviceRegister_4:
   \   00000094   2900               MOVS     R1,R5
   \   00000096   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000098   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   0000009C   ........           BL       I2C_SendData
   1075            
   1076            /* Test on TXE FLag (data dent) */
   1077            IOE_TimeOut = TIMEOUT_MAX;
   \   000000A0   ........           LDR.W    R0,??DataTable13_4
   \   000000A4   4FF44051           MOV      R1,#+12288
   \   000000A8   0160               STR      R1,[R0, #+0]
   1078            while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_TXE)) && (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF)))  
   \                     ??I2C_WriteDeviceRegister_5:
   \   000000AA   ........           LDR.W    R1,??DataTable13_8  ;; 0x10000080
   \   000000AE   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   000000B2   ........           BL       I2C_GetFlagStatus
   \   000000B6   0028               CMP      R0,#+0
   \   000000B8   12D1               BNE.N    ??I2C_WriteDeviceRegister_6
   \   000000BA   ........           LDR.W    R1,??DataTable13_9  ;; 0x10000004
   \   000000BE   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   000000C2   ........           BL       I2C_GetFlagStatus
   \   000000C6   0028               CMP      R0,#+0
   \   000000C8   0AD1               BNE.N    ??I2C_WriteDeviceRegister_6
   1079            {
   1080              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   000000CA   ........           LDR.W    R0,??DataTable13_4
   \   000000CE   0068               LDR      R0,[R0, #+0]
   \   000000D0   411E               SUBS     R1,R0,#+1
   \   000000D2   ........           LDR.W    R2,??DataTable13_4
   \   000000D6   1160               STR      R1,[R2, #+0]
   \   000000D8   0028               CMP      R0,#+0
   \   000000DA   E6D1               BNE.N    ??I2C_WriteDeviceRegister_5
   \   000000DC   0220               MOVS     R0,#+2
   \   000000DE   45E0               B.N      ??I2C_WriteDeviceRegister_2
   1081            }
   1082            
   1083            /* Enable I2C DMA request */
   1084            I2C_DMACmd(IOE_I2C,ENABLE);
   \                     ??I2C_WriteDeviceRegister_6:
   \   000000E0   0121               MOVS     R1,#+1
   \   000000E2   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   000000E6   ........           BL       I2C_DMACmd
   1085            
   1086            /* Enable DMA TX Channel */
   1087            DMA_Cmd(IOE_DMA_TX_STREAM, ENABLE);
   \   000000EA   0121               MOVS     R1,#+1
   \   000000EC   ........           LDR.W    R0,??DataTable13_10  ;; 0x400260a0
   \   000000F0   ........           BL       DMA_Cmd
   1088            
   1089            /* Wait until DMA Transfer Complete */
   1090            IOE_TimeOut = TIMEOUT_MAX;
   \   000000F4   ........           LDR.W    R0,??DataTable13_4
   \   000000F8   4FF44051           MOV      R1,#+12288
   \   000000FC   0160               STR      R1,[R0, #+0]
   1091            while (!DMA_GetFlagStatus(IOE_DMA_TX_STREAM,IOE_DMA_TX_TCFLAG))
   \                     ??I2C_WriteDeviceRegister_7:
   \   000000FE   ........           LDR.W    R1,??DataTable13_11  ;; 0x20200000
   \   00000102   ........           LDR.W    R0,??DataTable13_10  ;; 0x400260a0
   \   00000106   ........           BL       DMA_GetFlagStatus
   \   0000010A   0028               CMP      R0,#+0
   \   0000010C   0AD1               BNE.N    ??I2C_WriteDeviceRegister_8
   1092            {
   1093              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   0000010E   ........           LDR.W    R0,??DataTable13_4
   \   00000112   0068               LDR      R0,[R0, #+0]
   \   00000114   411E               SUBS     R1,R0,#+1
   \   00000116   ........           LDR.W    R2,??DataTable13_4
   \   0000011A   1160               STR      R1,[R2, #+0]
   \   0000011C   0028               CMP      R0,#+0
   \   0000011E   EED1               BNE.N    ??I2C_WriteDeviceRegister_7
   \   00000120   0220               MOVS     R0,#+2
   \   00000122   23E0               B.N      ??I2C_WriteDeviceRegister_2
   1094            }  
   1095            
   1096            /* Wait until BTF Flag is set before generating STOP */
   1097            IOE_TimeOut = 2 * TIMEOUT_MAX;
   \                     ??I2C_WriteDeviceRegister_8:
   \   00000124   ........           LDR.W    R0,??DataTable13_4
   \   00000128   4FF4C041           MOV      R1,#+24576
   \   0000012C   0160               STR      R1,[R0, #+0]
   1098            while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF)))  
   \                     ??I2C_WriteDeviceRegister_9:
   \   0000012E   ........           LDR.W    R1,??DataTable13_9  ;; 0x10000004
   \   00000132   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   00000136   ........           BL       I2C_GetFlagStatus
   \   0000013A   0028               CMP      R0,#+0
   \   0000013C   F7D0               BEQ.N    ??I2C_WriteDeviceRegister_9
   1099            {
   1100            }
   1101            
   1102            /* Send STOP Condition */
   1103            I2C_GenerateSTOP(IOE_I2C, ENABLE);
   \   0000013E   0121               MOVS     R1,#+1
   \   00000140   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   00000144   ........           BL       I2C_GenerateSTOP
   1104            
   1105            /* Disable DMA TX Channel */
   1106            DMA_Cmd(IOE_DMA_TX_STREAM, DISABLE);
   \   00000148   0021               MOVS     R1,#+0
   \   0000014A   ........           LDR.W    R0,??DataTable13_10  ;; 0x400260a0
   \   0000014E   ........           BL       DMA_Cmd
   1107            
   1108            /* Disable I2C DMA request */  
   1109            I2C_DMACmd(IOE_I2C,DISABLE);
   \   00000152   0021               MOVS     R1,#+0
   \   00000154   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   00000158   ........           BL       I2C_DMACmd
   1110            
   1111            /* Clear DMA TX Transfer Complete Flag */
   1112            DMA_ClearFlag(IOE_DMA_TX_STREAM,IOE_DMA_TX_TCFLAG);
   \   0000015C   ........           LDR.W    R1,??DataTable13_11  ;; 0x20200000
   \   00000160   ........           LDR.W    R0,??DataTable13_10  ;; 0x400260a0
   \   00000164   ........           BL       DMA_ClearFlag
   1113            
   1114          #ifdef VERIFY_WRITTENDATA
   1115            /* Verify (if needed) that the loaded data is correct  */
   1116            
   1117            /* Read the just written register*/
   1118            read_verif = I2C_ReadDeviceRegister(DeviceAddr, RegisterAddr);
   1119            /* Load the register and verify its value  */
   1120            if (read_verif != RegisterValue)
   1121            {
   1122              /* Control data wrongly tranfered */
   1123              read_verif = IOE_FAILURE;
   1124            }
   1125            else
   1126            {
   1127              /* Control data correctly transfered */
   1128              read_verif = 0;
   1129            }
   1130          #endif
   1131            
   1132            /* Return the verifying value: 0 (Passed) or 1 (Failed) */
   1133            return read_verif;
   \   00000168   2000               MOVS     R0,R4
   \   0000016A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??I2C_WriteDeviceRegister_2:
   \   0000016C   76BD               POP      {R1,R2,R4-R6,PC}  ;; return
   1134          }
   1135          
   1136          /**
   1137            * @brief  Reads a register of the device through I2C.
   1138            * @param  DeviceAddr: The address of the device, could be : IOE_1_ADDR
   1139            *         or IOE_2_ADDR. 
   1140            * @param  RegisterAddr: The target register adress (between 00x and 0x24)
   1141            * @retval The value of the read register (0xAA if Timout occured)   
   1142            */

   \                                 In section .text, align 2, keep-with-next
   1143          uint8_t I2C_ReadDeviceRegister(uint8_t DeviceAddr, uint8_t RegisterAddr)
   1144          {
   \                     I2C_ReadDeviceRegister:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   1145            uint8_t IOE_BufferRX[2] = {0x00, 0x00};  
   \   00000006   00A8               ADD      R0,SP,#+0
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   0180               STRH     R1,[R0, #+0]
   1146            
   1147            /* Configure DMA Peripheral */
   1148            IOE_DMA_Config(IOE_DMA_RX, (uint8_t*)IOE_BufferRX);
   \   0000000C   00A9               ADD      R1,SP,#+0
   \   0000000E   0120               MOVS     R0,#+1
   \   00000010   ........           BL       IOE_DMA_Config
   1149            
   1150            /* Enable DMA NACK automatic generation */
   1151            I2C_DMALastTransferCmd(IOE_I2C, ENABLE);
   \   00000014   0121               MOVS     R1,#+1
   \   00000016   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   0000001A   ........           BL       I2C_DMALastTransferCmd
   1152            
   1153            /* Enable the I2C peripheral */
   1154            I2C_GenerateSTART(IOE_I2C, ENABLE);
   \   0000001E   0121               MOVS     R1,#+1
   \   00000020   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   00000024   ........           BL       I2C_GenerateSTART
   1155            
   1156            /* Test on SB Flag */
   1157            IOE_TimeOut = TIMEOUT_MAX;
   \   00000028   ........           LDR.W    R0,??DataTable13_4
   \   0000002C   4FF44051           MOV      R1,#+12288
   \   00000030   0160               STR      R1,[R0, #+0]
   1158            while (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB)) 
   \                     ??I2C_ReadDeviceRegister_0:
   \   00000032   ........           LDR.W    R1,??DataTable13_6  ;; 0x10000001
   \   00000036   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   0000003A   ........           BL       I2C_GetFlagStatus
   \   0000003E   0028               CMP      R0,#+0
   \   00000040   0AD1               BNE.N    ??I2C_ReadDeviceRegister_1
   1159            {
   1160              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000042   ........           LDR.W    R0,??DataTable13_4
   \   00000046   0068               LDR      R0,[R0, #+0]
   \   00000048   411E               SUBS     R1,R0,#+1
   \   0000004A   ........           LDR.W    R2,??DataTable13_4
   \   0000004E   1160               STR      R1,[R2, #+0]
   \   00000050   0028               CMP      R0,#+0
   \   00000052   EED1               BNE.N    ??I2C_ReadDeviceRegister_0
   \   00000054   0220               MOVS     R0,#+2
   \   00000056   B9E0               B.N      ??I2C_ReadDeviceRegister_2
   1161            }
   1162            
   1163            /* Send device address for write */
   1164            I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Transmitter);
   \                     ??I2C_ReadDeviceRegister_1:
   \   00000058   0022               MOVS     R2,#+0
   \   0000005A   2100               MOVS     R1,R4
   \   0000005C   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005E   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   00000062   ........           BL       I2C_Send7bitAddress
   1165            
   1166            /* Test on ADDR Flag */
   1167            IOE_TimeOut = TIMEOUT_MAX;
   \   00000066   ........           LDR.W    R0,??DataTable13_4
   \   0000006A   4FF44051           MOV      R1,#+12288
   \   0000006E   0160               STR      R1,[R0, #+0]
   1168            while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) 
   \                     ??I2C_ReadDeviceRegister_3:
   \   00000070   ........           LDR.W    R1,??DataTable13_7  ;; 0x70082
   \   00000074   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   00000078   ........           BL       I2C_CheckEvent
   \   0000007C   0028               CMP      R0,#+0
   \   0000007E   0AD1               BNE.N    ??I2C_ReadDeviceRegister_4
   1169            {
   1170              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000080   ........           LDR.W    R0,??DataTable13_4
   \   00000084   0068               LDR      R0,[R0, #+0]
   \   00000086   411E               SUBS     R1,R0,#+1
   \   00000088   ........           LDR.W    R2,??DataTable13_4
   \   0000008C   1160               STR      R1,[R2, #+0]
   \   0000008E   0028               CMP      R0,#+0
   \   00000090   EED1               BNE.N    ??I2C_ReadDeviceRegister_3
   \   00000092   0220               MOVS     R0,#+2
   \   00000094   9AE0               B.N      ??I2C_ReadDeviceRegister_2
   1171            }
   1172            
   1173            /* Send the device's internal address to write to */
   1174            I2C_SendData(IOE_I2C, RegisterAddr);  
   \                     ??I2C_ReadDeviceRegister_4:
   \   00000096   2900               MOVS     R1,R5
   \   00000098   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000009A   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   0000009E   ........           BL       I2C_SendData
   1175            
   1176            /* Test on TXE FLag (data dent) */
   1177            IOE_TimeOut = TIMEOUT_MAX;
   \   000000A2   ........           LDR.W    R0,??DataTable13_4
   \   000000A6   4FF44051           MOV      R1,#+12288
   \   000000AA   0160               STR      R1,[R0, #+0]
   1178            while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_TXE)) && (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF)))  
   \                     ??I2C_ReadDeviceRegister_5:
   \   000000AC   ........           LDR.W    R1,??DataTable13_8  ;; 0x10000080
   \   000000B0   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   000000B4   ........           BL       I2C_GetFlagStatus
   \   000000B8   0028               CMP      R0,#+0
   \   000000BA   12D1               BNE.N    ??I2C_ReadDeviceRegister_6
   \   000000BC   ........           LDR.W    R1,??DataTable13_9  ;; 0x10000004
   \   000000C0   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   000000C4   ........           BL       I2C_GetFlagStatus
   \   000000C8   0028               CMP      R0,#+0
   \   000000CA   0AD1               BNE.N    ??I2C_ReadDeviceRegister_6
   1179            {
   1180              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   000000CC   ........           LDR.W    R0,??DataTable13_4
   \   000000D0   0068               LDR      R0,[R0, #+0]
   \   000000D2   411E               SUBS     R1,R0,#+1
   \   000000D4   ........           LDR.W    R2,??DataTable13_4
   \   000000D8   1160               STR      R1,[R2, #+0]
   \   000000DA   0028               CMP      R0,#+0
   \   000000DC   E6D1               BNE.N    ??I2C_ReadDeviceRegister_5
   \   000000DE   0220               MOVS     R0,#+2
   \   000000E0   74E0               B.N      ??I2C_ReadDeviceRegister_2
   1181            }
   1182            
   1183            /* Send START condition a second time */  
   1184            I2C_GenerateSTART(IOE_I2C, ENABLE);
   \                     ??I2C_ReadDeviceRegister_6:
   \   000000E2   0121               MOVS     R1,#+1
   \   000000E4   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   000000E8   ........           BL       I2C_GenerateSTART
   1185            
   1186            /* Test on SB Flag */
   1187            IOE_TimeOut = TIMEOUT_MAX;
   \   000000EC   ........           LDR.W    R0,??DataTable13_4
   \   000000F0   4FF44051           MOV      R1,#+12288
   \   000000F4   0160               STR      R1,[R0, #+0]
   1188            while (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB)) 
   \                     ??I2C_ReadDeviceRegister_7:
   \   000000F6   ........           LDR.W    R1,??DataTable13_6  ;; 0x10000001
   \   000000FA   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   000000FE   ........           BL       I2C_GetFlagStatus
   \   00000102   0028               CMP      R0,#+0
   \   00000104   0AD1               BNE.N    ??I2C_ReadDeviceRegister_8
   1189            {
   1190              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000106   ........           LDR.W    R0,??DataTable13_4
   \   0000010A   0068               LDR      R0,[R0, #+0]
   \   0000010C   411E               SUBS     R1,R0,#+1
   \   0000010E   ........           LDR.W    R2,??DataTable13_4
   \   00000112   1160               STR      R1,[R2, #+0]
   \   00000114   0028               CMP      R0,#+0
   \   00000116   EED1               BNE.N    ??I2C_ReadDeviceRegister_7
   \   00000118   0220               MOVS     R0,#+2
   \   0000011A   57E0               B.N      ??I2C_ReadDeviceRegister_2
   1191            }
   1192            
   1193            /* Send IOExpander address for read */
   1194            I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Receiver);
   \                     ??I2C_ReadDeviceRegister_8:
   \   0000011C   0122               MOVS     R2,#+1
   \   0000011E   2100               MOVS     R1,R4
   \   00000120   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000122   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   00000126   ........           BL       I2C_Send7bitAddress
   1195            
   1196            /* Test on ADDR Flag */
   1197            IOE_TimeOut = TIMEOUT_MAX;
   \   0000012A   ........           LDR.W    R0,??DataTable13_4
   \   0000012E   4FF44051           MOV      R1,#+12288
   \   00000132   0160               STR      R1,[R0, #+0]
   1198            while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))   
   \                     ??I2C_ReadDeviceRegister_9:
   \   00000134   ........           LDR.W    R1,??DataTable13_12  ;; 0x30002
   \   00000138   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   0000013C   ........           BL       I2C_CheckEvent
   \   00000140   0028               CMP      R0,#+0
   \   00000142   0AD1               BNE.N    ??I2C_ReadDeviceRegister_10
   1199            {
   1200              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000144   ........           LDR.W    R0,??DataTable13_4
   \   00000148   0068               LDR      R0,[R0, #+0]
   \   0000014A   411E               SUBS     R1,R0,#+1
   \   0000014C   ........           LDR.W    R2,??DataTable13_4
   \   00000150   1160               STR      R1,[R2, #+0]
   \   00000152   0028               CMP      R0,#+0
   \   00000154   EED1               BNE.N    ??I2C_ReadDeviceRegister_9
   \   00000156   0220               MOVS     R0,#+2
   \   00000158   38E0               B.N      ??I2C_ReadDeviceRegister_2
   1201            }
   1202              
   1203            /* Enable I2C DMA request */
   1204            I2C_DMACmd(IOE_I2C,ENABLE);
   \                     ??I2C_ReadDeviceRegister_10:
   \   0000015A   0121               MOVS     R1,#+1
   \   0000015C   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   00000160   ........           BL       I2C_DMACmd
   1205            
   1206            /* Enable DMA RX Channel */
   1207            DMA_Cmd(IOE_DMA_RX_STREAM, ENABLE);
   \   00000164   0121               MOVS     R1,#+1
   \   00000166   ........           LDR.W    R0,??DataTable13_13  ;; 0x40026010
   \   0000016A   ........           BL       DMA_Cmd
   1208            
   1209            /* Wait until DMA Transfer Complete */
   1210            IOE_TimeOut = 2 * TIMEOUT_MAX;
   \   0000016E   ........           LDR.W    R0,??DataTable13_4
   \   00000172   4FF4C041           MOV      R1,#+24576
   \   00000176   0160               STR      R1,[R0, #+0]
   1211            while (!DMA_GetFlagStatus(IOE_DMA_RX_STREAM,IOE_DMA_RX_TCFLAG))
   \                     ??I2C_ReadDeviceRegister_11:
   \   00000178   ........           LDR.W    R1,??DataTable13_14  ;; 0x10000020
   \   0000017C   ........           LDR.W    R0,??DataTable13_13  ;; 0x40026010
   \   00000180   ........           BL       DMA_GetFlagStatus
   \   00000184   0028               CMP      R0,#+0
   \   00000186   0AD1               BNE.N    ??I2C_ReadDeviceRegister_12
   1212            {
   1213              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000188   ........           LDR.W    R0,??DataTable13_4
   \   0000018C   0068               LDR      R0,[R0, #+0]
   \   0000018E   411E               SUBS     R1,R0,#+1
   \   00000190   ........           LDR.W    R2,??DataTable13_4
   \   00000194   1160               STR      R1,[R2, #+0]
   \   00000196   0028               CMP      R0,#+0
   \   00000198   EED1               BNE.N    ??I2C_ReadDeviceRegister_11
   \   0000019A   0220               MOVS     R0,#+2
   \   0000019C   16E0               B.N      ??I2C_ReadDeviceRegister_2
   1214            }        
   1215            
   1216            /* Send STOP Condition */
   1217            I2C_GenerateSTOP(IOE_I2C, ENABLE);
   \                     ??I2C_ReadDeviceRegister_12:
   \   0000019E   0121               MOVS     R1,#+1
   \   000001A0   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   000001A4   ........           BL       I2C_GenerateSTOP
   1218            
   1219            /* Disable DMA RX Channel */
   1220            DMA_Cmd(IOE_DMA_RX_STREAM, DISABLE);
   \   000001A8   0021               MOVS     R1,#+0
   \   000001AA   ........           LDR.W    R0,??DataTable13_13  ;; 0x40026010
   \   000001AE   ........           BL       DMA_Cmd
   1221            
   1222            /* Disable I2C DMA request */  
   1223            I2C_DMACmd(IOE_I2C,DISABLE);
   \   000001B2   0021               MOVS     R1,#+0
   \   000001B4   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   000001B8   ........           BL       I2C_DMACmd
   1224            
   1225            /* Clear DMA RX Transfer Complete Flag */
   1226           DMA_ClearFlag(IOE_DMA_RX_STREAM,IOE_DMA_RX_TCFLAG);
   \   000001BC   ........           LDR.W    R1,??DataTable13_14  ;; 0x10000020
   \   000001C0   ........           LDR.W    R0,??DataTable13_13  ;; 0x40026010
   \   000001C4   ........           BL       DMA_ClearFlag
   1227            
   1228            /* return a pointer to the IOE_Buffer */
   1229            return (uint8_t)IOE_BufferRX[0];
   \   000001C8   9DF80000           LDRB     R0,[SP, #+0]
   \                     ??I2C_ReadDeviceRegister_2:
   \   000001CC   32BD               POP      {R1,R4,R5,PC}    ;; return
   1230          }
   1231          
   1232          
   1233          /**
   1234            * @brief  Reads a buffer of 2 bytes from the device registers.
   1235            * @param  DeviceAddr: The address of the device, could be : IOE_1_ADDR
   1236            *         or IOE_2_ADDR. 
   1237            * @param  RegisterAddr: The target register adress (between 00x and 0x24)
   1238            * @retval A pointer to the buffer containing the two returned bytes (in halfword).  
   1239            */

   \                                 In section .text, align 2, keep-with-next
   1240          uint16_t I2C_ReadDataBuffer(uint8_t DeviceAddr, uint32_t RegisterAddr)
   1241          { 
   \                     I2C_ReadDataBuffer:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   \   00000004   0400               MOVS     R4,R0
   \   00000006   0D00               MOVS     R5,R1
   1242            uint8_t tmp= 0;
   \   00000008   0026               MOVS     R6,#+0
   1243            uint8_t IOE_BufferRX[2] = {0x00, 0x00};  
   \   0000000A   00A8               ADD      R0,SP,#+0
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   0180               STRH     R1,[R0, #+0]
   1244            
   1245            /* Configure DMA Peripheral */
   1246            IOE_DMA_Config(IOE_DMA_RX, (uint8_t*)IOE_BufferRX);
   \   00000010   00A9               ADD      R1,SP,#+0
   \   00000012   0120               MOVS     R0,#+1
   \   00000014   ........           BL       IOE_DMA_Config
   1247            
   1248            /* Enable DMA NACK automatic generation */
   1249            I2C_DMALastTransferCmd(IOE_I2C, ENABLE);
   \   00000018   0121               MOVS     R1,#+1
   \   0000001A   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   0000001E   ........           BL       I2C_DMALastTransferCmd
   1250            
   1251            /* Enable the I2C peripheral */
   1252            I2C_GenerateSTART(IOE_I2C, ENABLE);
   \   00000022   0121               MOVS     R1,#+1
   \   00000024   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   00000028   ........           BL       I2C_GenerateSTART
   1253            
   1254            /* Test on SB Flag */
   1255            IOE_TimeOut = TIMEOUT_MAX;
   \   0000002C   ........           LDR.W    R0,??DataTable13_4
   \   00000030   4FF44051           MOV      R1,#+12288
   \   00000034   0160               STR      R1,[R0, #+0]
   1256            while (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB)) 
   \                     ??I2C_ReadDataBuffer_0:
   \   00000036   ........           LDR.W    R1,??DataTable13_6  ;; 0x10000001
   \   0000003A   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   0000003E   ........           BL       I2C_GetFlagStatus
   \   00000042   0028               CMP      R0,#+0
   \   00000044   0AD1               BNE.N    ??I2C_ReadDataBuffer_1
   1257            {
   1258              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000046   ........           LDR.W    R0,??DataTable13_4
   \   0000004A   0068               LDR      R0,[R0, #+0]
   \   0000004C   411E               SUBS     R1,R0,#+1
   \   0000004E   ........           LDR.W    R2,??DataTable13_4
   \   00000052   1160               STR      R1,[R2, #+0]
   \   00000054   0028               CMP      R0,#+0
   \   00000056   EED1               BNE.N    ??I2C_ReadDataBuffer_0
   \   00000058   0220               MOVS     R0,#+2
   \   0000005A   A3E0               B.N      ??I2C_ReadDataBuffer_2
   1259            }
   1260            
   1261            /* Send device address for write */
   1262            I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Transmitter);
   \                     ??I2C_ReadDataBuffer_1:
   \   0000005C   0022               MOVS     R2,#+0
   \   0000005E   2100               MOVS     R1,R4
   \   00000060   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000062   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   00000066   ........           BL       I2C_Send7bitAddress
   1263            
   1264            /* Test on ADDR Flag */
   1265            IOE_TimeOut = TIMEOUT_MAX;
   \   0000006A   ........           LDR.W    R0,??DataTable13_4
   \   0000006E   4FF44051           MOV      R1,#+12288
   \   00000072   0160               STR      R1,[R0, #+0]
   1266            while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
   \                     ??I2C_ReadDataBuffer_3:
   \   00000074   ........           LDR.W    R1,??DataTable13_7  ;; 0x70082
   \   00000078   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   0000007C   ........           BL       I2C_CheckEvent
   \   00000080   0028               CMP      R0,#+0
   \   00000082   0AD1               BNE.N    ??I2C_ReadDataBuffer_4
   1267            {
   1268              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000084   ........           LDR.W    R0,??DataTable13_4
   \   00000088   0068               LDR      R0,[R0, #+0]
   \   0000008A   411E               SUBS     R1,R0,#+1
   \   0000008C   ........           LDR.W    R2,??DataTable13_4
   \   00000090   1160               STR      R1,[R2, #+0]
   \   00000092   0028               CMP      R0,#+0
   \   00000094   EED1               BNE.N    ??I2C_ReadDataBuffer_3
   \   00000096   0220               MOVS     R0,#+2
   \   00000098   84E0               B.N      ??I2C_ReadDataBuffer_2
   1269            }
   1270            
   1271            /* Send the device's internal address to write to */
   1272            I2C_SendData(IOE_I2C, RegisterAddr);  
   \                     ??I2C_ReadDataBuffer_4:
   \   0000009A   2900               MOVS     R1,R5
   \   0000009C   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000009E   ........           LDR.W    R0,??DataTable13_5  ;; 0x40005400
   \   000000A2   ........           BL       I2C_SendData
   1273            
   1274            /* Test on TXE FLag (data dent) */
   1275            IOE_TimeOut = TIMEOUT_MAX;
   \   000000A6   ....               LDR.N    R0,??DataTable13_4
   \   000000A8   4FF44051           MOV      R1,#+12288
   \   000000AC   0160               STR      R1,[R0, #+0]
   1276            while ((!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_TXE)) && (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_BTF)))  
   \                     ??I2C_ReadDataBuffer_5:
   \   000000AE   ........           LDR.W    R1,??DataTable13_8  ;; 0x10000080
   \   000000B2   ....               LDR.N    R0,??DataTable13_5  ;; 0x40005400
   \   000000B4   ........           BL       I2C_GetFlagStatus
   \   000000B8   0028               CMP      R0,#+0
   \   000000BA   0ED1               BNE.N    ??I2C_ReadDataBuffer_6
   \   000000BC   ....               LDR.N    R1,??DataTable13_9  ;; 0x10000004
   \   000000BE   ....               LDR.N    R0,??DataTable13_5  ;; 0x40005400
   \   000000C0   ........           BL       I2C_GetFlagStatus
   \   000000C4   0028               CMP      R0,#+0
   \   000000C6   08D1               BNE.N    ??I2C_ReadDataBuffer_6
   1277            {
   1278              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   000000C8   ....               LDR.N    R0,??DataTable13_4
   \   000000CA   0068               LDR      R0,[R0, #+0]
   \   000000CC   411E               SUBS     R1,R0,#+1
   \   000000CE   ....               LDR.N    R2,??DataTable13_4
   \   000000D0   1160               STR      R1,[R2, #+0]
   \   000000D2   0028               CMP      R0,#+0
   \   000000D4   EBD1               BNE.N    ??I2C_ReadDataBuffer_5
   \   000000D6   0220               MOVS     R0,#+2
   \   000000D8   64E0               B.N      ??I2C_ReadDataBuffer_2
   1279            }
   1280            
   1281            /* Send START condition a second time */  
   1282            I2C_GenerateSTART(IOE_I2C, ENABLE);
   \                     ??I2C_ReadDataBuffer_6:
   \   000000DA   0121               MOVS     R1,#+1
   \   000000DC   ....               LDR.N    R0,??DataTable13_5  ;; 0x40005400
   \   000000DE   ........           BL       I2C_GenerateSTART
   1283            
   1284            /* Test on SB Flag */
   1285            IOE_TimeOut = TIMEOUT_MAX;
   \   000000E2   ....               LDR.N    R0,??DataTable13_4
   \   000000E4   4FF44051           MOV      R1,#+12288
   \   000000E8   0160               STR      R1,[R0, #+0]
   1286            while (!I2C_GetFlagStatus(IOE_I2C,I2C_FLAG_SB)) 
   \                     ??I2C_ReadDataBuffer_7:
   \   000000EA   ....               LDR.N    R1,??DataTable13_6  ;; 0x10000001
   \   000000EC   ....               LDR.N    R0,??DataTable13_5  ;; 0x40005400
   \   000000EE   ........           BL       I2C_GetFlagStatus
   \   000000F2   0028               CMP      R0,#+0
   \   000000F4   08D1               BNE.N    ??I2C_ReadDataBuffer_8
   1287            {
   1288              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   000000F6   ....               LDR.N    R0,??DataTable13_4
   \   000000F8   0068               LDR      R0,[R0, #+0]
   \   000000FA   411E               SUBS     R1,R0,#+1
   \   000000FC   ....               LDR.N    R2,??DataTable13_4
   \   000000FE   1160               STR      R1,[R2, #+0]
   \   00000100   0028               CMP      R0,#+0
   \   00000102   F2D1               BNE.N    ??I2C_ReadDataBuffer_7
   \   00000104   0220               MOVS     R0,#+2
   \   00000106   4DE0               B.N      ??I2C_ReadDataBuffer_2
   1289            }
   1290            
   1291            /* Send IOExpander address for read */
   1292            I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Receiver);
   \                     ??I2C_ReadDataBuffer_8:
   \   00000108   0122               MOVS     R2,#+1
   \   0000010A   2100               MOVS     R1,R4
   \   0000010C   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000010E   ....               LDR.N    R0,??DataTable13_5  ;; 0x40005400
   \   00000110   ........           BL       I2C_Send7bitAddress
   1293            
   1294            /* Test on ADDR Flag */
   1295            IOE_TimeOut = TIMEOUT_MAX;
   \   00000114   ....               LDR.N    R0,??DataTable13_4
   \   00000116   4FF44051           MOV      R1,#+12288
   \   0000011A   0160               STR      R1,[R0, #+0]
   1296            while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))   
   \                     ??I2C_ReadDataBuffer_9:
   \   0000011C   ....               LDR.N    R1,??DataTable13_12  ;; 0x30002
   \   0000011E   ....               LDR.N    R0,??DataTable13_5  ;; 0x40005400
   \   00000120   ........           BL       I2C_CheckEvent
   \   00000124   0028               CMP      R0,#+0
   \   00000126   08D1               BNE.N    ??I2C_ReadDataBuffer_10
   1297            {
   1298              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   00000128   ....               LDR.N    R0,??DataTable13_4
   \   0000012A   0068               LDR      R0,[R0, #+0]
   \   0000012C   411E               SUBS     R1,R0,#+1
   \   0000012E   ....               LDR.N    R2,??DataTable13_4
   \   00000130   1160               STR      R1,[R2, #+0]
   \   00000132   0028               CMP      R0,#+0
   \   00000134   F2D1               BNE.N    ??I2C_ReadDataBuffer_9
   \   00000136   0220               MOVS     R0,#+2
   \   00000138   34E0               B.N      ??I2C_ReadDataBuffer_2
   1299            }
   1300            
   1301            /* Enable I2C DMA request */
   1302            I2C_DMACmd(IOE_I2C,ENABLE);
   \                     ??I2C_ReadDataBuffer_10:
   \   0000013A   0121               MOVS     R1,#+1
   \   0000013C   ....               LDR.N    R0,??DataTable13_5  ;; 0x40005400
   \   0000013E   ........           BL       I2C_DMACmd
   1303            
   1304            /* Enable DMA RX Channel */
   1305            DMA_Cmd(IOE_DMA_RX_STREAM, ENABLE);
   \   00000142   0121               MOVS     R1,#+1
   \   00000144   ....               LDR.N    R0,??DataTable13_13  ;; 0x40026010
   \   00000146   ........           BL       DMA_Cmd
   1306            
   1307            /* Wait until DMA Transfer Complete */
   1308            IOE_TimeOut = 2 * TIMEOUT_MAX;
   \   0000014A   ....               LDR.N    R0,??DataTable13_4
   \   0000014C   4FF4C041           MOV      R1,#+24576
   \   00000150   0160               STR      R1,[R0, #+0]
   1309            while (!DMA_GetFlagStatus(IOE_DMA_RX_STREAM, IOE_DMA_RX_TCFLAG))
   \                     ??I2C_ReadDataBuffer_11:
   \   00000152   ....               LDR.N    R1,??DataTable13_14  ;; 0x10000020
   \   00000154   ....               LDR.N    R0,??DataTable13_13  ;; 0x40026010
   \   00000156   ........           BL       DMA_GetFlagStatus
   \   0000015A   0028               CMP      R0,#+0
   \   0000015C   08D1               BNE.N    ??I2C_ReadDataBuffer_12
   1310            {
   1311              if (IOE_TimeOut-- == 0) return(IOE_TimeoutUserCallback());
   \   0000015E   ....               LDR.N    R0,??DataTable13_4
   \   00000160   0068               LDR      R0,[R0, #+0]
   \   00000162   411E               SUBS     R1,R0,#+1
   \   00000164   ....               LDR.N    R2,??DataTable13_4
   \   00000166   1160               STR      R1,[R2, #+0]
   \   00000168   0028               CMP      R0,#+0
   \   0000016A   F2D1               BNE.N    ??I2C_ReadDataBuffer_11
   \   0000016C   0220               MOVS     R0,#+2
   \   0000016E   19E0               B.N      ??I2C_ReadDataBuffer_2
   1312            }        
   1313            
   1314            /* Send STOP Condition */
   1315            I2C_GenerateSTOP(IOE_I2C, ENABLE);
   \                     ??I2C_ReadDataBuffer_12:
   \   00000170   0121               MOVS     R1,#+1
   \   00000172   ....               LDR.N    R0,??DataTable13_5  ;; 0x40005400
   \   00000174   ........           BL       I2C_GenerateSTOP
   1316            
   1317            /* Disable DMA RX Channel */
   1318            DMA_Cmd(IOE_DMA_RX_STREAM, DISABLE);
   \   00000178   0021               MOVS     R1,#+0
   \   0000017A   ....               LDR.N    R0,??DataTable13_13  ;; 0x40026010
   \   0000017C   ........           BL       DMA_Cmd
   1319            
   1320            /* Disable I2C DMA request */  
   1321            I2C_DMACmd(IOE_I2C,DISABLE);
   \   00000180   0021               MOVS     R1,#+0
   \   00000182   ....               LDR.N    R0,??DataTable13_5  ;; 0x40005400
   \   00000184   ........           BL       I2C_DMACmd
   1322            
   1323            /* Clear DMA RX Transfer Complete Flag */
   1324            DMA_ClearFlag(IOE_DMA_RX_STREAM,IOE_DMA_RX_TCFLAG);
   \   00000188   ....               LDR.N    R1,??DataTable13_14  ;; 0x10000020
   \   0000018A   ....               LDR.N    R0,??DataTable13_13  ;; 0x40026010
   \   0000018C   ........           BL       DMA_ClearFlag
   1325            
   1326            /* Reorganize received data */  
   1327            tmp = IOE_BufferRX[0];
   \   00000190   9DF80060           LDRB     R6,[SP, #+0]
   1328            IOE_BufferRX[0] = IOE_BufferRX[1];
   \   00000194   9DF80100           LDRB     R0,[SP, #+1]
   \   00000198   8DF80000           STRB     R0,[SP, #+0]
   1329            IOE_BufferRX[1] = tmp;
   \   0000019C   8DF80160           STRB     R6,[SP, #+1]
   1330            
   1331            /* return a pointer to the IOE_Buffer */
   1332            return *(uint16_t *)IOE_BufferRX; 
   \   000001A0   BDF80000           LDRH     R0,[SP, #+0]
   \                     ??I2C_ReadDataBuffer_2:
   \   000001A4   76BD               POP      {R1,R2,R4-R6,PC}  ;; return
   1333          }
   1334          
   1335          /**
   1336            * @brief  Return Touch Screen X position value
   1337            * @param  None
   1338            * @retval X position.
   1339            */

   \                                 In section .text, align 2, keep-with-next
   1340          static uint16_t IOE_TS_Read_X(void)
   1341          {
   \                     IOE_TS_Read_X:
   \   00000000   80B5               PUSH     {R7,LR}
   1342            int32_t x, xr;
   1343           
   1344            x = I2C_ReadDataBuffer(IOE_1_ADDR, IOE_REG_TSC_DATA_Y);
   \   00000002   4F21               MOVS     R1,#+79
   \   00000004   8220               MOVS     R0,#+130
   \   00000006   ........           BL       I2C_ReadDataBuffer
   1345            
   1346            /* first correction */
   1347            xr =  (x * 320) >> 12;
   \   0000000A   4FF4A071           MOV      R1,#+320
   \   0000000E   4843               MULS     R0,R1,R0
   \   00000010   0013               ASRS     R0,R0,#+12
   1348            /* second correction */
   1349            xr = ((xr * 32)/29) - 17;
   \   00000012   4001               LSLS     R0,R0,#+5
   \   00000014   1D21               MOVS     R1,#+29
   \   00000016   90FBF1F0           SDIV     R0,R0,R1
   \   0000001A   1138               SUBS     R0,R0,#+17
   1350            
   1351            if(xr <= 0)
   \   0000001C   0128               CMP      R0,#+1
   \   0000001E   00DA               BGE.N    ??IOE_TS_Read_X_0
   1352              xr = 0;
   \   00000020   0020               MOVS     R0,#+0
   1353            
   1354            return (uint16_t)(xr); 
   \                     ??IOE_TS_Read_X_0:
   \   00000022   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   02BD               POP      {R1,PC}          ;; return
   1355          }
   1356          
   1357          /**
   1358            * @brief  Return Touch Screen Y position value
   1359            * @param  None
   1360            * @retval Y position.
   1361            */

   \                                 In section .text, align 2, keep-with-next
   1362          static uint16_t IOE_TS_Read_Y(void)
   1363          {
   \                     IOE_TS_Read_Y:
   \   00000000   80B5               PUSH     {R7,LR}
   1364            int32_t y, yr;
   1365            y= I2C_ReadDataBuffer(IOE_1_ADDR, IOE_REG_TSC_DATA_X);
   \   00000002   4D21               MOVS     R1,#+77
   \   00000004   8220               MOVS     R0,#+130
   \   00000006   ........           BL       I2C_ReadDataBuffer
   1366            
   1367            yr= (y * 240) >> 12;
   \   0000000A   F021               MOVS     R1,#+240
   \   0000000C   4843               MULS     R0,R1,R0
   \   0000000E   0013               ASRS     R0,R0,#+12
   1368            yr = ((yr * 240) / 217) - 12;
   \   00000010   F021               MOVS     R1,#+240
   \   00000012   4843               MULS     R0,R1,R0
   \   00000014   D921               MOVS     R1,#+217
   \   00000016   90FBF1F0           SDIV     R0,R0,R1
   \   0000001A   0C38               SUBS     R0,R0,#+12
   1369            
   1370            if(yr <= 0)
   \   0000001C   0128               CMP      R0,#+1
   \   0000001E   00DA               BGE.N    ??IOE_TS_Read_Y_0
   1371              yr = 0;
   \   00000020   0020               MOVS     R0,#+0
   1372            
   1373            return (uint16_t)(yr); 
   \                     ??IOE_TS_Read_Y_0:
   \   00000022   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   02BD               POP      {R1,PC}          ;; return
   1374          }
   1375          
   1376          /**
   1377            * @brief  Return Touch Screen Z position value
   1378            * @param  None
   1379            * @retval Z position.
   1380            */

   \                                 In section .text, align 2, keep-with-next
   1381          static uint16_t IOE_TS_Read_Z(void)
   1382          {
   \                     IOE_TS_Read_Z:
   \   00000000   80B5               PUSH     {R7,LR}
   1383            uint32_t z;
   1384            z = I2C_ReadDataBuffer(IOE_1_ADDR, IOE_REG_TSC_DATA_Z);
   \   00000002   5121               MOVS     R1,#+81
   \   00000004   8220               MOVS     R0,#+130
   \   00000006   ........           BL       I2C_ReadDataBuffer
   1385            
   1386            
   1387            if(z <= 0)
   \   0000000A   0028               CMP      R0,#+0
   \   0000000C   00D1               BNE.N    ??IOE_TS_Read_Z_0
   1388              z = 0;
   \   0000000E   0020               MOVS     R0,#+0
   1389            
   1390            return (uint16_t)(z); 
   \                     ??IOE_TS_Read_Z_0:
   \   00000010   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000012   02BD               POP      {R1,PC}          ;; return
   1391          }
   1392          
   1393          /**
   1394            * @brief  Initializes the GPIO pins used by the IO expander.
   1395            * @param  None
   1396            * @retval None
   1397            */

   \                                 In section .text, align 2, keep-with-next
   1398          static void IOE_GPIO_Config(void)
   1399          {
   \                     IOE_GPIO_Config:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   83B0               SUB      SP,SP,#+12
   1400            GPIO_InitTypeDef GPIO_InitStructure;
   1401            
   1402            /* Enable IOE_I2C and IOE_I2C_GPIO_PORT & Alternate Function clocks */
   1403            RCC_APB1PeriphClockCmd(IOE_I2C_CLK, ENABLE);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   5FF40010           MOVS     R0,#+2097152
   \   0000000A   ........           BL       RCC_APB1PeriphClockCmd
   1404            RCC_AHB1PeriphClockCmd(IOE_I2C_SCL_GPIO_CLK | IOE_I2C_SDA_GPIO_CLK |
   1405                                   IOE_IT_GPIO_CLK, ENABLE);
   \   0000000E   0121               MOVS     R1,#+1
   \   00000010   4FF48170           MOV      R0,#+258
   \   00000014   ........           BL       RCC_AHB1PeriphClockCmd
   1406            RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
   \   00000018   0121               MOVS     R1,#+1
   \   0000001A   4FF48040           MOV      R0,#+16384
   \   0000001E   ........           BL       RCC_APB2PeriphClockCmd
   1407            
   1408            /* Reset IOE_I2C IP */
   1409            RCC_APB1PeriphResetCmd(IOE_I2C_CLK, ENABLE);
   \   00000022   0121               MOVS     R1,#+1
   \   00000024   5FF40010           MOVS     R0,#+2097152
   \   00000028   ........           BL       RCC_APB1PeriphResetCmd
   1410            
   1411            /* Release reset signal of IOE_I2C IP */
   1412            RCC_APB1PeriphResetCmd(IOE_I2C_CLK, DISABLE);
   \   0000002C   0021               MOVS     R1,#+0
   \   0000002E   5FF40010           MOVS     R0,#+2097152
   \   00000032   ........           BL       RCC_APB1PeriphResetCmd
   1413            
   1414            /* IOE_I2C SCL and SDA pins configuration */
   1415            GPIO_InitStructure.GPIO_Pin = IOE_I2C_SCL_PIN;
   \   00000036   4020               MOVS     R0,#+64
   \   00000038   0090               STR      R0,[SP, #+0]
   1416            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   0000003A   0220               MOVS     R0,#+2
   \   0000003C   8DF80400           STRB     R0,[SP, #+4]
   1417            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000040   0220               MOVS     R0,#+2
   \   00000042   8DF80500           STRB     R0,[SP, #+5]
   1418            GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
   \   00000046   0120               MOVS     R0,#+1
   \   00000048   8DF80600           STRB     R0,[SP, #+6]
   1419            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
   \   0000004C   0020               MOVS     R0,#+0
   \   0000004E   8DF80700           STRB     R0,[SP, #+7]
   1420            GPIO_Init(IOE_I2C_SCL_GPIO_PORT, &GPIO_InitStructure);
   \   00000052   00A9               ADD      R1,SP,#+0
   \   00000054   ....               LDR.N    R0,??DataTable13_15  ;; 0x40020400
   \   00000056   ........           BL       GPIO_Init
   1421          
   1422            GPIO_InitStructure.GPIO_Pin = IOE_I2C_SDA_PIN;
   \   0000005A   4FF40070           MOV      R0,#+512
   \   0000005E   0090               STR      R0,[SP, #+0]
   1423            GPIO_Init(IOE_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
   \   00000060   00A9               ADD      R1,SP,#+0
   \   00000062   ....               LDR.N    R0,??DataTable13_15  ;; 0x40020400
   \   00000064   ........           BL       GPIO_Init
   1424            
   1425            GPIO_PinAFConfig(IOE_I2C_SCL_GPIO_PORT, IOE_I2C_SCL_SOURCE, IOE_I2C_SCL_AF);
   \   00000068   0422               MOVS     R2,#+4
   \   0000006A   0621               MOVS     R1,#+6
   \   0000006C   ....               LDR.N    R0,??DataTable13_15  ;; 0x40020400
   \   0000006E   ........           BL       GPIO_PinAFConfig
   1426            GPIO_PinAFConfig(IOE_I2C_SDA_GPIO_PORT, IOE_I2C_SDA_SOURCE, IOE_I2C_SDA_AF);  
   \   00000072   0422               MOVS     R2,#+4
   \   00000074   0921               MOVS     R1,#+9
   \   00000076   ....               LDR.N    R0,??DataTable13_15  ;; 0x40020400
   \   00000078   ........           BL       GPIO_PinAFConfig
   1427            
   1428            /* Set EXTI pin as Input PullUp - IO_Expander_INT */
   1429            GPIO_InitStructure.GPIO_Pin = IOE_IT_PIN;
   \   0000007C   0420               MOVS     R0,#+4
   \   0000007E   0090               STR      R0,[SP, #+0]
   1430            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   00000080   0020               MOVS     R0,#+0
   \   00000082   8DF80400           STRB     R0,[SP, #+4]
   1431            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
   \   00000086   0020               MOVS     R0,#+0
   \   00000088   8DF80700           STRB     R0,[SP, #+7]
   1432            GPIO_Init(IOE_IT_GPIO_PORT, &GPIO_InitStructure);  
   \   0000008C   00A9               ADD      R1,SP,#+0
   \   0000008E   ....               LDR.N    R0,??DataTable13_16  ;; 0x40022000
   \   00000090   ........           BL       GPIO_Init
   1433            
   1434            /* Connect Button EXTI Line to Button GPIO Pin */
   1435            SYSCFG_EXTILineConfig(IOE_IT_EXTI_PORT_SOURCE, IOE_IT_EXTI_PIN_SOURCE);  
   \   00000094   0221               MOVS     R1,#+2
   \   00000096   0820               MOVS     R0,#+8
   \   00000098   ........           BL       SYSCFG_EXTILineConfig
   1436          }
   \   0000009C   07BD               POP      {R0-R2,PC}       ;; return
   1437          
   1438          /**
   1439            * @brief  Configure the I2C Peripheral used to communicate with IO_Expanders.
   1440            * @param  None
   1441            * @retval None
   1442            */

   \                                 In section .text, align 2, keep-with-next
   1443          static void IOE_I2C_Config(void)
   1444          {
   \                     IOE_I2C_Config:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   85B0               SUB      SP,SP,#+20
   1445            I2C_InitTypeDef I2C_InitStructure;
   1446            
   1447            /* IOE_I2C configuration */
   1448            I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   ADF80400           STRH     R0,[SP, #+4]
   1449            I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
   \   0000000A   4BF6FF70           MOVW     R0,#+49151
   \   0000000E   ADF80600           STRH     R0,[SP, #+6]
   1450            I2C_InitStructure.I2C_OwnAddress1 = 0x00;
   \   00000012   0020               MOVS     R0,#+0
   \   00000014   ADF80800           STRH     R0,[SP, #+8]
   1451            I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
   \   00000018   4FF48060           MOV      R0,#+1024
   \   0000001C   ADF80A00           STRH     R0,[SP, #+10]
   1452            I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
   \   00000020   4FF48040           MOV      R0,#+16384
   \   00000024   ADF80C00           STRH     R0,[SP, #+12]
   1453            I2C_InitStructure.I2C_ClockSpeed = IOE_I2C_SPEED;
   \   00000028   ....               LDR.N    R0,??DataTable13_17  ;; 0x61a80
   \   0000002A   0090               STR      R0,[SP, #+0]
   1454            
   1455            I2C_Init(IOE_I2C, &I2C_InitStructure);
   \   0000002C   00A9               ADD      R1,SP,#+0
   \   0000002E   ....               LDR.N    R0,??DataTable13_5  ;; 0x40005400
   \   00000030   ........           BL       I2C_Init
   1456          }
   \   00000034   05B0               ADD      SP,SP,#+20
   \   00000036   00BD               POP      {PC}             ;; return
   1457          
   1458          /**
   1459            * @brief  Configure the DMA Peripheral used to handle communication via I2C.
   1460            * @param  None
   1461            * @retval None
   1462            */
   1463          

   \                                 In section .text, align 2, keep-with-next
   1464          static void IOE_DMA_Config(IOE_DMADirection_TypeDef Direction, uint8_t* buffer)
   1465          {
   \                     IOE_DMA_Config:
   \   00000000   30B5               PUSH     {R4,R5,LR}
   \   00000002   8FB0               SUB      SP,SP,#+60
   \   00000004   0400               MOVS     R4,R0
   \   00000006   0D00               MOVS     R5,R1
   1466            DMA_InitTypeDef DMA_InitStructure;
   1467            
   1468            RCC_AHB1PeriphClockCmd(IOE_DMA_CLK, ENABLE);
   \   00000008   0121               MOVS     R1,#+1
   \   0000000A   5FF40010           MOVS     R0,#+2097152
   \   0000000E   ........           BL       RCC_AHB1PeriphClockCmd
   1469            
   1470            /* Initialize the DMA_Channel member */
   1471            DMA_InitStructure.DMA_Channel = IOE_DMA_CHANNEL;
   \   00000012   5FF00070           MOVS     R0,#+33554432
   \   00000016   0090               STR      R0,[SP, #+0]
   1472            
   1473            /* Initialize the DMA_PeripheralBaseAddr member */
   1474            DMA_InitStructure.DMA_PeripheralBaseAddr = IOE_I2C_DR;
   \   00000018   ....               LDR.N    R0,??DataTable13_18  ;; 0x40005410
   \   0000001A   0190               STR      R0,[SP, #+4]
   1475            
   1476            /* Initialize the DMA_Memory0BaseAddr member */
   1477            DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)buffer;
   \   0000001C   0295               STR      R5,[SP, #+8]
   1478            
   1479            /* Initialize the DMA_PeripheralInc member */
   1480            DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
   \   0000001E   0020               MOVS     R0,#+0
   \   00000020   0590               STR      R0,[SP, #+20]
   1481            
   1482            /* Initialize the DMA_MemoryInc member */
   1483            DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
   \   00000022   4FF48060           MOV      R0,#+1024
   \   00000026   0690               STR      R0,[SP, #+24]
   1484            
   1485            /* Initialize the DMA_PeripheralDataSize member */
   1486            DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
   \   00000028   0020               MOVS     R0,#+0
   \   0000002A   0790               STR      R0,[SP, #+28]
   1487            
   1488            /* Initialize the DMA_MemoryDataSize member */
   1489            DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
   \   0000002C   0020               MOVS     R0,#+0
   \   0000002E   0890               STR      R0,[SP, #+32]
   1490            
   1491            /* Initialize the DMA_Mode member */
   1492            DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
   \   00000030   0020               MOVS     R0,#+0
   \   00000032   0990               STR      R0,[SP, #+36]
   1493            
   1494            /* Initialize the DMA_Priority member */
   1495            DMA_InitStructure.DMA_Priority = DMA_Priority_Low;
   \   00000034   0020               MOVS     R0,#+0
   \   00000036   0A90               STR      R0,[SP, #+40]
   1496            
   1497            /* Initialize the DMA_FIFOMode member */
   1498            DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Enable;
   \   00000038   0420               MOVS     R0,#+4
   \   0000003A   0B90               STR      R0,[SP, #+44]
   1499            
   1500            /* Initialize the DMA_FIFOThreshold member */
   1501            DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
   \   0000003C   0020               MOVS     R0,#+0
   \   0000003E   0C90               STR      R0,[SP, #+48]
   1502            
   1503            /* Initialize the DMA_MemoryBurst member */
   1504            DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
   \   00000040   0020               MOVS     R0,#+0
   \   00000042   0D90               STR      R0,[SP, #+52]
   1505            
   1506            /* Initialize the DMA_PeripheralBurst member */
   1507            DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
   \   00000044   0020               MOVS     R0,#+0
   \   00000046   0E90               STR      R0,[SP, #+56]
   1508            
   1509            /* If using DMA for Reception */
   1510            if (Direction == IOE_DMA_RX)
   \   00000048   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004A   012C               CMP      R4,#+1
   \   0000004C   0BD1               BNE.N    ??IOE_DMA_Config_0
   1511            {    
   1512              /* Initialize the DMA_DIR member */
   1513              DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
   \   0000004E   0020               MOVS     R0,#+0
   \   00000050   0390               STR      R0,[SP, #+12]
   1514              
   1515              /* Initialize the DMA_BufferSize member */
   1516              DMA_InitStructure.DMA_BufferSize = 2;
   \   00000052   0220               MOVS     R0,#+2
   \   00000054   0490               STR      R0,[SP, #+16]
   1517              
   1518              DMA_DeInit(IOE_DMA_RX_STREAM);
   \   00000056   ....               LDR.N    R0,??DataTable13_13  ;; 0x40026010
   \   00000058   ........           BL       DMA_DeInit
   1519              
   1520              DMA_Init(IOE_DMA_RX_STREAM, &DMA_InitStructure);
   \   0000005C   00A9               ADD      R1,SP,#+0
   \   0000005E   ....               LDR.N    R0,??DataTable13_13  ;; 0x40026010
   \   00000060   ........           BL       DMA_Init
   \   00000064   0DE0               B.N      ??IOE_DMA_Config_1
   1521            }
   1522            /* If using DMA for Transmission */
   1523            else if (Direction == IOE_DMA_TX)
   \                     ??IOE_DMA_Config_0:
   \   00000066   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000068   002C               CMP      R4,#+0
   \   0000006A   0AD1               BNE.N    ??IOE_DMA_Config_1
   1524            { 
   1525              /* Initialize the DMA_DIR member */
   1526              DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
   \   0000006C   4020               MOVS     R0,#+64
   \   0000006E   0390               STR      R0,[SP, #+12]
   1527              
   1528              /* Initialize the DMA_BufferSize member */
   1529              DMA_InitStructure.DMA_BufferSize = 1;
   \   00000070   0120               MOVS     R0,#+1
   \   00000072   0490               STR      R0,[SP, #+16]
   1530              
   1531              DMA_DeInit(IOE_DMA_TX_STREAM);
   \   00000074   ....               LDR.N    R0,??DataTable13_10  ;; 0x400260a0
   \   00000076   ........           BL       DMA_DeInit
   1532              
   1533              DMA_Init(IOE_DMA_TX_STREAM, &DMA_InitStructure);
   \   0000007A   00A9               ADD      R1,SP,#+0
   \   0000007C   ....               LDR.N    R0,??DataTable13_10  ;; 0x400260a0
   \   0000007E   ........           BL       DMA_Init
   1534            }
   1535          }
   \                     ??IOE_DMA_Config_1:
   \   00000082   0FB0               ADD      SP,SP,#+60
   \   00000084   30BD               POP      {R4,R5,PC}       ;; return
   1536          
   1537          
   1538          /**
   1539            * @brief  Configures the IO expander Interrupt line and GPIO in EXTI mode.
   1540            * @param  None        
   1541            * @retval None
   1542            */

   \                                 In section .text, align 2, keep-with-next
   1543          static void IOE_EXTI_Config(void)
   1544          {
   \                     IOE_EXTI_Config:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   85B0               SUB      SP,SP,#+20
   1545            GPIO_InitTypeDef GPIO_InitStructure;
   1546            NVIC_InitTypeDef NVIC_InitStructure;
   1547            EXTI_InitTypeDef EXTI_InitStructure;
   1548           
   1549            /* Enable GPIO clock */
   1550            RCC_AHB1PeriphClockCmd(IOE_IT_GPIO_CLK, ENABLE);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   4FF48070           MOV      R0,#+256
   \   0000000A   ........           BL       RCC_AHB1PeriphClockCmd
   1551            RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
   \   0000000E   0121               MOVS     R1,#+1
   \   00000010   4FF48040           MOV      R0,#+16384
   \   00000014   ........           BL       RCC_APB2PeriphClockCmd
   1552          
   1553            /* Configure Button pin as input floating */
   1554            GPIO_InitStructure.GPIO_Pin = IOE_IT_PIN;
   \   00000018   0420               MOVS     R0,#+4
   \   0000001A   0390               STR      R0,[SP, #+12]
   1555            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   0000001C   0020               MOVS     R0,#+0
   \   0000001E   8DF81000           STRB     R0,[SP, #+16]
   1556            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
   \   00000022   0020               MOVS     R0,#+0
   \   00000024   8DF81300           STRB     R0,[SP, #+19]
   1557            GPIO_Init(IOE_IT_GPIO_PORT, &GPIO_InitStructure);  
   \   00000028   03A9               ADD      R1,SP,#+12
   \   0000002A   ....               LDR.N    R0,??DataTable13_16  ;; 0x40022000
   \   0000002C   ........           BL       GPIO_Init
   1558            
   1559            /* Connect Button EXTI Line to Button GPIO Pin */
   1560            SYSCFG_EXTILineConfig(IOE_IT_EXTI_PORT_SOURCE, IOE_IT_EXTI_PIN_SOURCE);  
   \   00000030   0221               MOVS     R1,#+2
   \   00000032   0820               MOVS     R0,#+8
   \   00000034   ........           BL       SYSCFG_EXTILineConfig
   1561            
   1562            /* Configure Button EXTI line */
   1563            EXTI_InitStructure.EXTI_Line = IOE_IT_EXTI_LINE;
   \   00000038   0420               MOVS     R0,#+4
   \   0000003A   0190               STR      R0,[SP, #+4]
   1564            EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   0000003C   0020               MOVS     R0,#+0
   \   0000003E   8DF80800           STRB     R0,[SP, #+8]
   1565            EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;  
   \   00000042   1020               MOVS     R0,#+16
   \   00000044   8DF80900           STRB     R0,[SP, #+9]
   1566            EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   00000048   0120               MOVS     R0,#+1
   \   0000004A   8DF80A00           STRB     R0,[SP, #+10]
   1567            EXTI_Init(&EXTI_InitStructure);
   \   0000004E   01A8               ADD      R0,SP,#+4
   \   00000050   ........           BL       EXTI_Init
   1568            
   1569            /* Enable and set Button EXTI Interrupt to the lowest priority */
   1570            NVIC_InitStructure.NVIC_IRQChannel = IOE_IT_EXTI_IRQn;
   \   00000054   0820               MOVS     R0,#+8
   \   00000056   8DF80000           STRB     R0,[SP, #+0]
   1571            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0F;
   \   0000005A   0F20               MOVS     R0,#+15
   \   0000005C   8DF80100           STRB     R0,[SP, #+1]
   1572            NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F;
   \   00000060   0F20               MOVS     R0,#+15
   \   00000062   8DF80200           STRB     R0,[SP, #+2]
   1573            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000066   0120               MOVS     R0,#+1
   \   00000068   8DF80300           STRB     R0,[SP, #+3]
   1574            NVIC_Init(&NVIC_InitStructure);
   \   0000006C   00A8               ADD      R0,SP,#+0
   \   0000006E   ........           BL       NVIC_Init
   1575          }
   \   00000072   05B0               ADD      SP,SP,#+20
   \   00000074   00BD               POP      {PC}             ;; return
   1576          
   1577          #ifndef USE_Delay
   1578          /**
   1579            * @brief  Inserts a delay time.
   1580            * @param  nCount: specifies the delay time length.
   1581            * @retval None
   1582            */

   \                                 In section .text, align 2, keep-with-next
   1583          static void delay(__IO uint32_t nCount)
   1584          {
   \                     delay:
   \   00000000   01B4               PUSH     {R0}
   \   00000002   81B0               SUB      SP,SP,#+4
   1585            __IO uint32_t index = 0; 
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   0090               STR      R0,[SP, #+0]
   1586            for(index = (100000 * nCount); index != 0; index--)
   \   00000008   0198               LDR      R0,[SP, #+4]
   \   0000000A   ....               LDR.N    R1,??DataTable13_19  ;; 0x186a0
   \   0000000C   4843               MULS     R0,R1,R0
   \   0000000E   0090               STR      R0,[SP, #+0]
   \   00000010   02E0               B.N      ??delay_0
   \                     ??delay_1:
   \   00000012   0098               LDR      R0,[SP, #+0]
   \   00000014   401E               SUBS     R0,R0,#+1
   \   00000016   0090               STR      R0,[SP, #+0]
   \                     ??delay_0:
   \   00000018   0098               LDR      R0,[SP, #+0]
   \   0000001A   0028               CMP      R0,#+0
   \   0000001C   F9D1               BNE.N    ??delay_1
   1587            {
   1588            }
   1589          }
   \   0000001E   02B0               ADD      SP,SP,#+8
   \   00000020   7047               BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   ........           DC32     TS_State

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   ........           DC32     ??_x

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   ........           DC32     ??_y

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   ........           DC32     ??tmp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   ........           DC32     IOE_TimeOut

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   00540040           DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   01000010           DC32     0x10000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   82000700           DC32     0x70082

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   80000010           DC32     0x10000080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   04000010           DC32     0x10000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   A0600240           DC32     0x400260a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   00002020           DC32     0x20200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   02000300           DC32     0x30002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \   00000000   10600240           DC32     0x40026010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_14:
   \   00000000   20000010           DC32     0x10000020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_15:
   \   00000000   00040240           DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_16:
   \   00000000   00200240           DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_17:
   \   00000000   801A0600           DC32     0x61a80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_18:
   \   00000000   10540040           DC32     0x40005410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_19:
   \   00000000   A0860100           DC32     0x186a0

   \                                 In section .text, align 2, keep-with-next
   \                     `?<Constant {0, 0}>`:
   \   00000000                      ; Initializer data, 2 bytes
   \   00000000   0000               DC8 0, 0

   \                                 In section .text, align 2, keep-with-next
   \                     `?<Constant {0, 0}>_1`:
   \   00000000                      ; Initializer data, 2 bytes
   \   00000000   0000               DC8 0, 0
   1590          #endif /* USE_Delay*/
   1591          /**
   1592            * @}
   1593            */ 
   1594          
   1595          /**
   1596            * @}
   1597            */ 
   1598          
   1599          /**
   1600            * @}
   1601            */ 
   1602          
   1603          /**
   1604            * @}
   1605            */ 
   1606          
   1607          /**
   1608            * @}
   1609            */      
   1610          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                .cstack
     --------                -------
     I2C_ReadDataBuffer          24
     I2C_ReadDeviceRegister      16
     I2C_WriteDeviceRegister     24
     IOE_ClearGITPending          8
     IOE_ClearIOITPending         8
     IOE_Config                   8
     IOE_DMA_Config              72
     IOE_EXTI_Config             24
     IOE_FnctCmd                 24
     IOE_GITCmd                  16
     IOE_GITConfig               24
     IOE_GPIO_Config             16
     IOE_GetGITStatus            16
     IOE_GetIOITStatus           16
     IOE_I2C_Config              24
     IOE_IOAFConfig              24
     IOE_IOEdgeConfig            24
     IOE_IOITConfig              24
     IOE_IOPinConfig             24
     IOE_ITConfig                 8
     IOE_ITOutConfig             16
     IOE_IsOperational            8
     IOE_JoyStickGetState         8
     IOE_ReadID                  16
     IOE_ReadIOPin                8
     IOE_Reset                    8
     IOE_TS_Config                8
     IOE_TS_GetState              8
     IOE_TS_Read_X                8
     IOE_TS_Read_Y                8
     IOE_TS_Read_Z                8
     IOE_TempSens_Config          8
     IOE_TempSens_GetData         8
     IOE_WriteIOPin               8
     delay                        8


   Section sizes:

     Function/Label          Bytes
     --------------          -----
     TS_State                   8
     IOE_TimeOut                4
     IOE_Config               216
     IOE_ITConfig             170
     IOE_WriteIOPin            64
     IOE_ReadIOPin             60
     IOE_JoyStickGetState      72
     IOE_TS_GetState          174
     _x                         4
     _y                         4
     IOE_TempSens_GetData     110
     tmp                        4
     IOE_GetGITStatus          40
     IOE_ClearGITPending       18
     IOE_GetIOITStatus         32
     IOE_ClearIOITPending      56
     IOE_IsOperational         38
     IOE_Reset                 38
     IOE_ReadID                38
     IOE_FnctCmd               52
     IOE_IOPinConfig           52
     IOE_GITCmd                52
     IOE_GITConfig             52
     IOE_IOITConfig            52
     IOE_TS_Config            218
     IOE_TempSens_Config       68
     IOE_IOAFConfig            52
     IOE_IOEdgeConfig          94
     IOE_ITOutConfig           76
     I2C_WriteDeviceRegister  366
     I2C_ReadDeviceRegister   462
     I2C_ReadDataBuffer       422
     IOE_TS_Read_X             38
     IOE_TS_Read_Y             38
     IOE_TS_Read_Z             20
     IOE_GPIO_Config          158
     IOE_I2C_Config            56
     IOE_DMA_Config           134
     IOE_EXTI_Config          118
     delay                     34
     ??DataTable13              4
     ??DataTable13_1            4
     ??DataTable13_2            4
     ??DataTable13_3            4
     ??DataTable13_4            4
     ??DataTable13_5            4
     ??DataTable13_6            4
     ??DataTable13_7            4
     ??DataTable13_8            4
     ??DataTable13_9            4
     ??DataTable13_10           4
     ??DataTable13_11           4
     ??DataTable13_12           4
     ??DataTable13_13           4
     ??DataTable13_14           4
     ??DataTable13_15           4
     ??DataTable13_16           4
     ??DataTable13_17           4
     ??DataTable13_18           4
     ??DataTable13_19           4
     ?<Constant {0, 0}>         2
     ?<Constant {0, 0}>_1       2

 
    20 bytes in section .bss
     4 bytes in section .data
 3 824 bytes in section .text
 
 3 824 bytes of CODE memory
    24 bytes of DATA memory

Errors: none
Warnings: none
