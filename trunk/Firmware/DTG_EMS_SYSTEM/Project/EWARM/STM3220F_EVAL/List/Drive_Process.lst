###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     19/Jan/2012  11:08:53 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\Drive_Pr #
#                    ocess.c                                                  #
#    Command line =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\Drive_Pr #
#                    ocess.c -D USE_STDPERIPH_DRIVER -D STM32F2XX -D          #
#                    USE_STM3220F_EVAL -D USE_USB_OTG_FS -D                   #
#                    RTC_CLOCK_SOURCE_LSE -lC F:\Work\S&G2000\Firmware\DTG_EM #
#                    S_SYSTEM\Project\EWARM\STM3220F_EVAL\List\ -lA           #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\ -o F:\Work\S&G2000\Firmware\DTG_EMS_SY #
#                    STEM\Project\EWARM\STM3220F_EVAL\Obj\ --no_cse           #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Full.h" -I                     #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWA #
#                    RM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I             #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I         #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\ -I                             #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\Common\ -I                      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_OTG_Driver\inc\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Core\inc\ -I      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\msc\inc\    #
#                    -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM #
#                    \..\Usb\ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Proj #
#                    ect\EWARM\..\Usb\Inc\ -I F:\Work\S&G2000\Firmware\DTG_EM #
#                    S_SYSTEM\Project\EWARM\..\Usb\src\ -I                    #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Core\inc\ -I        #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -Ol --use_c++_inline                                     #
#    List file    =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\Drive_Process.lst                       #
#    Object file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\Obj\Drive_Process.o                          #
#                                                                             #
#                                                                             #
###############################################################################

F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\Drive_Process.c
      1          
      2          #include "main.h"

   \                                 In section .text, align 2
   \   __intrinsic __interwork __softfp void *memcpy(void *, void const *, size_t)
   \                     memcpy:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           BL       __aeabi_memcpy
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   10BD               POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __intrinsic __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   1000               MOVS     R0,R2
   \   00000006   0A00               MOVS     R2,R1
   \   00000008   0100               MOVS     R1,R0
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   ........           BL       __aeabi_memset
   \   00000010   2000               MOVS     R0,R4
   \   00000012   10BD               POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LED1_OFF(void)
   \                     LED1_OFF:
   \   00000000   80B5               PUSH     {R7,LR}
   \   00000002   4FF40051           MOV      R1,#+8192
   \   00000006   ........           LDR.W    R0,??DataTable8  ;; 0x40021800
   \   0000000A   ........           BL       GPIO_SetBits
   \   0000000E   4FF48041           MOV      R1,#+16384
   \   00000012   ........           LDR.W    R0,??DataTable8  ;; 0x40021800
   \   00000016   ........           BL       GPIO_SetBits
   \   0000001A   01BD               POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LED1_RED(void)
   \                     LED1_RED:
   \   00000000   80B5               PUSH     {R7,LR}
   \   00000002   4FF40051           MOV      R1,#+8192
   \   00000006   ........           LDR.W    R0,??DataTable8  ;; 0x40021800
   \   0000000A   ........           BL       GPIO_ResetBits
   \   0000000E   4FF48041           MOV      R1,#+16384
   \   00000012   ........           LDR.W    R0,??DataTable8  ;; 0x40021800
   \   00000016   ........           BL       GPIO_SetBits
   \   0000001A   01BD               POP      {R0,PC}          ;; return
      3          #include "Drive_Process.h"
      4          #include "Voice.h"
      5          #include "Memory.h"
      6          #include "Ems_System.h"
      7          #include "Voice.h"
      8          #include "RTC.h"
      9          #include "GraphicLcd.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void Lcd_Backlight_ON(void)
   \                     Lcd_Backlight_ON:
   \   00000000   80B5               PUSH     {R7,LR}
   \   00000002   4FF40061           MOV      R1,#+2048
   \   00000006   ........           LDR.W    R0,??DataTable8_1  ;; 0x40021400
   \   0000000A   ........           BL       GPIO_SetBits
   \   0000000E   01BD               POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void Lcd_Backlight_OFF(void)
   \                     Lcd_Backlight_OFF:
   \   00000000   80B5               PUSH     {R7,LR}
   \   00000002   4FF40061           MOV      R1,#+2048
   \   00000006   ........           LDR.W    R0,??DataTable8_1  ;; 0x40021400
   \   0000000A   ........           BL       GPIO_ResetBits
   \   0000000E   01BD               POP      {R0,PC}          ;; return
     10          #include "i2c_ee.h"
     11          #include "usbh_usr.h"
     12          

   \                                 In section .text, align 2, keep-with-next
     13          void Driver_Start(void) // 자동차 운전 시작하기 위한 준비
     14          {    
   \                     Driver_Start:
   \   00000000   80B5               PUSH     {R7,LR}
     15               // 해더 위치 잡기
     16          //     Setting_Header_Information(); 
     17          
     18               // EEPROM 에서 먼저 데이터를 읽어와야 한다.	
     19               //현재 헤더를 구한다.
     20          
     21               if( Flag.WatchDog == 0 )                // 전원 온시 와치독이 아니면 시작멘트
   \   00000002   ........           LDR.W    R0,??DataTable8_2
   \   00000006   007A               LDRB     R0,[R0, #+8]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   02D1               BNE.N    ??Driver_Start_0
     22                    Voice_OutAdd(VOICE_DRIVE_ON);
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   ........           BL       Voice_OutAdd
     23          
     24               if( Info.EcoStatus == 0 ) // 에코모드인가
   \                     ??Driver_Start_0:
   \   00000012   ........           LDR.W    R0,??DataTable8_3
   \   00000016   007E               LDRB     R0,[R0, #+24]
   \   00000018   0028               CMP      R0,#+0
   \   0000001A   02D1               BNE.N    ??Driver_Start_1
     25               {          
     26                    LED1_OFF();		// 아님
   \   0000001C   ........           BL       LED1_OFF
   \   00000020   09E0               B.N      ??Driver_Start_2
     27               }else
     28               {
     29                    LED1_RED();      // 에코모드
   \                     ??Driver_Start_1:
   \   00000022   ........           BL       LED1_RED
     30                    if( Flag.WatchDog == 0 )
   \   00000026   ........           LDR.W    R0,??DataTable8_2
   \   0000002A   007A               LDRB     R0,[R0, #+8]
   \   0000002C   0028               CMP      R0,#+0
   \   0000002E   02D1               BNE.N    ??Driver_Start_2
     31                         Voice_OutAdd(VOICE_ECO_ON);
   \   00000030   0620               MOVS     R0,#+6
   \   00000032   ........           BL       Voice_OutAdd
     32               }		     
     33               
     34               memset(&ECO_Driving, 0, sizeof (struct _ECO_Driving ));      //ECO 드라이브 클리어
   \                     ??Driver_Start_2:
   \   00000036   0A22               MOVS     R2,#+10
   \   00000038   0021               MOVS     R1,#+0
   \   0000003A   ........           LDR.W    R0,??DataTable8_4
   \   0000003E   ........           BL       memset
     35               
     36               
     37               if(ACC_Drive_Value.Total_StartMotor > 40000)       // 
   \   00000042   ........           LDR.W    R0,??DataTable8_5
   \   00000046   0088               LDRH     R0,[R0, #+0]
   \   00000048   49F64141           MOVW     R1,#+40001
   \   0000004C   8842               CMP      R0,R1
   \   0000004E   02D3               BCC.N    ??Driver_Start_3
     38               {
     39                    Voice_OutAdd(VOICE_STARTOVER);
   \   00000050   0920               MOVS     R0,#+9
   \   00000052   ........           BL       Voice_OutAdd
     40               }
     41               //     Info.Active_Flag = 1;		// 기기 활성화 플래그
     42          }
   \                     ??Driver_Start_3:
   \   00000056   01BD               POP      {R0,PC}          ;; return
     43          
     44          

   \                                 In section .text, align 2, keep-with-next
     45          void Driver_End(void) 			// 자동차 운행 종료
     46          {
   \                     Driver_End:
   \   00000000   80B5               PUSH     {R7,LR}
     47          
     48               DTG_EMS_DataSave(NAND_Header_Index.Page_Count, Info.DTG_DataCount);	     // NAND FLASH 데이터 저장
   \   00000002   ........           LDR.W    R0,??DataTable8_3
   \   00000006   90F85A10           LDRB     R1,[R0, #+90]
   \   0000000A   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   ........           LDR.W    R0,??DataTable8_6
   \   00000010   4068               LDR      R0,[R0, #+4]
   \   00000012   ........           BL       DTG_EMS_DataSave
     49          
     50               Info.DTG_DataCount = 0;    // 페이지 처음부터 작성하기
   \   00000016   ........           LDR.W    R0,??DataTable8_3
   \   0000001A   0021               MOVS     R1,#+0
   \   0000001C   80F85A10           STRB     R1,[R0, #+90]
     51               memset(DTG_NAND_Binary,0, sizeof(DTG_NAND_Binary));     
   \   00000020   41F6F602           MOVW     R2,#+6390
   \   00000024   0021               MOVS     R1,#+0
   \   00000026   ........           LDR.W    R0,??DataTable8_7
   \   0000002A   ........           BL       memset
     52               
     53               // =========================================================================  
     54          
     55               Write_Header_EMS();                     // 누적 운행거리 저장
   \   0000002E   ........           BL       Write_Header_EMS
     56          
     57               if(NAND_Data_Transmit.End_Page >= MAX_NAND_PAGE)
   \   00000032   ........           LDR.W    R0,??DataTable8_8
   \   00000036   4068               LDR      R0,[R0, #+4]
   \   00000038   ........           LDR.W    R1,??DataTable8_9  ;; 0x3e7ff
   \   0000003C   8842               CMP      R0,R1
   \   0000003E   04D3               BCC.N    ??Driver_End_0
     58                    NAND_Data_Transmit.End_Page = 0;
   \   00000040   ........           LDR.W    R0,??DataTable8_8
   \   00000044   0021               MOVS     R1,#+0
   \   00000046   4160               STR      R1,[R0, #+4]
   \   00000048   06E0               B.N      ??Driver_End_1
     59               else
     60                    NAND_Data_Transmit.End_Page ++;         // 데이터 전송 페이지 저장
   \                     ??Driver_End_0:
   \   0000004A   ........           LDR.W    R0,??DataTable8_8
   \   0000004E   4068               LDR      R0,[R0, #+4]
   \   00000050   401C               ADDS     R0,R0,#+1
   \   00000052   ........           LDR.W    R1,??DataTable8_8
   \   00000056   4860               STR      R0,[R1, #+4]
     61          
     62               if(NAND_Header_Index.Page_Count >= MAX_NAND_PAGE)
   \                     ??Driver_End_1:
   \   00000058   ........           LDR.W    R0,??DataTable8_6
   \   0000005C   4068               LDR      R0,[R0, #+4]
   \   0000005E   ........           LDR.W    R1,??DataTable8_9  ;; 0x3e7ff
   \   00000062   8842               CMP      R0,R1
   \   00000064   04D3               BCC.N    ??Driver_End_2
     63                    NAND_Header_Index.Page_Count = 0;
   \   00000066   ........           LDR.W    R0,??DataTable8_6
   \   0000006A   0021               MOVS     R1,#+0
   \   0000006C   4160               STR      R1,[R0, #+4]
   \   0000006E   06E0               B.N      ??Driver_End_3
     64               else
     65                    NAND_Header_Index.Page_Count ++;
   \                     ??Driver_End_2:
   \   00000070   ........           LDR.W    R0,??DataTable8_6
   \   00000074   4068               LDR      R0,[R0, #+4]
   \   00000076   401C               ADDS     R0,R0,#+1
   \   00000078   ........           LDR.W    R1,??DataTable8_6
   \   0000007C   4860               STR      R0,[R1, #+4]
     66               if(NAND_Header_Info.End_Page >= MAX_NAND_PAGE)        
   \                     ??Driver_End_3:
   \   0000007E   ........           LDR.W    R0,??DataTable8_10
   \   00000082   8068               LDR      R0,[R0, #+8]
   \   00000084   ........           LDR.W    R1,??DataTable8_9  ;; 0x3e7ff
   \   00000088   8842               CMP      R0,R1
   \   0000008A   04D3               BCC.N    ??Driver_End_4
     67                    NAND_Header_Info.End_Page = 0;
   \   0000008C   ........           LDR.W    R0,??DataTable8_10
   \   00000090   0021               MOVS     R1,#+0
   \   00000092   8160               STR      R1,[R0, #+8]
   \   00000094   06E0               B.N      ??Driver_End_5
     68               else
     69                    NAND_Header_Info.End_Page++;
   \                     ??Driver_End_4:
   \   00000096   ........           LDR.W    R0,??DataTable8_10
   \   0000009A   8068               LDR      R0,[R0, #+8]
   \   0000009C   401C               ADDS     R0,R0,#+1
   \   0000009E   ........           LDR.W    R1,??DataTable8_10
   \   000000A2   8860               STR      R0,[R1, #+8]
     70               
     71               Write_Header_Information();                  // 해더 정보를 저장 	
   \                     ??Driver_End_5:
   \   000000A4   ........           BL       Write_Header_Information
     72               
     73               Write_Header_Index();                         // 해더 인덱스 정보를 저장 하고
   \   000000A8   ........           BL       Write_Header_Index
     74               
     75               Write_Transmit_Header();
   \   000000AC   ........           BL       Write_Transmit_Header
     76          }
   \   000000B0   01BD               POP      {R0,PC}          ;; return
     77          

   \                                 In section .text, align 2, keep-with-next
     78          void Drive_Acceident_Check(void)
     79          {
   \                     Drive_Acceident_Check:
   \   00000000   30B5               PUSH     {R4,R5,LR}
   \   00000002   85B0               SUB      SP,SP,#+20
     80               u16 GapTemp;
     81               u16 BufferSize ;
     82               if(Flag.Accident_Step == 0)  //    이벤트가 발생했다면
   \   00000004   ........           LDR.W    R0,??DataTable8_2
   \   00000008   4079               LDRB     R0,[R0, #+5]
   \   0000000A   0028               CMP      R0,#+0
   \   0000000C   00F0B180           BEQ.W    ??Drive_Acceident_Check_0
     83                    return;
     84               
     85               switch(Flag.Accident_Step ) 
   \                     ??Drive_Acceident_Check_1:
   \   00000010   ........           LDR.W    R0,??DataTable8_2
   \   00000014   4079               LDRB     R0,[R0, #+5]
   \   00000016   0128               CMP      R0,#+1
   \   00000018   09D0               BEQ.N    ??Drive_Acceident_Check_2
   \   0000001A   C0F0AA80           BCC.W    ??Drive_Acceident_Check_3
   \   0000001E   0328               CMP      R0,#+3
   \   00000020   00F08880           BEQ.W    ??Drive_Acceident_Check_4
   \   00000024   04D3               BCC.N    ??Drive_Acceident_Check_5
   \   00000026   0428               CMP      R0,#+4
   \   00000028   00F08580           BEQ.W    ??Drive_Acceident_Check_6
   \   0000002C   A1E0               B.N      ??Drive_Acceident_Check_3
     86               {
     87               case 1:
     88                    {
     89                         // 기다리기
     90                    }
     91                    break;
   \                     ??Drive_Acceident_Check_2:
   \   0000002E   A0E0               B.N      ??Drive_Acceident_Check_3
     92               case 2:
     93                    {
     94                         sprintf((char *) Accident_Time, "%02d%02d%02d%02d%02d%02d"
     95                                 ,SYSTEM_TIME.tm_year-2000,SYSTEM_TIME.tm_mon,SYSTEM_TIME.tm_mday
     96                                 ,SYSTEM_TIME.tm_hour,SYSTEM_TIME.tm_min,SYSTEM_TIME.tm_sec);          
   \                     ??Drive_Acceident_Check_5:
   \   00000030   ........           LDR.W    R0,??DataTable8_11
   \   00000034   0068               LDR      R0,[R0, #+0]
   \   00000036   0390               STR      R0,[SP, #+12]
   \   00000038   ....               LDR.N    R0,??DataTable8_11
   \   0000003A   4068               LDR      R0,[R0, #+4]
   \   0000003C   0290               STR      R0,[SP, #+8]
   \   0000003E   ....               LDR.N    R0,??DataTable8_11
   \   00000040   8068               LDR      R0,[R0, #+8]
   \   00000042   0190               STR      R0,[SP, #+4]
   \   00000044   ....               LDR.N    R0,??DataTable8_11
   \   00000046   C068               LDR      R0,[R0, #+12]
   \   00000048   0090               STR      R0,[SP, #+0]
   \   0000004A   ....               LDR.N    R0,??DataTable8_11
   \   0000004C   0369               LDR      R3,[R0, #+16]
   \   0000004E   ....               LDR.N    R0,??DataTable8_11
   \   00000050   4069               LDR      R0,[R0, #+20]
   \   00000052   B0F5FA62           SUBS     R2,R0,#+2000
   \   00000056   ........           ADR.W    R1,`?<Constant "%02d%02d%02d%02d%02d%02d">`
   \   0000005A   ....               LDR.N    R0,??DataTable8_12
   \   0000005C   ........           BL       sprintf
     97                         GapTemp = 1000 - AccidentPoint;
   \   00000060   4FF47A70           MOV      R0,#+1000
   \   00000064   ....               LDR.N    R1,??DataTable8_13
   \   00000066   0988               LDRH     R1,[R1, #+0]
   \   00000068   441A               SUBS     R4,R0,R1
     98                         BufferSize = sizeof(Accident_Buffer[0]);
   \   0000006A   0825               MOVS     R5,#+8
     99                         memcpy(&Accident_SaveBuffer[GapTemp], &Accident_Buffer, AccidentPoint * BufferSize);
   \   0000006C   ....               LDR.N    R0,??DataTable8_13
   \   0000006E   0088               LDRH     R0,[R0, #+0]
   \   00000070   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000072   05FB00F2           MUL      R2,R5,R0
   \   00000076   ....               LDR.N    R1,??DataTable8_14
   \   00000078   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000007A   ....               LDR.N    R0,??DataTable8_15
   \   0000007C   10EBC400           ADDS     R0,R0,R4, LSL #+3
   \   00000080   ........           BL       memcpy
    100                         memcpy(&Accident_SaveBuffer, &Accident_Buffer[AccidentPoint], GapTemp * BufferSize);
   \   00000084   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000086   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000088   05FB04F2           MUL      R2,R5,R4
   \   0000008C   ....               LDR.N    R0,??DataTable8_13
   \   0000008E   0088               LDRH     R0,[R0, #+0]
   \   00000090   ....               LDR.N    R1,??DataTable8_14
   \   00000092   11EBC001           ADDS     R1,R1,R0, LSL #+3
   \   00000096   ....               LDR.N    R0,??DataTable8_15
   \   00000098   ........           BL       memcpy
    101          
    102                         
    103                         GapTemp = 10 - AccidentPoint2;
   \   0000009C   ....               LDR.N    R0,??DataTable8_16
   \   0000009E   0088               LDRH     R0,[R0, #+0]
   \   000000A0   D0F10A04           RSBS     R4,R0,#+10
    104                         BufferSize = sizeof(Accident2_Buffer[0]);
   \   000000A4   1125               MOVS     R5,#+17
    105                         memcpy(&Accident2_SaveBuffer[GapTemp], &Accident2_Buffer, AccidentPoint2 * BufferSize);
   \   000000A6   ....               LDR.N    R0,??DataTable8_16
   \   000000A8   0088               LDRH     R0,[R0, #+0]
   \   000000AA   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000AC   05FB00F2           MUL      R2,R5,R0
   \   000000B0   ....               LDR.N    R1,??DataTable8_17
   \   000000B2   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000B4   1120               MOVS     R0,#+17
   \   000000B6   ....               LDR.N    R3,??DataTable8_18
   \   000000B8   00FB0430           MLA      R0,R0,R4,R3
   \   000000BC   ........           BL       memcpy
    106                         memcpy(&Accident2_SaveBuffer, &Accident2_Buffer[AccidentPoint2], GapTemp * BufferSize);
   \   000000C0   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000C2   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000C4   05FB04F2           MUL      R2,R5,R4
   \   000000C8   ....               LDR.N    R0,??DataTable8_16
   \   000000CA   0088               LDRH     R0,[R0, #+0]
   \   000000CC   1121               MOVS     R1,#+17
   \   000000CE   ....               LDR.N    R3,??DataTable8_17
   \   000000D0   01FB0031           MLA      R1,R1,R0,R3
   \   000000D4   ....               LDR.N    R0,??DataTable8_18
   \   000000D6   ........           BL       memcpy
    107          
    108                         if(Info.Accident_WritePoint >= 640)
   \   000000DA   ....               LDR.N    R0,??DataTable8_3
   \   000000DC   C08C               LDRH     R0,[R0, #+38]
   \   000000DE   4FF42071           MOV      R1,#+640
   \   000000E2   8842               CMP      R0,R1
   \   000000E4   02D3               BCC.N    ??Drive_Acceident_Check_7
    109                              Info.Accident_WritePoint = 0;
   \   000000E6   ....               LDR.N    R0,??DataTable8_3
   \   000000E8   0021               MOVS     R1,#+0
   \   000000EA   C184               STRH     R1,[R0, #+38]
    110                         if(Info.AccidentCount >= 640)
   \                     ??Drive_Acceident_Check_7:
   \   000000EC   ....               LDR.N    R0,??DataTable8_3
   \   000000EE   808C               LDRH     R0,[R0, #+36]
   \   000000F0   4FF42071           MOV      R1,#+640
   \   000000F4   8842               CMP      R0,R1
   \   000000F6   03D3               BCC.N    ??Drive_Acceident_Check_8
    111                              Info.AccidentCount = 640;
   \   000000F8   ....               LDR.N    R0,??DataTable8_3
   \   000000FA   4FF42071           MOV      R1,#+640
   \   000000FE   8184               STRH     R1,[R0, #+36]
    112                         
    113                         Accident_DataSave(Info.Accident_WritePoint++);
   \                     ??Drive_Acceident_Check_8:
   \   00000100   ....               LDR.N    R0,??DataTable8_3
   \   00000102   C08C               LDRH     R0,[R0, #+38]
   \   00000104   ....               LDR.N    R1,??DataTable8_3
   \   00000106   421C               ADDS     R2,R0,#+1
   \   00000108   CA84               STRH     R2,[R1, #+38]
   \   0000010A   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000010C   ........           BL       Accident_DataSave
    114                         
    115                         Info.AccidentCount++;
   \   00000110   ....               LDR.N    R0,??DataTable8_3
   \   00000112   808C               LDRH     R0,[R0, #+36]
   \   00000114   401C               ADDS     R0,R0,#+1
   \   00000116   ....               LDR.N    R1,??DataTable8_3
   \   00000118   8884               STRH     R0,[R1, #+36]
    116                         
    117                         Flag.Accident_Step = 3;       // 후반부 데이터 받기               
   \   0000011A   ....               LDR.N    R0,??DataTable8_2
   \   0000011C   0321               MOVS     R1,#+3
   \   0000011E   4171               STRB     R1,[R0, #+5]
    118                         AccidentPoint = 0;           // 포인트 클리어              
   \   00000120   ....               LDR.N    R0,??DataTable8_13
   \   00000122   0021               MOVS     R1,#+0
   \   00000124   0180               STRH     R1,[R0, #+0]
    119                         AccidentPoint2 = 0;
   \   00000126   ....               LDR.N    R0,??DataTable8_16
   \   00000128   0021               MOVS     R1,#+0
   \   0000012A   0180               STRH     R1,[R0, #+0]
    120                         
    121                         USBH_USR_ActionFlag = USH_USR_FS_WRITEACCIDENT;        // 10초전 데이터 ㄱ기록한다.                  
   \   0000012C   ....               LDR.N    R0,??DataTable8_19
   \   0000012E   0A21               MOVS     R1,#+10
   \   00000130   0170               STRB     R1,[R0, #+0]
    122                         //------------------------------------------------------------------------------
    123                    }break;
   \   00000132   1EE0               B.N      ??Drive_Acceident_Check_3
    124               case 3:break;
   \                     ??Drive_Acceident_Check_4:
   \   00000134   1DE0               B.N      ??Drive_Acceident_Check_3
    125               case 4:      
    126                    {
    127                         // 난드에 저장 한다.
    128                         //           
    129          
    130                         memcpy(Accident_SaveBuffer, Accident_Buffer,  sizeof(Accident_SaveBuffer));
   \                     ??Drive_Acceident_Check_6:
   \   00000136   4FF4FA52           MOV      R2,#+8000
   \   0000013A   ....               LDR.N    R1,??DataTable8_14
   \   0000013C   ....               LDR.N    R0,??DataTable8_15
   \   0000013E   ........           BL       memcpy
    131                         memcpy(Accident2_SaveBuffer, Accident2_Buffer,  sizeof(Accident2_SaveBuffer));
   \   00000142   AA22               MOVS     R2,#+170
   \   00000144   ....               LDR.N    R1,??DataTable8_17
   \   00000146   ....               LDR.N    R0,??DataTable8_18
   \   00000148   ........           BL       memcpy
    132                         
    133                         Accident_DataSave(Info.Accident_WritePoint++);
   \   0000014C   ....               LDR.N    R0,??DataTable8_3
   \   0000014E   C08C               LDRH     R0,[R0, #+38]
   \   00000150   ....               LDR.N    R1,??DataTable8_3
   \   00000152   421C               ADDS     R2,R0,#+1
   \   00000154   CA84               STRH     R2,[R1, #+38]
   \   00000156   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000158   ........           BL       Accident_DataSave
    134                         Info.AccidentCount++;
   \   0000015C   ....               LDR.N    R0,??DataTable8_3
   \   0000015E   808C               LDRH     R0,[R0, #+36]
   \   00000160   401C               ADDS     R0,R0,#+1
   \   00000162   ....               LDR.N    R1,??DataTable8_3
   \   00000164   8884               STRH     R0,[R1, #+36]
    135                         //------------------------------------------------------------------------------
    136                         USBH_USR_ActionFlag = USH_USR_FS_WRITEACCIDENT;        // 10초전 데이터 ㄱ기록한다.          
   \   00000166   ....               LDR.N    R0,??DataTable8_19
   \   00000168   0A21               MOVS     R1,#+10
   \   0000016A   0170               STRB     R1,[R0, #+0]
    137                         Flag.Accident_Step = 0;
   \   0000016C   ....               LDR.N    R0,??DataTable8_2
   \   0000016E   0021               MOVS     R1,#+0
   \   00000170   4171               STRB     R1,[R0, #+5]
    138          
    139                    }break;
    140               }
    141          }
   \                     ??Drive_Acceident_Check_3:
   \                     ??Drive_Acceident_Check_0:
   \   00000172   05B0               ADD      SP,SP,#+20
   \   00000174   30BD               POP      {R4,R5,PC}       ;; return
    142          

   \                                 In section .text, align 2, keep-with-next
    143          void Drive_Process(void)          // 운행 관련 체크 
    144          {
   \                     Drive_Process:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   8AB0               SUB      SP,SP,#+40
    145               static u16 Drive_Timer;
    146               static u8 Driver_Count;
    147               static u8 Key_On_Status = 0;
    148               static u8 Driver_Check = 0;
    149               TM_Struct DateCheck;
    150               u32 TimerData;
    151               if(!CheckTimeOver(1000,Drive_Timer))
   \   00000004   ....               LDR.N    R0,??DataTable8_20
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   4FF47A70           MOV      R0,#+1000
   \   0000000C   ........           BL       CheckTimeOver
   \   00000010   0028               CMP      R0,#+0
   \   00000012   00F0BD80           BEQ.W    ??Drive_Process_0
    152                    return;      
    153               Drive_Timer = MS_TIMER;  	// 타이머 5	     
   \                     ??Drive_Process_1:
   \   00000016   ....               LDR.N    R0,??DataTable8_21  ;; 0x40000c00
   \   00000018   ........           BL       TIM_GetCounter
   \   0000001C   ....               LDR.N    R1,??DataTable8_20
   \   0000001E   0880               STRH     R0,[R1, #+0]
    154              
    155          //     RTC_AddDay();       // 하루가 증가한다.
    156               if( (Info.Input_Status& INPUT_KEYON_FLAG)  )          // 키온이 되어있으면 운행시간 증가
   \   00000020   ....               LDR.N    R0,??DataTable8_3
   \   00000022   90F85500           LDRB     R0,[R0, #+85]
   \   00000026   0006               LSLS     R0,R0,#+24
   \   00000028   2DD5               BPL.N    ??Drive_Process_2
    157               {
    158                    if(Info.SPEED_Value > 0)
   \   0000002A   ....               LDR.N    R0,??DataTable8_3
   \   0000002C   90F82C00           LDRB     R0,[R0, #+44]
   \   00000030   0128               CMP      R0,#+1
   \   00000032   02D3               BCC.N    ??Drive_Process_3
    159                       Flag.DriveOn = 1;                              // 운행을 시작 하였다.  
   \   00000034   ....               LDR.N    R0,??DataTable8_2
   \   00000036   0121               MOVS     R1,#+1
   \   00000038   8172               STRB     R1,[R0, #+10]
    160                    if(Info.RPM_Value > 0)
   \                     ??Drive_Process_3:
   \   0000003A   ....               LDR.N    R0,??DataTable8_3
   \   0000003C   B0F82D00           LDRH     R0,[R0, #+45]
   \   00000040   0128               CMP      R0,#+1
   \   00000042   1AD3               BCC.N    ??Drive_Process_4
    161                    {
    162                         if(Info.Driver_Index == NO_DRIVER)           // 시동이 킨상태에서 운전자가 선택되지 않았다면
   \   00000044   ....               LDR.N    R0,??DataTable8_3
   \   00000046   0078               LDRB     R0,[R0, #+0]
   \   00000048   FF28               CMP      R0,#+255
   \   0000004A   16D1               BNE.N    ??Drive_Process_4
    163                         {
    164                              Driver_Count++;                    // 
   \   0000004C   ....               LDR.N    R0,??DataTable8_22
   \   0000004E   0078               LDRB     R0,[R0, #+0]
   \   00000050   401C               ADDS     R0,R0,#+1
   \   00000052   ....               LDR.N    R1,??DataTable8_22
   \   00000054   0870               STRB     R0,[R1, #+0]
    165                              
    166                              if( Driver_Count > 20)             // 20초 후에 USB를 읽어 본다.
   \   00000056   ....               LDR.N    R0,??DataTable8_22
   \   00000058   0078               LDRB     R0,[R0, #+0]
   \   0000005A   1528               CMP      R0,#+21
   \   0000005C   06D3               BCC.N    ??Drive_Process_5
    167                              {
    168                                   if(USBH_USR_ApplicationState == USH_USR_FS_IDLE)                                                   
   \   0000005E   ....               LDR.N    R0,??DataTable8_23
   \   00000060   0078               LDRB     R0,[R0, #+0]
   \   00000062   0128               CMP      R0,#+1
   \   00000064   02D1               BNE.N    ??Drive_Process_5
    169                                   {
    170                                        USBH_USR_ActionFlag = USH_USR_FS_READDRIVER;     
   \   00000066   ....               LDR.N    R0,??DataTable8_19
   \   00000068   0921               MOVS     R1,#+9
   \   0000006A   0170               STRB     R1,[R0, #+0]
    171                                   //     Driver_Check= 1;
    172                                   }                         
    173                              }
    174                              if(Driver_Count > 30)              // 30초 후에 멘트를 내보낸다.
   \                     ??Drive_Process_5:
   \   0000006C   ....               LDR.N    R0,??DataTable8_22
   \   0000006E   0078               LDRB     R0,[R0, #+0]
   \   00000070   1F28               CMP      R0,#+31
   \   00000072   02D3               BCC.N    ??Drive_Process_4
    175                              {
    176                                  // Voice_OutAdd(VOICE_INPUTID);
    177                                   Driver_Count = 0;
   \   00000074   ....               LDR.N    R0,??DataTable8_22
   \   00000076   0021               MOVS     R1,#+0
   \   00000078   0170               STRB     R1,[R0, #+0]
    178                              }
    179                         }
    180                    }
    181                    Lcd_Backlight_ON(); 
   \                     ??Drive_Process_4:
   \   0000007A   ........           BL       Lcd_Backlight_ON
    182                           
    183                    Key_On_Status = 1;
   \   0000007E   ....               LDR.N    R0,??DataTable8_24
   \   00000080   0121               MOVS     R1,#+1
   \   00000082   0170               STRB     R1,[R0, #+0]
   \   00000084   0AE0               B.N      ??Drive_Process_6
    184               }else          // 키가 오프상태일때
    185               {
    186                    if(Key_On_Status == 1)        // 키를 한번 켰었다면
   \                     ??Drive_Process_2:
   \   00000086   ....               LDR.N    R0,??DataTable8_24
   \   00000088   0078               LDRB     R0,[R0, #+0]
   \   0000008A   0128               CMP      R0,#+1
   \   0000008C   04D1               BNE.N    ??Drive_Process_7
    187                    {
    188                         Driver_End();            // 저장 한다.
   \   0000008E   ........           BL       Driver_End
    189                         Key_On_Status = 0;
   \   00000092   ....               LDR.N    R0,??DataTable8_24
   \   00000094   0021               MOVS     R1,#+0
   \   00000096   0170               STRB     R1,[R0, #+0]
    190                    }
    191                   Lcd_Backlight_OFF();           
   \                     ??Drive_Process_7:
   \   00000098   ........           BL       Lcd_Backlight_OFF
    192               }     
    193               if( Flag.Driver_Change == 1 )                     // 운전자가 변경이 됬는가?
   \                     ??Drive_Process_6:
   \   0000009C   ....               LDR.N    R0,??DataTable8_2
   \   0000009E   407A               LDRB     R0,[R0, #+9]
   \   000000A0   0128               CMP      R0,#+1
   \   000000A2   04D1               BNE.N    ??Drive_Process_8
    194               {
    195                    Driver_End();    
   \   000000A4   ........           BL       Driver_End
    196                    Flag.Driver_Change = 0;
   \   000000A8   ....               LDR.N    R0,??DataTable8_2
   \   000000AA   0021               MOVS     R1,#+0
   \   000000AC   4172               STRB     R1,[R0, #+9]
    197               }     
    198               if( Info.Driver_Index == NO_DRIVER && Driver_Check == 0)
   \                     ??Drive_Process_8:
   \   000000AE   ....               LDR.N    R0,??DataTable8_3
   \   000000B0   0078               LDRB     R0,[R0, #+0]
   \   000000B2   FF28               CMP      R0,#+255
   \   000000B4   0DD1               BNE.N    ??Drive_Process_9
   \   000000B6   ....               LDR.N    R0,??DataTable8_25
   \   000000B8   0078               LDRB     R0,[R0, #+0]
   \   000000BA   0028               CMP      R0,#+0
   \   000000BC   09D1               BNE.N    ??Drive_Process_9
    199               {
    200                    if(USBH_USR_ApplicationState == USH_USR_FS_IDLE)                                                   
   \   000000BE   ....               LDR.N    R0,??DataTable8_23
   \   000000C0   0078               LDRB     R0,[R0, #+0]
   \   000000C2   0128               CMP      R0,#+1
   \   000000C4   05D1               BNE.N    ??Drive_Process_9
    201                    {
    202                         USBH_USR_ActionFlag = USH_USR_FS_READDRIVER;     
   \   000000C6   ....               LDR.N    R0,??DataTable8_19
   \   000000C8   0921               MOVS     R1,#+9
   \   000000CA   0170               STRB     R1,[R0, #+0]
    203                         Driver_Check= 1;
   \   000000CC   ....               LDR.N    R0,??DataTable8_25
   \   000000CE   0121               MOVS     R1,#+1
   \   000000D0   0170               STRB     R1,[R0, #+0]
    204                    }
    205               }
    206               
    207               TimerData = RTC_DateToBinary(&SYSTEM_TIME);
   \                     ??Drive_Process_9:
   \   000000D2   ....               LDR.N    R0,??DataTable8_11
   \   000000D4   ........           BL       RTC_DateToBinary
   \   000000D8   0400               MOVS     R4,R0
    208               if( NAND_Header_Info.Verify == 0 )      // 헤더에 정보가 등록되지 않았다면
   \   000000DA   ....               LDR.N    R0,??DataTable8_10
   \   000000DC   8089               LDRH     R0,[R0, #+12]
   \   000000DE   0028               CMP      R0,#+0
   \   000000E0   07D1               BNE.N    ??Drive_Process_10
    209               {
    210                    if( SYSTEM_TIME.tm_mday != 0)      // 시간이 제대로 읽혀졌다면
   \   000000E2   ....               LDR.N    R0,??DataTable8_11
   \   000000E4   C068               LDR      R0,[R0, #+12]
   \   000000E6   0028               CMP      R0,#+0
   \   000000E8   03D0               BEQ.N    ??Drive_Process_10
    211                    {
    212                         Setting_Header_Information();                   
   \   000000EA   ........           BL       Setting_Header_Information
    213                         Write_Header_Information();             // 해더 정보를 저장 	                
   \   000000EE   ........           BL       Write_Header_Information
    214                    }          
    215               }
    216               
    217               if(EMS_Drive_Value.Datetime != 0)            // 맨처음이 아닌가?
   \                     ??Drive_Process_10:
   \   000000F2   ....               LDR.N    R0,??DataTable8_26
   \   000000F4   0068               LDR      R0,[R0, #+0]
   \   000000F6   0028               CMP      R0,#+0
   \   000000F8   48D0               BEQ.N    ??Drive_Process_11
    218               {
    219                    RTC_BinaryToDate(EMS_Drive_Value.Datetime,&DateCheck);
   \   000000FA   00A9               ADD      R1,SP,#+0
   \   000000FC   ....               LDR.N    R0,??DataTable8_26
   \   000000FE   0068               LDR      R0,[R0, #+0]
   \   00000100   ........           BL       RTC_BinaryToDate
    220                    
    221                    if( ( NAND_Header_Info.Date[0] != ( SYSTEM_TIME.tm_year - 2000 ) ) || 
    222                         ( NAND_Header_Info.Date[1] != SYSTEM_TIME.tm_mon ) || 
    223                         ( NAND_Header_Info.Date[2] != SYSTEM_TIME.tm_mday ) )
   \   00000104   ....               LDR.N    R0,??DataTable8_10
   \   00000106   0078               LDRB     R0,[R0, #+0]
   \   00000108   ....               LDR.N    R1,??DataTable8_11
   \   0000010A   4969               LDR      R1,[R1, #+20]
   \   0000010C   B1F5FA61           SUBS     R1,R1,#+2000
   \   00000110   8842               CMP      R0,R1
   \   00000112   0BD1               BNE.N    ??Drive_Process_12
   \   00000114   ....               LDR.N    R0,??DataTable8_10
   \   00000116   4078               LDRB     R0,[R0, #+1]
   \   00000118   ....               LDR.N    R1,??DataTable8_11
   \   0000011A   0969               LDR      R1,[R1, #+16]
   \   0000011C   8842               CMP      R0,R1
   \   0000011E   05D1               BNE.N    ??Drive_Process_12
   \   00000120   ....               LDR.N    R0,??DataTable8_10
   \   00000122   8078               LDRB     R0,[R0, #+2]
   \   00000124   ....               LDR.N    R1,??DataTable8_11
   \   00000126   C968               LDR      R1,[R1, #+12]
   \   00000128   8842               CMP      R0,R1
   \   0000012A   2CD0               BEQ.N    ??Drive_Process_13
    224                    {
    225                         
    226                         // 하루가 지나면 거기서 한번씩 저장한다.
    227                         Write_Header_EMS();                     // 누적 운행거리 저장
   \                     ??Drive_Process_12:
   \   0000012C   ........           BL       Write_Header_EMS
    228                         Write_Header_Information();             // 해더 정보를 저장 	     
   \   00000130   ........           BL       Write_Header_Information
    229                         Write_Header_Index();                         // 해더 인덱스 정보를 저장 하고     
   \   00000134   ........           BL       Write_Header_Index
    230                         Write_Transmit_Header();           
   \   00000138   ........           BL       Write_Transmit_Header
    231          
    232                         if( NAND_Header_Index.Write_Point >= MAX_HEADER_PAGE) // 210
   \   0000013C   ....               LDR.N    R0,??DataTable8_6
   \   0000013E   4088               LDRH     R0,[R0, #+2]
   \   00000140   D228               CMP      R0,#+210
   \   00000142   03D3               BCC.N    ??Drive_Process_14
    233                         {
    234                              NAND_Header_Index.Write_Point = 0;
   \   00000144   ....               LDR.N    R0,??DataTable8_6
   \   00000146   0021               MOVS     R1,#+0
   \   00000148   4180               STRH     R1,[R0, #+2]
   \   0000014A   04E0               B.N      ??Drive_Process_15
    235                         }
    236                         else
    237                              NAND_Header_Index.Write_Point++;		// 마지막 헤더의 위치를 증가한다. 
   \                     ??Drive_Process_14:
   \   0000014C   ....               LDR.N    R0,??DataTable8_6
   \   0000014E   4088               LDRH     R0,[R0, #+2]
   \   00000150   401C               ADDS     R0,R0,#+1
   \   00000152   ....               LDR.N    R1,??DataTable8_6
   \   00000154   4880               STRH     R0,[R1, #+2]
    238          
    239                         if(NAND_Header_Index.Header_Count >= MAX_HEADER_PAGE)
   \                     ??Drive_Process_15:
   \   00000156   ....               LDR.N    R0,??DataTable8_6
   \   00000158   0088               LDRH     R0,[R0, #+0]
   \   0000015A   D228               CMP      R0,#+210
   \   0000015C   03D3               BCC.N    ??Drive_Process_16
    240                              NAND_Header_Index.Header_Count = MAX_HEADER_PAGE;
   \   0000015E   ....               LDR.N    R0,??DataTable8_6
   \   00000160   D221               MOVS     R1,#+210
   \   00000162   0180               STRH     R1,[R0, #+0]
   \   00000164   04E0               B.N      ??Drive_Process_17
    241                         else
    242                              NAND_Header_Index.Header_Count ++;
   \                     ??Drive_Process_16:
   \   00000166   ....               LDR.N    R0,??DataTable8_6
   \   00000168   0088               LDRH     R0,[R0, #+0]
   \   0000016A   401C               ADDS     R0,R0,#+1
   \   0000016C   ....               LDR.N    R1,??DataTable8_6
   \   0000016E   0880               STRH     R0,[R1, #+0]
    243                         EMS_Drive_Value.Datetime = TimerData; 
   \                     ??Drive_Process_17:
   \   00000170   ....               LDR.N    R0,??DataTable8_26
   \   00000172   0460               STR      R4,[R0, #+0]
    244                         Setting_Header_Information();
   \   00000174   ........           BL       Setting_Header_Information
    245                         Driver_End();                           // 하루가 지나가면 거기서 한번끝는다.
   \   00000178   ........           BL       Driver_End
    246          
    247                         memset(&EMS_Drive_Value, 0 ,sizeof(EMS_Drive_Value));    // EMS 클리어                          
   \   0000017C   2522               MOVS     R2,#+37
   \   0000017E   0021               MOVS     R1,#+0
   \   00000180   ....               LDR.N    R0,??DataTable8_26
   \   00000182   ........           BL       memset
    248          
    249                    }
    250                    EMS_Drive_Value.Datetime = TimerData;          
   \                     ??Drive_Process_13:
   \   00000186   ....               LDR.N    R0,??DataTable8_26
   \   00000188   0460               STR      R4,[R0, #+0]
   \   0000018A   01E0               B.N      ??Drive_Process_18
    251               }
    252               else
    253               {
    254                    EMS_Drive_Value.Datetime = TimerData;
   \                     ??Drive_Process_11:
   \   0000018C   ....               LDR.N    R0,??DataTable8_26
   \   0000018E   0460               STR      R4,[R0, #+0]
    255               }
    256          }
   \                     ??Drive_Process_18:
   \                     ??Drive_Process_0:
   \   00000190   0AB0               ADD      SP,SP,#+40
   \   00000192   10BD               POP      {R4,PC}          ;; return

   \                                 In section .bss, align 2
   \                     ??Drive_Timer:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
   \                     ??Driver_Count:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     ??Key_On_Status:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     ??Driver_Check:
   \   00000000                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   00180240           DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   00140240           DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   ........           DC32     Flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   ........           DC32     Info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   ........           DC32     ECO_Driving

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   ........           DC32     ACC_Drive_Value

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   ........           DC32     NAND_Header_Index

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   ........           DC32     DTG_NAND_Binary

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   ........           DC32     NAND_Data_Transmit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   FFE70300           DC32     0x3e7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   ........           DC32     NAND_Header_Info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   ........           DC32     SYSTEM_TIME

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \   00000000   ........           DC32     Accident_Time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \   00000000   ........           DC32     AccidentPoint

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_14:
   \   00000000   ........           DC32     Accident_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_15:
   \   00000000   ........           DC32     Accident_SaveBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_16:
   \   00000000   ........           DC32     AccidentPoint2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_17:
   \   00000000   ........           DC32     Accident2_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_18:
   \   00000000   ........           DC32     Accident2_SaveBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_19:
   \   00000000   ........           DC32     USBH_USR_ActionFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_20:
   \   00000000   ........           DC32     ??Drive_Timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_21:
   \   00000000   000C0040           DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_22:
   \   00000000   ........           DC32     ??Driver_Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_23:
   \   00000000   ........           DC32     USBH_USR_ApplicationState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_24:
   \   00000000   ........           DC32     ??Key_On_Status

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_25:
   \   00000000   ........           DC32     ??Driver_Check

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_26:
   \   00000000   ........           DC32     EMS_Drive_Value

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%02d%02d%02d%02d%02d%02d">`:
   \   00000000                      ; Initializer data, 28 bytes
   \   00000000   253032642530       DC8 37, 48, 50, 100, 37, 48, 50, 100, 37, 48
   \              32642530    
   \   0000000A   326425303264       DC8 50, 100, 37, 48, 50, 100, 37, 48, 50, 100
   \              25303264    
   \   00000014   253032640000       DC8 37, 48, 50, 100, 0, 0, 0, 0
   \              0000        

   Maximum stack usage in bytes:

     Function              .cstack
     --------              -------
     Drive_Acceident_Check     32
     Drive_Process             48
     Driver_End                 8
     Driver_Start               8
     LED1_OFF                   8
     LED1_RED                   8
     Lcd_Backlight_OFF          8
     Lcd_Backlight_ON           8
     memcpy                     8
     memset                     8


   Section sizes:

     Function/Label                         Bytes
     --------------                         -----
     memcpy                                   14
     memset                                   20
     LED1_OFF                                 28
     LED1_RED                                 28
     Lcd_Backlight_ON                         16
     Lcd_Backlight_OFF                        16
     Driver_Start                             88
     Driver_End                              178
     Drive_Acceident_Check                   374
     Drive_Process                           404
     Drive_Timer                               2
     Driver_Count                              1
     Key_On_Status                             1
     Driver_Check                              1
     ??DataTable8                              4
     ??DataTable8_1                            4
     ??DataTable8_2                            4
     ??DataTable8_3                            4
     ??DataTable8_4                            4
     ??DataTable8_5                            4
     ??DataTable8_6                            4
     ??DataTable8_7                            4
     ??DataTable8_8                            4
     ??DataTable8_9                            4
     ??DataTable8_10                           4
     ??DataTable8_11                           4
     ??DataTable8_12                           4
     ??DataTable8_13                           4
     ??DataTable8_14                           4
     ??DataTable8_15                           4
     ??DataTable8_16                           4
     ??DataTable8_17                           4
     ??DataTable8_18                           4
     ??DataTable8_19                           4
     ??DataTable8_20                           4
     ??DataTable8_21                           4
     ??DataTable8_22                           4
     ??DataTable8_23                           4
     ??DataTable8_24                           4
     ??DataTable8_25                           4
     ??DataTable8_26                           4
     ?<Constant "%02d%02d%02d%02d%02d%02d">   28

 
     5 bytes in section .bss
 1 302 bytes in section .text
 
 1 268 bytes of CODE memory (+ 34 bytes shared)
     5 bytes of DATA memory

Errors: none
Warnings: none
