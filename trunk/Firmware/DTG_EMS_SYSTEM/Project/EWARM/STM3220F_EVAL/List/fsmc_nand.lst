###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     19/Jan/2012  11:08:56 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\fsmc_nan #
#                    d.c                                                      #
#    Command line =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\fsmc_nan #
#                    d.c -D USE_STDPERIPH_DRIVER -D STM32F2XX -D              #
#                    USE_STM3220F_EVAL -D USE_USB_OTG_FS -D                   #
#                    RTC_CLOCK_SOURCE_LSE -lC F:\Work\S&G2000\Firmware\DTG_EM #
#                    S_SYSTEM\Project\EWARM\STM3220F_EVAL\List\ -lA           #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\ -o F:\Work\S&G2000\Firmware\DTG_EMS_SY #
#                    STEM\Project\EWARM\STM3220F_EVAL\Obj\ --no_cse           #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Full.h" -I                     #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWA #
#                    RM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I             #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I         #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\ -I                             #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\Common\ -I                      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_OTG_Driver\inc\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Core\inc\ -I      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\msc\inc\    #
#                    -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM #
#                    \..\Usb\ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Proj #
#                    ect\EWARM\..\Usb\Inc\ -I F:\Work\S&G2000\Firmware\DTG_EM #
#                    S_SYSTEM\Project\EWARM\..\Usb\src\ -I                    #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Core\inc\ -I        #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -Ol --use_c++_inline                                     #
#    List file    =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\fsmc_nand.lst                           #
#    Object file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\Obj\fsmc_nand.o                              #
#                                                                             #
#                                                                             #
###############################################################################

F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\fsmc_nand.c
      1          /**
      2            ******************************************************************************
      3            * @file    FSMC/NAND/fsmc_nand.c
      4            * @author  MCD Application Team
      5            * @version V3.1.0
      6            * @date    06/19/2009
      7            * @brief   This file provides a set of functions needed to drive the
      8            *          NAND512W3A2 memory mounted on STM3210E-EVAL board.
      9            ******************************************************************************
     10            * @copy
     11            *
     12            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     13            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     14            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     15            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     16            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     17            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     18            *
     19            * <h2><center>&copy; COPYRIGHT 2009 STMicroelectronics</center></h2>
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "fsmc_nand.h"
     24          
     25          /** @addtogroup STM32F10x_StdPeriph_Examples
     26            * @{
     27            */
     28          
     29          /** @addtogroup FSMC_NAND
     30            * @{
     31            */
     32          
     33          

   \                                 In section .bss, align 4
     34          u8 NAND_Buffer[PAGE_SIZE + 1 ];
   \                     NAND_Buffer:
   \   00000000                      DS8 8196

   \                                 In section .bss, align 4
     35          u8 NAND_SpearArea[SPAER_SIZE +1 ];
   \                     NAND_SpearArea:
   \   00000000                      DS8 440
     36          
     37          /* Private typedef -----------------------------------------------------------*/
     38          
     39          /* Private define ------------------------------------------------------------*/
     40          
     41          #define FSMC_Bank_NAND     FSMC_Bank2_NAND
     42          #define Bank_NAND_ADDR     Bank2_NAND_ADDR
     43          #define Bank2_NAND_ADDR    ((uint32_t)0x70000000)
     44          
     45          /* Private macro -------------------------------------------------------------*/
     46          #define ROW_ADDRESS (Address.Page + (Address.Block + (Address.Zone * NAND_ZONE_SIZE)) * NAND_BLOCK_SIZE)
     47          
     48          
     49          /* Private variables ---------------------------------------------------------*/

   \                                 In section .bss, align 4
     50          NAND_ADDRESS NAND_Address;
   \                     NAND_Address:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
     51          NAND_IDTypeDef NAND_ID; 
   \                     NAND_ID:
   \   00000000                      DS8 4
     52          
     53          /* Private function prototypes -----------------------------------------------*/
     54          /* Private functions ---------------------------------------------------------*/
     55            
     56          
     57          
     58          
     59          /**
     60            * @brief  Configures the FSMC and GPIOs to interface with the NAND memory.
     61            *   This function must be called before any write/read operation on the NAND.
     62            * @param  None
     63            * @retval None
     64            */

   \                                 In section .text, align 2, keep-with-next
     65          void FSMC_NAND_Init(void)
     66          {
   \                     FSMC_NAND_Init:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   8FB0               SUB      SP,SP,#+60
     67          
     68            FSMC_NANDInitTypeDef FSMC_NANDInitStructure;
     69            FSMC_NAND_PCCARDTimingInitTypeDef  p;
     70            GPIO_InitTypeDef GPIO_InitStructure;
     71          
     72            RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD | RCC_AHB1Periph_GPIOG | RCC_AHB1Periph_GPIOE |
     73                                   RCC_AHB1Periph_GPIOF | RCC_AHB1Periph_GPIOB, ENABLE);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   7A20               MOVS     R0,#+122
   \   00000008   ........           BL       RCC_AHB1PeriphClockCmd
     74          
     75            RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   4FF48040           MOV      R0,#+16384
   \   00000012   ........           BL       RCC_APB2PeriphClockCmd
     76          
     77            RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE); 
   \   00000016   0121               MOVS     R1,#+1
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   ........           BL       RCC_AHB3PeriphClockCmd
     78            
     79          /*-- GPIO Configuration ------------------------------------------------------*/
     80            /* OneNAND Data lines configuration */
     81            GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FSMC);         //D0
   \   0000001E   0C22               MOVS     R2,#+12
   \   00000020   0E21               MOVS     R1,#+14
   \   00000022   ........           LDR.W    R0,??DataTable10  ;; 0x40020c00
   \   00000026   ........           BL       GPIO_PinAFConfig
     82            GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FSMC);         //D1
   \   0000002A   0C22               MOVS     R2,#+12
   \   0000002C   0F21               MOVS     R1,#+15
   \   0000002E   ........           LDR.W    R0,??DataTable10  ;; 0x40020c00
   \   00000032   ........           BL       GPIO_PinAFConfig
     83            GPIO_PinAFConfig(GPIOD, GPIO_PinSource0, GPIO_AF_FSMC);        //D2
   \   00000036   0C22               MOVS     R2,#+12
   \   00000038   0021               MOVS     R1,#+0
   \   0000003A   ........           LDR.W    R0,??DataTable10  ;; 0x40020c00
   \   0000003E   ........           BL       GPIO_PinAFConfig
     84            GPIO_PinAFConfig(GPIOD, GPIO_PinSource1, GPIO_AF_FSMC);      //D3
   \   00000042   0C22               MOVS     R2,#+12
   \   00000044   0121               MOVS     R1,#+1
   \   00000046   ........           LDR.W    R0,??DataTable10  ;; 0x40020c00
   \   0000004A   ........           BL       GPIO_PinAFConfig
     85          //  GPIO_PinAFConfig(GPIOD, GPIO_PinSource8, GPIO_AF_FSMC);       //D13
     86          //  GPIO_PinAFConfig(GPIOD, GPIO_PinSource9, GPIO_AF_FSMC);      //14
     87          //  GPIO_PinAFConfig(GPIOD, GPIO_PinSource10, GPIO_AF_FSMC);     //D15
     88          
     89            GPIO_PinAFConfig(GPIOE, GPIO_PinSource7, GPIO_AF_FSMC);        //D4
   \   0000004E   0C22               MOVS     R2,#+12
   \   00000050   0721               MOVS     R1,#+7
   \   00000052   ........           LDR.W    R0,??DataTable10_1  ;; 0x40021000
   \   00000056   ........           BL       GPIO_PinAFConfig
     90            GPIO_PinAFConfig(GPIOE, GPIO_PinSource8, GPIO_AF_FSMC);        //D5
   \   0000005A   0C22               MOVS     R2,#+12
   \   0000005C   0821               MOVS     R1,#+8
   \   0000005E   ........           LDR.W    R0,??DataTable10_1  ;; 0x40021000
   \   00000062   ........           BL       GPIO_PinAFConfig
     91            GPIO_PinAFConfig(GPIOE, GPIO_PinSource9, GPIO_AF_FSMC);          //D6
   \   00000066   0C22               MOVS     R2,#+12
   \   00000068   0921               MOVS     R1,#+9
   \   0000006A   ........           LDR.W    R0,??DataTable10_1  ;; 0x40021000
   \   0000006E   ........           BL       GPIO_PinAFConfig
     92            GPIO_PinAFConfig(GPIOE, GPIO_PinSource10, GPIO_AF_FSMC);         //D7
   \   00000072   0C22               MOVS     R2,#+12
   \   00000074   0A21               MOVS     R1,#+10
   \   00000076   ........           LDR.W    R0,??DataTable10_1  ;; 0x40021000
   \   0000007A   ........           BL       GPIO_PinAFConfig
     93          //  GPIO_PinAFConfig(GPIOE, GPIO_PinSource11, GPIO_AF_FSMC);           //D8
     94          //  GPIO_PinAFConfig(GPIOE, GPIO_PinSource12, GPIO_AF_FSMC);         //D9
     95          //  GPIO_PinAFConfig(GPIOE, GPIO_PinSource13, GPIO_AF_FSMC);       //D10
     96          //  GPIO_PinAFConfig(GPIOE, GPIO_PinSource14, GPIO_AF_FSMC);     //D11
     97          //  GPIO_PinAFConfig(GPIOE, GPIO_PinSource15, GPIO_AF_FSMC);    //D12
     98          
     99            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_14 | GPIO_Pin_15 ;
   \   0000007E   4CF20300           MOVW     R0,#+49155
   \   00000082   0090               STR      R0,[SP, #+0]
    100            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   00000084   0220               MOVS     R0,#+2
   \   00000086   8DF80400           STRB     R0,[SP, #+4]
    101            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
   \   0000008A   0020               MOVS     R0,#+0
   \   0000008C   8DF80500           STRB     R0,[SP, #+5]
    102            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000090   0020               MOVS     R0,#+0
   \   00000092   8DF80600           STRB     R0,[SP, #+6]
    103            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
   \   00000096   0120               MOVS     R0,#+1
   \   00000098   8DF80700           STRB     R0,[SP, #+7]
    104          
    105            GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   0000009C   00A9               ADD      R1,SP,#+0
   \   0000009E   ........           LDR.W    R0,??DataTable10  ;; 0x40020c00
   \   000000A2   ........           BL       GPIO_Init
    106           
    107            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 ;
   \   000000A6   4FF4F060           MOV      R0,#+1920
   \   000000AA   0090               STR      R0,[SP, #+0]
    108          
    109            GPIO_Init(GPIOE, &GPIO_InitStructure);
   \   000000AC   00A9               ADD      R1,SP,#+0
   \   000000AE   ........           LDR.W    R0,??DataTable10_1  ;; 0x40021000
   \   000000B2   ........           BL       GPIO_Init
    110          
    111            /* OneNAND Address lines configuration */
    112          /*  GPIO_PinAFConfig(GPIOF,GPIO_PinSource0, GPIO_AF_FSMC);
    113            GPIO_PinAFConfig(GPIOF,GPIO_PinSource1, GPIO_AF_FSMC);
    114            GPIO_PinAFConfig(GPIOF,GPIO_PinSource2, GPIO_AF_FSMC);
    115            GPIO_PinAFConfig(GPIOF,GPIO_PinSource3, GPIO_AF_FSMC);
    116            GPIO_PinAFConfig(GPIOF,GPIO_PinSource4, GPIO_AF_FSMC);
    117            GPIO_PinAFConfig(GPIOF,GPIO_PinSource5, GPIO_AF_FSMC);
    118          
    119            GPIO_PinAFConfig(GPIOF,GPIO_PinSource12, GPIO_AF_FSMC);
    120            GPIO_PinAFConfig(GPIOF,GPIO_PinSource13, GPIO_AF_FSMC);
    121            GPIO_PinAFConfig(GPIOF,GPIO_PinSource14, GPIO_AF_FSMC);
    122            GPIO_PinAFConfig(GPIOF,GPIO_PinSource15, GPIO_AF_FSMC);
    123          
    124            GPIO_PinAFConfig(GPIOG,GPIO_PinSource0, GPIO_AF_FSMC);
    125            GPIO_PinAFConfig(GPIOG,GPIO_PinSource1, GPIO_AF_FSMC);
    126            GPIO_PinAFConfig(GPIOG,GPIO_PinSource2, GPIO_AF_FSMC);
    127            GPIO_PinAFConfig(GPIOG,GPIO_PinSource3, GPIO_AF_FSMC);
    128            GPIO_PinAFConfig(GPIOG,GPIO_PinSource4, GPIO_AF_FSMC);
    129            GPIO_PinAFConfig(GPIOG,GPIO_PinSource5, GPIO_AF_FSMC);*/
    130          
    131            GPIO_PinAFConfig(GPIOD,GPIO_PinSource11, GPIO_AF_FSMC);     // A16
   \   000000B6   0C22               MOVS     R2,#+12
   \   000000B8   0B21               MOVS     R1,#+11
   \   000000BA   ........           LDR.W    R0,??DataTable10  ;; 0x40020c00
   \   000000BE   ........           BL       GPIO_PinAFConfig
    132            GPIO_PinAFConfig(GPIOD,GPIO_PinSource12, GPIO_AF_FSMC);     // A17
   \   000000C2   0C22               MOVS     R2,#+12
   \   000000C4   0C21               MOVS     R1,#+12
   \   000000C6   ........           LDR.W    R0,??DataTable10  ;; 0x40020c00
   \   000000CA   ........           BL       GPIO_PinAFConfig
    133            
    134            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12 ;
   \   000000CE   4FF4C050           MOV      R0,#+6144
   \   000000D2   0090               STR      R0,[SP, #+0]
    135          
    136            GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   000000D4   00A9               ADD      R1,SP,#+0
   \   000000D6   ........           LDR.W    R0,??DataTable10  ;; 0x40020c00
   \   000000DA   ........           BL       GPIO_Init
    137            /* NOE, NWE and CLK configuration */  
    138          //  GPIO_PinAFConfig(GPIOD,GPIO_PinSource3, GPIO_AF_FSMC);
    139            GPIO_PinAFConfig(GPIOD,GPIO_PinSource4, GPIO_AF_FSMC);
   \   000000DE   0C22               MOVS     R2,#+12
   \   000000E0   0421               MOVS     R1,#+4
   \   000000E2   ........           LDR.W    R0,??DataTable10  ;; 0x40020c00
   \   000000E6   ........           BL       GPIO_PinAFConfig
    140            GPIO_PinAFConfig(GPIOD,GPIO_PinSource5, GPIO_AF_FSMC);
   \   000000EA   0C22               MOVS     R2,#+12
   \   000000EC   0521               MOVS     R1,#+5
   \   000000EE   ........           LDR.W    R0,??DataTable10  ;; 0x40020c00
   \   000000F2   ........           BL       GPIO_PinAFConfig
    141          
    142            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 |GPIO_Pin_5;// | GPIO_Pin_3;
   \   000000F6   3020               MOVS     R0,#+48
   \   000000F8   0090               STR      R0,[SP, #+0]
    143          
    144            GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   000000FA   00A9               ADD      R1,SP,#+0
   \   000000FC   ........           LDR.W    R0,??DataTable10  ;; 0x40020c00
   \   00000100   ........           BL       GPIO_Init
    145          
    146          
    147            /* NE1 configuration */
    148            GPIO_PinAFConfig(GPIOD, GPIO_PinSource7, GPIO_AF_FSMC);
   \   00000104   0C22               MOVS     R2,#+12
   \   00000106   0721               MOVS     R1,#+7
   \   00000108   ........           LDR.W    R0,??DataTable10  ;; 0x40020c00
   \   0000010C   ........           BL       GPIO_PinAFConfig
    149            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7; 
   \   00000110   8020               MOVS     R0,#+128
   \   00000112   0090               STR      R0,[SP, #+0]
    150          
    151            GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   00000114   00A9               ADD      R1,SP,#+0
   \   00000116   ........           LDR.W    R0,??DataTable10  ;; 0x40020c00
   \   0000011A   ........           BL       GPIO_Init
    152          
    153            /* NL configuration */
    154           /* GPIO_PinAFConfig(GPIOB,GPIO_PinSource7, GPIO_AF_FSMC);
    155          
    156            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7; 
    157            GPIO_Init(GPIOB, &GPIO_InitStructure);
    158          
    159            /* NWAIT Configuration */
                   ^
Warning[Pe009]: nested comment is not allowed
    160            
    161            // NWATI 핀을 쓰지 않고 그냥  INT2로 설정하려면 인터럽트 백터를 설정해줘야한다.
    162            
    163            GPIO_PinAFConfig(GPIOD,GPIO_PinSource6, GPIO_AF_FSMC);
   \   0000011E   0C22               MOVS     R2,#+12
   \   00000120   0621               MOVS     R1,#+6
   \   00000122   ........           LDR.W    R0,??DataTable10  ;; 0x40020c00
   \   00000126   ........           BL       GPIO_PinAFConfig
    164          
    165            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; 
   \   0000012A   4020               MOVS     R0,#+64
   \   0000012C   0090               STR      R0,[SP, #+0]
    166          //  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;  
    167            GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   0000012E   00A9               ADD      R1,SP,#+0
   \   00000130   ........           LDR.W    R0,??DataTable10  ;; 0x40020c00
   \   00000134   ........           BL       GPIO_Init
    168            
    169            GPIO_PinAFConfig(GPIOG,GPIO_PinSource6, GPIO_AF_FSMC);
   \   00000138   0C22               MOVS     R2,#+12
   \   0000013A   0621               MOVS     R1,#+6
   \   0000013C   ........           LDR.W    R0,??DataTable10_2  ;; 0x40021800
   \   00000140   ........           BL       GPIO_PinAFConfig
    170          
    171            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; 
   \   00000144   4020               MOVS     R0,#+64
   \   00000146   0090               STR      R0,[SP, #+0]
    172          //  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;  
    173            GPIO_Init(GPIOG, &GPIO_InitStructure);
   \   00000148   00A9               ADD      R1,SP,#+0
   \   0000014A   ........           LDR.W    R0,??DataTable10_2  ;; 0x40021800
   \   0000014E   ........           BL       GPIO_Init
    174          
    175            
    176            /*-- FSMC Configuration ------------------------------------------------------*/
    177            p.FSMC_SetupTime = 0x1;
   \   00000152   0120               MOVS     R0,#+1
   \   00000154   0290               STR      R0,[SP, #+8]
    178            p.FSMC_WaitSetupTime = 0x3;
   \   00000156   0320               MOVS     R0,#+3
   \   00000158   0390               STR      R0,[SP, #+12]
    179            p.FSMC_HoldSetupTime = 0x2;
   \   0000015A   0220               MOVS     R0,#+2
   \   0000015C   0490               STR      R0,[SP, #+16]
    180            p.FSMC_HiZSetupTime = 0x1;
   \   0000015E   0120               MOVS     R0,#+1
   \   00000160   0590               STR      R0,[SP, #+20]
    181          /*  p.FSMC_SetupTime = 0x0;
    182            p.FSMC_WaitSetupTime = 0x2;
    183            p.FSMC_HoldSetupTime = 0x1;
    184            p.FSMC_HiZSetupTime = 0x0;*/
    185            
    186            
    187            FSMC_NANDInitStructure.FSMC_Bank = FSMC_Bank2_NAND;
   \   00000162   1020               MOVS     R0,#+16
   \   00000164   0690               STR      R0,[SP, #+24]
    188            FSMC_NANDInitStructure.FSMC_Waitfeature = FSMC_Waitfeature_Enable;
   \   00000166   0220               MOVS     R0,#+2
   \   00000168   0790               STR      R0,[SP, #+28]
    189            FSMC_NANDInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
   \   0000016A   0020               MOVS     R0,#+0
   \   0000016C   0890               STR      R0,[SP, #+32]
    190            FSMC_NANDInitStructure.FSMC_ECC = FSMC_ECC_Enable;
   \   0000016E   4020               MOVS     R0,#+64
   \   00000170   0990               STR      R0,[SP, #+36]
    191          #if 0
    192            FSMC_NANDInitStructure.FSMC_ECCPageSize = FSMC_ECCPageSize_512Bytes;
    193          #else
    194            FSMC_NANDInitStructure.FSMC_ECCPageSize = FSMC_ECCPageSize_2048Bytes;
   \   00000172   5FF4C020           MOVS     R0,#+393216
   \   00000176   0A90               STR      R0,[SP, #+40]
    195          #endif
    196          
    197            FSMC_NANDInitStructure.FSMC_TCLRSetupTime = 0x00;
   \   00000178   0020               MOVS     R0,#+0
   \   0000017A   0B90               STR      R0,[SP, #+44]
    198            FSMC_NANDInitStructure.FSMC_TARSetupTime = 0x00;
   \   0000017C   0020               MOVS     R0,#+0
   \   0000017E   0C90               STR      R0,[SP, #+48]
    199            FSMC_NANDInitStructure.FSMC_CommonSpaceTimingStruct = &p;
   \   00000180   02A8               ADD      R0,SP,#+8
   \   00000182   0D90               STR      R0,[SP, #+52]
    200            FSMC_NANDInitStructure.FSMC_AttributeSpaceTimingStruct = &p;
   \   00000184   02A8               ADD      R0,SP,#+8
   \   00000186   0E90               STR      R0,[SP, #+56]
    201          
    202            FSMC_NANDInit(&FSMC_NANDInitStructure);
   \   00000188   06A8               ADD      R0,SP,#+24
   \   0000018A   ........           BL       FSMC_NANDInit
    203            
    204          //  FSMC_ITConfig(FSMC_Bank2_NAND,FSMC_IT_RisingEdge,ENABLE);
    205            /* FSMC NAND Bank Cmd Test */
    206            FSMC_NANDCmd(FSMC_Bank2_NAND, ENABLE);
   \   0000018E   0121               MOVS     R1,#+1
   \   00000190   1020               MOVS     R0,#+16
   \   00000192   ........           BL       FSMC_NANDCmd
    207            
    208            FSMC_NAND_ReadID(&NAND_ID);
   \   00000196   ........           LDR.W    R0,??DataTable10_3
   \   0000019A   ........           BL       FSMC_NAND_ReadID
    209          }
   \   0000019E   0FB0               ADD      SP,SP,#+60
   \   000001A0   00BD               POP      {PC}             ;; return
    210          
    211          /**
    212            * @brief  Reads NAND memory's ID.
    213            * @param  NAND_ID: pointer to a NAND_IDTypeDef structure which will hold
    214            *                  the Manufacturer and Device ID.
    215            * @retval None
    216            */

   \                                 In section .text, align 2, keep-with-next
    217          void FSMC_NAND_ReadID(NAND_IDTypeDef* NAND_ID)
    218          {
    219            uint32_t data = 0;
   \                     FSMC_NAND_ReadID:
   \   00000000   0021               MOVS     R1,#+0
    220          
    221            /* Send Command to the command area */
    222            *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = 0x90;
   \   00000002   ........           LDR.W    R2,??DataTable10_4  ;; 0x70010000
   \   00000006   9023               MOVS     R3,#+144
   \   00000008   1370               STRB     R3,[R2, #+0]
    223            *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00;
   \   0000000A   ........           LDR.W    R2,??DataTable10_5  ;; 0x70020000
   \   0000000E   0023               MOVS     R3,#+0
   \   00000010   1370               STRB     R3,[R2, #+0]
    224          
    225             /* Sequence to read ID from NAND flash */
    226             data = *(__IO uint32_t *)(Bank_NAND_ADDR | DATA_AREA);
   \   00000012   5FF0E042           MOVS     R2,#+1879048192
   \   00000016   1268               LDR      R2,[R2, #+0]
   \   00000018   1100               MOVS     R1,R2
    227          
    228             NAND_ID->Maker_ID   = ADDR_1st_CYCLE (data);
   \   0000001A   0170               STRB     R1,[R0, #+0]
    229             NAND_ID->Device_ID  = ADDR_2nd_CYCLE (data);
   \   0000001C   0A0A               LSRS     R2,R1,#+8
   \   0000001E   4270               STRB     R2,[R0, #+1]
    230             NAND_ID->Third_ID   = ADDR_3rd_CYCLE (data);
   \   00000020   0A0C               LSRS     R2,R1,#+16
   \   00000022   8270               STRB     R2,[R0, #+2]
    231             NAND_ID->Fourth_ID  = ADDR_4th_CYCLE (data);
   \   00000024   090E               LSRS     R1,R1,#+24
   \   00000026   C170               STRB     R1,[R0, #+3]
    232          }
   \   00000028   7047               BX       LR               ;; return
    233          
    234          /**
    235            * @brief   This routine is for writing one or several 512 Bytes Page size.
    236            * @param  pBuffer: pointer on the Buffer containing data to be written
    237            * @param  Address: First page address
    238            * @param  NumPageToWrite: Number of page to write
    239            * @retval New status of the NAND operation. This parameter can be:
    240            *              - NAND_TIMEOUT_ERROR: when the previous operation generate
    241            *                a Timeout error
    242            *              - NAND_READY: when memory is ready for the next operation
    243            *                And the new status of the increment address operation. It can be:
    244            *              - NAND_VALID_ADDRESS: When the new address is valid address
    245            *              - NAND_INVALID_ADDRESS: When the new address is invalid address
    246            */
    247          

   \                                 In section .text, align 2, keep-with-next
    248          uint32_t NAND_WriteSmallPage(uint8_t *pBuffer, NAND_ADDRESS Address, uint32_t NumPageToWrite)
    249          {
   \                     NAND_WriteSmallPage:
   \   00000000   2DE9F641           PUSH     {R1,R2,R4-R8,LR}
   \   00000004   0400               MOVS     R4,R0
   \   00000006   1D00               MOVS     R5,R3
    250            uint32_t index = 0x00, numpagewritten = 0x00, addressstatus = NAND_VALID_ADDRESS;
   \   00000008   5FF00008           MOVS     R8,#+0
   \   0000000C   0026               MOVS     R6,#+0
   \   0000000E   4FF48070           MOV      R0,#+256
    251            uint32_t status = NAND_READY, size = 0x00;
   \   00000012   4027               MOVS     R7,#+64
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   13E0               B.N      ??NAND_WriteSmallPage_0
    252          
    253            while((NumPageToWrite != 0x00) && (addressstatus == NAND_VALID_ADDRESS) && (status == NAND_READY))
    254            {
    255              /*!< Page write command and address */
    256              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_AREA_A;
    257              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_WRITE0;
    258          
    259              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00;
    260              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_1st_CYCLE(ROW_ADDRESS);
    261              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_2nd_CYCLE(ROW_ADDRESS);
    262              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_3rd_CYCLE(ROW_ADDRESS);
    263          
    264              /*!< Calculate the size */
    265              size = NAND_PAGE_SIZE + (NAND_PAGE_SIZE * numpagewritten);
    266          
    267              /*!< Write data */
    268              for(; index < size; index++)
    269              {
    270                *(__IO uint8_t *)(Bank_NAND_ADDR | DATA_AREA) = pBuffer[index];
   \                     ??NAND_WriteSmallPage_1:
   \   00000018   18F80420           LDRB     R2,[R8, R4]
   \   0000001C   5FF0E043           MOVS     R3,#+1879048192
   \   00000020   1A70               STRB     R2,[R3, #+0]
    271              }
   \   00000022   18F10108           ADDS     R8,R8,#+1
   \                     ??NAND_WriteSmallPage_2:
   \   00000026   8845               CMP      R8,R1
   \   00000028   F6D3               BCC.N    ??NAND_WriteSmallPage_1
    272              
    273              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_WRITE_TRUE1;
   \   0000002A   ........           LDR.W    R1,??DataTable10_4  ;; 0x70010000
   \   0000002E   1022               MOVS     R2,#+16
   \   00000030   0A70               STRB     R2,[R1, #+0]
    274          
    275              /*!< Check status for successful operation */
    276             // status = NAND_GetStatus();
    277              
    278              if(status == NAND_READY)
   \   00000032   402F               CMP      R7,#+64
   \   00000034   04D1               BNE.N    ??NAND_WriteSmallPage_0
    279              {
    280                numpagewritten++;
   \   00000036   761C               ADDS     R6,R6,#+1
    281          
    282                NumPageToWrite--;
   \   00000038   6D1E               SUBS     R5,R5,#+1
    283          
    284                /*!< Calculate Next small page Address */
    285                addressstatus = FSMC_NAND_AddressIncrement(&Address);
   \   0000003A   00A8               ADD      R0,SP,#+0
   \   0000003C   ........           BL       FSMC_NAND_AddressIncrement
    286              }
   \                     ??NAND_WriteSmallPage_0:
   \   00000040   002D               CMP      R5,#+0
   \   00000042   4AD0               BEQ.N    ??NAND_WriteSmallPage_3
   \   00000044   4FF48071           MOV      R1,#+256
   \   00000048   8842               CMP      R0,R1
   \   0000004A   46D1               BNE.N    ??NAND_WriteSmallPage_3
   \   0000004C   402F               CMP      R7,#+64
   \   0000004E   44D1               BNE.N    ??NAND_WriteSmallPage_3
   \   00000050   ........           LDR.W    R1,??DataTable10_4  ;; 0x70010000
   \   00000054   0022               MOVS     R2,#+0
   \   00000056   0A70               STRB     R2,[R1, #+0]
   \   00000058   ........           LDR.W    R1,??DataTable10_4  ;; 0x70010000
   \   0000005C   8022               MOVS     R2,#+128
   \   0000005E   0A70               STRB     R2,[R1, #+0]
   \   00000060   ........           LDR.W    R1,??DataTable10_5  ;; 0x70020000
   \   00000064   0022               MOVS     R2,#+0
   \   00000066   0A70               STRB     R2,[R1, #+0]
   \   00000068   BDF80410           LDRH     R1,[SP, #+4]
   \   0000006C   BDF80220           LDRH     R2,[SP, #+2]
   \   00000070   BDF80030           LDRH     R3,[SP, #+0]
   \   00000074   40F61C0C           MOVW     R12,#+2076
   \   00000078   0CFB0322           MLA      R2,R12,R3,R2
   \   0000007C   8023               MOVS     R3,#+128
   \   0000007E   03FB0211           MLA      R1,R3,R2,R1
   \   00000082   ........           LDR.W    R2,??DataTable10_5  ;; 0x70020000
   \   00000086   1170               STRB     R1,[R2, #+0]
   \   00000088   BDF80410           LDRH     R1,[SP, #+4]
   \   0000008C   BDF80220           LDRH     R2,[SP, #+2]
   \   00000090   BDF80030           LDRH     R3,[SP, #+0]
   \   00000094   40F61C0C           MOVW     R12,#+2076
   \   00000098   0CFB0322           MLA      R2,R12,R3,R2
   \   0000009C   8023               MOVS     R3,#+128
   \   0000009E   03FB0211           MLA      R1,R3,R2,R1
   \   000000A2   0912               ASRS     R1,R1,#+8
   \   000000A4   ........           LDR.W    R2,??DataTable10_5  ;; 0x70020000
   \   000000A8   1170               STRB     R1,[R2, #+0]
   \   000000AA   BDF80410           LDRH     R1,[SP, #+4]
   \   000000AE   BDF80220           LDRH     R2,[SP, #+2]
   \   000000B2   BDF80030           LDRH     R3,[SP, #+0]
   \   000000B6   40F61C0C           MOVW     R12,#+2076
   \   000000BA   0CFB0322           MLA      R2,R12,R3,R2
   \   000000BE   8023               MOVS     R3,#+128
   \   000000C0   03FB0211           MLA      R1,R3,R2,R1
   \   000000C4   0914               ASRS     R1,R1,#+16
   \   000000C6   ........           LDR.W    R2,??DataTable10_5  ;; 0x70020000
   \   000000CA   1170               STRB     R1,[R2, #+0]
   \   000000CC   4FF40051           MOV      R1,#+8192
   \   000000D0   01FB06F1           MUL      R1,R1,R6
   \   000000D4   11F50051           ADDS     R1,R1,#+8192
   \   000000D8   A5E7               B.N      ??NAND_WriteSmallPage_2
    287            }
    288            
    289            return (status | addressstatus);
   \                     ??NAND_WriteSmallPage_3:
   \   000000DA   3843               ORRS     R0,R0,R7
   \   000000DC   BDE8F681           POP      {R1,R2,R4-R8,PC}  ;; return
    290          }
    291          
    292          /**
    293            * @brief  This routine is for sequential read from one or several 512 Bytes Page size.
    294            * @param  pBuffer: pointer on the Buffer to fill
    295            * @param  Address: First page address
    296            * @param  NumPageToRead: Number of page to read  
    297            * @retval New status of the NAND operation. This parameter can be:
    298            *              - NAND_TIMEOUT_ERROR: when the previous operation generate 
    299            *                a Timeout error
    300            *              - NAND_READY: when memory is ready for the next operation 
    301            *                And the new status of the increment address operation. It can be:
    302            *              - NAND_VALID_ADDRESS: When the new address is valid address
    303            *              - NAND_INVALID_ADDRESS: When the new address is invalid address
    304            */

   \                                 In section .text, align 2, keep-with-next
    305          uint32_t NAND_ReadSmallPage(uint8_t *pBuffer, NAND_ADDRESS Address, uint32_t NumPageToRead)
    306          {
   \                     NAND_ReadSmallPage:
   \   00000000   2DE9F641           PUSH     {R1,R2,R4-R8,LR}
   \   00000004   0400               MOVS     R4,R0
   \   00000006   9846               MOV      R8,R3
    307            uint32_t index = 0x00, numpageread = 0x00, addressstatus = NAND_VALID_ADDRESS;
   \   00000008   0026               MOVS     R6,#+0
   \   0000000A   0027               MOVS     R7,#+0
   \   0000000C   4FF48070           MOV      R0,#+256
    308            uint32_t status = NAND_READY, size = 0x00;
   \   00000010   4025               MOVS     R5,#+64
   \   00000012   0021               MOVS     R1,#+0
   \   00000014   0CE0               B.N      ??NAND_ReadSmallPage_0
    309          
    310            while((NumPageToRead != 0x0) && (addressstatus == NAND_VALID_ADDRESS))
    311            {
    312              /*!< Page Read command and page address */
    313              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_AREA_A;
    314             
    315              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00; 
    316              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_1st_CYCLE(ROW_ADDRESS);
    317              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_2nd_CYCLE(ROW_ADDRESS);
    318              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_3rd_CYCLE(ROW_ADDRESS);
    319              
    320              /*!< Calculate the size */
    321              size = NAND_PAGE_SIZE + (NAND_PAGE_SIZE * numpageread);
    322              
    323              /*!< Get Data into Buffer */    
    324              for(; index < size; index++)
    325              {
    326                pBuffer[index]= *(__IO uint8_t *)(Bank_NAND_ADDR | DATA_AREA);
   \                     ??NAND_ReadSmallPage_1:
   \   00000016   5FF0E040           MOVS     R0,#+1879048192
   \   0000001A   0078               LDRB     R0,[R0, #+0]
   \   0000001C   3055               STRB     R0,[R6, R4]
    327              }
   \   0000001E   761C               ADDS     R6,R6,#+1
   \                     ??NAND_ReadSmallPage_2:
   \   00000020   8E42               CMP      R6,R1
   \   00000022   F8D3               BCC.N    ??NAND_ReadSmallPage_1
    328          
    329              numpageread++;
   \   00000024   7F1C               ADDS     R7,R7,#+1
    330              
    331              NumPageToRead--;
   \   00000026   B8F10108           SUBS     R8,R8,#+1
    332          
    333              /*!< Calculate page address */
    334              addressstatus = FSMC_NAND_AddressIncrement(&Address);
   \   0000002A   00A8               ADD      R0,SP,#+0
   \   0000002C   ........           BL       FSMC_NAND_AddressIncrement
   \                     ??NAND_ReadSmallPage_0:
   \   00000030   B8F1000F           CMP      R8,#+0
   \   00000034   44D0               BEQ.N    ??NAND_ReadSmallPage_3
   \   00000036   4FF48071           MOV      R1,#+256
   \   0000003A   8842               CMP      R0,R1
   \   0000003C   40D1               BNE.N    ??NAND_ReadSmallPage_3
   \   0000003E   ........           LDR.W    R0,??DataTable10_4  ;; 0x70010000
   \   00000042   0021               MOVS     R1,#+0
   \   00000044   0170               STRB     R1,[R0, #+0]
   \   00000046   ........           LDR.W    R0,??DataTable10_5  ;; 0x70020000
   \   0000004A   0021               MOVS     R1,#+0
   \   0000004C   0170               STRB     R1,[R0, #+0]
   \   0000004E   BDF80400           LDRH     R0,[SP, #+4]
   \   00000052   BDF80210           LDRH     R1,[SP, #+2]
   \   00000056   BDF80020           LDRH     R2,[SP, #+0]
   \   0000005A   40F61C03           MOVW     R3,#+2076
   \   0000005E   03FB0211           MLA      R1,R3,R2,R1
   \   00000062   8022               MOVS     R2,#+128
   \   00000064   02FB0100           MLA      R0,R2,R1,R0
   \   00000068   ........           LDR.W    R1,??DataTable10_5  ;; 0x70020000
   \   0000006C   0870               STRB     R0,[R1, #+0]
   \   0000006E   BDF80400           LDRH     R0,[SP, #+4]
   \   00000072   BDF80210           LDRH     R1,[SP, #+2]
   \   00000076   BDF80020           LDRH     R2,[SP, #+0]
   \   0000007A   40F61C03           MOVW     R3,#+2076
   \   0000007E   03FB0211           MLA      R1,R3,R2,R1
   \   00000082   8022               MOVS     R2,#+128
   \   00000084   02FB0100           MLA      R0,R2,R1,R0
   \   00000088   0012               ASRS     R0,R0,#+8
   \   0000008A   ........           LDR.W    R1,??DataTable10_5  ;; 0x70020000
   \   0000008E   0870               STRB     R0,[R1, #+0]
   \   00000090   BDF80400           LDRH     R0,[SP, #+4]
   \   00000094   BDF80210           LDRH     R1,[SP, #+2]
   \   00000098   BDF80020           LDRH     R2,[SP, #+0]
   \   0000009C   40F61C03           MOVW     R3,#+2076
   \   000000A0   03FB0211           MLA      R1,R3,R2,R1
   \   000000A4   8022               MOVS     R2,#+128
   \   000000A6   02FB0100           MLA      R0,R2,R1,R0
   \   000000AA   0014               ASRS     R0,R0,#+16
   \   000000AC   ........           LDR.W    R1,??DataTable10_5  ;; 0x70020000
   \   000000B0   0870               STRB     R0,[R1, #+0]
   \   000000B2   4FF40050           MOV      R0,#+8192
   \   000000B6   00FB07F0           MUL      R0,R0,R7
   \   000000BA   10F50051           ADDS     R1,R0,#+8192
   \   000000BE   AFE7               B.N      ??NAND_ReadSmallPage_2
    335            }
    336          
    337           // status = NAND_GetStatus();
    338            
    339            return (status | addressstatus);
   \                     ??NAND_ReadSmallPage_3:
   \   000000C0   2843               ORRS     R0,R0,R5
   \   000000C2   BDE8F681           POP      {R1,R2,R4-R8,PC}  ;; return
    340          }
    341          
    342          

   \                                 In section .text, align 2, keep-with-next
    343          uint32_t FSMC_NAND_WriteSmallPage(uint8_t *pBuffer, NAND_ADDRESS Address, uint32_t NumPageToWrite)
    344          {
   \                     FSMC_NAND_WriteSmallPage:
   \   00000000   2DE9F647           PUSH     {R1,R2,R4-R10,LR}
   \   00000004   0400               MOVS     R4,R0
   \   00000006   1D00               MOVS     R5,R3
    345            u8 Loop;
    346            uint32_t index = 0x00, numpagewritten = 0x00, addressstatus = NAND_VALID_ADDRESS;
   \   00000008   0026               MOVS     R6,#+0
   \   0000000A   0027               MOVS     R7,#+0
   \   0000000C   4FF48078           MOV      R8,#+256
    347            uint32_t status = NAND_READY, size = 0x00;
   \   00000010   5FF0400A           MOVS     R10,#+64
   \   00000014   5FF00009           MOVS     R9,#+0
   \   00000018   16E0               B.N      ??FSMC_NAND_WriteSmallPage_0
    348          
    349            while((NumPageToWrite != 0x00) && (addressstatus == NAND_VALID_ADDRESS) && (status == NAND_READY))
    350            {
    351              /* Page write command and address */
    352              #if 0
    353              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_WRITE0;
    354          
    355              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00;
    356              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0X00;
    357              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_1st_CYCLE(ROW_ADDRESS);
    358              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_2nd_CYCLE(ROW_ADDRESS);
    359              #else
    360              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_AREA_A;
    361              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_WRITE0;
    362          
    363              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00;
    364              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00;    
    365              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_1st_CYCLE(ROW_ADDRESS);
    366              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_2nd_CYCLE(ROW_ADDRESS);
    367              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_3rd_CYCLE(ROW_ADDRESS);
    368              #endif
    369          
    370              /* Calculate the size */
    371              size = NAND_PAGE_SIZE + (NAND_PAGE_SIZE * numpagewritten);
    372          /*	for(Loop = 0 ; Loop < 10; Loop++)
    373          	{
    374          		*(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00;	   
    375          	}*/
    376              /* Write data */
    377              	Delay(NAND_FLASH_DELAY);
                     	^
Warning[Pe223]: function "Delay" declared implicitly

    u8 Loop;
       ^
"F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\fsmc_nand.c",345  Warning[Pe177]: 
          variable "Loop" was declared but never referenced
    378              for(; index < size; index++)
    379              {
    380                *(__IO uint8_t *)(Bank_NAND_ADDR | DATA_AREA) = pBuffer[index];
   \                     ??FSMC_NAND_WriteSmallPage_1:
   \   0000001A   305D               LDRB     R0,[R6, R4]
   \   0000001C   5FF0E041           MOVS     R1,#+1879048192
   \   00000020   0870               STRB     R0,[R1, #+0]
    381              }
   \   00000022   761C               ADDS     R6,R6,#+1
   \                     ??FSMC_NAND_WriteSmallPage_2:
   \   00000024   4E45               CMP      R6,R9
   \   00000026   F8D3               BCC.N    ??FSMC_NAND_WriteSmallPage_1
    382          
    383              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_WRITE_TRUE1;
   \   00000028   ........           LDR.W    R0,??DataTable10_4  ;; 0x70010000
   \   0000002C   1021               MOVS     R1,#+16
   \   0000002E   0170               STRB     R1,[R0, #+0]
    384          
    385              /* Check status for successful operation */
    386              status = FSMC_NAND_GetStatus();
   \   00000030   ........           BL       FSMC_NAND_GetStatus
   \   00000034   8246               MOV      R10,R0
    387          
    388              if(status == NAND_READY)
   \   00000036   BAF1400F           CMP      R10,#+64
   \   0000003A   05D1               BNE.N    ??FSMC_NAND_WriteSmallPage_0
    389              {
    390                numpagewritten++;
   \   0000003C   7F1C               ADDS     R7,R7,#+1
    391          
    392                NumPageToWrite--;
   \   0000003E   6D1E               SUBS     R5,R5,#+1
    393          
    394                /* Calculate Next small page Address */
    395                addressstatus = FSMC_NAND_AddressIncrement(&Address);
   \   00000040   00A8               ADD      R0,SP,#+0
   \   00000042   ........           BL       FSMC_NAND_AddressIncrement
   \   00000046   8046               MOV      R8,R0
    396              }
   \                     ??FSMC_NAND_WriteSmallPage_0:
   \   00000048   002D               CMP      R5,#+0
   \   0000004A   52D0               BEQ.N    ??FSMC_NAND_WriteSmallPage_3
   \   0000004C   4FF48070           MOV      R0,#+256
   \   00000050   8045               CMP      R8,R0
   \   00000052   4ED1               BNE.N    ??FSMC_NAND_WriteSmallPage_3
   \   00000054   BAF1400F           CMP      R10,#+64
   \   00000058   4BD1               BNE.N    ??FSMC_NAND_WriteSmallPage_3
   \   0000005A   ........           LDR.W    R0,??DataTable10_4  ;; 0x70010000
   \   0000005E   0021               MOVS     R1,#+0
   \   00000060   0170               STRB     R1,[R0, #+0]
   \   00000062   ........           LDR.W    R0,??DataTable10_4  ;; 0x70010000
   \   00000066   8021               MOVS     R1,#+128
   \   00000068   0170               STRB     R1,[R0, #+0]
   \   0000006A   ........           LDR.W    R0,??DataTable10_5  ;; 0x70020000
   \   0000006E   0021               MOVS     R1,#+0
   \   00000070   0170               STRB     R1,[R0, #+0]
   \   00000072   ........           LDR.W    R0,??DataTable10_5  ;; 0x70020000
   \   00000076   0021               MOVS     R1,#+0
   \   00000078   0170               STRB     R1,[R0, #+0]
   \   0000007A   BDF80400           LDRH     R0,[SP, #+4]
   \   0000007E   BDF80210           LDRH     R1,[SP, #+2]
   \   00000082   BDF80020           LDRH     R2,[SP, #+0]
   \   00000086   40F61C03           MOVW     R3,#+2076
   \   0000008A   03FB0211           MLA      R1,R3,R2,R1
   \   0000008E   8022               MOVS     R2,#+128
   \   00000090   02FB0100           MLA      R0,R2,R1,R0
   \   00000094   ........           LDR.W    R1,??DataTable10_5  ;; 0x70020000
   \   00000098   0870               STRB     R0,[R1, #+0]
   \   0000009A   BDF80400           LDRH     R0,[SP, #+4]
   \   0000009E   BDF80210           LDRH     R1,[SP, #+2]
   \   000000A2   BDF80020           LDRH     R2,[SP, #+0]
   \   000000A6   40F61C03           MOVW     R3,#+2076
   \   000000AA   03FB0211           MLA      R1,R3,R2,R1
   \   000000AE   8022               MOVS     R2,#+128
   \   000000B0   02FB0100           MLA      R0,R2,R1,R0
   \   000000B4   0012               ASRS     R0,R0,#+8
   \   000000B6   ........           LDR.W    R1,??DataTable10_5  ;; 0x70020000
   \   000000BA   0870               STRB     R0,[R1, #+0]
   \   000000BC   BDF80400           LDRH     R0,[SP, #+4]
   \   000000C0   BDF80210           LDRH     R1,[SP, #+2]
   \   000000C4   BDF80020           LDRH     R2,[SP, #+0]
   \   000000C8   40F61C03           MOVW     R3,#+2076
   \   000000CC   03FB0211           MLA      R1,R3,R2,R1
   \   000000D0   8022               MOVS     R2,#+128
   \   000000D2   02FB0100           MLA      R0,R2,R1,R0
   \   000000D6   0014               ASRS     R0,R0,#+16
   \   000000D8   ........           LDR.W    R1,??DataTable10_5  ;; 0x70020000
   \   000000DC   0870               STRB     R0,[R1, #+0]
   \   000000DE   4FF40050           MOV      R0,#+8192
   \   000000E2   00FB07F0           MUL      R0,R0,R7
   \   000000E6   10F50059           ADDS     R9,R0,#+8192
   \   000000EA   0520               MOVS     R0,#+5
   \   000000EC   ........           BL       Delay
   \   000000F0   98E7               B.N      ??FSMC_NAND_WriteSmallPage_2
    397            }
    398          
    399            return (status | addressstatus);
   \                     ??FSMC_NAND_WriteSmallPage_3:
   \   000000F2   58EA0A00           ORRS     R0,R8,R10
   \   000000F6   BDE8F687           POP      {R1,R2,R4-R10,PC}  ;; return
    400          }
    401          
    402          /**
    403            * @brief   This routine is for sequential read from one or several 512 Bytes Page size.
    404            * @param  pBuffer: pointer on the Buffer to fill
    405            * @param  Address: First page address
    406            * @param  NumPageToRead: Number of page to read
    407            * @retval New status of the NAND operation. This parameter can be:
    408            *              - NAND_TIMEOUT_ERROR: when the previous operation generate
    409            *                a Timeout error
    410            *              - NAND_READY: when memory is ready for the next operation
    411            *                And the new status of the increment address operation. It can be:
    412            *              - NAND_VALID_ADDRESS: When the new address is valid address
    413            *              - NAND_INVALID_ADDRESS: When the new address is invalid address
    414            */

   \                                 In section .text, align 2, keep-with-next
    415          uint32_t FSMC_NAND_ReadSmallPage(uint8_t *pBuffer, NAND_ADDRESS Address, uint32_t NumPageToRead)
    416          {
   \                     FSMC_NAND_ReadSmallPage:
   \   00000000   2DE9F743           PUSH     {R0-R2,R4-R9,LR}
   \   00000004   0400               MOVS     R4,R0
   \   00000006   1D00               MOVS     R5,R3
    417            uint32_t index = 0x00, numpageread = 0x00, addressstatus = NAND_VALID_ADDRESS;
   \   00000008   0026               MOVS     R6,#+0
   \   0000000A   0027               MOVS     R7,#+0
   \   0000000C   4FF48079           MOV      R9,#+256
    418            uint32_t status = NAND_READY, size = 0x00;
   \   00000010   4020               MOVS     R0,#+64
   \   00000012   5FF00008           MOVS     R8,#+0
    419            u8 Loop = 0;
   \   00000016   0021               MOVS     R1,#+0
    420            u8 Temp = 0;
   \   00000018   0022               MOVS     R2,#+0
   \   0000001A   0CE0               B.N      ??FSMC_NAND_ReadSmallPage_0
    421            while((NumPageToRead != 0x0) && (addressstatus == NAND_VALID_ADDRESS))
    422            {
    423          #if 0
    424              /* Page Read command and page address */
    425              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_AREA_A;
    426          
    427              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00;
    428              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0X00;
    429              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_1st_CYCLE(ROW_ADDRESS);
    430              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_2nd_CYCLE(ROW_ADDRESS);
    431          
    432              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_AREA_TRUE1;
    433          
    434          	 /* 극伎된덤，뤠橙뗍놔鑒앴嫩끽 */
    435          	while( GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_6) == 0 );
    436          #else
    437              /* Page Read command and page address */
    438              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_AREA_A;
    439              
    440              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00;
    441              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00;
    442              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_1st_CYCLE(ROW_ADDRESS);
    443              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_2nd_CYCLE(ROW_ADDRESS);
    444              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_3rd_CYCLE(ROW_ADDRESS);
    445          
    446              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_AREA_TRUE1;		//0x30
    447          #endif
    448          
    449              /* Calculate the size */
    450              size = NAND_PAGE_SIZE + (NAND_PAGE_SIZE * numpageread);
    451              	Delay(NAND_FLASH_DELAY);
                     	^
Warning[Pe223]: function "Delay" declared implicitly

    u8 Loop = 0;
       ^
"F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\fsmc_nand.c",419  Warning[Pe177]: 
          variable "Loop" was declared but never referenced

    u8 Temp = 0;
       ^
"F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\fsmc_nand.c",420  Warning[Pe177]: 
          variable "Temp" was declared but never referenced
    452              /* Get Data into Buffer */
    453              for(; index < size ; index++)
    454              {
    455                pBuffer[index]= *(__IO uint8_t *)(Bank_NAND_ADDR | DATA_AREA);
   \                     ??FSMC_NAND_ReadSmallPage_1:
   \   0000001C   5FF0E040           MOVS     R0,#+1879048192
   \   00000020   0078               LDRB     R0,[R0, #+0]
   \   00000022   3055               STRB     R0,[R6, R4]
    456          
    457              }
   \   00000024   761C               ADDS     R6,R6,#+1
   \                     ??FSMC_NAND_ReadSmallPage_2:
   \   00000026   4645               CMP      R6,R8
   \   00000028   F8D3               BCC.N    ??FSMC_NAND_ReadSmallPage_1
    458          
    459              numpageread++;
   \   0000002A   7F1C               ADDS     R7,R7,#+1
    460          
    461              NumPageToRead--;
   \   0000002C   6D1E               SUBS     R5,R5,#+1
    462          
    463              /* Calculate page address */
    464              addressstatus = FSMC_NAND_AddressIncrement(&Address);
   \   0000002E   01A8               ADD      R0,SP,#+4
   \   00000030   ........           BL       FSMC_NAND_AddressIncrement
   \   00000034   8146               MOV      R9,R0
   \                     ??FSMC_NAND_ReadSmallPage_0:
   \   00000036   002D               CMP      R5,#+0
   \   00000038   48D0               BEQ.N    ??FSMC_NAND_ReadSmallPage_3
   \   0000003A   4FF48070           MOV      R0,#+256
   \   0000003E   8145               CMP      R9,R0
   \   00000040   44D1               BNE.N    ??FSMC_NAND_ReadSmallPage_3
   \   00000042   ....               LDR.N    R0,??DataTable10_4  ;; 0x70010000
   \   00000044   0021               MOVS     R1,#+0
   \   00000046   0170               STRB     R1,[R0, #+0]
   \   00000048   ....               LDR.N    R0,??DataTable10_5  ;; 0x70020000
   \   0000004A   0021               MOVS     R1,#+0
   \   0000004C   0170               STRB     R1,[R0, #+0]
   \   0000004E   ....               LDR.N    R0,??DataTable10_5  ;; 0x70020000
   \   00000050   0021               MOVS     R1,#+0
   \   00000052   0170               STRB     R1,[R0, #+0]
   \   00000054   BDF80800           LDRH     R0,[SP, #+8]
   \   00000058   BDF80610           LDRH     R1,[SP, #+6]
   \   0000005C   BDF80420           LDRH     R2,[SP, #+4]
   \   00000060   40F61C03           MOVW     R3,#+2076
   \   00000064   03FB0211           MLA      R1,R3,R2,R1
   \   00000068   8022               MOVS     R2,#+128
   \   0000006A   02FB0100           MLA      R0,R2,R1,R0
   \   0000006E   ....               LDR.N    R1,??DataTable10_5  ;; 0x70020000
   \   00000070   0870               STRB     R0,[R1, #+0]
   \   00000072   BDF80800           LDRH     R0,[SP, #+8]
   \   00000076   BDF80610           LDRH     R1,[SP, #+6]
   \   0000007A   BDF80420           LDRH     R2,[SP, #+4]
   \   0000007E   40F61C03           MOVW     R3,#+2076
   \   00000082   03FB0211           MLA      R1,R3,R2,R1
   \   00000086   8022               MOVS     R2,#+128
   \   00000088   02FB0100           MLA      R0,R2,R1,R0
   \   0000008C   0012               ASRS     R0,R0,#+8
   \   0000008E   ....               LDR.N    R1,??DataTable10_5  ;; 0x70020000
   \   00000090   0870               STRB     R0,[R1, #+0]
   \   00000092   BDF80800           LDRH     R0,[SP, #+8]
   \   00000096   BDF80610           LDRH     R1,[SP, #+6]
   \   0000009A   BDF80420           LDRH     R2,[SP, #+4]
   \   0000009E   40F61C03           MOVW     R3,#+2076
   \   000000A2   03FB0211           MLA      R1,R3,R2,R1
   \   000000A6   8022               MOVS     R2,#+128
   \   000000A8   02FB0100           MLA      R0,R2,R1,R0
   \   000000AC   0014               ASRS     R0,R0,#+16
   \   000000AE   ....               LDR.N    R1,??DataTable10_5  ;; 0x70020000
   \   000000B0   0870               STRB     R0,[R1, #+0]
   \   000000B2   ....               LDR.N    R0,??DataTable10_4  ;; 0x70010000
   \   000000B4   3021               MOVS     R1,#+48
   \   000000B6   0170               STRB     R1,[R0, #+0]
   \   000000B8   4FF40050           MOV      R0,#+8192
   \   000000BC   00FB07F0           MUL      R0,R0,R7
   \   000000C0   10F50058           ADDS     R8,R0,#+8192
   \   000000C4   0520               MOVS     R0,#+5
   \   000000C6   ........           BL       Delay
   \   000000CA   ACE7               B.N      ??FSMC_NAND_ReadSmallPage_2
    465            }
    466          
    467            status = FSMC_NAND_GetStatus();
   \                     ??FSMC_NAND_ReadSmallPage_3:
   \   000000CC   ........           BL       FSMC_NAND_GetStatus
    468          
    469            return (status | addressstatus);
   \   000000D0   59EA0000           ORRS     R0,R9,R0
   \   000000D4   BDE8FE83           POP      {R1-R9,PC}       ;; return
    470          }
    471          
    472          /**
    473            * @brief   This routine write the spare area information for the specified
    474            *         pages addresses.
    475            * @param  pBuffer: pointer on the Buffer containing data to be written
    476            * @param  Address: First page address
    477            * @param  NumSpareAreaTowrite: Number of Spare Area to write
    478            * @retval New status of the NAND operation. This parameter can be:
    479            *              - NAND_TIMEOUT_ERROR: when the previous operation generate
    480            *                a Timeout error
    481            *              - NAND_READY: when memory is ready for the next operation
    482            *                And the new status of the increment address operation. It can be:
    483            *              - NAND_VALID_ADDRESS: When the new address is valid address
    484            *              - NAND_INVALID_ADDRESS: When the new address is invalid address
    485            */

   \                                 In section .text, align 2, keep-with-next
    486          uint32_t FSMC_NAND_WriteSpareArea(uint8_t *pBuffer, NAND_ADDRESS Address, uint32_t NumSpareAreaTowrite)
    487          {
   \                     FSMC_NAND_WriteSpareArea:
   \   00000000   2DE9F647           PUSH     {R1,R2,R4-R10,LR}
   \   00000004   0400               MOVS     R4,R0
   \   00000006   1D00               MOVS     R5,R3
    488            uint32_t index = 0x00, numsparesreawritten = 0x00, addressstatus = NAND_VALID_ADDRESS;
   \   00000008   0026               MOVS     R6,#+0
   \   0000000A   0027               MOVS     R7,#+0
   \   0000000C   4FF48078           MOV      R8,#+256
    489            uint32_t status = NAND_READY, size = 0x00;
   \   00000010   5FF0400A           MOVS     R10,#+64
   \   00000014   5FF00009           MOVS     R9,#+0
   \   00000018   15E0               B.N      ??FSMC_NAND_WriteSpareArea_0
    490          
    491            while((NumSpareAreaTowrite != 0x00) && (addressstatus == NAND_VALID_ADDRESS) && (status == NAND_READY))
    492            {
    493            #if 0
    494              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_WRITE0;
    495          
    496              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00;
    497              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x08;
    498              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_1st_CYCLE(ROW_ADDRESS);
    499              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_2nd_CYCLE(ROW_ADDRESS);
    500            #else
    501              /* Page write Spare area command and address */
    502          //    *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_AREA_C;
    503              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_WRITE0;
    504              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00;
    505              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00;
    506              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_1st_CYCLE(ROW_ADDRESS);
    507              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_2nd_CYCLE(ROW_ADDRESS);
    508              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_3rd_CYCLE(ROW_ADDRESS);
    509            #endif
    510          
    511              /* Calculate the size */
    512              size = NAND_SPARE_AREA_SIZE + (NAND_SPARE_AREA_SIZE * numsparesreawritten);
    513              	Delay(NAND_FLASH_DELAY);
                     	^
Warning[Pe223]: function "Delay" declared implicitly
    514              /* Write the data */
    515              for(; index < size; index++)
    516              {
    517                *(__IO uint8_t *)(Bank_NAND_ADDR | DATA_AREA) = pBuffer[index];
   \                     ??FSMC_NAND_WriteSpareArea_1:
   \   0000001A   305D               LDRB     R0,[R6, R4]
   \   0000001C   5FF0E041           MOVS     R1,#+1879048192
   \   00000020   0870               STRB     R0,[R1, #+0]
    518              }
   \   00000022   761C               ADDS     R6,R6,#+1
   \                     ??FSMC_NAND_WriteSpareArea_2:
   \   00000024   4E45               CMP      R6,R9
   \   00000026   F8D3               BCC.N    ??FSMC_NAND_WriteSpareArea_1
    519          
    520              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_WRITE_TRUE1;
   \   00000028   ....               LDR.N    R0,??DataTable10_4  ;; 0x70010000
   \   0000002A   1021               MOVS     R1,#+16
   \   0000002C   0170               STRB     R1,[R0, #+0]
    521          
    522              /* Check status for successful operation */
    523              status = FSMC_NAND_GetStatus();
   \   0000002E   ........           BL       FSMC_NAND_GetStatus
   \   00000032   8246               MOV      R10,R0
    524          
    525              if(status == NAND_READY)
   \   00000034   BAF1400F           CMP      R10,#+64
   \   00000038   05D1               BNE.N    ??FSMC_NAND_WriteSpareArea_0
    526              {
    527                numsparesreawritten++;
   \   0000003A   7F1C               ADDS     R7,R7,#+1
    528          
    529                NumSpareAreaTowrite--;
   \   0000003C   6D1E               SUBS     R5,R5,#+1
    530          
    531                /* Calculate Next page Address */
    532                addressstatus = FSMC_NAND_AddressIncrement(&Address);
   \   0000003E   00A8               ADD      R0,SP,#+0
   \   00000040   ........           BL       FSMC_NAND_AddressIncrement
   \   00000044   8046               MOV      R8,R0
    533              }
   \                     ??FSMC_NAND_WriteSpareArea_0:
   \   00000046   002D               CMP      R5,#+0
   \   00000048   48D0               BEQ.N    ??FSMC_NAND_WriteSpareArea_3
   \   0000004A   4FF48070           MOV      R0,#+256
   \   0000004E   8045               CMP      R8,R0
   \   00000050   44D1               BNE.N    ??FSMC_NAND_WriteSpareArea_3
   \   00000052   BAF1400F           CMP      R10,#+64
   \   00000056   41D1               BNE.N    ??FSMC_NAND_WriteSpareArea_3
   \   00000058   ....               LDR.N    R0,??DataTable10_4  ;; 0x70010000
   \   0000005A   8021               MOVS     R1,#+128
   \   0000005C   0170               STRB     R1,[R0, #+0]
   \   0000005E   ....               LDR.N    R0,??DataTable10_5  ;; 0x70020000
   \   00000060   0021               MOVS     R1,#+0
   \   00000062   0170               STRB     R1,[R0, #+0]
   \   00000064   ....               LDR.N    R0,??DataTable10_5  ;; 0x70020000
   \   00000066   0021               MOVS     R1,#+0
   \   00000068   0170               STRB     R1,[R0, #+0]
   \   0000006A   BDF80400           LDRH     R0,[SP, #+4]
   \   0000006E   BDF80210           LDRH     R1,[SP, #+2]
   \   00000072   BDF80020           LDRH     R2,[SP, #+0]
   \   00000076   40F61C03           MOVW     R3,#+2076
   \   0000007A   03FB0211           MLA      R1,R3,R2,R1
   \   0000007E   8022               MOVS     R2,#+128
   \   00000080   02FB0100           MLA      R0,R2,R1,R0
   \   00000084   ....               LDR.N    R1,??DataTable10_5  ;; 0x70020000
   \   00000086   0870               STRB     R0,[R1, #+0]
   \   00000088   BDF80400           LDRH     R0,[SP, #+4]
   \   0000008C   BDF80210           LDRH     R1,[SP, #+2]
   \   00000090   BDF80020           LDRH     R2,[SP, #+0]
   \   00000094   40F61C03           MOVW     R3,#+2076
   \   00000098   03FB0211           MLA      R1,R3,R2,R1
   \   0000009C   8022               MOVS     R2,#+128
   \   0000009E   02FB0100           MLA      R0,R2,R1,R0
   \   000000A2   0012               ASRS     R0,R0,#+8
   \   000000A4   ....               LDR.N    R1,??DataTable10_5  ;; 0x70020000
   \   000000A6   0870               STRB     R0,[R1, #+0]
   \   000000A8   BDF80400           LDRH     R0,[SP, #+4]
   \   000000AC   BDF80210           LDRH     R1,[SP, #+2]
   \   000000B0   BDF80020           LDRH     R2,[SP, #+0]
   \   000000B4   40F61C03           MOVW     R3,#+2076
   \   000000B8   03FB0211           MLA      R1,R3,R2,R1
   \   000000BC   8022               MOVS     R2,#+128
   \   000000BE   02FB0100           MLA      R0,R2,R1,R0
   \   000000C2   0014               ASRS     R0,R0,#+16
   \   000000C4   ....               LDR.N    R1,??DataTable10_5  ;; 0x70020000
   \   000000C6   0870               STRB     R0,[R1, #+0]
   \   000000C8   4FF4DA70           MOV      R0,#+436
   \   000000CC   00FB07F0           MUL      R0,R0,R7
   \   000000D0   00F2B419           ADDW     R9,R0,#+436
   \   000000D4   0520               MOVS     R0,#+5
   \   000000D6   ........           BL       Delay
   \   000000DA   A3E7               B.N      ??FSMC_NAND_WriteSpareArea_2
    534            }
    535          
    536            return (status | addressstatus);
   \                     ??FSMC_NAND_WriteSpareArea_3:
   \   000000DC   58EA0A00           ORRS     R0,R8,R10
   \   000000E0   BDE8F687           POP      {R1,R2,R4-R10,PC}  ;; return
    537          }
    538          
    539          /**
    540            * @brief   This routine read the spare area information from the specified
    541            *         pages addresses.
    542            * @param  pBuffer: pointer on the Buffer to fill
    543            * @param  Address: First page address
    544            * @param  NumSpareAreaToRead: Number of Spare Area to read
    545            * @retval New status of the NAND operation. This parameter can be:
    546            *              - NAND_TIMEOUT_ERROR: when the previous operation generate
    547            *                a Timeout error
    548            *              - NAND_READY: when memory is ready for the next operation
    549            *                And the new status of the increment address operation. It can be:
    550            *              - NAND_VALID_ADDRESS: When the new address is valid address
    551            *              - NAND_INVALID_ADDRESS: When the new address is invalid address
    552            */

   \                                 In section .text, align 2, keep-with-next
    553          uint32_t FSMC_NAND_ReadSpareArea(uint8_t *pBuffer, NAND_ADDRESS Address, uint32_t NumSpareAreaToRead)
    554          {
   \                     FSMC_NAND_ReadSpareArea:
   \   00000000   2DE9F641           PUSH     {R1,R2,R4-R8,LR}
   \   00000004   0400               MOVS     R4,R0
   \   00000006   1F00               MOVS     R7,R3
    555            uint32_t numsparearearead = 0x00, index = 0x00, addressstatus = NAND_VALID_ADDRESS;
   \   00000008   0026               MOVS     R6,#+0
   \   0000000A   0025               MOVS     R5,#+0
   \   0000000C   4FF48078           MOV      R8,#+256
    556            uint32_t status = NAND_READY, size = 0x00;
   \   00000010   4020               MOVS     R0,#+64
   \   00000012   0021               MOVS     R1,#+0
   \   00000014   0CE0               B.N      ??FSMC_NAND_ReadSpareArea_0
    557          
    558            while((NumSpareAreaToRead != 0x0) && (addressstatus == NAND_VALID_ADDRESS))
    559            {
    560              #if 0
    561              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_AREA_A;
    562          
    563              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00;
    564              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x08;
    565              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_1st_CYCLE(ROW_ADDRESS);
    566              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_2nd_CYCLE(ROW_ADDRESS);
    567          
    568              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_AREA_TRUE1;
    569          
    570               while( GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_6) == 0 );
    571              #else
    572              /* Page Read command and page address */
    573              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_AREA_C;
    574              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00;
    575              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00;
    576              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_1st_CYCLE(ROW_ADDRESS);
    577              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_2nd_CYCLE(ROW_ADDRESS);
    578              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_3rd_CYCLE(ROW_ADDRESS);
    579          
    580              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_AREA_TRUE1;
    581              #endif
    582              	Delay(NAND_FLASH_DELAY);
                     	^
Warning[Pe223]: function "Delay" declared implicitly
    583              /* Data Read */
    584              size = NAND_SPARE_AREA_SIZE +  (NAND_SPARE_AREA_SIZE * numsparearearead);
    585          
    586              /* Get Data into Buffer */
    587              for ( ;index < size; index++)
    588              {
    589                pBuffer[index] = *(__IO uint8_t *)(Bank_NAND_ADDR | DATA_AREA);
   \                     ??FSMC_NAND_ReadSpareArea_1:
   \   00000016   5FF0E040           MOVS     R0,#+1879048192
   \   0000001A   0078               LDRB     R0,[R0, #+0]
   \   0000001C   2855               STRB     R0,[R5, R4]
    590              }
   \   0000001E   6D1C               ADDS     R5,R5,#+1
   \                     ??FSMC_NAND_ReadSpareArea_2:
   \   00000020   8D42               CMP      R5,R1
   \   00000022   F8D3               BCC.N    ??FSMC_NAND_ReadSpareArea_1
    591          
    592              numsparearearead++;
   \   00000024   761C               ADDS     R6,R6,#+1
    593          
    594              NumSpareAreaToRead--;
   \   00000026   7F1E               SUBS     R7,R7,#+1
    595          
    596              /* Calculate page address */
    597              addressstatus = FSMC_NAND_AddressIncrement(&Address);
   \   00000028   00A8               ADD      R0,SP,#+0
   \   0000002A   ........           BL       FSMC_NAND_AddressIncrement
   \   0000002E   8046               MOV      R8,R0
   \                     ??FSMC_NAND_ReadSpareArea_0:
   \   00000030   002F               CMP      R7,#+0
   \   00000032   48D0               BEQ.N    ??FSMC_NAND_ReadSpareArea_3
   \   00000034   4FF48070           MOV      R0,#+256
   \   00000038   8045               CMP      R8,R0
   \   0000003A   44D1               BNE.N    ??FSMC_NAND_ReadSpareArea_3
   \   0000003C   ....               LDR.N    R0,??DataTable10_4  ;; 0x70010000
   \   0000003E   5021               MOVS     R1,#+80
   \   00000040   0170               STRB     R1,[R0, #+0]
   \   00000042   ....               LDR.N    R0,??DataTable10_5  ;; 0x70020000
   \   00000044   0021               MOVS     R1,#+0
   \   00000046   0170               STRB     R1,[R0, #+0]
   \   00000048   ....               LDR.N    R0,??DataTable10_5  ;; 0x70020000
   \   0000004A   0021               MOVS     R1,#+0
   \   0000004C   0170               STRB     R1,[R0, #+0]
   \   0000004E   BDF80400           LDRH     R0,[SP, #+4]
   \   00000052   BDF80210           LDRH     R1,[SP, #+2]
   \   00000056   BDF80020           LDRH     R2,[SP, #+0]
   \   0000005A   40F61C03           MOVW     R3,#+2076
   \   0000005E   03FB0211           MLA      R1,R3,R2,R1
   \   00000062   8022               MOVS     R2,#+128
   \   00000064   02FB0100           MLA      R0,R2,R1,R0
   \   00000068   ....               LDR.N    R1,??DataTable10_5  ;; 0x70020000
   \   0000006A   0870               STRB     R0,[R1, #+0]
   \   0000006C   BDF80400           LDRH     R0,[SP, #+4]
   \   00000070   BDF80210           LDRH     R1,[SP, #+2]
   \   00000074   BDF80020           LDRH     R2,[SP, #+0]
   \   00000078   40F61C03           MOVW     R3,#+2076
   \   0000007C   03FB0211           MLA      R1,R3,R2,R1
   \   00000080   8022               MOVS     R2,#+128
   \   00000082   02FB0100           MLA      R0,R2,R1,R0
   \   00000086   0012               ASRS     R0,R0,#+8
   \   00000088   ....               LDR.N    R1,??DataTable10_5  ;; 0x70020000
   \   0000008A   0870               STRB     R0,[R1, #+0]
   \   0000008C   BDF80400           LDRH     R0,[SP, #+4]
   \   00000090   BDF80210           LDRH     R1,[SP, #+2]
   \   00000094   BDF80020           LDRH     R2,[SP, #+0]
   \   00000098   40F61C03           MOVW     R3,#+2076
   \   0000009C   03FB0211           MLA      R1,R3,R2,R1
   \   000000A0   8022               MOVS     R2,#+128
   \   000000A2   02FB0100           MLA      R0,R2,R1,R0
   \   000000A6   0014               ASRS     R0,R0,#+16
   \   000000A8   ....               LDR.N    R1,??DataTable10_5  ;; 0x70020000
   \   000000AA   0870               STRB     R0,[R1, #+0]
   \   000000AC   ....               LDR.N    R0,??DataTable10_4  ;; 0x70010000
   \   000000AE   3021               MOVS     R1,#+48
   \   000000B0   0170               STRB     R1,[R0, #+0]
   \   000000B2   0520               MOVS     R0,#+5
   \   000000B4   ........           BL       Delay
   \   000000B8   4FF4DA70           MOV      R0,#+436
   \   000000BC   00FB06F0           MUL      R0,R0,R6
   \   000000C0   00F2B411           ADDW     R1,R0,#+436
   \   000000C4   ACE7               B.N      ??FSMC_NAND_ReadSpareArea_2
    598            }
    599          
    600            status = FSMC_NAND_GetStatus();
   \                     ??FSMC_NAND_ReadSpareArea_3:
   \   000000C6   ........           BL       FSMC_NAND_GetStatus
    601          
    602            return (status | addressstatus);
   \   000000CA   58EA0000           ORRS     R0,R8,R0
   \   000000CE   BDE8F681           POP      {R1,R2,R4-R8,PC}  ;; return
    603          }
    604          
    605          /**
    606            * @brief   This routine erase complete block from NAND FLASH
    607            * @param  Address: Any address into block to be erased
    608            * @retval New status of the NAND operation. This parameter can be:
    609            *              - NAND_TIMEOUT_ERROR: when the previous operation generate
    610            *                a Timeout error
    611            *              - NAND_READY: when memory is ready for the next operation
    612            */

   \                                 In section .text, align 2, keep-with-next
    613          uint32_t FSMC_NAND_EraseBlock(NAND_ADDRESS Address)
    614          {
   \                     FSMC_NAND_EraseBlock:
   \   00000000   03B5               PUSH     {R0,R1,LR}
   \   00000002   81B0               SUB      SP,SP,#+4
    615          
    616          #if 0
    617            *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_ERASE0;
    618          
    619            *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_1st_CYCLE(ROW_ADDRESS);
    620            *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_2nd_CYCLE(ROW_ADDRESS);
    621          
    622            *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_ERASE1;
    623            return (FSMC_NAND_GetStatus());
    624          
    625          #else
    626            *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_ERASE0;
   \   00000004   ....               LDR.N    R0,??DataTable10_4  ;; 0x70010000
   \   00000006   6021               MOVS     R1,#+96
   \   00000008   0170               STRB     R1,[R0, #+0]
    627          
    628            *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_1st_CYCLE(ROW_ADDRESS);
   \   0000000A   BDF80800           LDRH     R0,[SP, #+8]
   \   0000000E   BDF80610           LDRH     R1,[SP, #+6]
   \   00000012   BDF80420           LDRH     R2,[SP, #+4]
   \   00000016   40F61C03           MOVW     R3,#+2076
   \   0000001A   03FB0211           MLA      R1,R3,R2,R1
   \   0000001E   8022               MOVS     R2,#+128
   \   00000020   02FB0100           MLA      R0,R2,R1,R0
   \   00000024   ....               LDR.N    R1,??DataTable10_5  ;; 0x70020000
   \   00000026   0870               STRB     R0,[R1, #+0]
    629            *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_2nd_CYCLE(ROW_ADDRESS);
   \   00000028   BDF80800           LDRH     R0,[SP, #+8]
   \   0000002C   BDF80610           LDRH     R1,[SP, #+6]
   \   00000030   BDF80420           LDRH     R2,[SP, #+4]
   \   00000034   40F61C03           MOVW     R3,#+2076
   \   00000038   03FB0211           MLA      R1,R3,R2,R1
   \   0000003C   8022               MOVS     R2,#+128
   \   0000003E   02FB0100           MLA      R0,R2,R1,R0
   \   00000042   0012               ASRS     R0,R0,#+8
   \   00000044   ....               LDR.N    R1,??DataTable10_5  ;; 0x70020000
   \   00000046   0870               STRB     R0,[R1, #+0]
    630            *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_3rd_CYCLE(ROW_ADDRESS);
   \   00000048   BDF80800           LDRH     R0,[SP, #+8]
   \   0000004C   BDF80610           LDRH     R1,[SP, #+6]
   \   00000050   BDF80420           LDRH     R2,[SP, #+4]
   \   00000054   40F61C03           MOVW     R3,#+2076
   \   00000058   03FB0211           MLA      R1,R3,R2,R1
   \   0000005C   8022               MOVS     R2,#+128
   \   0000005E   02FB0100           MLA      R0,R2,R1,R0
   \   00000062   0014               ASRS     R0,R0,#+16
   \   00000064   ....               LDR.N    R1,??DataTable10_5  ;; 0x70020000
   \   00000066   0870               STRB     R0,[R1, #+0]
    631          
    632            *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_ERASE1;
   \   00000068   ....               LDR.N    R0,??DataTable10_4  ;; 0x70010000
   \   0000006A   D021               MOVS     R1,#+208
   \   0000006C   0170               STRB     R1,[R0, #+0]
    633            return (FSMC_NAND_GetStatus());
   \   0000006E   ........           BL       FSMC_NAND_GetStatus
   \   00000072   0EBD               POP      {R1-R3,PC}       ;; return
    634          #endif
    635          
    636          }
    637          
    638          /**
    639            * @brief   This routine reset the NAND FLASH
    640            * @param  None
    641            * @retval NAND_READY
    642            */

   \                                 In section .text, align 2, keep-with-next
    643          uint32_t FSMC_NAND_Reset(void)
    644          {
    645            *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_RESET;
   \                     FSMC_NAND_Reset:
   \   00000000   ....               LDR.N    R0,??DataTable10_4  ;; 0x70010000
   \   00000002   FF21               MOVS     R1,#+255
   \   00000004   0170               STRB     R1,[R0, #+0]
    646          
    647            return (NAND_READY);
   \   00000006   4020               MOVS     R0,#+64
   \   00000008   7047               BX       LR               ;; return
    648          }
    649          
    650          /**
    651            * @brief  Get the NAND operation status
    652            * @param  None
    653            * @retval New status of the NAND operation. This parameter can be:
    654            *              - NAND_TIMEOUT_ERROR: when the previous operation generate
    655            *                a Timeout error
    656            *              - NAND_READY: when memory is ready for the next operation
    657            */

   \                                 In section .text, align 2, keep-with-next
    658          uint32_t FSMC_NAND_GetStatus(void)
    659          {
   \                     FSMC_NAND_GetStatus:
   \   00000000   38B5               PUSH     {R3-R5,LR}
    660            uint32_t timeout = 0x1000;//0x1000000;
   \   00000002   4FF48054           MOV      R4,#+4096
    661            uint32_t status = NAND_READY;
   \   00000006   4025               MOVS     R5,#+64
    662          
    663            status = FSMC_NAND_ReadStatus();
   \   00000008   ........           BL       FSMC_NAND_ReadStatus
   \   0000000C   0500               MOVS     R5,R0
   \   0000000E   03E0               B.N      ??FSMC_NAND_GetStatus_0
    664          
    665            /* Wait for a NAND operation to complete or a TIMEOUT to occur */
    666            while ((status != NAND_READY) &&( timeout != 0x00))
    667            {
    668               status = FSMC_NAND_ReadStatus();
   \                     ??FSMC_NAND_GetStatus_1:
   \   00000010   ........           BL       FSMC_NAND_ReadStatus
   \   00000014   0500               MOVS     R5,R0
    669               timeout --;
   \   00000016   641E               SUBS     R4,R4,#+1
    670            }
   \                     ??FSMC_NAND_GetStatus_0:
   \   00000018   402D               CMP      R5,#+64
   \   0000001A   01D0               BEQ.N    ??FSMC_NAND_GetStatus_2
   \   0000001C   002C               CMP      R4,#+0
   \   0000001E   F7D1               BNE.N    ??FSMC_NAND_GetStatus_1
    671          
    672            if(timeout == 0x00)
   \                     ??FSMC_NAND_GetStatus_2:
   \   00000020   002C               CMP      R4,#+0
   \   00000022   01D1               BNE.N    ??FSMC_NAND_GetStatus_3
    673            {
    674              status =  NAND_TIMEOUT_ERROR;
   \   00000024   4FF48065           MOV      R5,#+1024
    675            }
    676          
    677            /* Return the operation status */
    678            return (status);
   \                     ??FSMC_NAND_GetStatus_3:
   \   00000028   2800               MOVS     R0,R5
   \   0000002A   32BD               POP      {R1,R4,R5,PC}    ;; return
    679          }
    680          
    681          /**
    682            * @brief  Reads the NAND memory status using the Read status command
    683            * @param  None
    684            * @retval The status of the NAND memory. This parameter can be:
    685            *              - NAND_BUSY: when memory is busy
    686            *              - NAND_READY: when memory is ready for the next operation
    687            *              - NAND_ERROR: when the previous operation gererates error
    688            */

   \                                 In section .text, align 2, keep-with-next
    689          uint32_t FSMC_NAND_ReadStatus(void)
    690          {
    691            uint32_t data = 0x00, status = NAND_BUSY;
   \                     FSMC_NAND_ReadStatus:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0020               MOVS     R0,#+0
    692          
    693            /* Read status operation ------------------------------------ */
    694            *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_STATUS;
   \   00000004   ....               LDR.N    R2,??DataTable10_4  ;; 0x70010000
   \   00000006   7023               MOVS     R3,#+112
   \   00000008   1370               STRB     R3,[R2, #+0]
    695            data = *(__IO uint8_t *)(Bank_NAND_ADDR);
   \   0000000A   5FF0E042           MOVS     R2,#+1879048192
   \   0000000E   1278               LDRB     R2,[R2, #+0]
   \   00000010   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000012   1100               MOVS     R1,R2
    696          
    697            if((data & NAND_ERROR) == NAND_ERROR)
   \   00000014   CA07               LSLS     R2,R1,#+31
   \   00000016   01D5               BPL.N    ??FSMC_NAND_ReadStatus_0
    698            {
    699              status = NAND_ERROR;
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   04E0               B.N      ??FSMC_NAND_ReadStatus_1
    700            }
    701            else if((data & NAND_READY) == NAND_READY)
   \                     ??FSMC_NAND_ReadStatus_0:
   \   0000001C   4806               LSLS     R0,R1,#+25
   \   0000001E   01D5               BPL.N    ??FSMC_NAND_ReadStatus_2
    702            {
    703              status = NAND_READY;
   \   00000020   4020               MOVS     R0,#+64
   \   00000022   00E0               B.N      ??FSMC_NAND_ReadStatus_1
    704            }
    705            else
    706            {
    707              status = NAND_BUSY;
   \                     ??FSMC_NAND_ReadStatus_2:
   \   00000024   0020               MOVS     R0,#+0
    708            }
    709          
    710            return (status);
   \                     ??FSMC_NAND_ReadStatus_1:
   \   00000026   7047               BX       LR               ;; return
    711          }
    712          
    713          /**
    714            * @brief  Increment the NAND memory address
    715            * @param  Address: address to be incremented.
    716            * @retval The new status of the increment address operation. It can be:
    717            *              - NAND_VALID_ADDRESS: When the new address is valid address
    718            *              - NAND_INVALID_ADDRESS: When the new address is invalid address
    719            */

   \                                 In section .text, align 2, keep-with-next
    720          uint32_t FSMC_NAND_AddressIncrement(NAND_ADDRESS* Address)
    721          {
    722            uint32_t status = NAND_VALID_ADDRESS;
   \                     FSMC_NAND_AddressIncrement:
   \   00000000   4FF48071           MOV      R1,#+256
    723          
    724            Address->Page++;
   \   00000004   8288               LDRH     R2,[R0, #+4]
   \   00000006   521C               ADDS     R2,R2,#+1
   \   00000008   8280               STRH     R2,[R0, #+4]
    725          
    726            if(Address->Page == NAND_BLOCK_SIZE)
   \   0000000A   8288               LDRH     R2,[R0, #+4]
   \   0000000C   802A               CMP      R2,#+128
   \   0000000E   13D1               BNE.N    ??FSMC_NAND_AddressIncrement_0
    727            {
    728              Address->Page = 0;
   \   00000010   0022               MOVS     R2,#+0
   \   00000012   8280               STRH     R2,[R0, #+4]
    729              Address->Block++;
   \   00000014   4288               LDRH     R2,[R0, #+2]
   \   00000016   521C               ADDS     R2,R2,#+1
   \   00000018   4280               STRH     R2,[R0, #+2]
    730          
    731              if(Address->Block == NAND_ZONE_SIZE)
   \   0000001A   4288               LDRH     R2,[R0, #+2]
   \   0000001C   40F61C03           MOVW     R3,#+2076
   \   00000020   9A42               CMP      R2,R3
   \   00000022   09D1               BNE.N    ??FSMC_NAND_AddressIncrement_0
    732              {
    733                Address->Block = 0;
   \   00000024   0022               MOVS     R2,#+0
   \   00000026   4280               STRH     R2,[R0, #+2]
    734                Address->Zone++;
   \   00000028   0288               LDRH     R2,[R0, #+0]
   \   0000002A   521C               ADDS     R2,R2,#+1
   \   0000002C   0280               STRH     R2,[R0, #+0]
    735          
    736                if(Address->Zone == NAND_MAX_ZONE)
   \   0000002E   0088               LDRH     R0,[R0, #+0]
   \   00000030   0128               CMP      R0,#+1
   \   00000032   01D1               BNE.N    ??FSMC_NAND_AddressIncrement_0
    737                {
    738                  status = NAND_INVALID_ADDRESS;
   \   00000034   4FF40071           MOV      R1,#+512
    739                }
    740              }
    741            }
    742          
    743            return (status);
   \                     ??FSMC_NAND_AddressIncrement_0:
   \   00000038   0800               MOVS     R0,R1
   \   0000003A   7047               BX       LR               ;; return
    744          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   000C0240           DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   00100240           DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   00180240           DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   ........           DC32     NAND_ID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   00000170           DC32     0x70010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   00000270           DC32     0x70020000
    745          
    746          /**
    747            * @}
    748            */
    749          
    750          /**
    751            * @}
    752            */
    753          
    754          /******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                   .cstack
     --------                   -------
     FSMC_NAND_AddressIncrement      0
     FSMC_NAND_EraseBlock           16
     FSMC_NAND_GetStatus            16
     FSMC_NAND_Init                 64
     FSMC_NAND_ReadID                0
     FSMC_NAND_ReadSmallPage        40
     FSMC_NAND_ReadSpareArea        32
     FSMC_NAND_ReadStatus            0
     FSMC_NAND_Reset                 0
     FSMC_NAND_WriteSmallPage       40
     FSMC_NAND_WriteSpareArea       40
     NAND_ReadSmallPage             32
     NAND_WriteSmallPage            32


   Section sizes:

     Function/Label             Bytes
     --------------             -----
     NAND_Buffer                8196
     NAND_SpearArea              440
     NAND_Address                  8
     NAND_ID                       4
     FSMC_NAND_Init              418
     FSMC_NAND_ReadID             42
     NAND_WriteSmallPage         224
     NAND_ReadSmallPage          198
     FSMC_NAND_WriteSmallPage    250
     FSMC_NAND_ReadSmallPage     216
     FSMC_NAND_WriteSpareArea    228
     FSMC_NAND_ReadSpareArea     210
     FSMC_NAND_EraseBlock        116
     FSMC_NAND_Reset              10
     FSMC_NAND_GetStatus          44
     FSMC_NAND_ReadStatus         40
     FSMC_NAND_AddressIncrement   60
     ??DataTable10                 4
     ??DataTable10_1               4
     ??DataTable10_2               4
     ??DataTable10_3               4
     ??DataTable10_4               4
     ??DataTable10_5               4

 
 8 648 bytes in section .bss
 2 080 bytes in section .text
 
 2 080 bytes of CODE memory
 8 648 bytes of DATA memory

Errors: none
Warnings: 8
