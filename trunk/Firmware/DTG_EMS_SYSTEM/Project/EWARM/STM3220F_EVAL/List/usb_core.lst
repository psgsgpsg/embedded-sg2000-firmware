###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     08/Jan/2012  13:10:10 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Libraries\STM32_USB_ #
#                    OTG_Driver\src\usb_core.c                                #
#    Command line =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Libraries\STM32_USB_ #
#                    OTG_Driver\src\usb_core.c -D USE_STDPERIPH_DRIVER -D     #
#                    STM32F2XX -D USE_STM3220F_EVAL -D USE_USB_OTG_FS -D      #
#                    RTC_CLOCK_SOURCE_LSE -lC E:\Work\Firmware\DTG\DTG_EMS_SY #
#                    STEM\Project\EWARM\STM3220F_EVAL\List\ -lA               #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\List\ -o E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Pro #
#                    ject\EWARM\STM3220F_EVAL\Obj\ --no_cse --no_unroll       #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWAR #
#                    M\..\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWA #
#                    RM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I             #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I       #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I             #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Utilities\STM32_EVAL\ -I E:\Work\Firmware\DTG\DTG_EMS_SY #
#                    STEM\Project\EWARM\..\..\Utilities\STM32_EVAL\Common\    #
#                    -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\ #
#                    ..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I                #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_OTG_Driver\inc\ -I                   #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_Device_Library\Core\inc\ -I          #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_Device_Library\Class\msc\inc\ -I     #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\Usb #
#                    \ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\. #
#                    .\Usb\Inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Projec #
#                    t\EWARM\..\Usb\src\ -I E:\Work\Firmware\DTG\DTG_EMS_SYST #
#                    EM\Project\EWARM\..\..\Libraries\STM32_USB_HOST_Library\ #
#                    Core\inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project #
#                    \EWARM\..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\ #
#                    inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWAR #
#                    M\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc #
#                    \ -Ol --use_c++_inline                                   #
#    List file    =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\List\usb_core.lst                                #
#    Object file  =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\Obj\usb_core.o                                   #
#                                                                             #
#                                                                             #
###############################################################################

E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Libraries\STM32_USB_OTG_Driver\src\usb_core.c
      1          /**
      2            ******************************************************************************
      3            * @file    usb_core.c
      4            * @author  MCD Application Team
      5            * @version V2.0.0RC1
      6            * @date    18-March-2011
      7            * @brief   USB-OTG Core Layer
      8            ******************************************************************************
      9            * @attention 
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE 
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "usb_core.h"
     24          #include "usb_bsp.h"
     25          
     26          
     27          /** @addtogroup USB_OTG_DRIVER
     28          * @{
     29          */
     30          
     31          /** @defgroup USB_CORE 
     32          * @brief This file includes the USB-OTG Core Layer
     33          * @{
     34          */
     35          
     36          
     37          /** @defgroup USB_CORE_Private_Defines
     38          * @{
     39          */ 
     40          /**
     41          * @}
     42          */ 
     43          
     44          
     45          /** @defgroup USB_CORE_Private_TypesDefinitions
     46          * @{
     47          */ 
     48          /**
     49          * @}
     50          */ 
     51          
     52          
     53          
     54          /** @defgroup USB_CORE_Private_Macros
     55          * @{
     56          */ 
     57          /**
     58          * @}
     59          */ 
     60          
     61          
     62          /** @defgroup USB_CORE_Private_Variables
     63          * @{
     64          */ 
     65          /**
     66          * @}
     67          */ 
     68          
     69          
     70          /** @defgroup USB_CORE_Private_FunctionPrototypes
     71          * @{
     72          */ 
     73          /**
     74          * @}
     75          */ 
     76          
     77          
     78          /** @defgroup USB_CORE_Private_Functions
     79          * @{
     80          */ 
     81          
     82          /**
     83          * @brief  USB_OTG_EnableCommonInt
     84          *         Initializes the commmon interrupts, used in both device and modes
     85          * @param  pdev : Selected device
     86          * @retval None
     87          */

   \                                 In section .text, align 2, keep-with-next
     88          static void USB_OTG_EnableCommonInt(USB_OTG_CORE_HANDLE *pdev)
     89          {
     90            USB_OTG_GINTMSK_TypeDef  int_mask;
     91            
     92            int_mask.d32 = 0;
   \                     USB_OTG_EnableCommonInt:
   \   00000000   0021               MOVS     R1,#+0
     93            /* Clear any pending USB_OTG Interrupts */
     94          #ifndef USE_OTG_MODE
     95            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GOTGINT, 0xFFFFFFFF);
   \   00000002   C268               LDR      R2,[R0, #+12]
   \   00000004   5FF0FF33           MOVS     R3,#-1
   \   00000008   5360               STR      R3,[R2, #+4]
     96          #endif
     97            /* Clear any pending interrupts */
     98            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
   \   0000000A   C268               LDR      R2,[R0, #+12]
   \   0000000C   5FF0FF33           MOVS     R3,#-1
   \   00000010   5361               STR      R3,[R2, #+20]
     99            /* Enable the interrupts in the INTMSK */
    100            int_mask.b.wkupintr = 1;
   \   00000012   51F00041           ORRS     R1,R1,#0x80000000
    101            int_mask.b.usbsuspend = 1; 
   \   00000016   51F40061           ORRS     R1,R1,#0x800
    102            
    103          #ifdef USE_OTG_MODE
    104            int_mask.b.otgintr = 1;
    105            int_mask.b.sessreqintr = 1;
    106            int_mask.b.conidstschng = 1;
    107          #endif
    108            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32);
   \   0000001A   C068               LDR      R0,[R0, #+12]
   \   0000001C   8161               STR      R1,[R0, #+24]
    109          }
   \   0000001E   7047               BX       LR               ;; return
    110          
    111          /**
    112          * @brief  USB_OTG_CoreReset : Soft reset of the core
    113          * @param  pdev : Selected device
    114          * @retval USB_OTG_STS : status
    115          */

   \                                 In section .text, align 2, keep-with-next
    116          static USB_OTG_STS USB_OTG_CoreReset(USB_OTG_CORE_HANDLE *pdev)
    117          {
   \                     USB_OTG_CoreReset:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   \   00000004   0400               MOVS     R4,R0
    118            USB_OTG_STS status = USB_OTG_OK;
   \   00000006   0025               MOVS     R5,#+0
    119            __IO USB_OTG_GRSTCTL_TypeDef  greset;
    120            uint32_t count = 0;
   \   00000008   0026               MOVS     R6,#+0
    121            
    122            greset.d32 = 0;
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   0090               STR      R0,[SP, #+0]
    123            /* Wait for AHB master IDLE state. */
    124            do
    125            {
    126              USB_OTG_BSP_uDelay(3);
   \                     ??USB_OTG_CoreReset_0:
   \   0000000E   0320               MOVS     R0,#+3
   \   00000010   ........           BL       USB_OTG_BSP_uDelay
    127              greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
   \   00000014   E068               LDR      R0,[R4, #+12]
   \   00000016   0069               LDR      R0,[R0, #+16]
   \   00000018   0090               STR      R0,[SP, #+0]
    128              if (++count > 200000)
   \   0000001A   761C               ADDS     R6,R6,#+1
   \   0000001C   ....               LDR.N    R0,??DataTable3  ;; 0x30d41
   \   0000001E   8642               CMP      R6,R0
   \   00000020   01D3               BCC.N    ??USB_OTG_CoreReset_1
    129              {
    130                return USB_OTG_OK;
   \   00000022   0020               MOVS     R0,#+0
   \   00000024   1CE0               B.N      ??USB_OTG_CoreReset_2
    131              }
    132            }
    133            while (greset.b.ahbidle == 0);
   \                     ??USB_OTG_CoreReset_1:
   \   00000026   0098               LDR      R0,[SP, #+0]
   \   00000028   0028               CMP      R0,#+0
   \   0000002A   F0D5               BPL.N    ??USB_OTG_CoreReset_0
    134            /* Core Soft Reset */
    135            count = 0;
   \   0000002C   0026               MOVS     R6,#+0
    136            greset.b.csftrst = 1;
   \   0000002E   0098               LDR      R0,[SP, #+0]
   \   00000030   50F00100           ORRS     R0,R0,#0x1
   \   00000034   0090               STR      R0,[SP, #+0]
    137            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
   \   00000036   E068               LDR      R0,[R4, #+12]
   \   00000038   0099               LDR      R1,[SP, #+0]
   \   0000003A   0161               STR      R1,[R0, #+16]
    138            do
    139            {
    140              greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
   \                     ??USB_OTG_CoreReset_3:
   \   0000003C   E068               LDR      R0,[R4, #+12]
   \   0000003E   0069               LDR      R0,[R0, #+16]
   \   00000040   0090               STR      R0,[SP, #+0]
    141              if (++count > 200000)
   \   00000042   761C               ADDS     R6,R6,#+1
   \   00000044   ....               LDR.N    R0,??DataTable3  ;; 0x30d41
   \   00000046   8642               CMP      R6,R0
   \   00000048   05D2               BCS.N    ??USB_OTG_CoreReset_4
    142              {
    143                break;
    144              }
    145            }
    146            while (greset.b.csftrst == 1);
   \                     ??USB_OTG_CoreReset_5:
   \   0000004A   0098               LDR      R0,[SP, #+0]
   \   0000004C   10F00100           ANDS     R0,R0,#0x1
   \   00000050   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0028               CMP      R0,#+0
   \   00000054   F2D1               BNE.N    ??USB_OTG_CoreReset_3
    147            /* Wait for 3 PHY Clocks*/
    148            USB_OTG_BSP_uDelay(3);
   \                     ??USB_OTG_CoreReset_4:
   \   00000056   0320               MOVS     R0,#+3
   \   00000058   ........           BL       USB_OTG_BSP_uDelay
    149            return status;
   \   0000005C   2800               MOVS     R0,R5
   \   0000005E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??USB_OTG_CoreReset_2:
   \   00000060   76BD               POP      {R1,R2,R4-R6,PC}  ;; return
    150          }
    151          
    152          /**
    153          * @brief  USB_OTG_WritePacket : Writes a packet into the Tx FIFO associated 
    154          *         with the EP
    155          * @param  pdev : Selected device
    156          * @param  src : source pointer
    157          * @param  ch_ep_num : end point number
    158          * @param  bytes : No. of bytes
    159          * @retval USB_OTG_STS : status
    160          */

   \                                 In section .text, align 2, keep-with-next
    161          USB_OTG_STS USB_OTG_WritePacket(USB_OTG_CORE_HANDLE *pdev, 
    162                                          uint8_t             *src, 
    163                                          uint8_t             ch_ep_num, 
    164                                          uint16_t            len)
    165          {
   \                     USB_OTG_WritePacket:
   \   00000000   F0B4               PUSH     {R4-R7}
   \   00000002   1C00               MOVS     R4,R3
    166            USB_OTG_STS status = USB_OTG_OK;
   \   00000004   0023               MOVS     R3,#+0
    167            if (pdev->cfg.dma_enable == 0)
   \   00000006   C578               LDRB     R5,[R0, #+3]
   \   00000008   002D               CMP      R5,#+0
   \   0000000A   15D1               BNE.N    ??USB_OTG_WritePacket_0
    168            {
    169              uint32_t count32b= 0 , i= 0;
   \   0000000C   0025               MOVS     R5,#+0
   \   0000000E   0026               MOVS     R6,#+0
    170              __IO uint32_t *fifo;
    171              
    172              count32b =  (len + 3) / 4;
   \   00000010   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000012   E41C               ADDS     R4,R4,#+3
   \   00000014   0427               MOVS     R7,#+4
   \   00000016   94FBF7F4           SDIV     R4,R4,R7
   \   0000001A   2500               MOVS     R5,R4
    173              fifo = pdev->regs.DFIFO[ch_ep_num];
   \   0000001C   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001E   10EB8200           ADDS     R0,R0,R2, LSL #+2
   \   00000022   D0F8D000           LDR      R0,[R0, #+208]
    174              for (i = 0; i < count32b; i++, src+=4)
   \   00000026   0022               MOVS     R2,#+0
   \   00000028   1600               MOVS     R6,R2
   \   0000002A   03E0               B.N      ??USB_OTG_WritePacket_1
    175              {
    176                USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
   \                     ??USB_OTG_WritePacket_2:
   \   0000002C   0A68               LDR      R2,[R1, #+0]
   \   0000002E   0260               STR      R2,[R0, #+0]
    177              }
   \   00000030   761C               ADDS     R6,R6,#+1
   \   00000032   091D               ADDS     R1,R1,#+4
   \                     ??USB_OTG_WritePacket_1:
   \   00000034   AE42               CMP      R6,R5
   \   00000036   F9D3               BCC.N    ??USB_OTG_WritePacket_2
    178            }
    179            return status;
   \                     ??USB_OTG_WritePacket_0:
   \   00000038   1800               MOVS     R0,R3
   \   0000003A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   F0BC               POP      {R4-R7}
   \   0000003E   7047               BX       LR               ;; return
    180          }
    181          
    182          
    183          /**
    184          * @brief  USB_OTG_ReadPacket : Reads a packet from the Rx FIFO
    185          * @param  pdev : Selected device
    186          * @param  dest : Destination Pointer
    187          * @param  bytes : No. of bytes
    188          * @retval None
    189          */

   \                                 In section .text, align 2, keep-with-next
    190          void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
    191                                   uint8_t *dest, 
    192                                   uint16_t len)
    193          {
   \                     USB_OTG_ReadPacket:
   \   00000000   10B4               PUSH     {R4}
    194            uint32_t i=0;
   \   00000002   0023               MOVS     R3,#+0
    195            uint32_t count32b = (len + 3) / 4;
   \   00000004   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000006   D21C               ADDS     R2,R2,#+3
   \   00000008   0424               MOVS     R4,#+4
   \   0000000A   92FBF4F2           SDIV     R2,R2,R4
    196            
    197            __IO uint32_t *fifo = pdev->regs.DFIFO[0];
   \   0000000E   D0F8D000           LDR      R0,[R0, #+208]
    198            
    199            for ( i = 0; i < count32b; i++, dest += 4 )
   \   00000012   0024               MOVS     R4,#+0
   \   00000014   2300               MOVS     R3,R4
   \   00000016   03E0               B.N      ??USB_OTG_ReadPacket_0
    200            {
    201              *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
   \                     ??USB_OTG_ReadPacket_1:
   \   00000018   0468               LDR      R4,[R0, #+0]
   \   0000001A   0C60               STR      R4,[R1, #+0]
    202              
    203            }
   \   0000001C   5B1C               ADDS     R3,R3,#+1
   \   0000001E   091D               ADDS     R1,R1,#+4
   \                     ??USB_OTG_ReadPacket_0:
   \   00000020   9342               CMP      R3,R2
   \   00000022   F9D3               BCC.N    ??USB_OTG_ReadPacket_1
    204            return ((void *)dest);
   \   00000024   0800               MOVS     R0,R1
   \   00000026   10BC               POP      {R4}
   \   00000028   7047               BX       LR               ;; return
    205          }
    206          
    207          /**
    208          * @brief  USB_OTG_SelectCore 
    209          *         Initialize core registers address.
    210          * @param  pdev : Selected device
    211          * @param  coreID : USB OTG Core ID
    212          * @retval USB_OTG_STS : status
    213          */

   \                                 In section .text, align 2, keep-with-next
    214          USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
    215                                         USB_OTG_CORE_ID_TypeDef coreID)
    216          {
   \                     USB_OTG_SelectCore:
   \   00000000   30B4               PUSH     {R4,R5}
   \   00000002   0A00               MOVS     R2,R1
    217            uint32_t i , baseAddress;
    218            USB_OTG_STS status = USB_OTG_OK;
   \   00000004   0021               MOVS     R1,#+0
    219            
    220            pdev->cfg.dma_enable       = 0;
   \   00000006   0024               MOVS     R4,#+0
   \   00000008   C470               STRB     R4,[R0, #+3]
    221            
    222            /* at startup the core is in FS mode */
    223            pdev->cfg.speed            = USB_OTG_SPEED_FULL;
   \   0000000A   0124               MOVS     R4,#+1
   \   0000000C   8470               STRB     R4,[R0, #+2]
    224            pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
   \   0000000E   4024               MOVS     R4,#+64
   \   00000010   8480               STRH     R4,[R0, #+4]
    225              
    226            /* initialize device cfg following its address */
    227            if (coreID == USB_OTG_FS_CORE_ID)
   \   00000012   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000014   012A               CMP      R2,#+1
   \   00000016   0DD1               BNE.N    ??USB_OTG_SelectCore_0
    228            {
    229              baseAddress                = USB_OTG_FS_BASE_ADDR;
   \   00000018   5FF0A043           MOVS     R3,#+1342177280
    230              pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
   \   0000001C   0122               MOVS     R2,#+1
   \   0000001E   C272               STRB     R2,[R0, #+11]
    231              pdev->cfg.host_channels    = 8 ;
   \   00000020   0822               MOVS     R2,#+8
   \   00000022   0270               STRB     R2,[R0, #+0]
    232              pdev->cfg.dev_endpoints    = 4 ;
   \   00000024   0422               MOVS     R2,#+4
   \   00000026   4270               STRB     R2,[R0, #+1]
    233              pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
   \   00000028   4FF4A072           MOV      R2,#+320
   \   0000002C   C280               STRH     R2,[R0, #+6]
    234          #ifdef USB_OTG_FS_I2C_PHY_ENABLED    
    235              pdev->cfg.phy_itface       = USB_OTG_FS_I2C_PHY; 
    236          #else
    237          #ifdef USB_OTG_FS_EMBEDDED_PHY_ENABLED   
    238              pdev->cfg.phy_itface       = USB_OTG_FS_EMBEDDED_PHY;     
   \   0000002E   0222               MOVS     R2,#+2
   \   00000030   0272               STRB     R2,[R0, #+8]
   \   00000032   0CE0               B.N      ??USB_OTG_SelectCore_1
    239          #endif
    240          #endif  
    241              
    242          #ifdef USB_OTG_FS_SOF_OUTPUT_ENABLED    
    243              pdev->cfg.Sof_output       = 1;    
    244          #endif 
    245              
    246          #ifdef USB_OTG_FS_LOW_PWR_MGMT_SUPPORT    
    247              pdev->cfg.low_power        = 1;    
    248          #endif     
    249            }
    250            else if (coreID == USB_OTG_HS_CORE_ID)
   \                     ??USB_OTG_SelectCore_0:
   \   00000034   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000036   002A               CMP      R2,#+0
   \   00000038   09D1               BNE.N    ??USB_OTG_SelectCore_1
    251            {
    252              baseAddress                = USB_OTG_HS_BASE_ADDR;
   \   0000003A   ....               LDR.N    R3,??DataTable3_1  ;; 0x40040000
    253              pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
   \   0000003C   0022               MOVS     R2,#+0
   \   0000003E   C272               STRB     R2,[R0, #+11]
    254              pdev->cfg.host_channels    = 12 ;
   \   00000040   0C22               MOVS     R2,#+12
   \   00000042   0270               STRB     R2,[R0, #+0]
    255              pdev->cfg.dev_endpoints    = 6 ;
   \   00000044   0622               MOVS     R2,#+6
   \   00000046   4270               STRB     R2,[R0, #+1]
    256              pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
   \   00000048   4FF4A062           MOV      R2,#+1280
   \   0000004C   C280               STRH     R2,[R0, #+6]
    257              
    258          #ifdef USB_OTG_HS_ULPI_PHY_ENABLED
    259              pdev->cfg.phy_itface       = USB_OTG_HS_ULPI_PHY;     
    260          #ifdef USB_OTG_HS_EMBEDDED_PHY_ENABLED
    261              pdev->cfg.phy_itface       = USB_OTG_FS_EMBEDDED_PHY;
    262          #else   
    263          #ifdef USB_OTG_HS_I2C_PHY_ENABLED    
    264              pdev->cfg.phy_itface       = USB_OTG_FS_I2C_PHY; 
    265          #endif
    266          #endif  
    267          #endif      
    268              
    269          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED    
    270              pdev->cfg.dma_enable       = 1;    
    271          #endif
    272              
    273          #ifdef USB_OTG_HS_SOF_OUTPUT_ENABLED    
    274              pdev->cfg.Sof_output       = 1;    
    275          #endif 
    276              
    277          #ifdef USB_OTG_HS_LOW_PWR_MGMT_SUPPORT    
    278              pdev->cfg.low_power        = 1;    
    279          #endif 
    280              
    281            }
    282            
    283            pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    284              USB_OTG_CORE_GLOBAL_REGS_OFFSET);
   \                     ??USB_OTG_SelectCore_1:
   \   0000004E   C360               STR      R3,[R0, #+12]
    285            pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
    286              USB_OTG_DEV_GLOBAL_REG_OFFSET);
   \   00000050   13F50062           ADDS     R2,R3,#+2048
   \   00000054   0261               STR      R2,[R0, #+16]
    287            
    288            for (i = 0; i < pdev->cfg.dev_endpoints; i++)
   \   00000056   0022               MOVS     R2,#+0
   \   00000058   0EE0               B.N      ??USB_OTG_SelectCore_2
    289            {
    290              pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
    291                (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
    292                  (i * USB_OTG_EP_REG_OFFSET));
   \                     ??USB_OTG_SelectCore_3:
   \   0000005A   10EB8204           ADDS     R4,R0,R2, LSL #+2
   \   0000005E   13EB4215           ADDS     R5,R3,R2, LSL #+5
   \   00000062   15F51065           ADDS     R5,R5,#+2304
   \   00000066   A561               STR      R5,[R4, #+24]
    293              pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
    294                (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
    295                  (i * USB_OTG_EP_REG_OFFSET));
   \   00000068   10EB8204           ADDS     R4,R0,R2, LSL #+2
   \   0000006C   13EB4215           ADDS     R5,R3,R2, LSL #+5
   \   00000070   15F53065           ADDS     R5,R5,#+2816
   \   00000074   6565               STR      R5,[R4, #+84]
    296            }
   \   00000076   521C               ADDS     R2,R2,#+1
   \                     ??USB_OTG_SelectCore_2:
   \   00000078   4478               LDRB     R4,[R0, #+1]
   \   0000007A   A242               CMP      R2,R4
   \   0000007C   EDD3               BCC.N    ??USB_OTG_SelectCore_3
    297            pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
    298              USB_OTG_HOST_GLOBAL_REG_OFFSET);
   \   0000007E   13F58062           ADDS     R2,R3,#+1024
   \   00000082   4261               STR      R2,[R0, #+20]
    299            pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
   \   00000084   13F58862           ADDS     R2,R3,#+1088
   \   00000088   C0F8CC20           STR      R2,[R0, #+204]
    300            
    301            for (i = 0; i < pdev->cfg.host_channels; i++)
   \   0000008C   0022               MOVS     R2,#+0
   \   0000008E   08E0               B.N      ??USB_OTG_SelectCore_4
    302            {
    303              pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
    304                USB_OTG_HOST_CHAN_REGS_OFFSET + \
    305                  (i * USB_OTG_CHAN_REGS_OFFSET));
   \                     ??USB_OTG_SelectCore_5:
   \   00000090   10EB8204           ADDS     R4,R0,R2, LSL #+2
   \   00000094   13EB4215           ADDS     R5,R3,R2, LSL #+5
   \   00000098   15F5A065           ADDS     R5,R5,#+1280
   \   0000009C   C4F89050           STR      R5,[R4, #+144]
    306            }
   \   000000A0   521C               ADDS     R2,R2,#+1
   \                     ??USB_OTG_SelectCore_4:
   \   000000A2   0478               LDRB     R4,[R0, #+0]
   \   000000A4   A242               CMP      R2,R4
   \   000000A6   F3D3               BCC.N    ??USB_OTG_SelectCore_5
    307            for (i = 0; i < pdev->cfg.host_channels; i++)
   \   000000A8   0022               MOVS     R2,#+0
   \   000000AA   0AE0               B.N      ??USB_OTG_SelectCore_6
    308            {
    309              pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
    310                (i * USB_OTG_DATA_FIFO_SIZE));
   \                     ??USB_OTG_SelectCore_7:
   \   000000AC   10EB8204           ADDS     R4,R0,R2, LSL #+2
   \   000000B0   4FF48055           MOV      R5,#+4096
   \   000000B4   05FB0235           MLA      R5,R5,R2,R3
   \   000000B8   15F58055           ADDS     R5,R5,#+4096
   \   000000BC   C4F8D050           STR      R5,[R4, #+208]
    311            }
   \   000000C0   521C               ADDS     R2,R2,#+1
   \                     ??USB_OTG_SelectCore_6:
   \   000000C2   0478               LDRB     R4,[R0, #+0]
   \   000000C4   A242               CMP      R2,R4
   \   000000C6   F1D3               BCC.N    ??USB_OTG_SelectCore_7
    312            pdev->regs.PCGCCTL = (uint32_t *)(baseAddress + USB_OTG_PCGCCTL_OFFSET);
   \   000000C8   13F56062           ADDS     R2,R3,#+3584
   \   000000CC   C0F80C21           STR      R2,[R0, #+268]
    313            
    314            return status;
   \   000000D0   0800               MOVS     R0,R1
   \   000000D2   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D4   30BC               POP      {R4,R5}
   \   000000D6   7047               BX       LR               ;; return
    315          }
    316          
    317          
    318          /**
    319          * @brief  USB_OTG_CoreInit
    320          *         Initializes the USB_OTG controller registers and prepares the core
    321          *         device mode or host mode operation.
    322          * @param  pdev : Selected device
    323          * @retval USB_OTG_STS : status
    324          */

   \                                 In section .text, align 2, keep-with-next
    325          USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
    326          {
   \                     USB_OTG_CoreInit:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
    327            USB_OTG_STS status = USB_OTG_OK;
   \   00000004   0025               MOVS     R5,#+0
    328            USB_OTG_GUSBCFG_TypeDef  usbcfg;
    329            USB_OTG_GCCFG_TypeDef    gccfg;
    330            USB_OTG_GI2CCTL_TypeDef  i2cctl;
    331            USB_OTG_GAHBCFG_TypeDef  ahbcfg;
    332            
    333            usbcfg.d32 = 0;
   \   00000006   0020               MOVS     R0,#+0
    334            gccfg.d32 = 0;
   \   00000008   0021               MOVS     R1,#+0
    335            ahbcfg.d32 = 0;
   \   0000000A   0026               MOVS     R6,#+0
    336            
    337          
    338            
    339            if (pdev->cfg.phy_itface == USB_OTG_HS_ULPI_PHY)
   \   0000000C   227A               LDRB     R2,[R4, #+8]
   \   0000000E   012A               CMP      R2,#+1
   \   00000010   2CD1               BNE.N    ??USB_OTG_CoreInit_0
    340            {
    341              gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
   \   00000012   E068               LDR      R0,[R4, #+12]
   \   00000014   816B               LDR      R1,[R0, #+56]
    342              gccfg.b.pwdn = 0;
   \   00000016   31F48031           BICS     R1,R1,#0x10000
    343              
    344              if (pdev->cfg.Sof_output)
   \   0000001A   607A               LDRB     R0,[R4, #+9]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   01D0               BEQ.N    ??USB_OTG_CoreInit_1
    345              {
    346                gccfg.b.sofouten = 1;   
   \   00000020   51F48011           ORRS     R1,R1,#0x100000
    347              }
    348              USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
   \                     ??USB_OTG_CoreInit_1:
   \   00000024   E068               LDR      R0,[R4, #+12]
   \   00000026   8163               STR      R1,[R0, #+56]
    349              
    350              /* Init The ULPI Interface */
    351              usbcfg.d32 = 0;
   \   00000028   0020               MOVS     R0,#+0
    352              usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
   \   0000002A   E168               LDR      R1,[R4, #+12]
   \   0000002C   C968               LDR      R1,[R1, #+12]
   \   0000002E   0800               MOVS     R0,R1
    353              
    354              usbcfg.b.physel            = 0; /* HS Interface */
   \   00000030   30F04000           BICS     R0,R0,#0x40
    355          #ifdef USB_OTG_INTERNAL_VBUS_ENABLED
    356              usbcfg.b.ulpi_ext_vbus_drv = 0; /* Use internal VBUS */
    357          #else
    358           #ifdef USB_OTG_EXTERNAL_VBUS_ENABLED    
    359              usbcfg.b.ulpi_ext_vbus_drv = 1; /* Use external VBUS */
    360           #endif
    361          #endif 
    362              usbcfg.b.term_sel_dl_pulse = 0; /* Data line pulsing using utmi_txvalid */    
   \   00000034   30F48000           BICS     R0,R0,#0x400000
    363              usbcfg.b.ulpi_utmi_sel     = 1; /* ULPI seleInterfacect */
   \   00000038   50F01000           ORRS     R0,R0,#0x10
    364              
    365              usbcfg.b.phyif             = 0; /* 8 bits */
   \   0000003C   30F00800           BICS     R0,R0,#0x8
    366              usbcfg.b.ddrsel            = 0; /* single data rate */
   \   00000040   30F08000           BICS     R0,R0,#0x80
    367              
    368              usbcfg.b.ulpi_fsls = 0;
   \   00000044   30F40030           BICS     R0,R0,#0x20000
    369              usbcfg.b.ulpi_clk_sus_m = 0;
   \   00000048   30F40020           BICS     R0,R0,#0x80000
    370              USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
   \   0000004C   E168               LDR      R1,[R4, #+12]
   \   0000004E   C860               STR      R0,[R1, #+12]
    371              
    372              /* Reset after a PHY select and set Host mode */
    373              USB_OTG_CoreReset(pdev);
   \   00000050   2000               MOVS     R0,R4
   \   00000052   ........           BL       USB_OTG_CoreReset
    374              
    375              if(pdev->cfg.dma_enable == 1)
   \   00000056   E078               LDRB     R0,[R4, #+3]
   \   00000058   0128               CMP      R0,#+1
   \   0000005A   4CD1               BNE.N    ??USB_OTG_CoreInit_2
    376              {
    377                
    378                ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
   \   0000005C   0520               MOVS     R0,#+5
   \   0000005E   60F34406           BFI      R6,R0,#+1,#+4
    379                ahbcfg.b.dmaenable = 1;
   \   00000062   56F02006           ORRS     R6,R6,#0x20
    380                USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
   \   00000066   E068               LDR      R0,[R4, #+12]
   \   00000068   8660               STR      R6,[R0, #+8]
   \   0000006A   44E0               B.N      ??USB_OTG_CoreInit_2
    381                
    382              }    
    383            }
    384            else /* FS interface (embedded Phy or I2C Phy) */
    385            {
    386              
    387              usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);;
   \                     ??USB_OTG_CoreInit_0:
   \   0000006C   E068               LDR      R0,[R4, #+12]
   \   0000006E   C068               LDR      R0,[R0, #+12]
    388              usbcfg.b.physel  = 1; /* FS Interface */
   \   00000070   50F04000           ORRS     R0,R0,#0x40
    389              USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
   \   00000074   E168               LDR      R1,[R4, #+12]
   \   00000076   C860               STR      R0,[R1, #+12]
    390              /* Reset after a PHY select and set Host mode */
    391              USB_OTG_CoreReset(pdev);
   \   00000078   2000               MOVS     R0,R4
   \   0000007A   ........           BL       USB_OTG_CoreReset
    392              /* Enable the I2C interface and deactivate the power down*/
    393              gccfg.d32 = 0;
   \   0000007E   0021               MOVS     R1,#+0
    394              gccfg.b.pwdn = 1;
   \   00000080   51F48031           ORRS     R1,R1,#0x10000
    395              
    396              if(pdev->cfg.phy_itface == USB_OTG_FS_I2C_PHY)
   \   00000084   207A               LDRB     R0,[R4, #+8]
   \   00000086   0328               CMP      R0,#+3
   \   00000088   01D1               BNE.N    ??USB_OTG_CoreInit_3
    397              {
    398                gccfg.b.i2cifen = 1;
   \   0000008A   51F40031           ORRS     R1,R1,#0x20000
    399              }   
    400              gccfg.b.vbussensingA = 1 ;
   \                     ??USB_OTG_CoreInit_3:
   \   0000008E   51F48021           ORRS     R1,R1,#0x40000
    401              gccfg.b.vbussensingB = 1 ;     
   \   00000092   51F40021           ORRS     R1,R1,#0x80000
    402              gccfg.b.disablevbussensing = 1; 
   \   00000096   51F40011           ORRS     R1,R1,#0x200000
    403              
    404              if(pdev->cfg.Sof_output)
   \   0000009A   607A               LDRB     R0,[R4, #+9]
   \   0000009C   0028               CMP      R0,#+0
   \   0000009E   01D0               BEQ.N    ??USB_OTG_CoreInit_4
    405              {
    406                gccfg.b.sofouten = 1;  
   \   000000A0   51F48011           ORRS     R1,R1,#0x100000
    407              }
    408              
    409              USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
   \                     ??USB_OTG_CoreInit_4:
   \   000000A4   E068               LDR      R0,[R4, #+12]
   \   000000A6   8163               STR      R1,[R0, #+56]
    410              USB_OTG_BSP_mDelay(20);
   \   000000A8   1420               MOVS     R0,#+20
   \   000000AA   ........           BL       USB_OTG_BSP_mDelay
    411              /* Program GUSBCFG.OtgUtmifsSel to I2C*/
    412              usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
   \   000000AE   E068               LDR      R0,[R4, #+12]
   \   000000B0   C068               LDR      R0,[R0, #+12]
    413              
    414              if(pdev->cfg.phy_itface == USB_OTG_FS_I2C_PHY)
   \   000000B2   217A               LDRB     R1,[R4, #+8]
   \   000000B4   0329               CMP      R1,#+3
   \   000000B6   01D1               BNE.N    ??USB_OTG_CoreInit_5
    415              {
    416                usbcfg.b.otgutmifssel = 1;
   \   000000B8   50F48030           ORRS     R0,R0,#0x10000
    417              }
    418              
    419              USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
   \                     ??USB_OTG_CoreInit_5:
   \   000000BC   E168               LDR      R1,[R4, #+12]
   \   000000BE   C860               STR      R0,[R1, #+12]
    420              
    421              if(pdev->cfg.phy_itface == USB_OTG_FS_I2C_PHY)
   \   000000C0   207A               LDRB     R0,[R4, #+8]
   \   000000C2   0328               CMP      R0,#+3
   \   000000C4   17D1               BNE.N    ??USB_OTG_CoreInit_2
    422              {
    423                /*Program GI2CCTL.I2CEn*/
    424                i2cctl.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GI2CCTL);
   \   000000C6   E068               LDR      R0,[R4, #+12]
   \   000000C8   066B               LDR      R6,[R0, #+48]
    425                i2cctl.b.i2cdevaddr = 1;
   \   000000CA   0120               MOVS     R0,#+1
   \   000000CC   60F39B66           BFI      R6,R0,#+26,#+2
    426                i2cctl.b.i2cen = 0;
   \   000000D0   36F40006           BICS     R6,R6,#0x800000
    427                i2cctl.b.dat_se0 = 1;
   \   000000D4   56F08056           ORRS     R6,R6,#0x10000000
    428                i2cctl.b.addr = 0x2D;
   \   000000D8   2D20               MOVS     R0,#+45
   \   000000DA   60F31646           BFI      R6,R0,#+16,#+7
    429                USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
   \   000000DE   E068               LDR      R0,[R4, #+12]
   \   000000E0   0663               STR      R6,[R0, #+48]
    430                
    431                USB_OTG_BSP_mDelay(200);
   \   000000E2   C820               MOVS     R0,#+200
   \   000000E4   ........           BL       USB_OTG_BSP_mDelay
    432                
    433                i2cctl.b.i2cen = 1;
   \   000000E8   56F40006           ORRS     R6,R6,#0x800000
    434                USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
   \   000000EC   E068               LDR      R0,[R4, #+12]
   \   000000EE   0663               STR      R6,[R0, #+48]
    435                USB_OTG_BSP_mDelay(200);
   \   000000F0   C820               MOVS     R0,#+200
   \   000000F2   ........           BL       USB_OTG_BSP_mDelay
    436              }
    437            }
    438            /* case the HS core is working in FS mode */
    439            if(pdev->cfg.dma_enable == 1)
   \                     ??USB_OTG_CoreInit_2:
   \   000000F6   E078               LDRB     R0,[R4, #+3]
   \   000000F8   0128               CMP      R0,#+1
   \   000000FA   08D1               BNE.N    ??USB_OTG_CoreInit_6
    440            {
    441              
    442              ahbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GAHBCFG);
   \   000000FC   E068               LDR      R0,[R4, #+12]
   \   000000FE   8668               LDR      R6,[R0, #+8]
    443              ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
   \   00000100   0520               MOVS     R0,#+5
   \   00000102   60F34406           BFI      R6,R0,#+1,#+4
    444              ahbcfg.b.dmaenable = 1;
   \   00000106   56F02006           ORRS     R6,R6,#0x20
    445              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
   \   0000010A   E068               LDR      R0,[R4, #+12]
   \   0000010C   8660               STR      R6,[R0, #+8]
    446              
    447            }
    448            /* initialize OTG features */
    449          #ifdef  USE_OTG_MODE
    450            usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
    451            usbcfg.b.hnpcap = 1;
    452            usbcfg.b.srpcap = 1;
    453            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
    454            USB_OTG_EnableCommonInt(pdev);
    455          #endif
    456            return status;
   \                     ??USB_OTG_CoreInit_6:
   \   0000010E   2800               MOVS     R0,R5
   \   00000110   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000112   70BD               POP      {R4-R6,PC}       ;; return
    457          }
    458          /**
    459          * @brief  USB_OTG_EnableGlobalInt
    460          *         Enables the controller's Global Int in the AHB Config reg
    461          * @param  pdev : Selected device
    462          * @retval USB_OTG_STS : status
    463          */

   \                                 In section .text, align 2, keep-with-next
    464          USB_OTG_STS USB_OTG_EnableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
    465          {
    466            USB_OTG_STS status = USB_OTG_OK;
   \                     USB_OTG_EnableGlobalInt:
   \   00000000   0021               MOVS     R1,#+0
    467            USB_OTG_GAHBCFG_TypeDef  ahbcfg;
    468            
    469            ahbcfg.d32 = 0;
   \   00000002   0022               MOVS     R2,#+0
    470            ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
   \   00000004   52F00102           ORRS     R2,R2,#0x1
    471            USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, 0, ahbcfg.d32);
   \   00000008   C368               LDR      R3,[R0, #+12]
   \   0000000A   9B68               LDR      R3,[R3, #+8]
   \   0000000C   1A43               ORRS     R2,R2,R3
   \   0000000E   C068               LDR      R0,[R0, #+12]
   \   00000010   8260               STR      R2,[R0, #+8]
    472            return status;
   \   00000012   0800               MOVS     R0,R1
   \   00000014   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   7047               BX       LR               ;; return
    473          }
    474          
    475          
    476          /**
    477          * @brief  USB_OTG_DisableGlobalInt
    478          *         Enables the controller's Global Int in the AHB Config reg
    479          * @param  pdev : Selected device
    480          * @retval USB_OTG_STS : status
    481          */

   \                                 In section .text, align 2, keep-with-next
    482          USB_OTG_STS USB_OTG_DisableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
    483          {
    484            USB_OTG_STS status = USB_OTG_OK;
   \                     USB_OTG_DisableGlobalInt:
   \   00000000   0021               MOVS     R1,#+0
    485            USB_OTG_GAHBCFG_TypeDef  ahbcfg;
    486            ahbcfg.d32 = 0;
   \   00000002   0022               MOVS     R2,#+0
    487            ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
   \   00000004   52F00102           ORRS     R2,R2,#0x1
    488            USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32, 0);
   \   00000008   C368               LDR      R3,[R0, #+12]
   \   0000000A   9B68               LDR      R3,[R3, #+8]
   \   0000000C   33EA0202           BICS     R2,R3,R2
   \   00000010   C068               LDR      R0,[R0, #+12]
   \   00000012   8260               STR      R2,[R0, #+8]
    489            return status;
   \   00000014   0800               MOVS     R0,R1
   \   00000016   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   7047               BX       LR               ;; return
    490          }
    491          
    492          
    493          /**
    494          * @brief  USB_OTG_FlushTxFifo : Flush a Tx FIFO
    495          * @param  pdev : Selected device
    496          * @param  num : FO num
    497          * @retval USB_OTG_STS : status
    498          */

   \                                 In section .text, align 2, keep-with-next
    499          USB_OTG_STS USB_OTG_FlushTxFifo (USB_OTG_CORE_HANDLE *pdev , uint32_t num )
    500          {
   \                     USB_OTG_FlushTxFifo:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
    501            USB_OTG_STS status = USB_OTG_OK;
   \   00000004   0024               MOVS     R4,#+0
    502            __IO USB_OTG_GRSTCTL_TypeDef  greset;
    503            
    504            uint32_t count = 0;
   \   00000006   0022               MOVS     R2,#+0
    505            greset.d32 = 0;
   \   00000008   0023               MOVS     R3,#+0
   \   0000000A   0093               STR      R3,[SP, #+0]
    506            greset.b.txfflsh = 1;
   \   0000000C   009B               LDR      R3,[SP, #+0]
   \   0000000E   53F02003           ORRS     R3,R3,#0x20
   \   00000012   0093               STR      R3,[SP, #+0]
    507            greset.b.txfnum  = num;
   \   00000014   009B               LDR      R3,[SP, #+0]
   \   00000016   61F38A13           BFI      R3,R1,#+6,#+5
   \   0000001A   0093               STR      R3,[SP, #+0]
    508            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
   \   0000001C   C168               LDR      R1,[R0, #+12]
   \   0000001E   009B               LDR      R3,[SP, #+0]
   \   00000020   0B61               STR      R3,[R1, #+16]
    509            do
    510            {
    511              greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
   \                     ??USB_OTG_FlushTxFifo_0:
   \   00000022   C168               LDR      R1,[R0, #+12]
   \   00000024   0969               LDR      R1,[R1, #+16]
   \   00000026   0091               STR      R1,[SP, #+0]
    512              if (++count > 200000)
   \   00000028   521C               ADDS     R2,R2,#+1
   \   0000002A   ....               LDR.N    R1,??DataTable3  ;; 0x30d41
   \   0000002C   8A42               CMP      R2,R1
   \   0000002E   04D2               BCS.N    ??USB_OTG_FlushTxFifo_1
    513              {
    514                break;
    515              }
    516            }
    517            while (greset.b.txfflsh == 1);
   \                     ??USB_OTG_FlushTxFifo_2:
   \   00000030   0099               LDR      R1,[SP, #+0]
   \   00000032   C1F34011           UBFX     R1,R1,#+5,#+1
   \   00000036   C907               LSLS     R1,R1,#+31
   \   00000038   F3D4               BMI.N    ??USB_OTG_FlushTxFifo_0
    518            /* Wait for 3 PHY Clocks*/
    519            USB_OTG_BSP_uDelay(3);
   \                     ??USB_OTG_FlushTxFifo_1:
   \   0000003A   0320               MOVS     R0,#+3
   \   0000003C   ........           BL       USB_OTG_BSP_uDelay
    520            return status;
   \   00000040   2000               MOVS     R0,R4
   \   00000042   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   16BD               POP      {R1,R2,R4,PC}    ;; return
    521          }
    522          
    523          
    524          /**
    525          * @brief  USB_OTG_FlushRxFifo : Flush a Rx FIFO
    526          * @param  pdev : Selected device
    527          * @retval USB_OTG_STS : status
    528          */

   \                                 In section .text, align 2, keep-with-next
    529          USB_OTG_STS USB_OTG_FlushRxFifo( USB_OTG_CORE_HANDLE *pdev )
    530          {
   \                     USB_OTG_FlushRxFifo:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
    531            USB_OTG_STS status = USB_OTG_OK;
   \   00000004   0024               MOVS     R4,#+0
    532            __IO USB_OTG_GRSTCTL_TypeDef  greset;
    533            uint32_t count = 0;
   \   00000006   0021               MOVS     R1,#+0
    534            
    535            greset.d32 = 0;
   \   00000008   0022               MOVS     R2,#+0
   \   0000000A   0092               STR      R2,[SP, #+0]
    536            greset.b.rxfflsh = 1;
   \   0000000C   009A               LDR      R2,[SP, #+0]
   \   0000000E   52F01002           ORRS     R2,R2,#0x10
   \   00000012   0092               STR      R2,[SP, #+0]
    537            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
   \   00000014   C268               LDR      R2,[R0, #+12]
   \   00000016   009B               LDR      R3,[SP, #+0]
   \   00000018   1361               STR      R3,[R2, #+16]
    538            do
    539            {
    540              greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
   \                     ??USB_OTG_FlushRxFifo_0:
   \   0000001A   C268               LDR      R2,[R0, #+12]
   \   0000001C   1269               LDR      R2,[R2, #+16]
   \   0000001E   0092               STR      R2,[SP, #+0]
    541              if (++count > 200000)
   \   00000020   491C               ADDS     R1,R1,#+1
   \   00000022   ....               LDR.N    R2,??DataTable3  ;; 0x30d41
   \   00000024   9142               CMP      R1,R2
   \   00000026   04D2               BCS.N    ??USB_OTG_FlushRxFifo_1
    542              {
    543                break;
    544              }
    545            }
    546            while (greset.b.rxfflsh == 1);
   \                     ??USB_OTG_FlushRxFifo_2:
   \   00000028   009A               LDR      R2,[SP, #+0]
   \   0000002A   C2F30012           UBFX     R2,R2,#+4,#+1
   \   0000002E   D207               LSLS     R2,R2,#+31
   \   00000030   F3D4               BMI.N    ??USB_OTG_FlushRxFifo_0
    547            /* Wait for 3 PHY Clocks*/
    548            USB_OTG_BSP_uDelay(3);
   \                     ??USB_OTG_FlushRxFifo_1:
   \   00000032   0320               MOVS     R0,#+3
   \   00000034   ........           BL       USB_OTG_BSP_uDelay
    549            return status;
   \   00000038   2000               MOVS     R0,R4
   \   0000003A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   16BD               POP      {R1,R2,R4,PC}    ;; return
    550          }
    551          
    552          
    553          /**
    554          * @brief  USB_OTG_SetCurrentMode : Set ID line
    555          * @param  pdev : Selected device
    556          * @param  mode :  (Host/device)
    557          * @retval USB_OTG_STS : status
    558          */

   \                                 In section .text, align 2, keep-with-next
    559          USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
    560          {
   \                     USB_OTG_SetCurrentMode:
   \   00000000   10B5               PUSH     {R4,LR}
    561            USB_OTG_STS status = USB_OTG_OK;
   \   00000002   0024               MOVS     R4,#+0
    562            USB_OTG_GUSBCFG_TypeDef  usbcfg;
    563            
    564            usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
   \   00000004   C268               LDR      R2,[R0, #+12]
   \   00000006   D268               LDR      R2,[R2, #+12]
    565            
    566            usbcfg.b.force_host = 0;
   \   00000008   32F00052           BICS     R2,R2,#0x20000000
    567            usbcfg.b.force_dev = 0;
   \   0000000C   32F08042           BICS     R2,R2,#0x40000000
    568            
    569            if ( mode == HOST_MODE)
   \   00000010   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0129               CMP      R1,#+1
   \   00000014   02D1               BNE.N    ??USB_OTG_SetCurrentMode_0
    570            {
    571              usbcfg.b.force_host = 1;
   \   00000016   52F00052           ORRS     R2,R2,#0x20000000
   \   0000001A   04E0               B.N      ??USB_OTG_SetCurrentMode_1
    572            }
    573            else if ( mode == DEVICE_MODE)
   \                     ??USB_OTG_SetCurrentMode_0:
   \   0000001C   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001E   0029               CMP      R1,#+0
   \   00000020   01D1               BNE.N    ??USB_OTG_SetCurrentMode_1
    574            {
    575              usbcfg.b.force_dev = 1;
   \   00000022   52F08042           ORRS     R2,R2,#0x40000000
    576            }
    577            
    578            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
   \                     ??USB_OTG_SetCurrentMode_1:
   \   00000026   C068               LDR      R0,[R0, #+12]
   \   00000028   C260               STR      R2,[R0, #+12]
    579            USB_OTG_BSP_mDelay(50);
   \   0000002A   3220               MOVS     R0,#+50
   \   0000002C   ........           BL       USB_OTG_BSP_mDelay
    580            return status;
   \   00000030   2000               MOVS     R0,R4
   \   00000032   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   10BD               POP      {R4,PC}          ;; return
    581          }
    582          
    583          
    584          /**
    585          * @brief  USB_OTG_GetMode : Get current mode
    586          * @param  pdev : Selected device
    587          * @retval current mode
    588          */

   \                                 In section .text, align 2, keep-with-next
    589          uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
    590          {
    591            return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
   \                     USB_OTG_GetMode:
   \   00000000   C068               LDR      R0,[R0, #+12]
   \   00000002   4069               LDR      R0,[R0, #+20]
   \   00000004   10F00100           ANDS     R0,R0,#0x1
   \   00000008   7047               BX       LR               ;; return
    592          }
    593          
    594          
    595          /**
    596          * @brief  USB_OTG_IsDeviceMode : Check if it is device mode
    597          * @param  pdev : Selected device
    598          * @retval num_in_ep
    599          */

   \                                 In section .text, align 2, keep-with-next
    600          uint8_t USB_OTG_IsDeviceMode(USB_OTG_CORE_HANDLE *pdev)
    601          {
   \                     USB_OTG_IsDeviceMode:
   \   00000000   80B5               PUSH     {R7,LR}
    602            return (USB_OTG_GetMode(pdev) != HOST_MODE);
   \   00000002   ........           BL       USB_OTG_GetMode
   \   00000006   0128               CMP      R0,#+1
   \   00000008   01D0               BEQ.N    ??USB_OTG_IsDeviceMode_0
   \   0000000A   0120               MOVS     R0,#+1
   \   0000000C   00E0               B.N      ??USB_OTG_IsDeviceMode_1
   \                     ??USB_OTG_IsDeviceMode_0:
   \   0000000E   0020               MOVS     R0,#+0
   \                     ??USB_OTG_IsDeviceMode_1:
   \   00000010   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   02BD               POP      {R1,PC}          ;; return
    603          }
    604          
    605          
    606          /**
    607          * @brief  USB_OTG_IsHostMode : Check if it is host mode
    608          * @param  pdev : Selected device
    609          * @retval num_in_ep
    610          */

   \                                 In section .text, align 2, keep-with-next
    611          uint8_t USB_OTG_IsHostMode(USB_OTG_CORE_HANDLE *pdev)
    612          {
   \                     USB_OTG_IsHostMode:
   \   00000000   80B5               PUSH     {R7,LR}
    613            return (USB_OTG_GetMode(pdev) == HOST_MODE);
   \   00000002   ........           BL       USB_OTG_GetMode
   \   00000006   0128               CMP      R0,#+1
   \   00000008   01D1               BNE.N    ??USB_OTG_IsHostMode_0
   \   0000000A   0120               MOVS     R0,#+1
   \   0000000C   00E0               B.N      ??USB_OTG_IsHostMode_1
   \                     ??USB_OTG_IsHostMode_0:
   \   0000000E   0020               MOVS     R0,#+0
   \                     ??USB_OTG_IsHostMode_1:
   \   00000010   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   02BD               POP      {R1,PC}          ;; return
    614          }
    615          
    616          
    617          /**
    618          * @brief  USB_OTG_ReadCoreItr : returns the Core Interrupt register
    619          * @param  pdev : Selected device
    620          * @retval Status
    621          */

   \                                 In section .text, align 2, keep-with-next
    622          uint32_t USB_OTG_ReadCoreItr(USB_OTG_CORE_HANDLE *pdev)
    623          {
    624            uint32_t v = 0;
   \                     USB_OTG_ReadCoreItr:
   \   00000000   0021               MOVS     R1,#+0
    625            v = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
   \   00000002   C268               LDR      R2,[R0, #+12]
   \   00000004   5269               LDR      R2,[R2, #+20]
   \   00000006   1100               MOVS     R1,R2
    626            v &= USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTMSK);
   \   00000008   C068               LDR      R0,[R0, #+12]
   \   0000000A   8069               LDR      R0,[R0, #+24]
   \   0000000C   0140               ANDS     R1,R0,R1
    627            return v;
   \   0000000E   0800               MOVS     R0,R1
   \   00000010   7047               BX       LR               ;; return
    628          }
    629          
    630          
    631          /**
    632          * @brief  USB_OTG_ReadOtgItr : returns the USB_OTG Interrupt register
    633          * @param  pdev : Selected device
    634          * @retval Status
    635          */

   \                                 In section .text, align 2, keep-with-next
    636          uint32_t USB_OTG_ReadOtgItr (USB_OTG_CORE_HANDLE *pdev)
    637          {
    638            return (USB_OTG_READ_REG32 (&pdev->regs.GREGS->GOTGINT));
   \                     USB_OTG_ReadOtgItr:
   \   00000000   C068               LDR      R0,[R0, #+12]
   \   00000002   4068               LDR      R0,[R0, #+4]
   \   00000004   7047               BX       LR               ;; return
    639          }
    640          
    641          #ifdef USE_HOST_MODE
    642          /**
    643          * @brief  USB_OTG_CoreInitHost : Initializes USB_OTG controller for host mode
    644          * @param  pdev : Selected device
    645          * @retval status
    646          */

   \                                 In section .text, align 2, keep-with-next
    647          USB_OTG_STS USB_OTG_CoreInitHost(USB_OTG_CORE_HANDLE *pdev)
    648          {
   \                     USB_OTG_CoreInitHost:
   \   00000000   2DE9F843           PUSH     {R3-R9,LR}
   \   00000004   0400               MOVS     R4,R0
    649            USB_OTG_STS                     status = USB_OTG_OK;
   \   00000006   0025               MOVS     R5,#+0
    650            USB_OTG_FSIZ_TypeDef            nptxfifosize;
    651            USB_OTG_FSIZ_TypeDef            ptxfifosize;  
    652            USB_OTG_HCFG_TypeDef            hcfg;
    653            
    654          #ifdef USE_OTG_MODE
    655            USB_OTG_OTGCTL_TypeDef          gotgctl;
    656          #endif
    657            
    658            uint32_t                        i = 0;
   \   00000008   0026               MOVS     R6,#+0
    659            
    660            nptxfifosize.d32 = 0;  
   \   0000000A   0027               MOVS     R7,#+0
    661            ptxfifosize.d32 = 0;
   \   0000000C   5FF00008           MOVS     R8,#+0
    662          #ifdef USE_OTG_MODE
    663            gotgctl.d32 = 0;
    664          #endif
    665            hcfg.d32 = 0;
   \   00000010   5FF00009           MOVS     R9,#+0
    666            
    667            
    668            /* configure charge pump IO */
    669            USB_OTG_BSP_ConfigVBUS(pdev);
   \   00000014   2000               MOVS     R0,R4
   \   00000016   ........           BL       USB_OTG_BSP_ConfigVBUS
    670            
    671            /* Restart the Phy Clock */
    672            USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
   \   0000001A   D4F80C01           LDR      R0,[R4, #+268]
   \   0000001E   0021               MOVS     R1,#+0
   \   00000020   0160               STR      R1,[R0, #+0]
    673            
    674            /* Initialize Host Configuration Register */
    675            USB_OTG_InitFSLSPClkSel(pdev , HCFG_48_MHZ); /* in init phase */
   \   00000022   0121               MOVS     R1,#+1
   \   00000024   2000               MOVS     R0,R4
   \   00000026   ........           BL       USB_OTG_InitFSLSPClkSel
    676            
    677            hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
   \   0000002A   6069               LDR      R0,[R4, #+20]
   \   0000002C   0068               LDR      R0,[R0, #+0]
   \   0000002E   8146               MOV      R9,R0
    678            hcfg.b.fslssupp = 0;
   \   00000030   39F00409           BICS     R9,R9,#0x4
    679            USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
   \   00000034   6069               LDR      R0,[R4, #+20]
   \   00000036   C0F80090           STR      R9,[R0, #+0]
    680            
    681            /* Configure data FIFO sizes */
    682            /* Rx FIFO */
    683          #ifdef USB_OTG_FS_CORE
    684            if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID)
   \   0000003A   E07A               LDRB     R0,[R4, #+11]
   \   0000003C   0128               CMP      R0,#+1
   \   0000003E   13D1               BNE.N    ??USB_OTG_CoreInitHost_0
    685            {
    686              /* set Rx FIFO size */
    687              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
   \   00000040   E068               LDR      R0,[R4, #+12]
   \   00000042   8021               MOVS     R1,#+128
   \   00000044   4162               STR      R1,[R0, #+36]
    688              nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;   
   \   00000046   8020               MOVS     R0,#+128
   \   00000048   60F30F07           BFI      R7,R0,#+0,#+16
    689              nptxfifosize.b.depth = TXH_NP_FS_FIFOSIZ;  
   \   0000004C   6020               MOVS     R0,#+96
   \   0000004E   60F31F47           BFI      R7,R0,#+16,#+16
    690              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
   \   00000052   E068               LDR      R0,[R4, #+12]
   \   00000054   8762               STR      R7,[R0, #+40]
    691              
    692              ptxfifosize.b.startaddr = RX_FIFO_FS_SIZE + TXH_NP_FS_FIFOSIZ;
   \   00000056   E020               MOVS     R0,#+224
   \   00000058   60F30F08           BFI      R8,R0,#+0,#+16
    693              ptxfifosize.b.depth     = TXH_P_FS_FIFOSIZ;
   \   0000005C   6020               MOVS     R0,#+96
   \   0000005E   60F31F48           BFI      R8,R0,#+16,#+16
    694              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
   \   00000062   E068               LDR      R0,[R4, #+12]
   \   00000064   C0F80081           STR      R8,[R0, #+256]
    695            }
    696          #endif
    697          #ifdef USB_OTG_HS_CORE  
    698             if (pdev->cfg.coreID == USB_OTG_HS_CORE_ID)
    699            {
    700             /* set Rx FIFO size */
    701              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_HS_SIZE);
    702              nptxfifosize.b.startaddr = RX_FIFO_HS_SIZE;   
    703              nptxfifosize.b.depth = TXH_NP_HS_FIFOSIZ;  
    704              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
    705              
    706              ptxfifosize.b.startaddr = RX_FIFO_HS_SIZE + TXH_NP_HS_FIFOSIZ;
    707              ptxfifosize.b.depth     = TXH_P_HS_FIFOSIZ;
    708              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
    709            }
    710          #endif  
    711            
    712          #ifdef USE_OTG_MODE
    713            /* Clear Host Set HNP Enable in the USB_OTG Control Register */
    714            gotgctl.b.hstsethnpen = 1;
    715            USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GOTGCTL, gotgctl.d32, 0);
    716          #endif
    717            
    718            /* Make sure the FIFOs are flushed. */
    719            USB_OTG_FlushTxFifo(pdev, 0x10 );         /* all Tx FIFOs */
   \                     ??USB_OTG_CoreInitHost_0:
   \   00000068   1021               MOVS     R1,#+16
   \   0000006A   2000               MOVS     R0,R4
   \   0000006C   ........           BL       USB_OTG_FlushTxFifo
    720            USB_OTG_FlushRxFifo(pdev);
   \   00000070   2000               MOVS     R0,R4
   \   00000072   ........           BL       USB_OTG_FlushRxFifo
    721            
    722            
    723            /* Clear all pending HC Interrupts */
    724            for (i = 0; i < pdev->cfg.host_channels; i++)
   \   00000076   0026               MOVS     R6,#+0
   \   00000078   0DE0               B.N      ??USB_OTG_CoreInitHost_1
    725            {
    726              USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
   \                     ??USB_OTG_CoreInitHost_2:
   \   0000007A   14EB8600           ADDS     R0,R4,R6, LSL #+2
   \   0000007E   D0F89000           LDR      R0,[R0, #+144]
   \   00000082   5FF0FF31           MOVS     R1,#-1
   \   00000086   8160               STR      R1,[R0, #+8]
    727              USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
   \   00000088   14EB8600           ADDS     R0,R4,R6, LSL #+2
   \   0000008C   D0F89000           LDR      R0,[R0, #+144]
   \   00000090   0021               MOVS     R1,#+0
   \   00000092   C160               STR      R1,[R0, #+12]
    728            }
   \   00000094   761C               ADDS     R6,R6,#+1
   \                     ??USB_OTG_CoreInitHost_1:
   \   00000096   2078               LDRB     R0,[R4, #+0]
   \   00000098   8642               CMP      R6,R0
   \   0000009A   EED3               BCC.N    ??USB_OTG_CoreInitHost_2
    729          #ifndef USE_OTG_MODE
    730            USB_OTG_DriveVbus(pdev, 1);
   \   0000009C   0121               MOVS     R1,#+1
   \   0000009E   2000               MOVS     R0,R4
   \   000000A0   ........           BL       USB_OTG_DriveVbus
    731          #endif
    732            
    733            USB_OTG_EnableHostInt(pdev);
   \   000000A4   2000               MOVS     R0,R4
   \   000000A6   ........           BL       USB_OTG_EnableHostInt
    734            return status;
   \   000000AA   2800               MOVS     R0,R5
   \   000000AC   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AE   BDE8F283           POP      {R1,R4-R9,PC}    ;; return
    735          }
    736          
    737          /**
    738          * @brief  USB_OTG_IsEvenFrame 
    739          *         This function returns the frame number for sof packet
    740          * @param  pdev : Selected device
    741          * @retval Frame number
    742          */

   \                                 In section .text, align 2, keep-with-next
    743          uint8_t USB_OTG_IsEvenFrame (USB_OTG_CORE_HANDLE *pdev) 
    744          {
    745            return !(USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0x1);
   \                     USB_OTG_IsEvenFrame:
   \   00000000   4069               LDR      R0,[R0, #+20]
   \   00000002   8068               LDR      R0,[R0, #+8]
   \   00000004   10F00100           ANDS     R0,R0,#0x1
   \   00000008   90F00100           EORS     R0,R0,#0x1
   \   0000000C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   7047               BX       LR               ;; return
    746          }
    747          
    748          /**
    749          * @brief  USB_OTG_DriveVbus : set/reset vbus
    750          * @param  pdev : Selected device
    751          * @param  state : VBUS state
    752          * @retval None
    753          */

   \                                 In section .text, align 2, keep-with-next
    754          void USB_OTG_DriveVbus (USB_OTG_CORE_HANDLE *pdev, uint8_t state)
    755          {
   \                     USB_OTG_DriveVbus:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0500               MOVS     R5,R0
   \   00000004   0E00               MOVS     R6,R1
    756            USB_OTG_HPRT0_TypeDef     hprt0;
    757            
    758            hprt0.d32 = 0;
   \   00000006   0024               MOVS     R4,#+0
    759            
    760            /* enable disable the external charge pump */
    761            USB_OTG_BSP_DriveVBUS(pdev, state);
   \   00000008   3100               MOVS     R1,R6
   \   0000000A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   2800               MOVS     R0,R5
   \   0000000E   ........           BL       USB_OTG_BSP_DriveVBUS
    762            
    763            /* Turn on the Host port power. */
    764            hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
   \   00000012   2800               MOVS     R0,R5
   \   00000014   ........           BL       USB_OTG_ReadHPRT0
   \   00000018   0400               MOVS     R4,R0
    765            if ((hprt0.b.prtpwr == 0 ) && (state == 1 ))
   \   0000001A   C4F30030           UBFX     R0,R4,#+12,#+1
   \   0000001E   C007               LSLS     R0,R0,#+31
   \   00000020   07D4               BMI.N    ??USB_OTG_DriveVbus_0
   \   00000022   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000024   012E               CMP      R6,#+1
   \   00000026   04D1               BNE.N    ??USB_OTG_DriveVbus_0
    766            {
    767              hprt0.b.prtpwr = 1;
   \   00000028   54F48054           ORRS     R4,R4,#0x1000
    768              USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
   \   0000002C   D5F8CC00           LDR      R0,[R5, #+204]
   \   00000030   0460               STR      R4,[R0, #+0]
    769            }
    770            if ((hprt0.b.prtpwr == 1 ) && (state == 0 ))
   \                     ??USB_OTG_DriveVbus_0:
   \   00000032   C4F30030           UBFX     R0,R4,#+12,#+1
   \   00000036   C007               LSLS     R0,R0,#+31
   \   00000038   07D5               BPL.N    ??USB_OTG_DriveVbus_1
   \   0000003A   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003C   002E               CMP      R6,#+0
   \   0000003E   04D1               BNE.N    ??USB_OTG_DriveVbus_1
    771            {
    772              hprt0.b.prtpwr = 0;
   \   00000040   34F48054           BICS     R4,R4,#0x1000
    773              USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
   \   00000044   D5F8CC00           LDR      R0,[R5, #+204]
   \   00000048   0460               STR      R4,[R0, #+0]
    774            }
    775            
    776            USB_OTG_BSP_mDelay(200);
   \                     ??USB_OTG_DriveVbus_1:
   \   0000004A   C820               MOVS     R0,#+200
   \   0000004C   ........           BL       USB_OTG_BSP_mDelay
    777          }
   \   00000050   70BD               POP      {R4-R6,PC}       ;; return
    778          /**
    779          * @brief  USB_OTG_EnableHostInt: Enables the Host mode interrupts
    780          * @param  pdev : Selected device
    781          * @retval USB_OTG_STS : status
    782          */

   \                                 In section .text, align 2, keep-with-next
    783          USB_OTG_STS USB_OTG_EnableHostInt(USB_OTG_CORE_HANDLE *pdev)
    784          {
   \                     USB_OTG_EnableHostInt:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
    785            USB_OTG_STS       status = USB_OTG_OK;
   \   00000004   0025               MOVS     R5,#+0
    786            USB_OTG_GINTMSK_TypeDef  intmsk;
    787            intmsk.d32 = 0;
   \   00000006   0026               MOVS     R6,#+0
    788            /* Disable all interrupts. */
    789            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTMSK, 0);
   \   00000008   E068               LDR      R0,[R4, #+12]
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   8161               STR      R1,[R0, #+24]
    790            
    791            /* Clear any pending interrupts. */
    792            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
   \   0000000E   E068               LDR      R0,[R4, #+12]
   \   00000010   5FF0FF31           MOVS     R1,#-1
   \   00000014   4161               STR      R1,[R0, #+20]
    793            
    794            /* Enable the common interrupts */
    795            USB_OTG_EnableCommonInt(pdev);
   \   00000016   2000               MOVS     R0,R4
   \   00000018   ........           BL       USB_OTG_EnableCommonInt
    796            
    797            if (pdev->cfg.dma_enable == 0)
   \   0000001C   E078               LDRB     R0,[R4, #+3]
   \   0000001E   0028               CMP      R0,#+0
   \   00000020   01D1               BNE.N    ??USB_OTG_EnableHostInt_0
    798            {  
    799              intmsk.b.rxstsqlvl  = 1;
   \   00000022   56F01006           ORRS     R6,R6,#0x10
    800            }  
    801            intmsk.b.portintr   = 1;
   \                     ??USB_OTG_EnableHostInt_0:
   \   00000026   56F08076           ORRS     R6,R6,#0x1000000
    802            intmsk.b.hcintr     = 1;
   \   0000002A   56F00076           ORRS     R6,R6,#0x2000000
    803            intmsk.b.disconnect = 1;  
   \   0000002E   56F00056           ORRS     R6,R6,#0x20000000
    804            intmsk.b.sofintr    = 1;  
   \   00000032   56F00806           ORRS     R6,R6,#0x8
    805            intmsk.b.incomplisoout  = 1; 
   \   00000036   56F40016           ORRS     R6,R6,#0x200000
    806            USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
   \   0000003A   E068               LDR      R0,[R4, #+12]
   \   0000003C   8069               LDR      R0,[R0, #+24]
   \   0000003E   B043               BICS     R0,R0,R6
   \   00000040   3043               ORRS     R0,R6,R0
   \   00000042   E168               LDR      R1,[R4, #+12]
   \   00000044   8861               STR      R0,[R1, #+24]
    807            return status;
   \   00000046   2800               MOVS     R0,R5
   \   00000048   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   70BD               POP      {R4-R6,PC}       ;; return
    808          }
    809          
    810          /**
    811          * @brief  USB_OTG_InitFSLSPClkSel : Initializes the FSLSPClkSel field of the 
    812          *         HCFG register on the PHY type
    813          * @param  pdev : Selected device
    814          * @param  freq : clock frequency
    815          * @retval None
    816          */

   \                                 In section .text, align 2, keep-with-next
    817          void USB_OTG_InitFSLSPClkSel(USB_OTG_CORE_HANDLE *pdev , uint8_t freq)
    818          {
    819            USB_OTG_HCFG_TypeDef   hcfg;
    820            
    821            hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
   \                     USB_OTG_InitFSLSPClkSel:
   \   00000000   4269               LDR      R2,[R0, #+20]
   \   00000002   1268               LDR      R2,[R2, #+0]
    822            hcfg.b.fslspclksel = freq;
   \   00000004   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   61F30102           BFI      R2,R1,#+0,#+2
    823            USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
   \   0000000A   4069               LDR      R0,[R0, #+20]
   \   0000000C   0260               STR      R2,[R0, #+0]
    824          }
   \   0000000E   7047               BX       LR               ;; return
    825          
    826          
    827          /**
    828          * @brief  USB_OTG_ReadHPRT0 : Reads HPRT0 to modify later
    829          * @param  pdev : Selected device
    830          * @retval HPRT0 value
    831          */

   \                                 In section .text, align 2, keep-with-next
    832          uint32_t USB_OTG_ReadHPRT0(USB_OTG_CORE_HANDLE *pdev)
    833          {
    834            USB_OTG_HPRT0_TypeDef  hprt0;
    835            
    836            hprt0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
   \                     USB_OTG_ReadHPRT0:
   \   00000000   D0F8CC00           LDR      R0,[R0, #+204]
   \   00000004   0068               LDR      R0,[R0, #+0]
    837            hprt0.b.prtena = 0;
   \   00000006   30F00400           BICS     R0,R0,#0x4
    838            hprt0.b.prtconndet = 0;
   \   0000000A   30F00200           BICS     R0,R0,#0x2
    839            hprt0.b.prtenchng = 0;
   \   0000000E   30F00800           BICS     R0,R0,#0x8
    840            hprt0.b.prtovrcurrchng = 0;
   \   00000012   30F02000           BICS     R0,R0,#0x20
    841            return hprt0.d32;
   \   00000016   7047               BX       LR               ;; return
    842          }
    843          
    844          
    845          /**
    846          * @brief  USB_OTG_ReadHostAllChannels_intr : Register PCD Callbacks
    847          * @param  pdev : Selected device
    848          * @retval Status
    849          */

   \                                 In section .text, align 2, keep-with-next
    850          uint32_t USB_OTG_ReadHostAllChannels_intr (USB_OTG_CORE_HANDLE *pdev)
    851          {
    852            return (USB_OTG_READ_REG32 (&pdev->regs.HREGS->HAINT));
   \                     USB_OTG_ReadHostAllChannels_intr:
   \   00000000   4069               LDR      R0,[R0, #+20]
   \   00000002   4069               LDR      R0,[R0, #+20]
   \   00000004   7047               BX       LR               ;; return
    853          }
    854          
    855          
    856          /**
    857          * @brief  USB_OTG_ResetPort : Reset Host Port
    858          * @param  pdev : Selected device
    859          * @retval status
    860          * @note : (1)The application must wait at least 10 ms (+ 10 ms security)
    861          *   before clearing the reset bit.
    862          */

   \                                 In section .text, align 2, keep-with-next
    863          uint32_t USB_OTG_ResetPort(USB_OTG_CORE_HANDLE *pdev)
    864          {
   \                     USB_OTG_ResetPort:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
    865            USB_OTG_HPRT0_TypeDef  hprt0;
    866            
    867            hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           BL       USB_OTG_ReadHPRT0
   \   0000000A   0500               MOVS     R5,R0
    868            hprt0.b.prtrst = 1;
   \   0000000C   4FF48070           MOV      R0,#+256
   \   00000010   0543               ORRS     R5,R0,R5
    869            USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
   \   00000012   D4F8CC00           LDR      R0,[R4, #+204]
   \   00000016   0560               STR      R5,[R0, #+0]
    870            USB_OTG_BSP_mDelay (10);                                /* See Note #1 */
   \   00000018   0A20               MOVS     R0,#+10
   \   0000001A   ........           BL       USB_OTG_BSP_mDelay
    871            hprt0.b.prtrst = 0;
   \   0000001E   35F48075           BICS     R5,R5,#0x100
    872            USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
   \   00000022   D4F8CC00           LDR      R0,[R4, #+204]
   \   00000026   0560               STR      R5,[R0, #+0]
    873            USB_OTG_BSP_mDelay (20);   
   \   00000028   1420               MOVS     R0,#+20
   \   0000002A   ........           BL       USB_OTG_BSP_mDelay
    874            return 1;
   \   0000002E   0120               MOVS     R0,#+1
   \   00000030   32BD               POP      {R1,R4,R5,PC}    ;; return
    875          }
    876          
    877          
    878          /**
    879          * @brief  USB_OTG_HC_Init : Prepares a host channel for transferring packets
    880          * @param  pdev : Selected device
    881          * @param  hc_num : channel number
    882          * @retval USB_OTG_STS : status
    883          */

   \                                 In section .text, align 2, keep-with-next
    884          USB_OTG_STS USB_OTG_HC_Init(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
    885          {
   \                     USB_OTG_HC_Init:
   \   00000000   F0B4               PUSH     {R4-R7}
    886            USB_OTG_STS status = USB_OTG_OK;
   \   00000002   0022               MOVS     R2,#+0
    887            uint32_t intr_enable = 0;
   \   00000004   0026               MOVS     R6,#+0
    888            USB_OTG_HCGINTMSK_TypeDef  hcintmsk;
    889            USB_OTG_GINTMSK_TypeDef    gintmsk;
    890            USB_OTG_HCCHAR_TypeDef     hcchar;
    891            USB_OTG_HCINTn_TypeDef     hcint;
    892            
    893            
    894            gintmsk.d32 = 0;
   \   00000006   0023               MOVS     R3,#+0
    895            hcintmsk.d32 = 0;
   \   00000008   0024               MOVS     R4,#+0
    896            hcchar.d32 = 0;
   \   0000000A   0025               MOVS     R5,#+0
    897            
    898            /* Clear old interrupt conditions for this host channel. */
    899            hcint.d32 = 0xFFFFFFFF;
   \   0000000C   5FF0FF37           MOVS     R7,#-1
    900            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINT, hcint.d32);
   \   00000010   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   10EB810C           ADDS     R12,R0,R1, LSL #+2
   \   00000016   DCF890C0           LDR      R12,[R12, #+144]
   \   0000001A   CCF80870           STR      R7,[R12, #+8]
    901            
    902            /* Enable channel interrupts required for this transfer. */
    903            hcintmsk.d32 = 0;
   \   0000001E   0027               MOVS     R7,#+0
   \   00000020   3C00               MOVS     R4,R7
    904            
    905            if (pdev->cfg.dma_enable == 1)
   \   00000022   C778               LDRB     R7,[R0, #+3]
   \   00000024   012F               CMP      R7,#+1
   \   00000026   01D1               BNE.N    ??USB_OTG_HC_Init_0
    906            {
    907              hcintmsk.b.ahberr = 1;
   \   00000028   54F00404           ORRS     R4,R4,#0x4
    908            }
    909            
    910            switch (pdev->host.hc[hc_num].ep_type) 
   \                     ??USB_OTG_HC_Init_0:
   \   0000002C   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002E   10EB4115           ADDS     R5,R0,R1, LSL #+5
   \   00000032   95F88D57           LDRB     R5,[R5, #+1933]
   \   00000036   002D               CMP      R5,#+0
   \   00000038   05D0               BEQ.N    ??USB_OTG_HC_Init_1
   \   0000003A   022D               CMP      R5,#+2
   \   0000003C   03D0               BEQ.N    ??USB_OTG_HC_Init_1
   \   0000003E   3BD3               BCC.N    ??USB_OTG_HC_Init_2
   \   00000040   032D               CMP      R5,#+3
   \   00000042   21D0               BEQ.N    ??USB_OTG_HC_Init_3
   \   00000044   4BE0               B.N      ??USB_OTG_HC_Init_4
    911            {
    912            case EP_TYPE_CTRL:
    913            case EP_TYPE_BULK:
    914              hcintmsk.b.xfercompl = 1;
   \                     ??USB_OTG_HC_Init_1:
   \   00000046   54F00104           ORRS     R4,R4,#0x1
    915              hcintmsk.b.stall = 1;
   \   0000004A   54F00804           ORRS     R4,R4,#0x8
    916              hcintmsk.b.xacterr = 1;
   \   0000004E   54F08004           ORRS     R4,R4,#0x80
    917              hcintmsk.b.datatglerr = 1;
   \   00000052   54F48064           ORRS     R4,R4,#0x400
    918              hcintmsk.b.nak = 1;  
   \   00000056   54F01004           ORRS     R4,R4,#0x10
    919              if (pdev->host.hc[hc_num].ep_is_in) 
   \   0000005A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005C   10EB4115           ADDS     R5,R0,R1, LSL #+5
   \   00000060   95F88A57           LDRB     R5,[R5, #+1930]
   \   00000064   002D               CMP      R5,#+0
   \   00000066   03D0               BEQ.N    ??USB_OTG_HC_Init_5
    920              {
    921                hcintmsk.b.bblerr = 1;
   \   00000068   4FF48075           MOV      R5,#+256
   \   0000006C   2C43               ORRS     R4,R5,R4
   \   0000006E   0AE0               B.N      ??USB_OTG_HC_Init_6
    922              } 
    923              else 
    924              {
    925                hcintmsk.b.nyet = 1;
   \                     ??USB_OTG_HC_Init_5:
   \   00000070   54F04004           ORRS     R4,R4,#0x40
    926                if (pdev->host.hc[hc_num].do_ping) 
   \   00000074   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000076   10EB4115           ADDS     R5,R0,R1, LSL #+5
   \   0000007A   95F88C57           LDRB     R5,[R5, #+1932]
   \   0000007E   002D               CMP      R5,#+0
   \   00000080   01D0               BEQ.N    ??USB_OTG_HC_Init_6
    927                {
    928                  hcintmsk.b.ack = 1;
   \   00000082   54F02004           ORRS     R4,R4,#0x20
    929                }
    930              }
    931              break;
   \                     ??USB_OTG_HC_Init_6:
   \   00000086   2AE0               B.N      ??USB_OTG_HC_Init_4
    932            case EP_TYPE_INTR:
    933              hcintmsk.b.xfercompl = 1;
   \                     ??USB_OTG_HC_Init_3:
   \   00000088   54F00104           ORRS     R4,R4,#0x1
    934              hcintmsk.b.nak = 1;
   \   0000008C   54F01004           ORRS     R4,R4,#0x10
    935              hcintmsk.b.stall = 1;
   \   00000090   54F00804           ORRS     R4,R4,#0x8
    936              hcintmsk.b.xacterr = 1;
   \   00000094   54F08004           ORRS     R4,R4,#0x80
    937              hcintmsk.b.datatglerr = 1;
   \   00000098   54F48064           ORRS     R4,R4,#0x400
    938              hcintmsk.b.frmovrun = 1;
   \   0000009C   4FF40075           MOV      R5,#+512
   \   000000A0   2C43               ORRS     R4,R5,R4
    939              
    940              if (pdev->host.hc[hc_num].ep_is_in) 
   \   000000A2   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A4   10EB4115           ADDS     R5,R0,R1, LSL #+5
   \   000000A8   95F88A57           LDRB     R5,[R5, #+1930]
   \   000000AC   002D               CMP      R5,#+0
   \   000000AE   02D0               BEQ.N    ??USB_OTG_HC_Init_7
    941              {
    942                hcintmsk.b.bblerr = 1;
   \   000000B0   4FF48075           MOV      R5,#+256
   \   000000B4   2C43               ORRS     R4,R5,R4
    943              }
    944              
    945              break;
   \                     ??USB_OTG_HC_Init_7:
   \   000000B6   12E0               B.N      ??USB_OTG_HC_Init_4
    946            case EP_TYPE_ISOC:
    947              hcintmsk.b.xfercompl = 1;
   \                     ??USB_OTG_HC_Init_2:
   \   000000B8   54F00104           ORRS     R4,R4,#0x1
    948              hcintmsk.b.frmovrun = 1;
   \   000000BC   4FF40075           MOV      R5,#+512
   \   000000C0   2C43               ORRS     R4,R5,R4
    949              hcintmsk.b.ack = 1;
   \   000000C2   54F02004           ORRS     R4,R4,#0x20
    950              
    951              if (pdev->host.hc[hc_num].ep_is_in) 
   \   000000C6   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000C8   10EB4115           ADDS     R5,R0,R1, LSL #+5
   \   000000CC   95F88A57           LDRB     R5,[R5, #+1930]
   \   000000D0   002D               CMP      R5,#+0
   \   000000D2   04D0               BEQ.N    ??USB_OTG_HC_Init_8
    952              {
    953                hcintmsk.b.xacterr = 1;
   \   000000D4   54F08004           ORRS     R4,R4,#0x80
    954                hcintmsk.b.bblerr = 1;
   \   000000D8   4FF48075           MOV      R5,#+256
   \   000000DC   2C43               ORRS     R4,R5,R4
    955              }
    956              break;
    957            }
    958            
    959            
    960            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCGINTMSK, hcintmsk.d32);
   \                     ??USB_OTG_HC_Init_8:
   \                     ??USB_OTG_HC_Init_4:
   \   000000DE   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000E0   10EB8105           ADDS     R5,R0,R1, LSL #+2
   \   000000E4   D5F89050           LDR      R5,[R5, #+144]
   \   000000E8   EC60               STR      R4,[R5, #+12]
    961            
    962            
    963            /* Enable the top level host channel interrupt. */
    964            intr_enable = (1 << hc_num);
   \   000000EA   0124               MOVS     R4,#+1
   \   000000EC   14FA01F6           LSLS     R6,R4,R1
    965            USB_OTG_MODIFY_REG32(&pdev->regs.HREGS->HAINTMSK, 0, intr_enable);
   \   000000F0   4469               LDR      R4,[R0, #+20]
   \   000000F2   A469               LDR      R4,[R4, #+24]
   \   000000F4   3443               ORRS     R4,R6,R4
   \   000000F6   4569               LDR      R5,[R0, #+20]
   \   000000F8   AC61               STR      R4,[R5, #+24]
    966            
    967            /* Make sure host channel interrupts are enabled. */
    968            gintmsk.b.hcintr = 1;
   \   000000FA   53F00073           ORRS     R3,R3,#0x2000000
    969            USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, gintmsk.d32);
   \   000000FE   C468               LDR      R4,[R0, #+12]
   \   00000100   A469               LDR      R4,[R4, #+24]
   \   00000102   2343               ORRS     R3,R3,R4
   \   00000104   C468               LDR      R4,[R0, #+12]
   \   00000106   A361               STR      R3,[R4, #+24]
    970            
    971            /* Program the HCCHAR register */
    972            hcchar.d32 = 0;
   \   00000108   0025               MOVS     R5,#+0
    973            hcchar.b.devaddr = pdev->host.hc[hc_num].dev_addr;
   \   0000010A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000010C   10EB4113           ADDS     R3,R0,R1, LSL #+5
   \   00000110   93F88837           LDRB     R3,[R3, #+1928]
   \   00000114   63F39C55           BFI      R5,R3,#+22,#+7
    974            hcchar.b.epnum   = pdev->host.hc[hc_num].ep_num;
   \   00000118   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000011A   10EB4113           ADDS     R3,R0,R1, LSL #+5
   \   0000011E   93F88937           LDRB     R3,[R3, #+1929]
   \   00000122   63F3CE25           BFI      R5,R3,#+11,#+4
    975            hcchar.b.epdir   = pdev->host.hc[hc_num].ep_is_in;
   \   00000126   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000128   10EB4113           ADDS     R3,R0,R1, LSL #+5
   \   0000012C   93F88A37           LDRB     R3,[R3, #+1930]
   \   00000130   63F3CF35           BFI      R5,R3,#+15,#+1
    976            hcchar.b.lspddev = (pdev->host.hc[hc_num].speed == HPRT0_PRTSPD_LOW_SPEED);
   \   00000134   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000136   10EB4113           ADDS     R3,R0,R1, LSL #+5
   \   0000013A   93F88B37           LDRB     R3,[R3, #+1931]
   \   0000013E   022B               CMP      R3,#+2
   \   00000140   01D1               BNE.N    ??USB_OTG_HC_Init_9
   \   00000142   0123               MOVS     R3,#+1
   \   00000144   00E0               B.N      ??USB_OTG_HC_Init_10
   \                     ??USB_OTG_HC_Init_9:
   \   00000146   0023               MOVS     R3,#+0
   \                     ??USB_OTG_HC_Init_10:
   \   00000148   DBB2               UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000014A   63F35145           BFI      R5,R3,#+17,#+1
    977            hcchar.b.eptype  = pdev->host.hc[hc_num].ep_type;
   \   0000014E   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000150   10EB4113           ADDS     R3,R0,R1, LSL #+5
   \   00000154   93F88D37           LDRB     R3,[R3, #+1933]
   \   00000158   63F39345           BFI      R5,R3,#+18,#+2
    978            hcchar.b.mps     = pdev->host.hc[hc_num].max_packet;
   \   0000015C   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000015E   10EB4113           ADDS     R3,R0,R1, LSL #+5
   \   00000162   B3F88E37           LDRH     R3,[R3, #+1934]
   \   00000166   63F30A05           BFI      R5,R3,#+0,#+11
    979            if (pdev->host.hc[hc_num].ep_type == HCCHAR_INTR)
   \   0000016A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000016C   10EB4113           ADDS     R3,R0,R1, LSL #+5
   \   00000170   93F88D37           LDRB     R3,[R3, #+1933]
   \   00000174   032B               CMP      R3,#+3
   \   00000176   01D1               BNE.N    ??USB_OTG_HC_Init_11
    980            {
    981              hcchar.b.oddfrm  = 1;
   \   00000178   55F00055           ORRS     R5,R5,#0x20000000
    982            }
    983            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
   \                     ??USB_OTG_HC_Init_11:
   \   0000017C   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000017E   10EB8100           ADDS     R0,R0,R1, LSL #+2
   \   00000182   D0F89000           LDR      R0,[R0, #+144]
   \   00000186   0560               STR      R5,[R0, #+0]
    984            return status;
   \   00000188   1000               MOVS     R0,R2
   \   0000018A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000018C   F0BC               POP      {R4-R7}
   \   0000018E   7047               BX       LR               ;; return
    985          }
    986          
    987          
    988          /**
    989          * @brief  USB_OTG_HC_StartXfer : Start transfer
    990          * @param  pdev : Selected device
    991          * @param  hc_num : channel number
    992          * @retval USB_OTG_STS : status
    993          */

   \                                 In section .text, align 2, keep-with-next
    994          USB_OTG_STS USB_OTG_HC_StartXfer(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
    995          {
   \                     USB_OTG_HC_StartXfer:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   0400               MOVS     R4,R0
   \   00000006   0D00               MOVS     R5,R1
    996            USB_OTG_STS status = USB_OTG_OK;
   \   00000008   0026               MOVS     R6,#+0
    997            USB_OTG_HCCHAR_TypeDef   hcchar;
    998            USB_OTG_HCTSIZn_TypeDef  hctsiz;
    999            USB_OTG_HNPTXSTS_TypeDef hnptxsts; 
   1000            USB_OTG_HPTXSTS_TypeDef  hptxsts; 
   1001            USB_OTG_GINTMSK_TypeDef  intmsk;
   1002            uint16_t                 len_words = 0;   
   \   0000000A   0022               MOVS     R2,#+0
   1003            
   1004            uint16_t num_packets;
   1005            uint16_t max_hc_pkt_count;
   1006            
   1007            max_hc_pkt_count = 256;
   \   0000000C   4FF48070           MOV      R0,#+256
   1008            hctsiz.d32 = 0;
   \   00000010   0021               MOVS     R1,#+0
   1009            hcchar.d32 = 0;
   \   00000012   5FF00008           MOVS     R8,#+0
   1010            intmsk.d32 = 0;
   \   00000016   0027               MOVS     R7,#+0
   1011            
   1012            /* Compute the expected number of packets associated to the transfer */
   1013            if (pdev->host.hc[hc_num].xfer_len > 0)
   \   00000018   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   14EB4513           ADDS     R3,R4,R5, LSL #+5
   \   0000001E   D3F89837           LDR      R3,[R3, #+1944]
   \   00000022   002B               CMP      R3,#+0
   \   00000024   25D0               BEQ.N    ??USB_OTG_HC_StartXfer_0
   1014            {
   1015              num_packets = (pdev->host.hc[hc_num].xfer_len + \
   1016                pdev->host.hc[hc_num].max_packet - 1) / pdev->host.hc[hc_num].max_packet;
   \   00000026   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   14EB4512           ADDS     R2,R4,R5, LSL #+5
   \   0000002C   D2F89827           LDR      R2,[R2, #+1944]
   \   00000030   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   14EB4513           ADDS     R3,R4,R5, LSL #+5
   \   00000036   B3F88E37           LDRH     R3,[R3, #+1934]
   \   0000003A   9A18               ADDS     R2,R3,R2
   \   0000003C   521E               SUBS     R2,R2,#+1
   \   0000003E   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   14EB4513           ADDS     R3,R4,R5, LSL #+5
   \   00000044   B3F88E37           LDRH     R3,[R3, #+1934]
   \   00000048   B2FBF3F2           UDIV     R2,R2,R3
   1017              
   1018              if (num_packets > max_hc_pkt_count)
   \   0000004C   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004E   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000050   9042               CMP      R0,R2
   \   00000052   0FD2               BCS.N    ??USB_OTG_HC_StartXfer_1
   1019              {
   1020                num_packets = max_hc_pkt_count;
   \   00000054   0200               MOVS     R2,R0
   1021                pdev->host.hc[hc_num].xfer_len = num_packets * \
   1022                  pdev->host.hc[hc_num].max_packet;
   \   00000056   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000058   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005A   14EB4510           ADDS     R0,R4,R5, LSL #+5
   \   0000005E   B0F88E07           LDRH     R0,[R0, #+1934]
   \   00000062   00FB02F0           MUL      R0,R0,R2
   \   00000066   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000068   14EB4513           ADDS     R3,R4,R5, LSL #+5
   \   0000006C   C3F89807           STR      R0,[R3, #+1944]
   \   00000070   00E0               B.N      ??USB_OTG_HC_StartXfer_1
   1023              }
   1024            }
   1025            else
   1026            {
   1027              num_packets = 1;
   \                     ??USB_OTG_HC_StartXfer_0:
   \   00000072   0122               MOVS     R2,#+1
   1028            }
   1029            if (pdev->host.hc[hc_num].ep_is_in)
   \                     ??USB_OTG_HC_StartXfer_1:
   \   00000074   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000076   14EB4510           ADDS     R0,R4,R5, LSL #+5
   \   0000007A   90F88A07           LDRB     R0,[R0, #+1930]
   \   0000007E   0028               CMP      R0,#+0
   \   00000080   0CD0               BEQ.N    ??USB_OTG_HC_StartXfer_2
   1030            {
   1031              pdev->host.hc[hc_num].xfer_len = num_packets * \
   1032                pdev->host.hc[hc_num].max_packet;
   \   00000082   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000084   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000086   14EB4510           ADDS     R0,R4,R5, LSL #+5
   \   0000008A   B0F88E07           LDRH     R0,[R0, #+1934]
   \   0000008E   00FB02F0           MUL      R0,R0,R2
   \   00000092   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000094   14EB4513           ADDS     R3,R4,R5, LSL #+5
   \   00000098   C3F89807           STR      R0,[R3, #+1944]
   1033            }
   1034            /* Initialize the HCTSIZn register */
   1035            hctsiz.b.xfersize = pdev->host.hc[hc_num].xfer_len;
   \                     ??USB_OTG_HC_StartXfer_2:
   \   0000009C   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009E   14EB4510           ADDS     R0,R4,R5, LSL #+5
   \   000000A2   D0F89807           LDR      R0,[R0, #+1944]
   \   000000A6   60F31201           BFI      R1,R0,#+0,#+19
   1036            hctsiz.b.pktcnt = num_packets;
   \   000000AA   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000AC   62F3DC41           BFI      R1,R2,#+19,#+10
   1037            hctsiz.b.pid = pdev->host.hc[hc_num].data_pid;
   \   000000B0   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B2   14EB4510           ADDS     R0,R4,R5, LSL #+5
   \   000000B6   90F89007           LDRB     R0,[R0, #+1936]
   \   000000BA   60F35E71           BFI      R1,R0,#+29,#+2
   1038            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
   \   000000BE   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C0   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   000000C4   D0F89000           LDR      R0,[R0, #+144]
   \   000000C8   0161               STR      R1,[R0, #+16]
   1039            
   1040            if (pdev->cfg.dma_enable == 1)
   \   000000CA   E078               LDRB     R0,[R4, #+3]
   \   000000CC   0128               CMP      R0,#+1
   \   000000CE   0AD1               BNE.N    ??USB_OTG_HC_StartXfer_3
   1041            {
   1042              USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCDMA, (unsigned int)pdev->host.hc[hc_num].xfer_buff);
   \   000000D0   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D2   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   000000D6   D0F89000           LDR      R0,[R0, #+144]
   \   000000DA   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000DC   14EB4511           ADDS     R1,R4,R5, LSL #+5
   \   000000E0   D1F89417           LDR      R1,[R1, #+1940]
   \   000000E4   4161               STR      R1,[R0, #+20]
   1043            }
   1044            
   1045            
   1046            hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
   \                     ??USB_OTG_HC_StartXfer_3:
   \   000000E6   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E8   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   000000EC   D0F89000           LDR      R0,[R0, #+144]
   \   000000F0   D0F80080           LDR      R8,[R0, #+0]
   1047            hcchar.b.oddfrm = USB_OTG_IsEvenFrame(pdev);
   \   000000F4   2000               MOVS     R0,R4
   \   000000F6   ........           BL       USB_OTG_IsEvenFrame
   \   000000FA   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000FC   60F35D78           BFI      R8,R0,#+29,#+1
   1048            
   1049            /* Set host channel enable */
   1050            hcchar.b.chen = 1;
   \   00000100   58F00048           ORRS     R8,R8,#0x80000000
   1051            hcchar.b.chdis = 0;
   \   00000104   38F08048           BICS     R8,R8,#0x40000000
   1052            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
   \   00000108   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000010A   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   0000010E   D0F89000           LDR      R0,[R0, #+144]
   \   00000112   C0F80080           STR      R8,[R0, #+0]
   1053          
   1054            if (pdev->cfg.dma_enable == 0) /* Slave mode */
   \   00000116   E078               LDRB     R0,[R4, #+3]
   \   00000118   0028               CMP      R0,#+0
   \   0000011A   56D1               BNE.N    ??USB_OTG_HC_StartXfer_4
   1055            {  
   1056              if((pdev->host.hc[hc_num].ep_is_in == 0) && 
   1057                  (pdev->host.hc[hc_num].xfer_len > 0))
   \   0000011C   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000011E   14EB4510           ADDS     R0,R4,R5, LSL #+5
   \   00000122   90F88A07           LDRB     R0,[R0, #+1930]
   \   00000126   0028               CMP      R0,#+0
   \   00000128   4FD1               BNE.N    ??USB_OTG_HC_StartXfer_4
   \   0000012A   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000012C   14EB4510           ADDS     R0,R4,R5, LSL #+5
   \   00000130   D0F89807           LDR      R0,[R0, #+1944]
   \   00000134   0028               CMP      R0,#+0
   \   00000136   48D0               BEQ.N    ??USB_OTG_HC_StartXfer_4
   1058              {
   1059                switch(pdev->host.hc[hc_num].ep_type) 
   \   00000138   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000013A   14EB4510           ADDS     R0,R4,R5, LSL #+5
   \   0000013E   90F88D07           LDRB     R0,[R0, #+1933]
   \   00000142   0028               CMP      R0,#+0
   \   00000144   05D0               BEQ.N    ??USB_OTG_HC_StartXfer_5
   \   00000146   0228               CMP      R0,#+2
   \   00000148   03D0               BEQ.N    ??USB_OTG_HC_StartXfer_5
   \   0000014A   18D3               BCC.N    ??USB_OTG_HC_StartXfer_6
   \   0000014C   0328               CMP      R0,#+3
   \   0000014E   16D0               BEQ.N    ??USB_OTG_HC_StartXfer_6
   \   00000150   2BE0               B.N      ??USB_OTG_HC_StartXfer_7
   1060                {
   1061                  /* Non periodic transfer */
   1062                case EP_TYPE_CTRL:
   1063                case EP_TYPE_BULK:
   1064                  
   1065                  hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
   \                     ??USB_OTG_HC_StartXfer_5:
   \   00000152   E068               LDR      R0,[R4, #+12]
   \   00000154   C06A               LDR      R0,[R0, #+44]
   1066                  len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
   \   00000156   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000158   14EB4511           ADDS     R1,R4,R5, LSL #+5
   \   0000015C   D1F89817           LDR      R1,[R1, #+1944]
   \   00000160   C91C               ADDS     R1,R1,#+3
   \   00000162   8A08               LSRS     R2,R1,#+2
   1067                  
   1068                  /* check if there is enough space in FIFO space */
   1069                  if(len_words > hnptxsts.b.nptxfspcavail)
   \   00000164   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000166   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000168   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000016A   9042               CMP      R0,R2
   \   0000016C   06D2               BCS.N    ??USB_OTG_HC_StartXfer_8
   1070                  {
   1071                    /* need to process data in nptxfempty interrupt */
   1072                    intmsk.b.nptxfempty = 1;
   \   0000016E   57F02007           ORRS     R7,R7,#0x20
   1073                    USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
   \   00000172   E068               LDR      R0,[R4, #+12]
   \   00000174   8069               LDR      R0,[R0, #+24]
   \   00000176   3843               ORRS     R0,R7,R0
   \   00000178   E168               LDR      R1,[R4, #+12]
   \   0000017A   8861               STR      R0,[R1, #+24]
   1074                  }
   1075                  
   1076                  break;
   \                     ??USB_OTG_HC_StartXfer_8:
   \   0000017C   15E0               B.N      ??USB_OTG_HC_StartXfer_9
   1077                  /* Periodic transfer */
   1078                case EP_TYPE_INTR:
   1079                case EP_TYPE_ISOC:
   1080                  hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
   \                     ??USB_OTG_HC_StartXfer_6:
   \   0000017E   6069               LDR      R0,[R4, #+20]
   \   00000180   0069               LDR      R0,[R0, #+16]
   1081                  len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
   \   00000182   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000184   14EB4511           ADDS     R1,R4,R5, LSL #+5
   \   00000188   D1F89817           LDR      R1,[R1, #+1944]
   \   0000018C   C91C               ADDS     R1,R1,#+3
   \   0000018E   8A08               LSRS     R2,R1,#+2
   1082                  /* check if there is enough space in FIFO space */
   1083                  if(len_words > hptxsts.b.ptxfspcavail) /* split the transfer */
   \   00000190   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000192   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000194   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000196   9042               CMP      R0,R2
   \   00000198   06D2               BCS.N    ??USB_OTG_HC_StartXfer_10
   1084                  {
   1085                    /* need to process data in ptxfempty interrupt */
   1086                    intmsk.b.ptxfempty = 1;
   \   0000019A   57F08067           ORRS     R7,R7,#0x4000000
   1087                    USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
   \   0000019E   E068               LDR      R0,[R4, #+12]
   \   000001A0   8069               LDR      R0,[R0, #+24]
   \   000001A2   3843               ORRS     R0,R7,R0
   \   000001A4   E168               LDR      R1,[R4, #+12]
   \   000001A6   8861               STR      R0,[R1, #+24]
   1088                  }
   1089                  break;
   \                     ??USB_OTG_HC_StartXfer_10:
   \   000001A8   FFE7               B.N      ??USB_OTG_HC_StartXfer_9
   1090                  
   1091                default:
   1092                  break;
   1093                }
   1094                
   1095                /* Write packet into the Tx FIFO. */
   1096                USB_OTG_WritePacket(pdev, 
   1097                                    pdev->host.hc[hc_num].xfer_buff , 
   1098                                    hc_num, pdev->host.hc[hc_num].xfer_len);
   \                     ??USB_OTG_HC_StartXfer_7:
   \                     ??USB_OTG_HC_StartXfer_9:
   \   000001AA   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001AC   14EB4510           ADDS     R0,R4,R5, LSL #+5
   \   000001B0   D0F89837           LDR      R3,[R0, #+1944]
   \   000001B4   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000001B6   2A00               MOVS     R2,R5
   \   000001B8   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001BA   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001BC   14EB4510           ADDS     R0,R4,R5, LSL #+5
   \   000001C0   D0F89417           LDR      R1,[R0, #+1940]
   \   000001C4   2000               MOVS     R0,R4
   \   000001C6   ........           BL       USB_OTG_WritePacket
   1099              }
   1100            }
   1101            return status;
   \                     ??USB_OTG_HC_StartXfer_4:
   \   000001CA   3000               MOVS     R0,R6
   \   000001CC   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001CE   BDE8F081           POP      {R4-R8,PC}       ;; return
   1102          }
   1103          
   1104          
   1105          /**
   1106          * @brief  USB_OTG_HC_Halt : Halt channel
   1107          * @param  pdev : Selected device
   1108          * @param  hc_num : channel number
   1109          * @retval USB_OTG_STS : status
   1110          */

   \                                 In section .text, align 2, keep-with-next
   1111          USB_OTG_STS USB_OTG_HC_Halt(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
   1112          {
   \                     USB_OTG_HC_Halt:
   \   00000000   70B4               PUSH     {R4-R6}
   \   00000002   0A00               MOVS     R2,R1
   1113            USB_OTG_STS status = USB_OTG_OK;
   \   00000004   0021               MOVS     R1,#+0
   1114            USB_OTG_HNPTXSTS_TypeDef            nptxsts;
   1115            USB_OTG_HPTXSTS_TypeDef             hptxsts;
   1116            USB_OTG_HCCHAR_TypeDef              hcchar;
   1117            
   1118            nptxsts.d32 = 0;
   \   00000006   0023               MOVS     R3,#+0
   1119            hptxsts.d32 = 0;
   \   00000008   0024               MOVS     R4,#+0
   1120            hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
   \   0000000A   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   10EB8205           ADDS     R5,R0,R2, LSL #+2
   \   00000010   D5F89050           LDR      R5,[R5, #+144]
   \   00000014   2D68               LDR      R5,[R5, #+0]
   1121            hcchar.b.chen = 1;
   \   00000016   55F00045           ORRS     R5,R5,#0x80000000
   1122            hcchar.b.chdis = 1;
   \   0000001A   55F08045           ORRS     R5,R5,#0x40000000
   1123            
   1124            /* Check for space in the request queue to issue the halt. */
   1125            if (hcchar.b.eptype == HCCHAR_CTRL || hcchar.b.eptype == HCCHAR_BULK)
   \   0000001E   C5F38146           UBFX     R6,R5,#+18,#+2
   \   00000022   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000024   002E               CMP      R6,#+0
   \   00000026   04D0               BEQ.N    ??USB_OTG_HC_Halt_0
   \   00000028   C5F38143           UBFX     R3,R5,#+18,#+2
   \   0000002C   DBB2               UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000002E   022B               CMP      R3,#+2
   \   00000030   09D1               BNE.N    ??USB_OTG_HC_Halt_1
   1126            {
   1127              nptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
   \                     ??USB_OTG_HC_Halt_0:
   \   00000032   C368               LDR      R3,[R0, #+12]
   \   00000034   DB6A               LDR      R3,[R3, #+44]
   1128              if (nptxsts.b.nptxqspcavail == 0)
   \   00000036   C3F30743           UBFX     R3,R3,#+16,#+8
   \   0000003A   DBB2               UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000003C   002B               CMP      R3,#+0
   \   0000003E   0BD1               BNE.N    ??USB_OTG_HC_Halt_2
   1129              {
   1130                hcchar.b.chen = 0;
   \   00000040   6D00               LSLS     R5,R5,#+1
   \   00000042   6D08               LSRS     R5,R5,#+1
   \   00000044   08E0               B.N      ??USB_OTG_HC_Halt_2
   1131              }
   1132            }
   1133            else
   1134            {
   1135              hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
   \                     ??USB_OTG_HC_Halt_1:
   \   00000046   4369               LDR      R3,[R0, #+20]
   \   00000048   1C69               LDR      R4,[R3, #+16]
   1136              if (hptxsts.b.ptxqspcavail == 0)
   \   0000004A   C4F30743           UBFX     R3,R4,#+16,#+8
   \   0000004E   DBB2               UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000050   002B               CMP      R3,#+0
   \   00000052   01D1               BNE.N    ??USB_OTG_HC_Halt_2
   1137              {
   1138                hcchar.b.chen = 0;
   \   00000054   6D00               LSLS     R5,R5,#+1
   \   00000056   6D08               LSRS     R5,R5,#+1
   1139              }
   1140            }
   1141            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
   \                     ??USB_OTG_HC_Halt_2:
   \   00000058   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000005A   10EB8200           ADDS     R0,R0,R2, LSL #+2
   \   0000005E   D0F89000           LDR      R0,[R0, #+144]
   \   00000062   0560               STR      R5,[R0, #+0]
   1142            return status;
   \   00000064   0800               MOVS     R0,R1
   \   00000066   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   70BC               POP      {R4-R6}
   \   0000006A   7047               BX       LR               ;; return
   1143          }
   1144          
   1145          /**
   1146          * @brief  Issue a ping token
   1147          * @param  None
   1148          * @retval : None
   1149          */

   \                                 In section .text, align 2, keep-with-next
   1150          USB_OTG_STS USB_OTG_HC_DoPing(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
   1151          {
   \                     USB_OTG_HC_DoPing:
   \   00000000   10B4               PUSH     {R4}
   1152            USB_OTG_STS               status = USB_OTG_OK;
   \   00000002   0022               MOVS     R2,#+0
   1153            USB_OTG_HCCHAR_TypeDef    hcchar;
   1154            USB_OTG_HCTSIZn_TypeDef   hctsiz;  
   1155           
   1156            hctsiz.d32 = 0;
   \   00000004   0023               MOVS     R3,#+0
   1157            hctsiz.b.dopng = 1;
   \   00000006   53F00043           ORRS     R3,R3,#0x80000000
   1158            hctsiz.b.pktcnt = 1;
   \   0000000A   0124               MOVS     R4,#+1
   \   0000000C   64F3DC43           BFI      R3,R4,#+19,#+10
   1159            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
   \   00000010   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   10EB8104           ADDS     R4,R0,R1, LSL #+2
   \   00000016   D4F89040           LDR      R4,[R4, #+144]
   \   0000001A   2361               STR      R3,[R4, #+16]
   1160            
   1161            hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
   \   0000001C   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001E   10EB8103           ADDS     R3,R0,R1, LSL #+2
   \   00000022   D3F89030           LDR      R3,[R3, #+144]
   \   00000026   1B68               LDR      R3,[R3, #+0]
   1162            hcchar.b.chen = 1;
   \   00000028   53F00043           ORRS     R3,R3,#0x80000000
   1163            hcchar.b.chdis = 0;
   \   0000002C   33F08043           BICS     R3,R3,#0x40000000
   1164            USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
   \   00000030   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000032   10EB8100           ADDS     R0,R0,R1, LSL #+2
   \   00000036   D0F89000           LDR      R0,[R0, #+144]
   \   0000003A   0360               STR      R3,[R0, #+0]
   1165            return status;  
   \   0000003C   1000               MOVS     R0,R2
   \   0000003E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   10BC               POP      {R4}
   \   00000042   7047               BX       LR               ;; return
   1166          }
   1167          
   1168          /**
   1169          * @brief  Stop the device and clean up fifo's
   1170          * @param  None
   1171          * @retval : None
   1172          */

   \                                 In section .text, align 2, keep-with-next
   1173          void USB_OTG_StopHost(USB_OTG_CORE_HANDLE *pdev)
   1174          {
   \                     USB_OTG_StopHost:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   1175            USB_OTG_HCCHAR_TypeDef  hcchar;
   1176            uint32_t                i;
   1177            
   1178            USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINTMSK , 0);
   \   00000004   6069               LDR      R0,[R4, #+20]
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   8161               STR      R1,[R0, #+24]
   1179            USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINT,      0xFFFFFFFF);
   \   0000000A   6069               LDR      R0,[R4, #+20]
   \   0000000C   5FF0FF31           MOVS     R1,#-1
   \   00000010   4161               STR      R1,[R0, #+20]
   1180            /* Flush out any leftover queued requests. */
   1181            
   1182            for (i = 0; i < pdev->cfg.host_channels; i++)
   \   00000012   0021               MOVS     R1,#+0
   \   00000014   10E0               B.N      ??USB_OTG_StopHost_0
   1183            {
   1184              hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
   \                     ??USB_OTG_StopHost_1:
   \   00000016   14EB8100           ADDS     R0,R4,R1, LSL #+2
   \   0000001A   D0F89000           LDR      R0,[R0, #+144]
   \   0000001E   0068               LDR      R0,[R0, #+0]
   1185              hcchar.b.chen = 0;
   \   00000020   4000               LSLS     R0,R0,#+1
   \   00000022   4008               LSRS     R0,R0,#+1
   1186              hcchar.b.chdis = 1;
   \   00000024   50F08040           ORRS     R0,R0,#0x40000000
   1187              hcchar.b.epdir = 0;
   \   00000028   30F40040           BICS     R0,R0,#0x8000
   1188              USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
   \   0000002C   14EB8102           ADDS     R2,R4,R1, LSL #+2
   \   00000030   D2F89020           LDR      R2,[R2, #+144]
   \   00000034   1060               STR      R0,[R2, #+0]
   1189            }
   \   00000036   491C               ADDS     R1,R1,#+1
   \                     ??USB_OTG_StopHost_0:
   \   00000038   2078               LDRB     R0,[R4, #+0]
   \   0000003A   8142               CMP      R1,R0
   \   0000003C   EBD3               BCC.N    ??USB_OTG_StopHost_1
   1190            
   1191            /* Flush the FIFO */
   1192            USB_OTG_FlushRxFifo(pdev);
   \   0000003E   2000               MOVS     R0,R4
   \   00000040   ........           BL       USB_OTG_FlushRxFifo
   1193            USB_OTG_FlushTxFifo(pdev ,  0x10 );  
   \   00000044   1021               MOVS     R1,#+16
   \   00000046   2000               MOVS     R0,R4
   \   00000048   ........           BL       USB_OTG_FlushTxFifo
   1194          }
   \   0000004C   10BD               POP      {R4,PC}          ;; return
   1195          #endif
   1196          #ifdef USE_DEVICE_MODE
   1197          /*         PCD Core Layer       */
   1198          
   1199          /**
   1200          * @brief  USB_OTG_InitDevSpeed :Initializes the DevSpd field of DCFG register 
   1201          *         depending the PHY type and the enumeration speed of the device.
   1202          * @param  pdev : Selected device
   1203          * @retval : None
   1204          */

   \                                 In section .text, align 2, keep-with-next
   1205          void USB_OTG_InitDevSpeed(USB_OTG_CORE_HANDLE *pdev , uint8_t speed)
   1206          {
   1207            USB_OTG_DCFG_TypeDef   dcfg;
   1208            
   1209            dcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCFG);
   \                     USB_OTG_InitDevSpeed:
   \   00000000   0269               LDR      R2,[R0, #+16]
   \   00000002   1268               LDR      R2,[R2, #+0]
   1210            dcfg.b.devspd = speed;
   \   00000004   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   61F30102           BFI      R2,R1,#+0,#+2
   1211            USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCFG, dcfg.d32);
   \   0000000A   0069               LDR      R0,[R0, #+16]
   \   0000000C   0260               STR      R2,[R0, #+0]
   1212          }
   \   0000000E   7047               BX       LR               ;; return
   1213          
   1214          
   1215          /**
   1216          * @brief  USB_OTG_CoreInitDev : Initializes the USB_OTG controller registers 
   1217          *         for device mode
   1218          * @param  pdev : Selected device
   1219          * @retval USB_OTG_STS : status
   1220          */

   \                                 In section .text, align 2, keep-with-next
   1221          USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
   1222          {
   \                     USB_OTG_CoreInitDev:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   1223            USB_OTG_STS             status       = USB_OTG_OK;
   \   00000004   0025               MOVS     R5,#+0
   1224            USB_OTG_DEPCTL_TypeDef  depctl;
   1225            uint32_t i;
   1226            USB_OTG_DCFG_TypeDef    dcfg;
   1227            USB_OTG_FSIZ_TypeDef    nptxfifosize;
   1228            USB_OTG_FSIZ_TypeDef    txfifosize;
   1229            USB_OTG_DIEPMSK_TypeDef msk;
   1230            USB_OTG_DTHRCTL_TypeDef dthrctl;  
   1231            
   1232            depctl.d32 = 0;
   \   00000006   0020               MOVS     R0,#+0
   1233            dcfg.d32 = 0;
   \   00000008   0022               MOVS     R2,#+0
   1234            nptxfifosize.d32 = 0;
   \   0000000A   0026               MOVS     R6,#+0
   1235            txfifosize.d32 = 0;
   \   0000000C   0027               MOVS     R7,#+0
   1236            msk.d32 = 0;
   \   0000000E   0021               MOVS     R1,#+0
   1237            
   1238            /* Restart the Phy Clock */
   1239            USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
   \   00000010   D4F80C31           LDR      R3,[R4, #+268]
   \   00000014   5FF0000C           MOVS     R12,#+0
   \   00000018   C3F800C0           STR      R12,[R3, #+0]
   1240            /* Device configuration register */
   1241            dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
   \   0000001C   2369               LDR      R3,[R4, #+16]
   \   0000001E   1B68               LDR      R3,[R3, #+0]
   \   00000020   1A00               MOVS     R2,R3
   1242            dcfg.b.perfrint = DCFG_FRAME_INTERVAL_80;
   \   00000022   32F4C052           BICS     R2,R2,#0x1800
   1243            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32 );
   \   00000026   2369               LDR      R3,[R4, #+16]
   \   00000028   1A60               STR      R2,[R3, #+0]
   1244            
   1245          #ifdef USB_OTG_FS_CORE
   1246            if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID  )
   \   0000002A   E27A               LDRB     R2,[R4, #+11]
   \   0000002C   012A               CMP      R2,#+1
   \   0000002E   2AD1               BNE.N    ??USB_OTG_CoreInitDev_0
   1247            {  
   1248              
   1249              /* Set Full speed phy */
   1250              USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
   \   00000030   0321               MOVS     R1,#+3
   \   00000032   2000               MOVS     R0,R4
   \   00000034   ........           BL       USB_OTG_InitDevSpeed
   1251              
   1252              /* set Rx FIFO size */
   1253              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
   \   00000038   E068               LDR      R0,[R4, #+12]
   \   0000003A   8021               MOVS     R1,#+128
   \   0000003C   4162               STR      R1,[R0, #+36]
   1254              
   1255              /* EP0 TX*/
   1256              nptxfifosize.b.depth     = TX0_FIFO_FS_SIZE;
   \   0000003E   2020               MOVS     R0,#+32
   \   00000040   60F31F46           BFI      R6,R0,#+16,#+16
   1257              nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
   \   00000044   8020               MOVS     R0,#+128
   \   00000046   60F30F06           BFI      R6,R0,#+0,#+16
   1258              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
   \   0000004A   E068               LDR      R0,[R4, #+12]
   \   0000004C   8662               STR      R6,[R0, #+40]
   1259              
   1260              
   1261              /* EP1 TX*/
   1262              txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
   \   0000004E   16EB1640           ADDS     R0,R6,R6, LSR #+16
   \   00000052   60F30F07           BFI      R7,R0,#+0,#+16
   1263              txfifosize.b.depth = TX1_FIFO_FS_SIZE;
   \   00000056   8020               MOVS     R0,#+128
   \   00000058   60F31F47           BFI      R7,R0,#+16,#+16
   1264              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
   \   0000005C   E068               LDR      R0,[R4, #+12]
   \   0000005E   C0F80471           STR      R7,[R0, #+260]
   1265              
   1266              
   1267              /* EP2 TX*/
   1268              txfifosize.b.startaddr += txfifosize.b.depth;
   \   00000062   17EB1740           ADDS     R0,R7,R7, LSR #+16
   \   00000066   60F30F07           BFI      R7,R0,#+0,#+16
   1269              txfifosize.b.depth = TX2_FIFO_FS_SIZE;
   \   0000006A   2020               MOVS     R0,#+32
   \   0000006C   60F31F47           BFI      R7,R0,#+16,#+16
   1270              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[1], txfifosize.d32 );
   \   00000070   E068               LDR      R0,[R4, #+12]
   \   00000072   C0F80871           STR      R7,[R0, #+264]
   1271              
   1272              
   1273              /* EP3 TX*/  
   1274              txfifosize.b.startaddr += txfifosize.b.depth;
   \   00000076   17EB1740           ADDS     R0,R7,R7, LSR #+16
   \   0000007A   60F30F07           BFI      R7,R0,#+0,#+16
   1275              txfifosize.b.depth = TX3_FIFO_FS_SIZE;
   \   0000007E   BFB2               UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   1276              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[2], txfifosize.d32 );
   \   00000080   E068               LDR      R0,[R4, #+12]
   \   00000082   C0F80C71           STR      R7,[R0, #+268]
   1277            }
   1278          #endif
   1279          #ifdef USB_OTG_HS_CORE
   1280            if(pdev->cfg.coreID == USB_OTG_HS_CORE_ID  )
   1281            {
   1282              
   1283              /* Set High speed phy */
   1284              
   1285              if(pdev->cfg.phy_itface  == USB_OTG_HS_ULPI_PHY)
   1286              {
   1287                 USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_HIGH);
   1288              }
   1289              else /* set High speed phy in Full speed mode */
   1290              {
   1291                USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_HIGH_IN_FULL);
   1292              }
   1293              
   1294              /* set Rx FIFO size */
   1295              USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_HS_SIZE);
   1296              
   1297              /* EP0 TX*/
   1298              nptxfifosize.b.depth     = TX0_FIFO_HS_SIZE;
   1299              nptxfifosize.b.startaddr = RX_FIFO_HS_SIZE;
   1300              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
   1301              
   1302              
   1303              /* EP1 TX*/
   1304              txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
   1305              txfifosize.b.depth = TX1_FIFO_HS_SIZE;
   1306              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
   1307              
   1308              
   1309              /* EP2 TX*/
   1310              txfifosize.b.startaddr += txfifosize.b.depth;
   1311              txfifosize.b.depth = TX2_FIFO_HS_SIZE;
   1312              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[1], txfifosize.d32 );
   1313              
   1314              
   1315              /* EP3 TX*/  
   1316              txfifosize.b.startaddr += txfifosize.b.depth;
   1317              txfifosize.b.depth = TX3_FIFO_HS_SIZE;
   1318              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[2], txfifosize.d32 );
   1319              
   1320              /* EP4 TX*/
   1321              txfifosize.b.startaddr += txfifosize.b.depth;
   1322              txfifosize.b.depth = TX4_FIFO_HS_SIZE;
   1323              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[3], txfifosize.d32 );
   1324              
   1325              
   1326              /* EP5 TX*/  
   1327              txfifosize.b.startaddr += txfifosize.b.depth;
   1328              txfifosize.b.depth = TX5_FIFO_HS_SIZE;
   1329              USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[4], txfifosize.d32 );
   1330            }
   1331          #endif  
   1332            /* Flush the FIFOs */
   1333            USB_OTG_FlushTxFifo(pdev , 0x10); /* all Tx FIFOs */
   \                     ??USB_OTG_CoreInitDev_0:
   \   00000086   1021               MOVS     R1,#+16
   \   00000088   2000               MOVS     R0,R4
   \   0000008A   ........           BL       USB_OTG_FlushTxFifo
   1334            USB_OTG_FlushRxFifo(pdev);
   \   0000008E   2000               MOVS     R0,R4
   \   00000090   ........           BL       USB_OTG_FlushRxFifo
   1335            /* Clear all pending Device Interrupts */
   1336            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
   \   00000094   2069               LDR      R0,[R4, #+16]
   \   00000096   0021               MOVS     R1,#+0
   \   00000098   0161               STR      R1,[R0, #+16]
   1337            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
   \   0000009A   2069               LDR      R0,[R4, #+16]
   \   0000009C   0021               MOVS     R1,#+0
   \   0000009E   4161               STR      R1,[R0, #+20]
   1338            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
   \   000000A0   2069               LDR      R0,[R4, #+16]
   \   000000A2   5FF0FF31           MOVS     R1,#-1
   \   000000A6   8161               STR      R1,[R0, #+24]
   1339            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
   \   000000A8   2069               LDR      R0,[R4, #+16]
   \   000000AA   0021               MOVS     R1,#+0
   \   000000AC   C161               STR      R1,[R0, #+28]
   1340            
   1341            for (i = 0; i < pdev->cfg.dev_endpoints; i++)
   \   000000AE   0021               MOVS     R1,#+0
   \   000000B0   0FE0               B.N      ??USB_OTG_CoreInitDev_1
   1342            {
   1343              depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[i]->DIEPCTL);
   1344              if (depctl.b.epena)
   1345              {
   1346                depctl.d32 = 0;
   1347                depctl.b.epdis = 1;
   1348                depctl.b.snak = 1;
   1349              }
   1350              else
   1351              {
   1352                depctl.d32 = 0;
   \                     ??USB_OTG_CoreInitDev_2:
   \   000000B2   0020               MOVS     R0,#+0
   1353              }
   1354              USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
   \                     ??USB_OTG_CoreInitDev_3:
   \   000000B4   14EB8102           ADDS     R2,R4,R1, LSL #+2
   \   000000B8   9269               LDR      R2,[R2, #+24]
   \   000000BA   1060               STR      R0,[R2, #+0]
   1355              USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
   \   000000BC   14EB8100           ADDS     R0,R4,R1, LSL #+2
   \   000000C0   8069               LDR      R0,[R0, #+24]
   \   000000C2   0022               MOVS     R2,#+0
   \   000000C4   0261               STR      R2,[R0, #+16]
   1356              USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
   \   000000C6   14EB8100           ADDS     R0,R4,R1, LSL #+2
   \   000000CA   8069               LDR      R0,[R0, #+24]
   \   000000CC   FF22               MOVS     R2,#+255
   \   000000CE   8260               STR      R2,[R0, #+8]
   \   000000D0   491C               ADDS     R1,R1,#+1
   \                     ??USB_OTG_CoreInitDev_1:
   \   000000D2   6078               LDRB     R0,[R4, #+1]
   \   000000D4   8142               CMP      R1,R0
   \   000000D6   0BD2               BCS.N    ??USB_OTG_CoreInitDev_4
   \   000000D8   14EB8100           ADDS     R0,R4,R1, LSL #+2
   \   000000DC   8069               LDR      R0,[R0, #+24]
   \   000000DE   0068               LDR      R0,[R0, #+0]
   \   000000E0   0028               CMP      R0,#+0
   \   000000E2   E6D5               BPL.N    ??USB_OTG_CoreInitDev_2
   \   000000E4   0020               MOVS     R0,#+0
   \   000000E6   50F08040           ORRS     R0,R0,#0x40000000
   \   000000EA   50F00060           ORRS     R0,R0,#0x8000000
   \   000000EE   E1E7               B.N      ??USB_OTG_CoreInitDev_3
   1357            }
   1358            for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
   \                     ??USB_OTG_CoreInitDev_4:
   \   000000F0   0021               MOVS     R1,#+0
   \   000000F2   0FE0               B.N      ??USB_OTG_CoreInitDev_5
   1359            {
   1360              USB_OTG_DEPCTL_TypeDef  depctl;
   1361              depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[i]->DOEPCTL);
   1362              if (depctl.b.epena)
   1363              {
   1364                depctl.d32 = 0;
   1365                depctl.b.epdis = 1;
   1366                depctl.b.snak = 1;
   1367              }
   1368              else
   1369              {
   1370                depctl.d32 = 0;
   \                     ??USB_OTG_CoreInitDev_6:
   \   000000F4   0020               MOVS     R0,#+0
   1371              }
   1372              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPCTL, depctl.d32);
   \                     ??USB_OTG_CoreInitDev_7:
   \   000000F6   14EB8102           ADDS     R2,R4,R1, LSL #+2
   \   000000FA   526D               LDR      R2,[R2, #+84]
   \   000000FC   1060               STR      R0,[R2, #+0]
   1373              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPTSIZ, 0);
   \   000000FE   14EB8100           ADDS     R0,R4,R1, LSL #+2
   \   00000102   406D               LDR      R0,[R0, #+84]
   \   00000104   0022               MOVS     R2,#+0
   \   00000106   0261               STR      R2,[R0, #+16]
   1374              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
   \   00000108   14EB8100           ADDS     R0,R4,R1, LSL #+2
   \   0000010C   406D               LDR      R0,[R0, #+84]
   \   0000010E   FF22               MOVS     R2,#+255
   \   00000110   8260               STR      R2,[R0, #+8]
   \   00000112   491C               ADDS     R1,R1,#+1
   \                     ??USB_OTG_CoreInitDev_5:
   \   00000114   6078               LDRB     R0,[R4, #+1]
   \   00000116   8142               CMP      R1,R0
   \   00000118   0BD2               BCS.N    ??USB_OTG_CoreInitDev_8
   \   0000011A   14EB8100           ADDS     R0,R4,R1, LSL #+2
   \   0000011E   406D               LDR      R0,[R0, #+84]
   \   00000120   0068               LDR      R0,[R0, #+0]
   \   00000122   0028               CMP      R0,#+0
   \   00000124   E6D5               BPL.N    ??USB_OTG_CoreInitDev_6
   \   00000126   0020               MOVS     R0,#+0
   \   00000128   50F08040           ORRS     R0,R0,#0x40000000
   \   0000012C   50F00060           ORRS     R0,R0,#0x8000000
   \   00000130   E1E7               B.N      ??USB_OTG_CoreInitDev_7
   1375            }
   1376            msk.d32 = 0;
   \                     ??USB_OTG_CoreInitDev_8:
   \   00000132   0021               MOVS     R1,#+0
   1377            msk.b.txfifoundrn = 1;
   \   00000134   4FF48070           MOV      R0,#+256
   \   00000138   0143               ORRS     R1,R0,R1
   1378            USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPMSK, msk.d32, msk.d32);
   \   0000013A   2069               LDR      R0,[R4, #+16]
   \   0000013C   0069               LDR      R0,[R0, #+16]
   \   0000013E   8843               BICS     R0,R0,R1
   \   00000140   0843               ORRS     R0,R1,R0
   \   00000142   2169               LDR      R1,[R4, #+16]
   \   00000144   0861               STR      R0,[R1, #+16]
   1379            
   1380            if (pdev->cfg.dma_enable == 1)
   \   00000146   E078               LDRB     R0,[R4, #+3]
   \   00000148   0128               CMP      R0,#+1
   \   0000014A   0ED1               BNE.N    ??USB_OTG_CoreInitDev_9
   1381            {
   1382              dthrctl.d32 = 0;
   \   0000014C   0020               MOVS     R0,#+0
   1383              dthrctl.b.non_iso_thr_en = 1;
   \   0000014E   50F00100           ORRS     R0,R0,#0x1
   1384              dthrctl.b.iso_thr_en = 1;
   \   00000152   50F00200           ORRS     R0,R0,#0x2
   1385              dthrctl.b.tx_thr_len = 64;
   \   00000156   4021               MOVS     R1,#+64
   \   00000158   61F38A00           BFI      R0,R1,#+2,#+9
   1386              dthrctl.b.rx_thr_en = 1;
   \   0000015C   50F48030           ORRS     R0,R0,#0x10000
   1387              dthrctl.b.rx_thr_len = 64;
   \   00000160   4021               MOVS     R1,#+64
   \   00000162   61F35940           BFI      R0,R1,#+17,#+9
   1388              USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DTHRCTL, dthrctl.d32);  
   \   00000166   2169               LDR      R1,[R4, #+16]
   \   00000168   0863               STR      R0,[R1, #+48]
   1389            }
   1390            USB_OTG_EnableDevInt(pdev);
   \                     ??USB_OTG_CoreInitDev_9:
   \   0000016A   2000               MOVS     R0,R4
   \   0000016C   ........           BL       USB_OTG_EnableDevInt
   1391            return status;
   \   00000170   2800               MOVS     R0,R5
   \   00000172   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000174   F2BD               POP      {R1,R4-R7,PC}    ;; return
   1392          }
   1393          
   1394          
   1395          /**
   1396          * @brief  USB_OTG_EnableDevInt : Enables the Device mode interrupts
   1397          * @param  pdev : Selected device
   1398          * @retval USB_OTG_STS : status
   1399          */

   \                                 In section .text, align 2, keep-with-next
   1400          USB_OTG_STS USB_OTG_EnableDevInt(USB_OTG_CORE_HANDLE *pdev)
   1401          {
   \                     USB_OTG_EnableDevInt:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   1402            USB_OTG_STS status = USB_OTG_OK;
   \   00000004   0025               MOVS     R5,#+0
   1403            USB_OTG_GINTMSK_TypeDef  intmsk;
   1404            
   1405            intmsk.d32 = 0;
   \   00000006   0026               MOVS     R6,#+0
   1406            
   1407            /* Disable all interrupts. */
   1408            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
   \   00000008   E068               LDR      R0,[R4, #+12]
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   8161               STR      R1,[R0, #+24]
   1409            /* Clear any pending interrupts */
   1410            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
   \   0000000E   E068               LDR      R0,[R4, #+12]
   \   00000010   5FF0FF31           MOVS     R1,#-1
   \   00000014   4161               STR      R1,[R0, #+20]
   1411            /* Enable the common interrupts */
   1412            USB_OTG_EnableCommonInt(pdev);
   \   00000016   2000               MOVS     R0,R4
   \   00000018   ........           BL       USB_OTG_EnableCommonInt
   1413            
   1414            if (pdev->cfg.dma_enable == 0)
   \   0000001C   E078               LDRB     R0,[R4, #+3]
   \   0000001E   0028               CMP      R0,#+0
   \   00000020   01D1               BNE.N    ??USB_OTG_EnableDevInt_0
   1415            {
   1416              intmsk.b.rxstsqlvl = 1;
   \   00000022   56F01006           ORRS     R6,R6,#0x10
   1417            }
   1418            
   1419            /* Enable interrupts matching to the Device mode ONLY */
   1420            intmsk.b.usbsuspend = 1;
   \                     ??USB_OTG_EnableDevInt_0:
   \   00000026   56F40066           ORRS     R6,R6,#0x800
   1421            intmsk.b.usbreset   = 1;
   \   0000002A   56F48056           ORRS     R6,R6,#0x1000
   1422            intmsk.b.enumdone   = 1;
   \   0000002E   56F40056           ORRS     R6,R6,#0x2000
   1423            intmsk.b.inepintr   = 1;
   \   00000032   56F48026           ORRS     R6,R6,#0x40000
   1424            intmsk.b.outepintr  = 1;
   \   00000036   56F40026           ORRS     R6,R6,#0x80000
   1425            intmsk.b.sofintr    = 1; 
   \   0000003A   56F00806           ORRS     R6,R6,#0x8
   1426            USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
   \   0000003E   E068               LDR      R0,[R4, #+12]
   \   00000040   8069               LDR      R0,[R0, #+24]
   \   00000042   B043               BICS     R0,R0,R6
   \   00000044   3043               ORRS     R0,R6,R0
   \   00000046   E168               LDR      R1,[R4, #+12]
   \   00000048   8861               STR      R0,[R1, #+24]
   1427            return status;
   \   0000004A   2800               MOVS     R0,R5
   \   0000004C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   70BD               POP      {R4-R6,PC}       ;; return
   1428          }
   1429          
   1430          
   1431          /**
   1432          * @brief  USB_OTG_GetDeviceSpeed
   1433          *         Get the device speed from the device status register
   1434          * @param  None
   1435          * @retval status
   1436          */

   \                                 In section .text, align 2, keep-with-next
   1437          enum USB_OTG_SPEED USB_OTG_GetDeviceSpeed (USB_OTG_CORE_HANDLE *pdev)
   1438          {
   1439            USB_OTG_DSTS_TypeDef  dsts;
   1440            enum USB_OTG_SPEED speed = USB_SPEED_UNKNOWN;
   \                     USB_OTG_GetDeviceSpeed:
   \   00000000   0021               MOVS     R1,#+0
   1441            
   1442            
   1443            dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
   \   00000002   0069               LDR      R0,[R0, #+16]
   \   00000004   8068               LDR      R0,[R0, #+8]
   1444            
   1445            switch (dsts.b.enumspd)
   \   00000006   4008               LSRS     R0,R0,#+1
   \   00000008   10F00300           ANDS     R0,R0,#0x3
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   05D0               BEQ.N    ??USB_OTG_GetDeviceSpeed_0
   \   00000010   0228               CMP      R0,#+2
   \   00000012   07D0               BEQ.N    ??USB_OTG_GetDeviceSpeed_1
   \   00000014   04D3               BCC.N    ??USB_OTG_GetDeviceSpeed_2
   \   00000016   0328               CMP      R0,#+3
   \   00000018   02D0               BEQ.N    ??USB_OTG_GetDeviceSpeed_2
   \   0000001A   04E0               B.N      ??USB_OTG_GetDeviceSpeed_3
   1446            {
   1447            case DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
   1448              speed = USB_SPEED_HIGH;
   \                     ??USB_OTG_GetDeviceSpeed_0:
   \   0000001C   0321               MOVS     R1,#+3
   1449              break;
   \   0000001E   02E0               B.N      ??USB_OTG_GetDeviceSpeed_3
   1450            case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
   1451            case DSTS_ENUMSPD_FS_PHY_48MHZ:
   1452              speed = USB_SPEED_FULL;
   \                     ??USB_OTG_GetDeviceSpeed_2:
   \   00000020   0221               MOVS     R1,#+2
   1453              break;
   \   00000022   00E0               B.N      ??USB_OTG_GetDeviceSpeed_3
   1454              
   1455            case DSTS_ENUMSPD_LS_PHY_6MHZ:
   1456              speed = USB_SPEED_LOW;
   \                     ??USB_OTG_GetDeviceSpeed_1:
   \   00000024   0121               MOVS     R1,#+1
   1457              break;
   1458            }
   1459            
   1460            return speed;
   \                     ??USB_OTG_GetDeviceSpeed_3:
   \   00000026   0800               MOVS     R0,R1
   \   00000028   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   7047               BX       LR               ;; return
   1461          }
   1462          /**
   1463          * @brief  enables EP0 OUT to receive SETUP packets and configures EP0
   1464          *   for transmitting packets
   1465          * @param  None
   1466          * @retval USB_OTG_STS : status
   1467          */

   \                                 In section .text, align 2, keep-with-next
   1468          USB_OTG_STS  USB_OTG_EP0Activate(USB_OTG_CORE_HANDLE *pdev)
   1469          {
   \                     USB_OTG_EP0Activate:
   \   00000000   10B4               PUSH     {R4}
   1470            USB_OTG_STS             status = USB_OTG_OK;
   \   00000002   0021               MOVS     R1,#+0
   1471            USB_OTG_DSTS_TypeDef    dsts;
   1472            USB_OTG_DEPCTL_TypeDef  diepctl;
   1473            USB_OTG_DCTL_TypeDef    dctl;
   1474            
   1475            dctl.d32 = 0;
   \   00000004   0022               MOVS     R2,#+0
   1476            /* Read the Device Status and Endpoint 0 Control registers */
   1477            dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
   \   00000006   0369               LDR      R3,[R0, #+16]
   \   00000008   9B68               LDR      R3,[R3, #+8]
   1478            diepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL);
   \   0000000A   8469               LDR      R4,[R0, #+24]
   \   0000000C   2468               LDR      R4,[R4, #+0]
   1479            /* Set the MPS of the IN EP based on the enumeration speed */
   1480            switch (dsts.b.enumspd)
   \   0000000E   5B08               LSRS     R3,R3,#+1
   \   00000010   13F00303           ANDS     R3,R3,#0x3
   \   00000014   002B               CMP      R3,#+0
   \   00000016   04D0               BEQ.N    ??USB_OTG_EP0Activate_0
   \   00000018   022B               CMP      R3,#+2
   \   0000001A   05D0               BEQ.N    ??USB_OTG_EP0Activate_1
   \   0000001C   01D3               BCC.N    ??USB_OTG_EP0Activate_0
   \   0000001E   032B               CMP      R3,#+3
   \   00000020   05D1               BNE.N    ??USB_OTG_EP0Activate_2
   1481            {
   1482            case DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
   1483            case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
   1484            case DSTS_ENUMSPD_FS_PHY_48MHZ:
   1485              diepctl.b.mps = DEP0CTL_MPS_64;
   \                     ??USB_OTG_EP0Activate_0:
   \   00000022   E40A               LSRS     R4,R4,#+11
   \   00000024   E402               LSLS     R4,R4,#+11
   1486              break;
   \   00000026   02E0               B.N      ??USB_OTG_EP0Activate_2
   1487            case DSTS_ENUMSPD_LS_PHY_6MHZ:
   1488              diepctl.b.mps = DEP0CTL_MPS_8;
   \                     ??USB_OTG_EP0Activate_1:
   \   00000028   0323               MOVS     R3,#+3
   \   0000002A   63F30A04           BFI      R4,R3,#+0,#+11
   1489              break;
   1490            }
   1491            USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL, diepctl.d32);
   \                     ??USB_OTG_EP0Activate_2:
   \   0000002E   8369               LDR      R3,[R0, #+24]
   \   00000030   1C60               STR      R4,[R3, #+0]
   1492            dctl.b.cgnpinnak = 1;
   \   00000032   4FF48073           MOV      R3,#+256
   \   00000036   1A43               ORRS     R2,R3,R2
   1493            USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, dctl.d32);
   \   00000038   0369               LDR      R3,[R0, #+16]
   \   0000003A   5B68               LDR      R3,[R3, #+4]
   \   0000003C   9343               BICS     R3,R3,R2
   \   0000003E   1A43               ORRS     R2,R2,R3
   \   00000040   0069               LDR      R0,[R0, #+16]
   \   00000042   4260               STR      R2,[R0, #+4]
   1494            return status;
   \   00000044   0800               MOVS     R0,R1
   \   00000046   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   10BC               POP      {R4}
   \   0000004A   7047               BX       LR               ;; return
   1495          }
   1496          
   1497          
   1498          /**
   1499          * @brief  USB_OTG_EPActivate : Activates an EP
   1500          * @param  pdev : Selected device
   1501          * @retval USB_OTG_STS : status
   1502          */

   \                                 In section .text, align 2, keep-with-next
   1503          USB_OTG_STS USB_OTG_EPActivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
   1504          {
   \                     USB_OTG_EPActivate:
   \   00000000   70B4               PUSH     {R4-R6}
   1505            USB_OTG_STS status = USB_OTG_OK;
   \   00000002   0022               MOVS     R2,#+0
   1506            USB_OTG_DEPCTL_TypeDef  depctl;
   1507            USB_OTG_DAINT_TypeDef  daintmsk;
   1508            __IO uint32_t *addr;
   1509            
   1510            
   1511            depctl.d32 = 0;
   \   00000004   0025               MOVS     R5,#+0
   1512            daintmsk.d32 = 0;
   \   00000006   0023               MOVS     R3,#+0
   1513            /* Read DEPCTLn register */
   1514            if (ep->is_in == 1)
   \   00000008   4C78               LDRB     R4,[R1, #+1]
   \   0000000A   012C               CMP      R4,#+1
   \   0000000C   0AD1               BNE.N    ??USB_OTG_EPActivate_0
   1515            {
   1516              addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
   \   0000000E   0C78               LDRB     R4,[R1, #+0]
   \   00000010   10EB8404           ADDS     R4,R0,R4, LSL #+2
   \   00000014   A469               LDR      R4,[R4, #+24]
   1517              daintmsk.ep.in = 1 << ep->num;
   \   00000016   0125               MOVS     R5,#+1
   \   00000018   91F90060           LDRSB    R6,[R1, #+0]
   \   0000001C   B540               LSLS     R5,R5,R6
   \   0000001E   65F30F03           BFI      R3,R5,#+0,#+16
   \   00000022   09E0               B.N      ??USB_OTG_EPActivate_1
   1518            }
   1519            else
   1520            {
   1521              addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
   \                     ??USB_OTG_EPActivate_0:
   \   00000024   0C78               LDRB     R4,[R1, #+0]
   \   00000026   10EB8404           ADDS     R4,R0,R4, LSL #+2
   \   0000002A   646D               LDR      R4,[R4, #+84]
   1522              daintmsk.ep.out = 1 << ep->num;
   \   0000002C   0125               MOVS     R5,#+1
   \   0000002E   91F90060           LDRSB    R6,[R1, #+0]
   \   00000032   B540               LSLS     R5,R5,R6
   \   00000034   65F31F43           BFI      R3,R5,#+16,#+16
   1523            }
   1524            /* If the EP is already active don't change the EP Control
   1525            * register. */
   1526            depctl.d32 = USB_OTG_READ_REG32(addr);
   \                     ??USB_OTG_EPActivate_1:
   \   00000038   2568               LDR      R5,[R4, #+0]
   1527            if (!depctl.b.usbactep)
   \   0000003A   C5F3C036           UBFX     R6,R5,#+15,#+1
   \   0000003E   F607               LSLS     R6,R6,#+31
   \   00000040   0DD4               BMI.N    ??USB_OTG_EPActivate_2
   1528            {
   1529              depctl.b.mps    = ep->maxpacket;
   \   00000042   8E68               LDR      R6,[R1, #+8]
   \   00000044   66F30A05           BFI      R5,R6,#+0,#+11
   1530              depctl.b.eptype = ep->type;
   \   00000048   CE78               LDRB     R6,[R1, #+3]
   \   0000004A   66F39345           BFI      R5,R6,#+18,#+2
   1531              depctl.b.txfnum = ep->tx_fifo_num;
   \   0000004E   C988               LDRH     R1,[R1, #+6]
   \   00000050   61F39955           BFI      R5,R1,#+22,#+4
   1532              depctl.b.setd0pid = 1;
   \   00000054   55F08055           ORRS     R5,R5,#0x10000000
   1533              depctl.b.usbactep = 1;
   \   00000058   55F40045           ORRS     R5,R5,#0x8000
   1534              USB_OTG_WRITE_REG32(addr, depctl.d32);
   \   0000005C   2560               STR      R5,[R4, #+0]
   1535            }
   1536            /* Enable the Interrupt for this EP */
   1537          #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED
   1538            if((ep->num == 1)&&(pdev->cfg.coreID == USB_OTG_HS_CORE_ID))
   1539            {
   1540              USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, 0, daintmsk.d32);
   1541            }
   1542            else
   1543          #endif   
   1544              USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, 0, daintmsk.d32);
   \                     ??USB_OTG_EPActivate_2:
   \   0000005E   0169               LDR      R1,[R0, #+16]
   \   00000060   C969               LDR      R1,[R1, #+28]
   \   00000062   1943               ORRS     R1,R3,R1
   \   00000064   0069               LDR      R0,[R0, #+16]
   \   00000066   C161               STR      R1,[R0, #+28]
   1545            return status;
   \   00000068   1000               MOVS     R0,R2
   \   0000006A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   70BC               POP      {R4-R6}
   \   0000006E   7047               BX       LR               ;; return
   1546          }
   1547          
   1548          
   1549          /**
   1550          * @brief  USB_OTG_EPDeactivate : Deactivates an EP
   1551          * @param  pdev : Selected device
   1552          * @retval USB_OTG_STS : status
   1553          */

   \                                 In section .text, align 2, keep-with-next
   1554          USB_OTG_STS USB_OTG_EPDeactivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
   1555          {
   \                     USB_OTG_EPDeactivate:
   \   00000000   70B4               PUSH     {R4-R6}
   \   00000002   0A00               MOVS     R2,R1
   1556            USB_OTG_STS status = USB_OTG_OK;
   \   00000004   0021               MOVS     R1,#+0
   1557            USB_OTG_DEPCTL_TypeDef  depctl;
   1558            USB_OTG_DAINT_TypeDef  daintmsk;
   1559            __IO uint32_t *addr;
   1560            
   1561            depctl.d32 = 0;
   \   00000006   0023               MOVS     R3,#+0
   1562            daintmsk.d32 = 0;  
   \   00000008   0024               MOVS     R4,#+0
   1563            /* Read DEPCTLn register */
   1564            if (ep->is_in == 1)
   \   0000000A   5578               LDRB     R5,[R2, #+1]
   \   0000000C   012D               CMP      R5,#+1
   \   0000000E   0BD1               BNE.N    ??USB_OTG_EPDeactivate_0
   1565            {
   1566              addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
   \   00000010   1578               LDRB     R5,[R2, #+0]
   \   00000012   10EB8505           ADDS     R5,R0,R5, LSL #+2
   \   00000016   AD69               LDR      R5,[R5, #+24]
   1567              daintmsk.ep.in = 1 << ep->num;
   \   00000018   0126               MOVS     R6,#+1
   \   0000001A   92F90020           LDRSB    R2,[R2, #+0]
   \   0000001E   16FA02F2           LSLS     R2,R6,R2
   \   00000022   62F30F04           BFI      R4,R2,#+0,#+16
   \   00000026   0AE0               B.N      ??USB_OTG_EPDeactivate_1
   1568            }
   1569            else
   1570            {
   1571              addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
   \                     ??USB_OTG_EPDeactivate_0:
   \   00000028   1578               LDRB     R5,[R2, #+0]
   \   0000002A   10EB8505           ADDS     R5,R0,R5, LSL #+2
   \   0000002E   6D6D               LDR      R5,[R5, #+84]
   1572              daintmsk.ep.out = 1 << ep->num;
   \   00000030   0126               MOVS     R6,#+1
   \   00000032   92F90020           LDRSB    R2,[R2, #+0]
   \   00000036   16FA02F2           LSLS     R2,R6,R2
   \   0000003A   62F31F44           BFI      R4,R2,#+16,#+16
   1573            }
   1574            depctl.b.usbactep = 0;
   \                     ??USB_OTG_EPDeactivate_1:
   \   0000003E   33F40043           BICS     R3,R3,#0x8000
   1575            USB_OTG_WRITE_REG32(addr, depctl.d32);
   \   00000042   2B60               STR      R3,[R5, #+0]
   1576            /* Disable the Interrupt for this EP */
   1577            
   1578          #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED
   1579            if((ep->num == 1)&&(pdev->cfg.coreID == USB_OTG_HS_CORE_ID))
   1580            {
   1581              USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, daintmsk.d32, 0);
   1582            }
   1583            else
   1584          #endif    
   1585              USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, daintmsk.d32, 0);
   \   00000044   0269               LDR      R2,[R0, #+16]
   \   00000046   D269               LDR      R2,[R2, #+28]
   \   00000048   A243               BICS     R2,R2,R4
   \   0000004A   0069               LDR      R0,[R0, #+16]
   \   0000004C   C261               STR      R2,[R0, #+28]
   1586            return status;
   \   0000004E   0800               MOVS     R0,R1
   \   00000050   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   70BC               POP      {R4-R6}
   \   00000054   7047               BX       LR               ;; return
   1587          }
   1588          
   1589          
   1590          /**
   1591          * @brief  USB_OTG_EPStartXfer : Handle the setup for data xfer for an EP and 
   1592          *         starts the xfer
   1593          * @param  pdev : Selected device
   1594          * @retval USB_OTG_STS : status
   1595          */

   \                                 In section .text, align 2, keep-with-next
   1596          USB_OTG_STS USB_OTG_EPStartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
   1597          {
   \                     USB_OTG_EPStartXfer:
   \   00000000   70B4               PUSH     {R4-R6}
   1598            USB_OTG_STS status = USB_OTG_OK;
   \   00000002   0022               MOVS     R2,#+0
   1599            USB_OTG_DEPCTL_TypeDef     depctl;
   1600            USB_OTG_DEPXFRSIZ_TypeDef  deptsiz;
   1601            uint32_t fifoemptymsk = 0;  
   \   00000004   0025               MOVS     R5,#+0
   1602            
   1603            depctl.d32 = 0;
   \   00000006   0023               MOVS     R3,#+0
   1604            deptsiz.d32 = 0;
   \   00000008   0024               MOVS     R4,#+0
   1605            /* IN endpoint */
   1606            if (ep->is_in == 1)
   \   0000000A   4E78               LDRB     R6,[R1, #+1]
   \   0000000C   012E               CMP      R6,#+1
   \   0000000E   47D1               BNE.N    ??USB_OTG_EPStartXfer_0
   1607            {
   1608              depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
   \   00000010   0B78               LDRB     R3,[R1, #+0]
   \   00000012   10EB8303           ADDS     R3,R0,R3, LSL #+2
   \   00000016   9B69               LDR      R3,[R3, #+24]
   \   00000018   1B68               LDR      R3,[R3, #+0]
   1609              deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
   \   0000001A   0C78               LDRB     R4,[R1, #+0]
   \   0000001C   10EB8404           ADDS     R4,R0,R4, LSL #+2
   \   00000020   A469               LDR      R4,[R4, #+24]
   \   00000022   2469               LDR      R4,[R4, #+16]
   1610              /* Zero Length Packet? */
   1611              if (ep->xfer_len == 0)
   \   00000024   4D69               LDR      R5,[R1, #+20]
   \   00000026   002D               CMP      R5,#+0
   \   00000028   05D1               BNE.N    ??USB_OTG_EPStartXfer_1
   1612              {
   1613                deptsiz.b.xfersize = 0;
   \   0000002A   E40C               LSRS     R4,R4,#+19
   \   0000002C   E404               LSLS     R4,R4,#+19
   1614                deptsiz.b.pktcnt = 1;
   \   0000002E   0125               MOVS     R5,#+1
   \   00000030   65F3DC44           BFI      R4,R5,#+19,#+10
   \   00000034   0BE0               B.N      ??USB_OTG_EPStartXfer_2
   1615              }
   1616              else
   1617              {
   1618                /* Program the transfer size and packet count
   1619                * as follows: xfersize = N * maxpacket +
   1620                * short_packet pktcnt = N + (short_packet
   1621                * exist ? 1 : 0)
   1622                */
   1623                deptsiz.b.xfersize = ep->xfer_len;
   \                     ??USB_OTG_EPStartXfer_1:
   \   00000036   4D69               LDR      R5,[R1, #+20]
   \   00000038   65F31204           BFI      R4,R5,#+0,#+19
   1624                deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
   \   0000003C   4D69               LDR      R5,[R1, #+20]
   \   0000003E   8E68               LDR      R6,[R1, #+8]
   \   00000040   7519               ADDS     R5,R6,R5
   \   00000042   6D1E               SUBS     R5,R5,#+1
   \   00000044   8E68               LDR      R6,[R1, #+8]
   \   00000046   B5FBF6F5           UDIV     R5,R5,R6
   \   0000004A   65F3DC44           BFI      R4,R5,#+19,#+10
   1625              }
   1626              USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ, deptsiz.d32);
   \                     ??USB_OTG_EPStartXfer_2:
   \   0000004E   0D78               LDRB     R5,[R1, #+0]
   \   00000050   10EB8505           ADDS     R5,R0,R5, LSL #+2
   \   00000054   AD69               LDR      R5,[R5, #+24]
   \   00000056   2C61               STR      R4,[R5, #+16]
   1627              if (pdev->cfg.dma_enable == 1)
   \   00000058   C478               LDRB     R4,[R0, #+3]
   \   0000005A   012C               CMP      R4,#+1
   \   0000005C   06D1               BNE.N    ??USB_OTG_EPStartXfer_3
   1628              {
   1629                USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);
   \   0000005E   0C78               LDRB     R4,[R1, #+0]
   \   00000060   10EB8404           ADDS     R4,R0,R4, LSL #+2
   \   00000064   A469               LDR      R4,[R4, #+24]
   \   00000066   0D69               LDR      R5,[R1, #+16]
   \   00000068   6561               STR      R5,[R4, #+20]
   \   0000006A   0FE0               B.N      ??USB_OTG_EPStartXfer_4
   1630              }
   1631              else
   1632              {
   1633                if (ep->type != EP_TYPE_ISOC)
   \                     ??USB_OTG_EPStartXfer_3:
   \   0000006C   CC78               LDRB     R4,[R1, #+3]
   \   0000006E   012C               CMP      R4,#+1
   \   00000070   0CD0               BEQ.N    ??USB_OTG_EPStartXfer_4
   1634                {
   1635                  /* Enable the Tx FIFO Empty Interrupt for this EP */
   1636                  if (ep->xfer_len > 0)
   \   00000072   4C69               LDR      R4,[R1, #+20]
   \   00000074   002C               CMP      R4,#+0
   \   00000076   09D0               BEQ.N    ??USB_OTG_EPStartXfer_4
   1637                  {
   1638                    fifoemptymsk = 1 << ep->num;
   \   00000078   0124               MOVS     R4,#+1
   \   0000007A   91F90050           LDRSB    R5,[R1, #+0]
   \   0000007E   14FA05F5           LSLS     R5,R4,R5
   1639                    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
   \   00000082   0469               LDR      R4,[R0, #+16]
   \   00000084   646B               LDR      R4,[R4, #+52]
   \   00000086   2C43               ORRS     R4,R5,R4
   \   00000088   0569               LDR      R5,[R0, #+16]
   \   0000008A   6C63               STR      R4,[R5, #+52]
   1640                  }
   1641                }
   1642              }
   1643              /* EP enable, IN data in FIFO */
   1644              depctl.b.cnak = 1;
   \                     ??USB_OTG_EPStartXfer_4:
   \   0000008C   53F08063           ORRS     R3,R3,#0x4000000
   1645              depctl.b.epena = 1;
   \   00000090   53F00043           ORRS     R3,R3,#0x80000000
   1646              USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);
   \   00000094   0978               LDRB     R1,[R1, #+0]
   \   00000096   10EB8100           ADDS     R0,R0,R1, LSL #+2
   \   0000009A   8069               LDR      R0,[R0, #+24]
   \   0000009C   0360               STR      R3,[R0, #+0]
   \   0000009E   44E0               B.N      ??USB_OTG_EPStartXfer_5
   1647              
   1648              
   1649            }
   1650            else
   1651            {
   1652              /* OUT endpoint */
   1653              depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL));
   \                     ??USB_OTG_EPStartXfer_0:
   \   000000A0   0B78               LDRB     R3,[R1, #+0]
   \   000000A2   10EB8303           ADDS     R3,R0,R3, LSL #+2
   \   000000A6   5B6D               LDR      R3,[R3, #+84]
   \   000000A8   1B68               LDR      R3,[R3, #+0]
   1654              deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ));
   \   000000AA   0C78               LDRB     R4,[R1, #+0]
   \   000000AC   10EB8404           ADDS     R4,R0,R4, LSL #+2
   \   000000B0   646D               LDR      R4,[R4, #+84]
   \   000000B2   2469               LDR      R4,[R4, #+16]
   1655              /* Program the transfer size and packet count as follows:
   1656              * pktcnt = N
   1657              * xfersize = N * maxpacket
   1658              */
   1659              if (ep->xfer_len == 0)
   \   000000B4   4D69               LDR      R5,[R1, #+20]
   \   000000B6   002D               CMP      R5,#+0
   \   000000B8   06D1               BNE.N    ??USB_OTG_EPStartXfer_6
   1660              {
   1661                deptsiz.b.xfersize = ep->maxpacket;
   \   000000BA   8D68               LDR      R5,[R1, #+8]
   \   000000BC   65F31204           BFI      R4,R5,#+0,#+19
   1662                deptsiz.b.pktcnt = 1;
   \   000000C0   0125               MOVS     R5,#+1
   \   000000C2   65F3DC44           BFI      R4,R5,#+19,#+10
   \   000000C6   0EE0               B.N      ??USB_OTG_EPStartXfer_7
   1663              }
   1664              else
   1665              {
   1666                deptsiz.b.pktcnt = (ep->xfer_len + (ep->maxpacket - 1)) / ep->maxpacket;
   \                     ??USB_OTG_EPStartXfer_6:
   \   000000C8   4D69               LDR      R5,[R1, #+20]
   \   000000CA   8E68               LDR      R6,[R1, #+8]
   \   000000CC   7519               ADDS     R5,R6,R5
   \   000000CE   6D1E               SUBS     R5,R5,#+1
   \   000000D0   8E68               LDR      R6,[R1, #+8]
   \   000000D2   B5FBF6F5           UDIV     R5,R5,R6
   \   000000D6   65F3DC44           BFI      R4,R5,#+19,#+10
   1667                deptsiz.b.xfersize = deptsiz.b.pktcnt * ep->maxpacket;
   \   000000DA   C4F3C945           UBFX     R5,R4,#+19,#+10
   \   000000DE   8E68               LDR      R6,[R1, #+8]
   \   000000E0   7543               MULS     R5,R6,R5
   \   000000E2   65F31204           BFI      R4,R5,#+0,#+19
   1668              }
   1669              USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
   \                     ??USB_OTG_EPStartXfer_7:
   \   000000E6   0D78               LDRB     R5,[R1, #+0]
   \   000000E8   10EB8505           ADDS     R5,R0,R5, LSL #+2
   \   000000EC   6D6D               LDR      R5,[R5, #+84]
   \   000000EE   2C61               STR      R4,[R5, #+16]
   1670              
   1671              if (pdev->cfg.dma_enable == 1)
   \   000000F0   C478               LDRB     R4,[R0, #+3]
   \   000000F2   012C               CMP      R4,#+1
   \   000000F4   05D1               BNE.N    ??USB_OTG_EPStartXfer_8
   1672              {
   1673                USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
   \   000000F6   0C78               LDRB     R4,[R1, #+0]
   \   000000F8   10EB8404           ADDS     R4,R0,R4, LSL #+2
   \   000000FC   646D               LDR      R4,[R4, #+84]
   \   000000FE   0D69               LDR      R5,[R1, #+16]
   \   00000100   6561               STR      R5,[R4, #+20]
   1674              }
   1675              
   1676              if (ep->type == EP_TYPE_ISOC)
   \                     ??USB_OTG_EPStartXfer_8:
   \   00000102   CC78               LDRB     R4,[R1, #+3]
   \   00000104   012C               CMP      R4,#+1
   \   00000106   07D1               BNE.N    ??USB_OTG_EPStartXfer_9
   1677              {
   1678                if (ep->even_odd_frame)
   \   00000108   4C79               LDRB     R4,[R1, #+5]
   \   0000010A   002C               CMP      R4,#+0
   \   0000010C   02D0               BEQ.N    ??USB_OTG_EPStartXfer_10
   1679                {
   1680                  depctl.b.setd1pid = 1;
   \   0000010E   53F00053           ORRS     R3,R3,#0x20000000
   \   00000112   01E0               B.N      ??USB_OTG_EPStartXfer_9
   1681                }
   1682                else
   1683                {
   1684                  depctl.b.setd0pid = 1;
   \                     ??USB_OTG_EPStartXfer_10:
   \   00000114   53F08053           ORRS     R3,R3,#0x10000000
   1685                }
   1686              }
   1687              /* EP enable */
   1688              depctl.b.cnak = 1;
   \                     ??USB_OTG_EPStartXfer_9:
   \   00000118   53F08063           ORRS     R3,R3,#0x4000000
   1689              depctl.b.epena = 1;
   \   0000011C   53F00043           ORRS     R3,R3,#0x80000000
   1690              USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL, depctl.d32);
   \   00000120   0978               LDRB     R1,[R1, #+0]
   \   00000122   10EB8100           ADDS     R0,R0,R1, LSL #+2
   \   00000126   406D               LDR      R0,[R0, #+84]
   \   00000128   0360               STR      R3,[R0, #+0]
   1691            }
   1692            return status;
   \                     ??USB_OTG_EPStartXfer_5:
   \   0000012A   1000               MOVS     R0,R2
   \   0000012C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000012E   70BC               POP      {R4-R6}
   \   00000130   7047               BX       LR               ;; return
   1693          }
   1694          
   1695          
   1696          /**
   1697          * @brief  USB_OTG_EP0StartXfer : Handle the setup for a data xfer for EP0 and 
   1698          *         starts the xfer
   1699          * @param  pdev : Selected device
   1700          * @retval USB_OTG_STS : status
   1701          */

   \                                 In section .text, align 2, keep-with-next
   1702          USB_OTG_STS USB_OTG_EP0StartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
   1703          {
   \                     USB_OTG_EP0StartXfer:
   \   00000000   FCB4               PUSH     {R2-R7}
   1704            USB_OTG_STS                 status = USB_OTG_OK;
   \   00000002   0022               MOVS     R2,#+0
   1705            USB_OTG_DEPCTL_TypeDef      depctl;
   1706            USB_OTG_DEP0XFRSIZ_TypeDef  deptsiz;
   1707            USB_OTG_INEPREGS          *in_regs;
   1708            uint32_t fifoemptymsk = 0;
   \   00000004   0024               MOVS     R4,#+0
   1709            
   1710            depctl.d32   = 0;
   \   00000006   0023               MOVS     R3,#+0
   1711            deptsiz.d32  = 0;
   \   00000008   0025               MOVS     R5,#+0
   \   0000000A   0095               STR      R5,[SP, #+0]
   1712            /* IN endpoint */
   1713            if (ep->is_in == 1)
   \   0000000C   4D78               LDRB     R5,[R1, #+1]
   \   0000000E   012D               CMP      R5,#+1
   \   00000010   48D1               BNE.N    ??USB_OTG_EP0StartXfer_0
   1714            {
   1715              in_regs = pdev->regs.INEP_REGS[0];
   \   00000012   8569               LDR      R5,[R0, #+24]
   1716              depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
   \   00000014   2B68               LDR      R3,[R5, #+0]
   1717              deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
   \   00000016   2E69               LDR      R6,[R5, #+16]
   \   00000018   0096               STR      R6,[SP, #+0]
   1718              /* Zero Length Packet? */
   1719              if (ep->xfer_len == 0)
   \   0000001A   4E69               LDR      R6,[R1, #+20]
   \   0000001C   002E               CMP      R6,#+0
   \   0000001E   09D1               BNE.N    ??USB_OTG_EP0StartXfer_1
   1720              {
   1721                deptsiz.b.xfersize = 0;
   \   00000020   009E               LDR      R6,[SP, #+0]
   \   00000022   F609               LSRS     R6,R6,#+7
   \   00000024   F601               LSLS     R6,R6,#+7
   \   00000026   0096               STR      R6,[SP, #+0]
   1722                deptsiz.b.pktcnt = 1;
   \   00000028   0126               MOVS     R6,#+1
   \   0000002A   009F               LDR      R7,[SP, #+0]
   \   0000002C   66F3D447           BFI      R7,R6,#+19,#+2
   \   00000030   0097               STR      R7,[SP, #+0]
   \   00000032   15E0               B.N      ??USB_OTG_EP0StartXfer_2
   1723                
   1724              }
   1725              else
   1726              {
   1727                if (ep->xfer_len > ep->maxpacket)
   \                     ??USB_OTG_EP0StartXfer_1:
   \   00000034   8E68               LDR      R6,[R1, #+8]
   \   00000036   4F69               LDR      R7,[R1, #+20]
   \   00000038   BE42               CMP      R6,R7
   \   0000003A   07D2               BCS.N    ??USB_OTG_EP0StartXfer_3
   1728                {
   1729                  ep->xfer_len = ep->maxpacket;
   \   0000003C   8E68               LDR      R6,[R1, #+8]
   \   0000003E   4E61               STR      R6,[R1, #+20]
   1730                  deptsiz.b.xfersize = ep->maxpacket;
   \   00000040   8E68               LDR      R6,[R1, #+8]
   \   00000042   009F               LDR      R7,[SP, #+0]
   \   00000044   66F30607           BFI      R7,R6,#+0,#+7
   \   00000048   0097               STR      R7,[SP, #+0]
   \   0000004A   04E0               B.N      ??USB_OTG_EP0StartXfer_4
   1731                }
   1732                else
   1733                {
   1734                  deptsiz.b.xfersize = ep->xfer_len;
   \                     ??USB_OTG_EP0StartXfer_3:
   \   0000004C   4E69               LDR      R6,[R1, #+20]
   \   0000004E   009F               LDR      R7,[SP, #+0]
   \   00000050   66F30607           BFI      R7,R6,#+0,#+7
   \   00000054   0097               STR      R7,[SP, #+0]
   1735                }
   1736                deptsiz.b.pktcnt = 1;
   \                     ??USB_OTG_EP0StartXfer_4:
   \   00000056   0126               MOVS     R6,#+1
   \   00000058   009F               LDR      R7,[SP, #+0]
   \   0000005A   66F3D447           BFI      R7,R6,#+19,#+2
   \   0000005E   0097               STR      R7,[SP, #+0]
   1737              }
   1738              USB_OTG_WRITE_REG32(&in_regs->DIEPTSIZ, deptsiz.d32);
   \                     ??USB_OTG_EP0StartXfer_2:
   \   00000060   009E               LDR      R6,[SP, #+0]
   \   00000062   2E61               STR      R6,[R5, #+16]
   1739              
   1740              if (pdev->cfg.dma_enable == 1)
   \   00000064   C678               LDRB     R6,[R0, #+3]
   \   00000066   012E               CMP      R6,#+1
   \   00000068   05D1               BNE.N    ??USB_OTG_EP0StartXfer_5
   1741              {
   1742                USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);  
   \   0000006A   0E78               LDRB     R6,[R1, #+0]
   \   0000006C   10EB8606           ADDS     R6,R0,R6, LSL #+2
   \   00000070   B669               LDR      R6,[R6, #+24]
   \   00000072   0F69               LDR      R7,[R1, #+16]
   \   00000074   7761               STR      R7,[R6, #+20]
   1743              }
   1744              
   1745              /* EP enable, IN data in FIFO */
   1746              depctl.b.cnak = 1;
   \                     ??USB_OTG_EP0StartXfer_5:
   \   00000076   53F08063           ORRS     R3,R3,#0x4000000
   1747              depctl.b.epena = 1;
   \   0000007A   53F00043           ORRS     R3,R3,#0x80000000
   1748              USB_OTG_WRITE_REG32(&in_regs->DIEPCTL, depctl.d32);
   \   0000007E   2B60               STR      R3,[R5, #+0]
   1749              
   1750              
   1751              
   1752              if (pdev->cfg.dma_enable == 0)
   \   00000080   C378               LDRB     R3,[R0, #+3]
   \   00000082   002B               CMP      R3,#+0
   \   00000084   4BD1               BNE.N    ??USB_OTG_EP0StartXfer_6
   1753              {
   1754                /* Enable the Tx FIFO Empty Interrupt for this EP */
   1755                if (ep->xfer_len > 0)
   \   00000086   4B69               LDR      R3,[R1, #+20]
   \   00000088   002B               CMP      R3,#+0
   \   0000008A   48D0               BEQ.N    ??USB_OTG_EP0StartXfer_6
   1756                {
   1757                  {
   1758                    fifoemptymsk |= 1 << ep->num;
   \   0000008C   0123               MOVS     R3,#+1
   \   0000008E   91F90010           LDRSB    R1,[R1, #+0]
   \   00000092   13FA01F1           LSLS     R1,R3,R1
   \   00000096   0C43               ORRS     R4,R1,R4
   1759                    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
   \   00000098   0169               LDR      R1,[R0, #+16]
   \   0000009A   496B               LDR      R1,[R1, #+52]
   \   0000009C   2143               ORRS     R1,R4,R1
   \   0000009E   0069               LDR      R0,[R0, #+16]
   \   000000A0   4163               STR      R1,[R0, #+52]
   \   000000A2   3CE0               B.N      ??USB_OTG_EP0StartXfer_6
   1760                  }
   1761                }
   1762              }
   1763            }
   1764            else
   1765            {
   1766              /* OUT endpoint */
   1767              depctl.d32  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
   \                     ??USB_OTG_EP0StartXfer_0:
   \   000000A4   0B78               LDRB     R3,[R1, #+0]
   \   000000A6   10EB8303           ADDS     R3,R0,R3, LSL #+2
   \   000000AA   5B6D               LDR      R3,[R3, #+84]
   \   000000AC   1B68               LDR      R3,[R3, #+0]
   1768              deptsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ);
   \   000000AE   0C78               LDRB     R4,[R1, #+0]
   \   000000B0   10EB8404           ADDS     R4,R0,R4, LSL #+2
   \   000000B4   646D               LDR      R4,[R4, #+84]
   \   000000B6   2469               LDR      R4,[R4, #+16]
   \   000000B8   0094               STR      R4,[SP, #+0]
   1769              /* Program the transfer size and packet count as follows:
   1770              * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
   1771              * pktcnt = N           */
   1772              if (ep->xfer_len == 0)
   \   000000BA   4C69               LDR      R4,[R1, #+20]
   \   000000BC   002C               CMP      R4,#+0
   \   000000BE   0AD1               BNE.N    ??USB_OTG_EP0StartXfer_7
   1773              {
   1774                deptsiz.b.xfersize = ep->maxpacket;
   \   000000C0   8C68               LDR      R4,[R1, #+8]
   \   000000C2   009D               LDR      R5,[SP, #+0]
   \   000000C4   64F30605           BFI      R5,R4,#+0,#+7
   \   000000C8   0095               STR      R5,[SP, #+0]
   1775                deptsiz.b.pktcnt = 1;
   \   000000CA   0124               MOVS     R4,#+1
   \   000000CC   009D               LDR      R5,[SP, #+0]
   \   000000CE   64F3D445           BFI      R5,R4,#+19,#+2
   \   000000D2   0095               STR      R5,[SP, #+0]
   \   000000D4   0BE0               B.N      ??USB_OTG_EP0StartXfer_8
   1776              }
   1777              else
   1778              {
   1779                ep->xfer_len = ep->maxpacket;
   \                     ??USB_OTG_EP0StartXfer_7:
   \   000000D6   8C68               LDR      R4,[R1, #+8]
   \   000000D8   4C61               STR      R4,[R1, #+20]
   1780                deptsiz.b.xfersize = ep->maxpacket;
   \   000000DA   8C68               LDR      R4,[R1, #+8]
   \   000000DC   009D               LDR      R5,[SP, #+0]
   \   000000DE   64F30605           BFI      R5,R4,#+0,#+7
   \   000000E2   0095               STR      R5,[SP, #+0]
   1781                deptsiz.b.pktcnt = 1;
   \   000000E4   0124               MOVS     R4,#+1
   \   000000E6   009D               LDR      R5,[SP, #+0]
   \   000000E8   64F3D445           BFI      R5,R4,#+19,#+2
   \   000000EC   0095               STR      R5,[SP, #+0]
   1782              }
   1783              USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
   \                     ??USB_OTG_EP0StartXfer_8:
   \   000000EE   0C78               LDRB     R4,[R1, #+0]
   \   000000F0   10EB8404           ADDS     R4,R0,R4, LSL #+2
   \   000000F4   646D               LDR      R4,[R4, #+84]
   \   000000F6   009D               LDR      R5,[SP, #+0]
   \   000000F8   2561               STR      R5,[R4, #+16]
   1784              if (pdev->cfg.dma_enable == 1)
   \   000000FA   C478               LDRB     R4,[R0, #+3]
   \   000000FC   012C               CMP      R4,#+1
   \   000000FE   05D1               BNE.N    ??USB_OTG_EP0StartXfer_9
   1785              {
   1786                USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
   \   00000100   0C78               LDRB     R4,[R1, #+0]
   \   00000102   10EB8404           ADDS     R4,R0,R4, LSL #+2
   \   00000106   646D               LDR      R4,[R4, #+84]
   \   00000108   0D69               LDR      R5,[R1, #+16]
   \   0000010A   6561               STR      R5,[R4, #+20]
   1787              }
   1788              /* EP enable */
   1789              depctl.b.cnak = 1;
   \                     ??USB_OTG_EP0StartXfer_9:
   \   0000010C   53F08063           ORRS     R3,R3,#0x4000000
   1790              depctl.b.epena = 1;
   \   00000110   53F00043           ORRS     R3,R3,#0x80000000
   1791              USB_OTG_WRITE_REG32 (&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL), depctl.d32);
   \   00000114   0978               LDRB     R1,[R1, #+0]
   \   00000116   10EB8100           ADDS     R0,R0,R1, LSL #+2
   \   0000011A   406D               LDR      R0,[R0, #+84]
   \   0000011C   0360               STR      R3,[R0, #+0]
   1792              
   1793            }
   1794            return status;
   \                     ??USB_OTG_EP0StartXfer_6:
   \   0000011E   1000               MOVS     R0,R2
   \   00000120   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000122   F6BC               POP      {R1,R2,R4-R7}
   \   00000124   7047               BX       LR               ;; return
   1795          }
   1796          
   1797          
   1798          /**
   1799          * @brief  USB_OTG_EPSetStall : Set the EP STALL
   1800          * @param  pdev : Selected device
   1801          * @retval USB_OTG_STS : status
   1802          */

   \                                 In section .text, align 2, keep-with-next
   1803          USB_OTG_STS USB_OTG_EPSetStall(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
   1804          {
   \                     USB_OTG_EPSetStall:
   \   00000000   10B4               PUSH     {R4}
   1805            USB_OTG_STS status = USB_OTG_OK;
   \   00000002   0022               MOVS     R2,#+0
   1806            USB_OTG_DEPCTL_TypeDef  depctl;
   1807            __IO uint32_t *depctl_addr;
   1808            
   1809            depctl.d32 = 0;
   \   00000004   0023               MOVS     R3,#+0
   1810            if (ep->is_in == 1)
   \   00000006   4C78               LDRB     R4,[R1, #+1]
   \   00000008   012C               CMP      R4,#+1
   \   0000000A   0CD1               BNE.N    ??USB_OTG_EPSetStall_0
   1811            {
   1812              depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
   \   0000000C   0978               LDRB     R1,[R1, #+0]
   \   0000000E   10EB8100           ADDS     R0,R0,R1, LSL #+2
   \   00000012   8069               LDR      R0,[R0, #+24]
   1813              depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
   \   00000014   0368               LDR      R3,[R0, #+0]
   1814              /* set the disable and stall bits */
   1815              if (depctl.b.epena)
   \   00000016   002B               CMP      R3,#+0
   \   00000018   01D5               BPL.N    ??USB_OTG_EPSetStall_1
   1816              {
   1817                depctl.b.epdis = 1;
   \   0000001A   53F08043           ORRS     R3,R3,#0x40000000
   1818              }
   1819              depctl.b.stall = 1;
   \                     ??USB_OTG_EPSetStall_1:
   \   0000001E   53F40013           ORRS     R3,R3,#0x200000
   1820              USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
   \   00000022   0360               STR      R3,[R0, #+0]
   \   00000024   07E0               B.N      ??USB_OTG_EPSetStall_2
   1821            }
   1822            else
   1823            {
   1824              depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
   \                     ??USB_OTG_EPSetStall_0:
   \   00000026   0978               LDRB     R1,[R1, #+0]
   \   00000028   10EB8100           ADDS     R0,R0,R1, LSL #+2
   \   0000002C   406D               LDR      R0,[R0, #+84]
   1825              depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
   \   0000002E   0368               LDR      R3,[R0, #+0]
   1826              /* set the stall bit */
   1827              depctl.b.stall = 1;
   \   00000030   53F40013           ORRS     R3,R3,#0x200000
   1828              USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
   \   00000034   0360               STR      R3,[R0, #+0]
   1829            }
   1830            return status;
   \                     ??USB_OTG_EPSetStall_2:
   \   00000036   1000               MOVS     R0,R2
   \   00000038   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   10BC               POP      {R4}
   \   0000003C   7047               BX       LR               ;; return
   1831          }
   1832          
   1833          
   1834          /**
   1835          * @brief  Clear the EP STALL
   1836          * @param  pdev : Selected device
   1837          * @retval USB_OTG_STS : status
   1838          */

   \                                 In section .text, align 2, keep-with-next
   1839          USB_OTG_STS USB_OTG_EPClearStall(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
   1840          {
   \                     USB_OTG_EPClearStall:
   \   00000000   10B4               PUSH     {R4}
   1841            USB_OTG_STS status = USB_OTG_OK;
   \   00000002   0022               MOVS     R2,#+0
   1842            USB_OTG_DEPCTL_TypeDef  depctl;
   1843            __IO uint32_t *depctl_addr;
   1844            
   1845            depctl.d32 = 0;
   \   00000004   0023               MOVS     R3,#+0
   1846            
   1847            if (ep->is_in == 1)
   \   00000006   4C78               LDRB     R4,[R1, #+1]
   \   00000008   012C               CMP      R4,#+1
   \   0000000A   04D1               BNE.N    ??USB_OTG_EPClearStall_0
   1848            {
   1849              depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
   \   0000000C   0B78               LDRB     R3,[R1, #+0]
   \   0000000E   10EB8300           ADDS     R0,R0,R3, LSL #+2
   \   00000012   8069               LDR      R0,[R0, #+24]
   \   00000014   03E0               B.N      ??USB_OTG_EPClearStall_1
   1850            }
   1851            else
   1852            {
   1853              depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
   \                     ??USB_OTG_EPClearStall_0:
   \   00000016   0B78               LDRB     R3,[R1, #+0]
   \   00000018   10EB8300           ADDS     R0,R0,R3, LSL #+2
   \   0000001C   406D               LDR      R0,[R0, #+84]
   1854            }
   1855            depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
   \                     ??USB_OTG_EPClearStall_1:
   \   0000001E   0368               LDR      R3,[R0, #+0]
   1856            /* clear the stall bits */
   1857            depctl.b.stall = 0;
   \   00000020   33F40013           BICS     R3,R3,#0x200000
   1858            if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
   \   00000024   CC78               LDRB     R4,[R1, #+3]
   \   00000026   032C               CMP      R4,#+3
   \   00000028   02D0               BEQ.N    ??USB_OTG_EPClearStall_2
   \   0000002A   C978               LDRB     R1,[R1, #+3]
   \   0000002C   0229               CMP      R1,#+2
   \   0000002E   01D1               BNE.N    ??USB_OTG_EPClearStall_3
   1859            {
   1860              depctl.b.setd0pid = 1; /* DATA0 */
   \                     ??USB_OTG_EPClearStall_2:
   \   00000030   53F08053           ORRS     R3,R3,#0x10000000
   1861            }
   1862            USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
   \                     ??USB_OTG_EPClearStall_3:
   \   00000034   0360               STR      R3,[R0, #+0]
   1863            return status;
   \   00000036   1000               MOVS     R0,R2
   \   00000038   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   10BC               POP      {R4}
   \   0000003C   7047               BX       LR               ;; return
   1864          }
   1865          
   1866          
   1867          /**
   1868          * @brief  USB_OTG_ReadDevAllOutEp_itr : returns OUT endpoint interrupt bits
   1869          * @param  pdev : Selected device
   1870          * @retval OUT endpoint interrupt bits
   1871          */

   \                                 In section .text, align 2, keep-with-next
   1872          uint32_t USB_OTG_ReadDevAllOutEp_itr(USB_OTG_CORE_HANDLE *pdev)
   1873          {
   1874            uint32_t v;
   1875            v  = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
   \                     USB_OTG_ReadDevAllOutEp_itr:
   \   00000000   0169               LDR      R1,[R0, #+16]
   \   00000002   8969               LDR      R1,[R1, #+24]
   1876            v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
   \   00000004   0069               LDR      R0,[R0, #+16]
   \   00000006   C069               LDR      R0,[R0, #+28]
   \   00000008   0140               ANDS     R1,R0,R1
   1877            return ((v & 0xffff0000) >> 16);
   \   0000000A   080C               LSRS     R0,R1,#+16
   \   0000000C   7047               BX       LR               ;; return
   1878          }
   1879          
   1880          
   1881          /**
   1882          * @brief  USB_OTG_ReadDevOutEP_itr : returns Device OUT EP Interrupt register
   1883          * @param  pdev : Selected device
   1884          * @param  ep : end point number
   1885          * @retval Device OUT EP Interrupt register
   1886          */

   \                                 In section .text, align 2, keep-with-next
   1887          uint32_t USB_OTG_ReadDevOutEP_itr(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
   1888          {
   1889            uint32_t v;
   1890            v  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[epnum]->DOEPINT);
   \                     USB_OTG_ReadDevOutEP_itr:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   10EB8101           ADDS     R1,R0,R1, LSL #+2
   \   00000006   496D               LDR      R1,[R1, #+84]
   \   00000008   8968               LDR      R1,[R1, #+8]
   1891            v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DOEPMSK);
   \   0000000A   0069               LDR      R0,[R0, #+16]
   \   0000000C   4069               LDR      R0,[R0, #+20]
   \   0000000E   0140               ANDS     R1,R0,R1
   1892            return v;
   \   00000010   0800               MOVS     R0,R1
   \   00000012   7047               BX       LR               ;; return
   1893          }
   1894          
   1895          
   1896          /**
   1897          * @brief  USB_OTG_ReadDevAllInEPItr : Get int status register
   1898          * @param  pdev : Selected device
   1899          * @retval int status register
   1900          */

   \                                 In section .text, align 2, keep-with-next
   1901          uint32_t USB_OTG_ReadDevAllInEPItr(USB_OTG_CORE_HANDLE *pdev)
   1902          {
   1903            uint32_t v;
   1904            v = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
   \                     USB_OTG_ReadDevAllInEPItr:
   \   00000000   0169               LDR      R1,[R0, #+16]
   \   00000002   8969               LDR      R1,[R1, #+24]
   1905            v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
   \   00000004   0069               LDR      R0,[R0, #+16]
   \   00000006   C069               LDR      R0,[R0, #+28]
   \   00000008   0140               ANDS     R1,R0,R1
   1906            return (v & 0xffff);
   \   0000000A   88B2               UXTH     R0,R1            ;; ZeroExt  R0,R1,#+16,#+16
   \   0000000C   7047               BX       LR               ;; return
   1907          }
   1908          
   1909          /**
   1910          * @brief  configures EPO to receive SETUP packets
   1911          * @param  None
   1912          * @retval : None
   1913          */

   \                                 In section .text, align 2, keep-with-next
   1914          void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
   1915          {
   \                     USB_OTG_EP0_OutStart:
   \   00000000   82B0               SUB      SP,SP,#+8
   1916            USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
   1917            doeptsize0.d32 = 0;
   \   00000002   0021               MOVS     R1,#+0
   \   00000004   0091               STR      R1,[SP, #+0]
   1918            doeptsize0.b.supcnt = 3;
   \   00000006   0099               LDR      R1,[SP, #+0]
   \   00000008   51F04041           ORRS     R1,R1,#0xC0000000
   \   0000000C   0091               STR      R1,[SP, #+0]
   1919            doeptsize0.b.pktcnt = 1;
   \   0000000E   0121               MOVS     R1,#+1
   \   00000010   009A               LDR      R2,[SP, #+0]
   \   00000012   61F3D442           BFI      R2,R1,#+19,#+2
   \   00000016   0092               STR      R2,[SP, #+0]
   1920            doeptsize0.b.xfersize = 8 * 3;
   \   00000018   1821               MOVS     R1,#+24
   \   0000001A   009A               LDR      R2,[SP, #+0]
   \   0000001C   61F30602           BFI      R2,R1,#+0,#+7
   \   00000020   0092               STR      R2,[SP, #+0]
   1921            USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPTSIZ, doeptsize0.d32 );
   \   00000022   416D               LDR      R1,[R0, #+84]
   \   00000024   009A               LDR      R2,[SP, #+0]
   \   00000026   0A61               STR      R2,[R1, #+16]
   1922            
   1923            if (pdev->cfg.dma_enable == 1)
   \   00000028   C178               LDRB     R1,[R0, #+3]
   \   0000002A   0129               CMP      R1,#+1
   \   0000002C   0ED1               BNE.N    ??USB_OTG_EP0_OutStart_0
   1924            {
   1925              USB_OTG_DEPCTL_TypeDef  doepctl;
   1926              doepctl.d32 = 0;
   \   0000002E   0021               MOVS     R1,#+0
   1927              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPDMA, 
   1928                                  (uint32_t)&pdev->dev.setup_packet);
   \   00000030   426D               LDR      R2,[R0, #+84]
   \   00000032   00F2C853           ADDW     R3,R0,#+1480
   \   00000036   5361               STR      R3,[R2, #+20]
   1929              
   1930              /* EP enable */
   1931              doepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[0]->DOEPCTL);
   \   00000038   426D               LDR      R2,[R0, #+84]
   \   0000003A   1268               LDR      R2,[R2, #+0]
   \   0000003C   1100               MOVS     R1,R2
   1932              doepctl.b.epena = 1;
   \   0000003E   51F00041           ORRS     R1,R1,#0x80000000
   1933              doepctl.d32 = 0x80008000;
   \   00000042   5FF08022           MOVS     R2,#-2147450880
   \   00000046   1100               MOVS     R1,R2
   1934              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPCTL, doepctl.d32);
   \   00000048   406D               LDR      R0,[R0, #+84]
   \   0000004A   0160               STR      R1,[R0, #+0]
   1935            }
   1936          }
   \                     ??USB_OTG_EP0_OutStart_0:
   \   0000004C   02B0               ADD      SP,SP,#+8
   \   0000004E   7047               BX       LR               ;; return
   1937          
   1938          /**
   1939          * @brief  USB_OTG_RemoteWakeup : active remote wakeup signalling
   1940          * @param  None
   1941          * @retval : None
   1942          */

   \                                 In section .text, align 2, keep-with-next
   1943          void USB_OTG_ActiveRemoteWakeup(USB_OTG_CORE_HANDLE *pdev)
   1944          {
   \                     USB_OTG_ActiveRemoteWakeup:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
   1945            
   1946            USB_OTG_DCTL_TypeDef     dctl;
   1947            USB_OTG_DSTS_TypeDef     dsts;
   1948            USB_OTG_PCGCCTL_TypeDef  power;  
   1949            
   1950            if (pdev->dev.DevRemoteWakeup) 
   \   00000004   D4F81401           LDR      R0,[R4, #+276]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   22D0               BEQ.N    ??USB_OTG_ActiveRemoteWakeup_0
   1951            {
   1952              dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
   \   0000000C   2069               LDR      R0,[R4, #+16]
   \   0000000E   8068               LDR      R0,[R0, #+8]
   1953              if(dsts.b.suspsts == 1)
   \   00000010   10F00100           ANDS     R0,R0,#0x1
   \   00000014   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0028               CMP      R0,#+0
   \   00000018   1BD0               BEQ.N    ??USB_OTG_ActiveRemoteWakeup_0
   1954              {
   1955                if(pdev->cfg.low_power)
   \   0000001A   A07A               LDRB     R0,[R4, #+10]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   08D0               BEQ.N    ??USB_OTG_ActiveRemoteWakeup_1
   1956                {
   1957                  /* un-gate USB Core clock */
   1958                  power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
   \   00000020   D4F80C01           LDR      R0,[R4, #+268]
   1959                  power.b.gatehclk = 0;
   \   00000024   30F00200           BICS     R0,R0,#0x2
   1960                  power.b.stoppclk = 0;
   \   00000028   4008               LSRS     R0,R0,#+1
   \   0000002A   4000               LSLS     R0,R0,#+1
   1961                  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
   \   0000002C   D4F80C11           LDR      R1,[R4, #+268]
   \   00000030   0860               STR      R0,[R1, #+0]
   1962                }   
   1963                /* active Remote wakeup signaling */
   1964                dctl.d32 = 0;
   \                     ??USB_OTG_ActiveRemoteWakeup_1:
   \   00000032   0025               MOVS     R5,#+0
   1965                dctl.b.rmtwkupsig = 1;
   \   00000034   55F00105           ORRS     R5,R5,#0x1
   1966                USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, 0, dctl.d32);
   \   00000038   2069               LDR      R0,[R4, #+16]
   \   0000003A   4068               LDR      R0,[R0, #+4]
   \   0000003C   2843               ORRS     R0,R5,R0
   \   0000003E   2169               LDR      R1,[R4, #+16]
   \   00000040   4860               STR      R0,[R1, #+4]
   1967                USB_OTG_BSP_mDelay(5);
   \   00000042   0520               MOVS     R0,#+5
   \   00000044   ........           BL       USB_OTG_BSP_mDelay
   1968                USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
   \   00000048   2069               LDR      R0,[R4, #+16]
   \   0000004A   4068               LDR      R0,[R0, #+4]
   \   0000004C   A843               BICS     R0,R0,R5
   \   0000004E   2169               LDR      R1,[R4, #+16]
   \   00000050   4860               STR      R0,[R1, #+4]
   1969              }
   1970            }
   1971          }
   \                     ??USB_OTG_ActiveRemoteWakeup_0:
   \   00000052   31BD               POP      {R0,R4,R5,PC}    ;; return
   1972          
   1973          
   1974          /**
   1975          * @brief  USB_OTG_UngateClock : active USB Core clock
   1976          * @param  None
   1977          * @retval : None
   1978          */

   \                                 In section .text, align 2, keep-with-next
   1979          void USB_OTG_UngateClock(USB_OTG_CORE_HANDLE *pdev)
   1980          {
   1981            if(pdev->cfg.low_power)
   \                     USB_OTG_UngateClock:
   \   00000000   817A               LDRB     R1,[R0, #+10]
   \   00000002   0029               CMP      R1,#+0
   \   00000004   0FD0               BEQ.N    ??USB_OTG_UngateClock_0
   1982            {
   1983              
   1984              USB_OTG_DSTS_TypeDef     dsts;
   1985              USB_OTG_PCGCCTL_TypeDef  power; 
   1986              
   1987              dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
   \   00000006   0169               LDR      R1,[R0, #+16]
   \   00000008   8968               LDR      R1,[R1, #+8]
   1988              
   1989              if(dsts.b.suspsts == 1)
   \   0000000A   11F00101           ANDS     R1,R1,#0x1
   \   0000000E   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0029               CMP      R1,#+0
   \   00000012   08D0               BEQ.N    ??USB_OTG_UngateClock_0
   1990              {
   1991                /* un-gate USB Core clock */
   1992                power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
   \   00000014   D0F80C11           LDR      R1,[R0, #+268]
   1993                power.b.gatehclk = 0;
   \   00000018   31F00201           BICS     R1,R1,#0x2
   1994                power.b.stoppclk = 0;
   \   0000001C   4908               LSRS     R1,R1,#+1
   \   0000001E   4900               LSLS     R1,R1,#+1
   1995                USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
   \   00000020   D0F80C01           LDR      R0,[R0, #+268]
   \   00000024   0160               STR      R1,[R0, #+0]
   1996                
   1997              }
   1998            }
   1999          }
   \                     ??USB_OTG_UngateClock_0:
   \   00000026   7047               BX       LR               ;; return
   2000          
   2001          /**
   2002          * @brief  Stop the device and clean up fifo's
   2003          * @param  None
   2004          * @retval : None
   2005          */

   \                                 In section .text, align 2, keep-with-next
   2006          void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
   2007          {
   \                     USB_OTG_StopDevice:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   2008            uint32_t i;
   2009            
   2010            pdev->dev.device_status = 1;
   \   00000004   0120               MOVS     R0,#+1
   \   00000006   84F81201           STRB     R0,[R4, #+274]
   2011              
   2012            for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   0AE0               B.N      ??USB_OTG_StopDevice_0
   2013            {
   2014              USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
   \                     ??USB_OTG_StopDevice_1:
   \   0000000E   14EB8001           ADDS     R1,R4,R0, LSL #+2
   \   00000012   8969               LDR      R1,[R1, #+24]
   \   00000014   FF22               MOVS     R2,#+255
   \   00000016   8A60               STR      R2,[R1, #+8]
   2015              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
   \   00000018   14EB8001           ADDS     R1,R4,R0, LSL #+2
   \   0000001C   496D               LDR      R1,[R1, #+84]
   \   0000001E   FF22               MOVS     R2,#+255
   \   00000020   8A60               STR      R2,[R1, #+8]
   2016            }
   \   00000022   401C               ADDS     R0,R0,#+1
   \                     ??USB_OTG_StopDevice_0:
   \   00000024   6178               LDRB     R1,[R4, #+1]
   \   00000026   8842               CMP      R0,R1
   \   00000028   F1D3               BCC.N    ??USB_OTG_StopDevice_1
   2017          
   2018            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
   \   0000002A   2069               LDR      R0,[R4, #+16]
   \   0000002C   0021               MOVS     R1,#+0
   \   0000002E   0161               STR      R1,[R0, #+16]
   2019            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
   \   00000030   2069               LDR      R0,[R4, #+16]
   \   00000032   0021               MOVS     R1,#+0
   \   00000034   4161               STR      R1,[R0, #+20]
   2020            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
   \   00000036   2069               LDR      R0,[R4, #+16]
   \   00000038   0021               MOVS     R1,#+0
   \   0000003A   C161               STR      R1,[R0, #+28]
   2021            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
   \   0000003C   2069               LDR      R0,[R4, #+16]
   \   0000003E   5FF0FF31           MOVS     R1,#-1
   \   00000042   8161               STR      R1,[R0, #+24]
   2022            
   2023            /* Flush the FIFO */
   2024            USB_OTG_FlushRxFifo(pdev);
   \   00000044   2000               MOVS     R0,R4
   \   00000046   ........           BL       USB_OTG_FlushRxFifo
   2025            USB_OTG_FlushTxFifo(pdev ,  0x10 );  
   \   0000004A   1021               MOVS     R1,#+16
   \   0000004C   2000               MOVS     R0,R4
   \   0000004E   ........           BL       USB_OTG_FlushTxFifo
   2026          }
   \   00000052   10BD               POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   410D0300           DC32     0x30d41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   00000440           DC32     0x40040000
   2027          #endif
   2028          /**
   2029          * @}
   2030          */ 
   2031          
   2032          /**
   2033          * @}
   2034          */ 
   2035          
   2036          /**
   2037          * @}
   2038          */
   2039          
   2040          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     USB_OTG_ActiveRemoteWakeup         16
     USB_OTG_CoreInit                   16
     USB_OTG_CoreInitDev                24
     USB_OTG_CoreInitHost               32
     USB_OTG_CoreReset                  24
     USB_OTG_DisableGlobalInt            0
     USB_OTG_DriveVbus                  16
     USB_OTG_EP0Activate                 4
     USB_OTG_EP0StartXfer               24
     USB_OTG_EP0_OutStart                8
     USB_OTG_EPActivate                 12
     USB_OTG_EPClearStall                4
     USB_OTG_EPDeactivate               12
     USB_OTG_EPSetStall                  4
     USB_OTG_EPStartXfer                12
     USB_OTG_EnableCommonInt             0
     USB_OTG_EnableDevInt               16
     USB_OTG_EnableGlobalInt             0
     USB_OTG_EnableHostInt              16
     USB_OTG_FlushRxFifo                16
     USB_OTG_FlushTxFifo                16
     USB_OTG_GetDeviceSpeed              0
     USB_OTG_GetMode                     0
     USB_OTG_HC_DoPing                   4
     USB_OTG_HC_Halt                    12
     USB_OTG_HC_Init                    16
     USB_OTG_HC_StartXfer               24
     USB_OTG_InitDevSpeed                0
     USB_OTG_InitFSLSPClkSel             0
     USB_OTG_IsDeviceMode                8
     USB_OTG_IsEvenFrame                 0
     USB_OTG_IsHostMode                  8
     USB_OTG_ReadCoreItr                 0
     USB_OTG_ReadDevAllInEPItr           0
     USB_OTG_ReadDevAllOutEp_itr         0
     USB_OTG_ReadDevOutEP_itr            0
     USB_OTG_ReadHPRT0                   0
     USB_OTG_ReadHostAllChannels_intr
                                         0
     USB_OTG_ReadOtgItr                  0
     USB_OTG_ReadPacket                  4
     USB_OTG_ResetPort                  16
     USB_OTG_SelectCore                  8
     USB_OTG_SetCurrentMode              8
     USB_OTG_StopDevice                  8
     USB_OTG_StopHost                    8
     USB_OTG_UngateClock                 0
     USB_OTG_WritePacket                16


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     USB_OTG_EnableCommonInt          32
     USB_OTG_CoreReset                98
     USB_OTG_WritePacket              64
     USB_OTG_ReadPacket               42
     USB_OTG_SelectCore              216
     USB_OTG_CoreInit                276
     USB_OTG_EnableGlobalInt          24
     USB_OTG_DisableGlobalInt         26
     USB_OTG_FlushTxFifo              70
     USB_OTG_FlushRxFifo              62
     USB_OTG_SetCurrentMode           54
     USB_OTG_GetMode                  10
     USB_OTG_IsDeviceMode             20
     USB_OTG_IsHostMode               20
     USB_OTG_ReadCoreItr              18
     USB_OTG_ReadOtgItr                6
     USB_OTG_CoreInitHost            178
     USB_OTG_IsEvenFrame              16
     USB_OTG_DriveVbus                82
     USB_OTG_EnableHostInt            76
     USB_OTG_InitFSLSPClkSel          16
     USB_OTG_ReadHPRT0                24
     USB_OTG_ReadHostAllChannels_intr
                                       6
     USB_OTG_ResetPort                50
     USB_OTG_HC_Init                 400
     USB_OTG_HC_StartXfer            466
     USB_OTG_HC_Halt                 108
     USB_OTG_HC_DoPing                68
     USB_OTG_StopHost                 78
     USB_OTG_InitDevSpeed             16
     USB_OTG_CoreInitDev             374
     USB_OTG_EnableDevInt             80
     USB_OTG_GetDeviceSpeed           44
     USB_OTG_EP0Activate              76
     USB_OTG_EPActivate              112
     USB_OTG_EPDeactivate             86
     USB_OTG_EPStartXfer             306
     USB_OTG_EP0StartXfer            294
     USB_OTG_EPSetStall               62
     USB_OTG_EPClearStall             62
     USB_OTG_ReadDevAllOutEp_itr      14
     USB_OTG_ReadDevOutEP_itr         20
     USB_OTG_ReadDevAllInEPItr        14
     USB_OTG_EP0_OutStart             80
     USB_OTG_ActiveRemoteWakeup       84
     USB_OTG_UngateClock              40
     USB_OTG_StopDevice               84
     ??DataTable3                      4
     ??DataTable3_1                    4

 
 4 462 bytes in section .text
 
 4 462 bytes of CODE memory

Errors: none
Warnings: none
