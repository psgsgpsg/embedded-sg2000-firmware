###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     27/May/2011  17:13:48 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\묵작업\[ NewDTG ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4 #
#                    \STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPer #
#                    iph_Template\stm3210e_eval_fsmc_nand.c                   #
#    Command line =  "D:\묵작업\[ NewDTG ]\자료\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\stm3210e_eval_fsmc_nand.c" -D              #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D USE_ULPI_PHY -D                     #
#                    RTC_CLOCK_SOURCE_LSE -lC "D:\묵작업\[ NewDTG             #
#                    ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    STM3220F_EVAL\List\" -lA "D:\묵작업\[ NewDTG             #
#                    ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    STM3220F_EVAL\List\" -o "D:\묵작업\[ NewDTG              #
#                    ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    STM3220F_EVAL\Obj\" --no_cse --no_unroll --no_inline     #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "D:\묵작업\[ NewDTG                              #
#                    ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\" -I "D:\묵작업\[ NewDTG                              #
#                    ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\..\..\Libraries\CMSIS\CM3\CoreSupport\" -I            #
#                    "D:\묵작업\[ NewDTG ]\자료\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Libraries\CMSIS\CM3\DeviceS #
#                    upport\ST\STM32F2xx\" -I "D:\묵작업\[ NewDTG             #
#                    ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I   #
#                    "D:\묵작업\[ NewDTG ]\자료\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Utilities\STM32_EVAL\" -I   #
#                    "D:\묵작업\[ NewDTG ]\자료\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Utilities\STM32_EVAL\Common #
#                    \" -I "D:\묵작업\[ NewDTG ]\자료\STM32F2xx_StdPeriph_Lib #
#                    _V0.0.4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx #
#                    _StdPeriph_Template\EWARM\..\..\..\Utilities\STM32_EVAL\ #
#                    STM3220F_EVAL\" -I "D:\묵작업\[ NewDTG                   #
#                    ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I         #
#                    "D:\묵작업\[ NewDTG ]\자료\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Libraries\STM32_USB_Device_ #
#                    Library\Core\inc\" -I "D:\묵작업\[ NewDTG                #
#                    ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\..\..\Libraries\STM32_USB_Device_Library\Class\msc\in #
#                    c\" -Ol --use_c++_inline                                 #
#    List file    =  D:\묵작업\[ NewDTG ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4 #
#                    \STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPer #
#                    iph_Template\EWARM\STM3220F_EVAL\List\stm3210e_eval_fsmc #
#                    _nand.lst                                                #
#    Object file  =  D:\묵작업\[ NewDTG ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4 #
#                    \STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPer #
#                    iph_Template\EWARM\STM3220F_EVAL\Obj\stm3210e_eval_fsmc_ #
#                    nand.o                                                   #
#                                                                             #
#                                                                             #
###############################################################################

D:\묵작업\[ NewDTG ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\stm3210e_eval_fsmc_nand.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm3210e_eval_fsmc_nand.c
      4            * @author  MCD Application Team
      5            * @version V4.6.1
      6            * @date    18-April-2011
      7            * @brief   This file provides a set of functions needed to drive the
      8            *          NAND512W3A2 memory mounted on STM3210E-EVAL board.
      9            ******************************************************************************
     10            * @attention
     11            *
     12            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     13            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     14            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     15            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     16            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     17            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     18            *
     19            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     20            ******************************************************************************  
     21            */ 
     22          
     23          /* Includes ------------------------------------------------------------------*/
     24          #include "stm3210e_eval_fsmc_nand.h"
     25          
     26          /** @addtogroup Utilities
     27            * @{
     28            */
     29            
     30          /** @addtogroup STM32_EVAL
     31            * @{
     32            */ 
     33          
     34          /** @addtogroup STM3210E_EVAL
     35            * @{
     36            */
     37            
     38          /** @addtogroup STM3210E_EVAL_FSMC_NAND
     39            * @brief      This file provides a set of functions needed to drive the
     40            *             NAND512W3A2 memory mounted on STM3210E-EVAL board.
     41            * @{
     42            */ 
     43          
     44          /** @defgroup STM3210E_EVAL_FSMC_NAND_Private_Types
     45            * @{
     46            */ 
     47          /**
     48            * @}
     49            */ 
     50          
     51          
     52          /** @defgroup STM3210E_EVAL_FSMC_NAND_Private_Defines
     53            * @{
     54            */ 
     55          /** 
     56            * @brief  FSMC Bank 2 
     57            */
     58          #define FSMC_Bank_NAND     FSMC_Bank2_NAND
     59          #define Bank_NAND_ADDR     Bank2_NAND_ADDR 
     60          #define Bank2_NAND_ADDR    ((uint32_t)0x70000000)     
     61          /**
     62            * @}
     63            */ 
     64          
     65          /** @defgroup STM3210E_EVAL_FSMC_NAND_Private_Macros
     66            * @{
     67            */
     68          #define ROW_ADDRESS (Address.Page + (Address.Block + (Address.Zone * NAND_ZONE_SIZE)) * NAND_BLOCK_SIZE)  
     69          /**
     70            * @}
     71            */ 
     72            
     73          
     74          /** @defgroup STM3210E_EVAL_FSMC_NAND_Private_Variables
     75            * @{
     76            */ 
     77          /**
     78            * @}
     79            */ 
     80          
     81          
     82          /** @defgroup STM3210E_EVAL_FSMC_NAND_Private_Function_Prototypes
     83            * @{
     84            */ 
     85          /**
     86            * @}
     87            */ 
     88          
     89          
     90          /** @defgroup STM3210E_EVAL_FSMC_NAND_Private_Functions
     91            * @{
     92            */ 
     93          
     94          /**
     95            * @brief  Configures the FSMC and GPIOs to interface with the NAND memory.
     96            *         This function must be called before any write/read operation on the 
     97            *         NAND.
     98            * @param  None
     99            * @retval None
    100            */

   \                                 In section .text, align 2, keep-with-next
    101          void NAND_Init(void)
    102          {
   \                     NAND_Init:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   8FB0               SUB      SP,SP,#+60
    103            FSMC_NANDInitTypeDef FSMC_NANDInitStructure;
    104            FSMC_NAND_PCCARDTimingInitTypeDef  p;
    105            GPIO_InitTypeDef GPIO_InitStructure;
    106          
    107            RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD | RCC_AHB1Periph_GPIOG | RCC_AHB1Periph_GPIOE |
    108                                   RCC_AHB1Periph_GPIOF | RCC_AHB1Periph_GPIOB, ENABLE);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   7A20               MOVS     R0,#+122
   \   00000008   ........           BL       RCC_AHB1PeriphClockCmd
    109          
    110            RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   4FF48040           MOV      R0,#+16384
   \   00000012   ........           BL       RCC_APB2PeriphClockCmd
    111          
    112            RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE); 
   \   00000016   0121               MOVS     R1,#+1
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   ........           BL       RCC_AHB3PeriphClockCmd
    113            
    114          /*-- GPIO Configuration ------------------------------------------------------*/
    115            /* OneNAND Data lines configuration */
    116            GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FSMC);         //D0
   \   0000001E   0C22               MOVS     R2,#+12
   \   00000020   0E21               MOVS     R1,#+14
   \   00000022   ........           LDR.W    R0,??DataTable8  ;; 0x40020c00
   \   00000026   ........           BL       GPIO_PinAFConfig
    117            GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FSMC);         //D1
   \   0000002A   0C22               MOVS     R2,#+12
   \   0000002C   0F21               MOVS     R1,#+15
   \   0000002E   ........           LDR.W    R0,??DataTable8  ;; 0x40020c00
   \   00000032   ........           BL       GPIO_PinAFConfig
    118            GPIO_PinAFConfig(GPIOD, GPIO_PinSource0, GPIO_AF_FSMC);        //D2
   \   00000036   0C22               MOVS     R2,#+12
   \   00000038   0021               MOVS     R1,#+0
   \   0000003A   ........           LDR.W    R0,??DataTable8  ;; 0x40020c00
   \   0000003E   ........           BL       GPIO_PinAFConfig
    119            GPIO_PinAFConfig(GPIOD, GPIO_PinSource1, GPIO_AF_FSMC);      //D3
   \   00000042   0C22               MOVS     R2,#+12
   \   00000044   0121               MOVS     R1,#+1
   \   00000046   ........           LDR.W    R0,??DataTable8  ;; 0x40020c00
   \   0000004A   ........           BL       GPIO_PinAFConfig
    120          //  GPIO_PinAFConfig(GPIOD, GPIO_PinSource8, GPIO_AF_FSMC);       //D13
    121          //  GPIO_PinAFConfig(GPIOD, GPIO_PinSource9, GPIO_AF_FSMC);      //14
    122          //  GPIO_PinAFConfig(GPIOD, GPIO_PinSource10, GPIO_AF_FSMC);     //D15
    123          
    124            GPIO_PinAFConfig(GPIOE, GPIO_PinSource7, GPIO_AF_FSMC);        //D4
   \   0000004E   0C22               MOVS     R2,#+12
   \   00000050   0721               MOVS     R1,#+7
   \   00000052   ........           LDR.W    R0,??DataTable8_1  ;; 0x40021000
   \   00000056   ........           BL       GPIO_PinAFConfig
    125            GPIO_PinAFConfig(GPIOE, GPIO_PinSource8, GPIO_AF_FSMC);        //D5
   \   0000005A   0C22               MOVS     R2,#+12
   \   0000005C   0821               MOVS     R1,#+8
   \   0000005E   ........           LDR.W    R0,??DataTable8_1  ;; 0x40021000
   \   00000062   ........           BL       GPIO_PinAFConfig
    126            GPIO_PinAFConfig(GPIOE, GPIO_PinSource9, GPIO_AF_FSMC);          //D6
   \   00000066   0C22               MOVS     R2,#+12
   \   00000068   0921               MOVS     R1,#+9
   \   0000006A   ........           LDR.W    R0,??DataTable8_1  ;; 0x40021000
   \   0000006E   ........           BL       GPIO_PinAFConfig
    127            GPIO_PinAFConfig(GPIOE, GPIO_PinSource10, GPIO_AF_FSMC);         //D7
   \   00000072   0C22               MOVS     R2,#+12
   \   00000074   0A21               MOVS     R1,#+10
   \   00000076   ........           LDR.W    R0,??DataTable8_1  ;; 0x40021000
   \   0000007A   ........           BL       GPIO_PinAFConfig
    128          //  GPIO_PinAFConfig(GPIOE, GPIO_PinSource11, GPIO_AF_FSMC);           //D8
    129          //  GPIO_PinAFConfig(GPIOE, GPIO_PinSource12, GPIO_AF_FSMC);         //D9
    130          //  GPIO_PinAFConfig(GPIOE, GPIO_PinSource13, GPIO_AF_FSMC);       //D10
    131          //  GPIO_PinAFConfig(GPIOE, GPIO_PinSource14, GPIO_AF_FSMC);     //D11
    132          //  GPIO_PinAFConfig(GPIOE, GPIO_PinSource15, GPIO_AF_FSMC);    //D12
    133          
    134            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_14 | GPIO_Pin_15 ;
   \   0000007E   4CF20300           MOVW     R0,#+49155
   \   00000082   0090               STR      R0,[SP, #+0]
    135            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   00000084   0220               MOVS     R0,#+2
   \   00000086   8DF80400           STRB     R0,[SP, #+4]
    136            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   \   0000008A   0320               MOVS     R0,#+3
   \   0000008C   8DF80500           STRB     R0,[SP, #+5]
    137            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000090   0020               MOVS     R0,#+0
   \   00000092   8DF80600           STRB     R0,[SP, #+6]
    138            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
   \   00000096   0120               MOVS     R0,#+1
   \   00000098   8DF80700           STRB     R0,[SP, #+7]
    139          
    140            GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   0000009C   00A9               ADD      R1,SP,#+0
   \   0000009E   ........           LDR.W    R0,??DataTable8  ;; 0x40020c00
   \   000000A2   ........           BL       GPIO_Init
    141           
    142            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 ;
   \   000000A6   4FF4F060           MOV      R0,#+1920
   \   000000AA   0090               STR      R0,[SP, #+0]
    143          
    144            GPIO_Init(GPIOE, &GPIO_InitStructure);
   \   000000AC   00A9               ADD      R1,SP,#+0
   \   000000AE   ........           LDR.W    R0,??DataTable8_1  ;; 0x40021000
   \   000000B2   ........           BL       GPIO_Init
    145          
    146            /* OneNAND Address lines configuration */
    147          /*  GPIO_PinAFConfig(GPIOF,GPIO_PinSource0, GPIO_AF_FSMC);
    148            GPIO_PinAFConfig(GPIOF,GPIO_PinSource1, GPIO_AF_FSMC);
    149            GPIO_PinAFConfig(GPIOF,GPIO_PinSource2, GPIO_AF_FSMC);
    150            GPIO_PinAFConfig(GPIOF,GPIO_PinSource3, GPIO_AF_FSMC);
    151            GPIO_PinAFConfig(GPIOF,GPIO_PinSource4, GPIO_AF_FSMC);
    152            GPIO_PinAFConfig(GPIOF,GPIO_PinSource5, GPIO_AF_FSMC);
    153          
    154            GPIO_PinAFConfig(GPIOF,GPIO_PinSource12, GPIO_AF_FSMC);
    155            GPIO_PinAFConfig(GPIOF,GPIO_PinSource13, GPIO_AF_FSMC);
    156            GPIO_PinAFConfig(GPIOF,GPIO_PinSource14, GPIO_AF_FSMC);
    157            GPIO_PinAFConfig(GPIOF,GPIO_PinSource15, GPIO_AF_FSMC);
    158          
    159            GPIO_PinAFConfig(GPIOG,GPIO_PinSource0, GPIO_AF_FSMC);
    160            GPIO_PinAFConfig(GPIOG,GPIO_PinSource1, GPIO_AF_FSMC);
    161            GPIO_PinAFConfig(GPIOG,GPIO_PinSource2, GPIO_AF_FSMC);
    162            GPIO_PinAFConfig(GPIOG,GPIO_PinSource3, GPIO_AF_FSMC);
    163            GPIO_PinAFConfig(GPIOG,GPIO_PinSource4, GPIO_AF_FSMC);
    164            GPIO_PinAFConfig(GPIOG,GPIO_PinSource5, GPIO_AF_FSMC);*/
    165          
    166            GPIO_PinAFConfig(GPIOD,GPIO_PinSource11, GPIO_AF_FSMC);     // A16
   \   000000B6   0C22               MOVS     R2,#+12
   \   000000B8   0B21               MOVS     R1,#+11
   \   000000BA   ........           LDR.W    R0,??DataTable8  ;; 0x40020c00
   \   000000BE   ........           BL       GPIO_PinAFConfig
    167            GPIO_PinAFConfig(GPIOD,GPIO_PinSource12, GPIO_AF_FSMC);     // A17
   \   000000C2   0C22               MOVS     R2,#+12
   \   000000C4   0C21               MOVS     R1,#+12
   \   000000C6   ........           LDR.W    R0,??DataTable8  ;; 0x40020c00
   \   000000CA   ........           BL       GPIO_PinAFConfig
    168            
    169            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12 ;
   \   000000CE   4FF4C050           MOV      R0,#+6144
   \   000000D2   0090               STR      R0,[SP, #+0]
    170          
    171            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 |GPIO_Pin_12;
   \   000000D4   4FF4C050           MOV      R0,#+6144
   \   000000D8   0090               STR      R0,[SP, #+0]
    172          
    173            GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   000000DA   00A9               ADD      R1,SP,#+0
   \   000000DC   ........           LDR.W    R0,??DataTable8  ;; 0x40020c00
   \   000000E0   ........           BL       GPIO_Init
    174            /* NOE, NWE and CLK configuration */  
    175          //  GPIO_PinAFConfig(GPIOD,GPIO_PinSource3, GPIO_AF_FSMC);
    176            GPIO_PinAFConfig(GPIOD,GPIO_PinSource4, GPIO_AF_FSMC);
   \   000000E4   0C22               MOVS     R2,#+12
   \   000000E6   0421               MOVS     R1,#+4
   \   000000E8   ........           LDR.W    R0,??DataTable8  ;; 0x40020c00
   \   000000EC   ........           BL       GPIO_PinAFConfig
    177            GPIO_PinAFConfig(GPIOD,GPIO_PinSource5, GPIO_AF_FSMC);
   \   000000F0   0C22               MOVS     R2,#+12
   \   000000F2   0521               MOVS     R1,#+5
   \   000000F4   ........           LDR.W    R0,??DataTable8  ;; 0x40020c00
   \   000000F8   ........           BL       GPIO_PinAFConfig
    178          
    179            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 |GPIO_Pin_5;// | GPIO_Pin_3;
   \   000000FC   3020               MOVS     R0,#+48
   \   000000FE   0090               STR      R0,[SP, #+0]
    180          
    181            GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   00000100   00A9               ADD      R1,SP,#+0
   \   00000102   ........           LDR.W    R0,??DataTable8  ;; 0x40020c00
   \   00000106   ........           BL       GPIO_Init
    182          
    183          
    184            /* NE1 configuration */
    185            GPIO_PinAFConfig(GPIOD, GPIO_PinSource7, GPIO_AF_FSMC);
   \   0000010A   0C22               MOVS     R2,#+12
   \   0000010C   0721               MOVS     R1,#+7
   \   0000010E   ........           LDR.W    R0,??DataTable8  ;; 0x40020c00
   \   00000112   ........           BL       GPIO_PinAFConfig
    186            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7; 
   \   00000116   8020               MOVS     R0,#+128
   \   00000118   0090               STR      R0,[SP, #+0]
    187          
    188            GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   0000011A   00A9               ADD      R1,SP,#+0
   \   0000011C   ........           LDR.W    R0,??DataTable8  ;; 0x40020c00
   \   00000120   ........           BL       GPIO_Init
    189          
    190            /* NL configuration */
    191           /* GPIO_PinAFConfig(GPIOB,GPIO_PinSource7, GPIO_AF_FSMC);
    192          
    193            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7; 
    194            GPIO_Init(GPIOB, &GPIO_InitStructure);
    195          
    196            /* NWAIT Configuration */
                   ^
Warning[Pe009]: nested comment is not allowed
    197            
    198            // NWATI 핀을 쓰지 않고 그냥  INT2로 설정하려면 인터럽트 백터를 설정해줘야한다.
    199            
    200            GPIO_PinAFConfig(GPIOD,GPIO_PinSource6, GPIO_AF_FSMC);
   \   00000124   0C22               MOVS     R2,#+12
   \   00000126   0621               MOVS     R1,#+6
   \   00000128   ........           LDR.W    R0,??DataTable8  ;; 0x40020c00
   \   0000012C   ........           BL       GPIO_PinAFConfig
    201              
    202            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; 
   \   00000130   4020               MOVS     R0,#+64
   \   00000132   0090               STR      R0,[SP, #+0]
    203            GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   00000134   00A9               ADD      R1,SP,#+0
   \   00000136   ........           LDR.W    R0,??DataTable8  ;; 0x40020c00
   \   0000013A   ........           BL       GPIO_Init
    204          
    205          
    206            
    207            /*-- FSMC Configuration ------------------------------------------------------*/
    208            p.FSMC_SetupTime = 0x1;
   \   0000013E   0120               MOVS     R0,#+1
   \   00000140   0290               STR      R0,[SP, #+8]
    209            p.FSMC_WaitSetupTime = 0x30;
   \   00000142   3020               MOVS     R0,#+48
   \   00000144   0390               STR      R0,[SP, #+12]
    210            p.FSMC_HoldSetupTime = 0x2;
   \   00000146   0220               MOVS     R0,#+2
   \   00000148   0490               STR      R0,[SP, #+16]
    211          //  p.FSMC_HiZSetupTime = 0x1;  // 원래 시간
    212            p.FSMC_HiZSetupTime = 0x1;
   \   0000014A   0120               MOVS     R0,#+1
   \   0000014C   0590               STR      R0,[SP, #+20]
    213          
    214            FSMC_NANDInitStructure.FSMC_Bank = FSMC_Bank2_NAND;
   \   0000014E   1020               MOVS     R0,#+16
   \   00000150   0690               STR      R0,[SP, #+24]
    215            FSMC_NANDInitStructure.FSMC_Waitfeature = FSMC_Waitfeature_Enable;
   \   00000152   0220               MOVS     R0,#+2
   \   00000154   0790               STR      R0,[SP, #+28]
    216            FSMC_NANDInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
   \   00000156   0020               MOVS     R0,#+0
   \   00000158   0890               STR      R0,[SP, #+32]
    217            FSMC_NANDInitStructure.FSMC_ECC = FSMC_ECC_Enable;
   \   0000015A   4020               MOVS     R0,#+64
   \   0000015C   0990               STR      R0,[SP, #+36]
    218          #if 1
    219            FSMC_NANDInitStructure.FSMC_ECCPageSize = FSMC_ECCPageSize_512Bytes;
   \   0000015E   5FF40030           MOVS     R0,#+131072
   \   00000162   0A90               STR      R0,[SP, #+40]
    220          #else
    221            FSMC_NANDInitStructure.FSMC_ECCPageSize = FSMC_ECCPageSize_2048Bytes;
    222          #endif
    223          
    224            FSMC_NANDInitStructure.FSMC_TCLRSetupTime = 0x00;
   \   00000164   0020               MOVS     R0,#+0
   \   00000166   0B90               STR      R0,[SP, #+44]
    225            FSMC_NANDInitStructure.FSMC_TARSetupTime = 0x00;
   \   00000168   0020               MOVS     R0,#+0
   \   0000016A   0C90               STR      R0,[SP, #+48]
    226            FSMC_NANDInitStructure.FSMC_CommonSpaceTimingStruct = &p;
   \   0000016C   02A8               ADD      R0,SP,#+8
   \   0000016E   0D90               STR      R0,[SP, #+52]
    227            FSMC_NANDInitStructure.FSMC_AttributeSpaceTimingStruct = &p;
   \   00000170   02A8               ADD      R0,SP,#+8
   \   00000172   0E90               STR      R0,[SP, #+56]
    228          
    229            FSMC_NANDInit(&FSMC_NANDInitStructure);
   \   00000174   06A8               ADD      R0,SP,#+24
   \   00000176   ........           BL       FSMC_NANDInit
    230          //  FSMC_ITConfig(FSMC_Bank2_NAND,FSMC_IT_RisingEdge,ENABLE);
    231            /* FSMC NAND Bank Cmd Test */
    232            FSMC_NANDCmd(FSMC_Bank2_NAND, ENABLE);
   \   0000017A   0121               MOVS     R1,#+1
   \   0000017C   1020               MOVS     R0,#+16
   \   0000017E   ........           BL       FSMC_NANDCmd
    233          }
   \   00000182   0FB0               ADD      SP,SP,#+60
   \   00000184   00BD               POP      {PC}             ;; return
    234          
    235          /**
    236            * @brief  Reads NAND memory's ID.
    237            * @param  NAND_ID: pointer to a NAND_IDTypeDef structure which will hold
    238            *         the Manufacturer and Device ID.  
    239            * @retval None
    240            */

   \                                 In section .text, align 2, keep-with-next
    241          void NAND_ReadID(NAND_IDTypeDef* NAND_ID)
    242          {
    243            uint32_t data = 0;
   \                     NAND_ReadID:
   \   00000000   0021               MOVS     R1,#+0
    244          
    245            /*!< Send Command to the command area */
    246            *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = 0x90;
   \   00000002   ........           LDR.W    R2,??DataTable8_2  ;; 0x70010000
   \   00000006   9023               MOVS     R3,#+144
   \   00000008   1370               STRB     R3,[R2, #+0]
    247            *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00;
   \   0000000A   ........           LDR.W    R2,??DataTable8_3  ;; 0x70020000
   \   0000000E   0023               MOVS     R3,#+0
   \   00000010   1370               STRB     R3,[R2, #+0]
    248          
    249             /*!< Sequence to read ID from NAND flash */
    250             data = *(__IO uint32_t *)(Bank_NAND_ADDR | DATA_AREA);
   \   00000012   5FF0E042           MOVS     R2,#+1879048192
   \   00000016   1268               LDR      R2,[R2, #+0]
   \   00000018   1100               MOVS     R1,R2
    251          
    252             NAND_ID->Maker_ID   = ADDR_1st_CYCLE (data);
   \   0000001A   0170               STRB     R1,[R0, #+0]
    253             NAND_ID->Device_ID  = ADDR_2nd_CYCLE (data);
   \   0000001C   0A0A               LSRS     R2,R1,#+8
   \   0000001E   4270               STRB     R2,[R0, #+1]
    254             NAND_ID->Third_ID   = ADDR_3rd_CYCLE (data);
   \   00000020   0A0C               LSRS     R2,R1,#+16
   \   00000022   8270               STRB     R2,[R0, #+2]
    255             NAND_ID->Fourth_ID  = ADDR_4th_CYCLE (data);
   \   00000024   090E               LSRS     R1,R1,#+24
   \   00000026   C170               STRB     R1,[R0, #+3]
    256          }
   \   00000028   7047               BX       LR               ;; return
    257          
    258          /**
    259            * @brief  This routine is for writing one or several 512 Bytes Page size.
    260            * @param  pBuffer: pointer on the Buffer containing data to be written 
    261            * @param  Address: First page address
    262            * @param  NumPageToWrite: Number of page to write  
    263            * @retval New status of the NAND operation. This parameter can be:
    264            *              - NAND_TIMEOUT_ERROR: when the previous operation generate 
    265            *                a Timeout error
    266            *              - NAND_READY: when memory is ready for the next operation 
    267            *                And the new status of the increment address operation. It can be:
    268            *              - NAND_VALID_ADDRESS: When the new address is valid address
    269            *              - NAND_INVALID_ADDRESS: When the new address is invalid address  
    270            */

   \                                 In section .text, align 2, keep-with-next
    271          uint32_t NAND_WriteSmallPage(uint8_t *pBuffer, NAND_ADDRESS Address, uint32_t NumPageToWrite)
    272          {
   \                     NAND_WriteSmallPage:
   \   00000000   2DE9F743           PUSH     {R0-R2,R4-R9,LR}
   \   00000004   0400               MOVS     R4,R0
   \   00000006   1D00               MOVS     R5,R3
    273            uint32_t index = 0x00, numpagewritten = 0x00, addressstatus = NAND_VALID_ADDRESS;
   \   00000008   0026               MOVS     R6,#+0
   \   0000000A   0027               MOVS     R7,#+0
   \   0000000C   4FF48078           MOV      R8,#+256
    274            uint32_t status = NAND_READY, size = 0x00;
   \   00000010   5FF04009           MOVS     R9,#+64
   \   00000014   0020               MOVS     R0,#+0
   \   00000016   16E0               B.N      ??NAND_WriteSmallPage_0
    275          
    276            while((NumPageToWrite != 0x00) && (addressstatus == NAND_VALID_ADDRESS) && (status == NAND_READY))
    277            {
    278              /*!< Page write command and address */
    279              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_AREA_A;
    280              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_WRITE0;
    281          
    282              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00;
    283              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_1st_CYCLE(ROW_ADDRESS);
    284              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_2nd_CYCLE(ROW_ADDRESS);
    285              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_3rd_CYCLE(ROW_ADDRESS);
    286          
    287              /*!< Calculate the size */
    288              size = NAND_PAGE_SIZE + (NAND_PAGE_SIZE * numpagewritten);
    289          
    290              /*!< Write data */
    291              for(; index < size; index++)
    292              {
    293                *(__IO uint8_t *)(Bank_NAND_ADDR | DATA_AREA) = pBuffer[index];
   \                     ??NAND_WriteSmallPage_1:
   \   00000018   315D               LDRB     R1,[R6, R4]
   \   0000001A   5FF0E042           MOVS     R2,#+1879048192
   \   0000001E   1170               STRB     R1,[R2, #+0]
    294              }
   \   00000020   761C               ADDS     R6,R6,#+1
   \                     ??NAND_WriteSmallPage_2:
   \   00000022   8642               CMP      R6,R0
   \   00000024   F8D3               BCC.N    ??NAND_WriteSmallPage_1
    295              
    296              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_WRITE_TRUE1;
   \   00000026   ........           LDR.W    R0,??DataTable8_2  ;; 0x70010000
   \   0000002A   1021               MOVS     R1,#+16
   \   0000002C   0170               STRB     R1,[R0, #+0]
    297          
    298              /*!< Check status for successful operation */
    299              status = NAND_GetStatus();
   \   0000002E   ........           BL       NAND_GetStatus
   \   00000032   8146               MOV      R9,R0
    300              
    301              if(status == NAND_READY)
   \   00000034   B9F1400F           CMP      R9,#+64
   \   00000038   05D1               BNE.N    ??NAND_WriteSmallPage_0
    302              {
    303                numpagewritten++;
   \   0000003A   7F1C               ADDS     R7,R7,#+1
    304          
    305                NumPageToWrite--;
   \   0000003C   6D1E               SUBS     R5,R5,#+1
    306          
    307                /*!< Calculate Next small page Address */
    308                addressstatus = NAND_AddressIncrement(&Address);
   \   0000003E   01A8               ADD      R0,SP,#+4
   \   00000040   ........           BL       NAND_AddressIncrement
   \   00000044   8046               MOV      R8,R0
    309              }
   \                     ??NAND_WriteSmallPage_0:
   \   00000046   002D               CMP      R5,#+0
   \   00000048   45D0               BEQ.N    ??NAND_WriteSmallPage_3
   \   0000004A   4FF48070           MOV      R0,#+256
   \   0000004E   8045               CMP      R8,R0
   \   00000050   41D1               BNE.N    ??NAND_WriteSmallPage_3
   \   00000052   B9F1400F           CMP      R9,#+64
   \   00000056   3ED1               BNE.N    ??NAND_WriteSmallPage_3
   \   00000058   ........           LDR.W    R0,??DataTable8_2  ;; 0x70010000
   \   0000005C   0021               MOVS     R1,#+0
   \   0000005E   0170               STRB     R1,[R0, #+0]
   \   00000060   ........           LDR.W    R0,??DataTable8_2  ;; 0x70010000
   \   00000064   8021               MOVS     R1,#+128
   \   00000066   0170               STRB     R1,[R0, #+0]
   \   00000068   ........           LDR.W    R0,??DataTable8_3  ;; 0x70020000
   \   0000006C   0021               MOVS     R1,#+0
   \   0000006E   0170               STRB     R1,[R0, #+0]
   \   00000070   BDF80800           LDRH     R0,[SP, #+8]
   \   00000074   BDF80610           LDRH     R1,[SP, #+6]
   \   00000078   BDF80420           LDRH     R2,[SP, #+4]
   \   0000007C   4FF48063           MOV      R3,#+1024
   \   00000080   03FB0211           MLA      R1,R3,R2,R1
   \   00000084   10EB4110           ADDS     R0,R0,R1, LSL #+5
   \   00000088   ....               LDR.N    R1,??DataTable8_3  ;; 0x70020000
   \   0000008A   0870               STRB     R0,[R1, #+0]
   \   0000008C   BDF80800           LDRH     R0,[SP, #+8]
   \   00000090   BDF80610           LDRH     R1,[SP, #+6]
   \   00000094   BDF80420           LDRH     R2,[SP, #+4]
   \   00000098   4FF48063           MOV      R3,#+1024
   \   0000009C   03FB0211           MLA      R1,R3,R2,R1
   \   000000A0   10EB4110           ADDS     R0,R0,R1, LSL #+5
   \   000000A4   0012               ASRS     R0,R0,#+8
   \   000000A6   ....               LDR.N    R1,??DataTable8_3  ;; 0x70020000
   \   000000A8   0870               STRB     R0,[R1, #+0]
   \   000000AA   BDF80800           LDRH     R0,[SP, #+8]
   \   000000AE   BDF80610           LDRH     R1,[SP, #+6]
   \   000000B2   BDF80420           LDRH     R2,[SP, #+4]
   \   000000B6   4FF48063           MOV      R3,#+1024
   \   000000BA   03FB0211           MLA      R1,R3,R2,R1
   \   000000BE   10EB4110           ADDS     R0,R0,R1, LSL #+5
   \   000000C2   0014               ASRS     R0,R0,#+16
   \   000000C4   ....               LDR.N    R1,??DataTable8_3  ;; 0x70020000
   \   000000C6   0870               STRB     R0,[R1, #+0]
   \   000000C8   4FF40070           MOV      R0,#+512
   \   000000CC   00FB07F0           MUL      R0,R0,R7
   \   000000D0   00F20020           ADDW     R0,R0,#+512
   \   000000D4   A5E7               B.N      ??NAND_WriteSmallPage_2
    310            }
    311            
    312            return (status | addressstatus);
   \                     ??NAND_WriteSmallPage_3:
   \   000000D6   58EA0900           ORRS     R0,R8,R9
   \   000000DA   BDE8FE83           POP      {R1-R9,PC}       ;; return
    313          }
    314          
    315          /**
    316            * @brief  This routine is for sequential read from one or several 512 Bytes Page size.
    317            * @param  pBuffer: pointer on the Buffer to fill
    318            * @param  Address: First page address
    319            * @param  NumPageToRead: Number of page to read  
    320            * @retval New status of the NAND operation. This parameter can be:
    321            *              - NAND_TIMEOUT_ERROR: when the previous operation generate 
    322            *                a Timeout error
    323            *              - NAND_READY: when memory is ready for the next operation 
    324            *                And the new status of the increment address operation. It can be:
    325            *              - NAND_VALID_ADDRESS: When the new address is valid address
    326            *              - NAND_INVALID_ADDRESS: When the new address is invalid address
    327            */

   \                                 In section .text, align 2, keep-with-next
    328          uint32_t NAND_ReadSmallPage(uint8_t *pBuffer, NAND_ADDRESS Address, uint32_t NumPageToRead)
    329          {
   \                     NAND_ReadSmallPage:
   \   00000000   2DE9F641           PUSH     {R1,R2,R4-R8,LR}
   \   00000004   0400               MOVS     R4,R0
   \   00000006   1F00               MOVS     R7,R3
    330            uint32_t index = 0x00, numpageread = 0x00, addressstatus = NAND_VALID_ADDRESS;
   \   00000008   0025               MOVS     R5,#+0
   \   0000000A   0026               MOVS     R6,#+0
   \   0000000C   4FF48078           MOV      R8,#+256
    331            uint32_t status = NAND_READY, size = 0x00;
   \   00000010   4020               MOVS     R0,#+64
   \   00000012   0021               MOVS     R1,#+0
   \   00000014   0CE0               B.N      ??NAND_ReadSmallPage_0
    332          
    333            while((NumPageToRead != 0x0) && (addressstatus == NAND_VALID_ADDRESS))
    334            {
    335              /*!< Page Read command and page address */
    336              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_AREA_A;
    337             
    338              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00; 
    339              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_1st_CYCLE(ROW_ADDRESS);
    340              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_2nd_CYCLE(ROW_ADDRESS);
    341              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_3rd_CYCLE(ROW_ADDRESS);
    342              
    343              /*!< Calculate the size */
    344              size = NAND_PAGE_SIZE + (NAND_PAGE_SIZE * numpageread);
    345              
    346              /*!< Get Data into Buffer */    
    347              for(; index < size; index++)
    348              {
    349                pBuffer[index]= *(__IO uint8_t *)(Bank_NAND_ADDR | DATA_AREA);
   \                     ??NAND_ReadSmallPage_1:
   \   00000016   5FF0E040           MOVS     R0,#+1879048192
   \   0000001A   0078               LDRB     R0,[R0, #+0]
   \   0000001C   2855               STRB     R0,[R5, R4]
    350              }
   \   0000001E   6D1C               ADDS     R5,R5,#+1
   \                     ??NAND_ReadSmallPage_2:
   \   00000020   8D42               CMP      R5,R1
   \   00000022   F8D3               BCC.N    ??NAND_ReadSmallPage_1
    351          
    352              numpageread++;
   \   00000024   761C               ADDS     R6,R6,#+1
    353              
    354              NumPageToRead--;
   \   00000026   7F1E               SUBS     R7,R7,#+1
    355          
    356              /*!< Calculate page address */
    357              addressstatus = NAND_AddressIncrement(&Address);
   \   00000028   00A8               ADD      R0,SP,#+0
   \   0000002A   ........           BL       NAND_AddressIncrement
   \   0000002E   8046               MOV      R8,R0
   \                     ??NAND_ReadSmallPage_0:
   \   00000030   002F               CMP      R7,#+0
   \   00000032   3CD0               BEQ.N    ??NAND_ReadSmallPage_3
   \   00000034   4FF48070           MOV      R0,#+256
   \   00000038   8045               CMP      R8,R0
   \   0000003A   38D1               BNE.N    ??NAND_ReadSmallPage_3
   \   0000003C   ....               LDR.N    R0,??DataTable8_2  ;; 0x70010000
   \   0000003E   0021               MOVS     R1,#+0
   \   00000040   0170               STRB     R1,[R0, #+0]
   \   00000042   ....               LDR.N    R0,??DataTable8_3  ;; 0x70020000
   \   00000044   0021               MOVS     R1,#+0
   \   00000046   0170               STRB     R1,[R0, #+0]
   \   00000048   BDF80400           LDRH     R0,[SP, #+4]
   \   0000004C   BDF80210           LDRH     R1,[SP, #+2]
   \   00000050   BDF80020           LDRH     R2,[SP, #+0]
   \   00000054   4FF48063           MOV      R3,#+1024
   \   00000058   03FB0211           MLA      R1,R3,R2,R1
   \   0000005C   10EB4110           ADDS     R0,R0,R1, LSL #+5
   \   00000060   ....               LDR.N    R1,??DataTable8_3  ;; 0x70020000
   \   00000062   0870               STRB     R0,[R1, #+0]
   \   00000064   BDF80400           LDRH     R0,[SP, #+4]
   \   00000068   BDF80210           LDRH     R1,[SP, #+2]
   \   0000006C   BDF80020           LDRH     R2,[SP, #+0]
   \   00000070   4FF48063           MOV      R3,#+1024
   \   00000074   03FB0211           MLA      R1,R3,R2,R1
   \   00000078   10EB4110           ADDS     R0,R0,R1, LSL #+5
   \   0000007C   0012               ASRS     R0,R0,#+8
   \   0000007E   ....               LDR.N    R1,??DataTable8_3  ;; 0x70020000
   \   00000080   0870               STRB     R0,[R1, #+0]
   \   00000082   BDF80400           LDRH     R0,[SP, #+4]
   \   00000086   BDF80210           LDRH     R1,[SP, #+2]
   \   0000008A   BDF80020           LDRH     R2,[SP, #+0]
   \   0000008E   4FF48063           MOV      R3,#+1024
   \   00000092   03FB0211           MLA      R1,R3,R2,R1
   \   00000096   10EB4110           ADDS     R0,R0,R1, LSL #+5
   \   0000009A   0014               ASRS     R0,R0,#+16
   \   0000009C   ....               LDR.N    R1,??DataTable8_3  ;; 0x70020000
   \   0000009E   0870               STRB     R0,[R1, #+0]
   \   000000A0   4FF40070           MOV      R0,#+512
   \   000000A4   00FB06F0           MUL      R0,R0,R6
   \   000000A8   00F20021           ADDW     R1,R0,#+512
   \   000000AC   B8E7               B.N      ??NAND_ReadSmallPage_2
    358            }
    359          
    360            status = NAND_GetStatus();
   \                     ??NAND_ReadSmallPage_3:
   \   000000AE   ........           BL       NAND_GetStatus
    361            
    362            return (status | addressstatus);
   \   000000B2   58EA0000           ORRS     R0,R8,R0
   \   000000B6   BDE8F681           POP      {R1,R2,R4-R8,PC}  ;; return
    363          }
    364          
    365          /**
    366            * @brief  This routine write the spare area information for the specified
    367            *         pages addresses.  
    368            * @param  pBuffer: pointer on the Buffer containing data to be written 
    369            * @param  Address: First page address
    370            * @param  NumSpareAreaTowrite: Number of Spare Area to write
    371            * @retval New status of the NAND operation. This parameter can be:
    372            *              - NAND_TIMEOUT_ERROR: when the previous operation generate 
    373            *                a Timeout error
    374            *              - NAND_READY: when memory is ready for the next operation 
    375            *                And the new status of the increment address operation. It can be:
    376            *              - NAND_VALID_ADDRESS: When the new address is valid address
    377            *              - NAND_INVALID_ADDRESS: When the new address is invalid address
    378            */

   \                                 In section .text, align 2, keep-with-next
    379          uint32_t NAND_WriteSpareArea(uint8_t *pBuffer, NAND_ADDRESS Address, uint32_t NumSpareAreaTowrite)
    380          {
   \                     NAND_WriteSpareArea:
   \   00000000   2DE9F743           PUSH     {R0-R2,R4-R9,LR}
   \   00000004   0400               MOVS     R4,R0
   \   00000006   1D00               MOVS     R5,R3
    381            uint32_t index = 0x00, numsparesreawritten = 0x00, addressstatus = NAND_VALID_ADDRESS;
   \   00000008   0026               MOVS     R6,#+0
   \   0000000A   0027               MOVS     R7,#+0
   \   0000000C   4FF48078           MOV      R8,#+256
    382            uint32_t status = NAND_READY, size = 0x00; 
   \   00000010   5FF04009           MOVS     R9,#+64
   \   00000014   0020               MOVS     R0,#+0
   \   00000016   15E0               B.N      ??NAND_WriteSpareArea_0
    383          
    384            while((NumSpareAreaTowrite != 0x00) && (addressstatus == NAND_VALID_ADDRESS) && (status == NAND_READY))
    385            {
    386              /*!< Page write Spare area command and address */
    387              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_AREA_C;
    388              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_WRITE0;
    389          
    390              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00; 
    391              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_1st_CYCLE(ROW_ADDRESS);
    392              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_2nd_CYCLE(ROW_ADDRESS);
    393              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_3rd_CYCLE(ROW_ADDRESS);
    394          
    395              /*!< Calculate the size */ 
    396              size = NAND_SPARE_AREA_SIZE + (NAND_SPARE_AREA_SIZE * numsparesreawritten);
    397          
    398              /*!< Write the data */ 
    399              for(; index < size; index++)
    400              {
    401                *(__IO uint8_t *)(Bank_NAND_ADDR | DATA_AREA) = pBuffer[index];
   \                     ??NAND_WriteSpareArea_1:
   \   00000018   315D               LDRB     R1,[R6, R4]
   \   0000001A   5FF0E042           MOVS     R2,#+1879048192
   \   0000001E   1170               STRB     R1,[R2, #+0]
    402              }
   \   00000020   761C               ADDS     R6,R6,#+1
   \                     ??NAND_WriteSpareArea_2:
   \   00000022   8642               CMP      R6,R0
   \   00000024   F8D3               BCC.N    ??NAND_WriteSpareArea_1
    403              
    404              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_WRITE_TRUE1;
   \   00000026   ....               LDR.N    R0,??DataTable8_2  ;; 0x70010000
   \   00000028   1021               MOVS     R1,#+16
   \   0000002A   0170               STRB     R1,[R0, #+0]
    405          
    406              /*!< Check status for successful operation */
    407              status = NAND_GetStatus();
   \   0000002C   ........           BL       NAND_GetStatus
   \   00000030   8146               MOV      R9,R0
    408          
    409              if(status == NAND_READY)
   \   00000032   B9F1400F           CMP      R9,#+64
   \   00000036   05D1               BNE.N    ??NAND_WriteSpareArea_0
    410              {
    411                numsparesreawritten++;
   \   00000038   7F1C               ADDS     R7,R7,#+1
    412          
    413                NumSpareAreaTowrite--;
   \   0000003A   6D1E               SUBS     R5,R5,#+1
    414              
    415                /*!< Calculate Next page Address */
    416                addressstatus = NAND_AddressIncrement(&Address);
   \   0000003C   01A8               ADD      R0,SP,#+4
   \   0000003E   ........           BL       NAND_AddressIncrement
   \   00000042   8046               MOV      R8,R0
    417              }
   \                     ??NAND_WriteSpareArea_0:
   \   00000044   002D               CMP      R5,#+0
   \   00000046   3ED0               BEQ.N    ??NAND_WriteSpareArea_3
   \   00000048   4FF48070           MOV      R0,#+256
   \   0000004C   8045               CMP      R8,R0
   \   0000004E   3AD1               BNE.N    ??NAND_WriteSpareArea_3
   \   00000050   B9F1400F           CMP      R9,#+64
   \   00000054   37D1               BNE.N    ??NAND_WriteSpareArea_3
   \   00000056   ....               LDR.N    R0,??DataTable8_2  ;; 0x70010000
   \   00000058   5021               MOVS     R1,#+80
   \   0000005A   0170               STRB     R1,[R0, #+0]
   \   0000005C   ....               LDR.N    R0,??DataTable8_2  ;; 0x70010000
   \   0000005E   8021               MOVS     R1,#+128
   \   00000060   0170               STRB     R1,[R0, #+0]
   \   00000062   ....               LDR.N    R0,??DataTable8_3  ;; 0x70020000
   \   00000064   0021               MOVS     R1,#+0
   \   00000066   0170               STRB     R1,[R0, #+0]
   \   00000068   BDF80800           LDRH     R0,[SP, #+8]
   \   0000006C   BDF80610           LDRH     R1,[SP, #+6]
   \   00000070   BDF80420           LDRH     R2,[SP, #+4]
   \   00000074   4FF48063           MOV      R3,#+1024
   \   00000078   03FB0211           MLA      R1,R3,R2,R1
   \   0000007C   10EB4110           ADDS     R0,R0,R1, LSL #+5
   \   00000080   ....               LDR.N    R1,??DataTable8_3  ;; 0x70020000
   \   00000082   0870               STRB     R0,[R1, #+0]
   \   00000084   BDF80800           LDRH     R0,[SP, #+8]
   \   00000088   BDF80610           LDRH     R1,[SP, #+6]
   \   0000008C   BDF80420           LDRH     R2,[SP, #+4]
   \   00000090   4FF48063           MOV      R3,#+1024
   \   00000094   03FB0211           MLA      R1,R3,R2,R1
   \   00000098   10EB4110           ADDS     R0,R0,R1, LSL #+5
   \   0000009C   0012               ASRS     R0,R0,#+8
   \   0000009E   ....               LDR.N    R1,??DataTable8_3  ;; 0x70020000
   \   000000A0   0870               STRB     R0,[R1, #+0]
   \   000000A2   BDF80800           LDRH     R0,[SP, #+8]
   \   000000A6   BDF80610           LDRH     R1,[SP, #+6]
   \   000000AA   BDF80420           LDRH     R2,[SP, #+4]
   \   000000AE   4FF48063           MOV      R3,#+1024
   \   000000B2   03FB0211           MLA      R1,R3,R2,R1
   \   000000B6   10EB4110           ADDS     R0,R0,R1, LSL #+5
   \   000000BA   0014               ASRS     R0,R0,#+16
   \   000000BC   ....               LDR.N    R1,??DataTable8_3  ;; 0x70020000
   \   000000BE   0870               STRB     R0,[R1, #+0]
   \   000000C0   3801               LSLS     R0,R7,#+4
   \   000000C2   1030               ADDS     R0,R0,#+16
   \   000000C4   ADE7               B.N      ??NAND_WriteSpareArea_2
    418            }
    419            
    420            return (status | addressstatus);
   \                     ??NAND_WriteSpareArea_3:
   \   000000C6   58EA0900           ORRS     R0,R8,R9
   \   000000CA   BDE8FE83           POP      {R1-R9,PC}       ;; return
    421          }
    422          
    423          /**
    424            * @brief  This routine read the spare area information from the specified
    425            *         pages addresses.  
    426            * @param  pBuffer: pointer on the Buffer to fill 
    427            * @param  Address: First page address
    428            * @param  NumSpareAreaToRead: Number of Spare Area to read
    429            * @retval New status of the NAND operation. This parameter can be:
    430            *              - NAND_TIMEOUT_ERROR: when the previous operation generate 
    431            *                a Timeout error
    432            *              - NAND_READY: when memory is ready for the next operation 
    433            *                And the new status of the increment address operation. It can be:
    434            *              - NAND_VALID_ADDRESS: When the new address is valid address
    435            *              - NAND_INVALID_ADDRESS: When the new address is invalid address
    436            */

   \                                 In section .text, align 2, keep-with-next
    437          uint32_t NAND_ReadSpareArea(uint8_t *pBuffer, NAND_ADDRESS Address, uint32_t NumSpareAreaToRead)
    438          {
   \                     NAND_ReadSpareArea:
   \   00000000   2DE9F641           PUSH     {R1,R2,R4-R8,LR}
   \   00000004   0400               MOVS     R4,R0
   \   00000006   1F00               MOVS     R7,R3
    439            uint32_t numsparearearead = 0x00, index = 0x00, addressstatus = NAND_VALID_ADDRESS;
   \   00000008   0026               MOVS     R6,#+0
   \   0000000A   0025               MOVS     R5,#+0
   \   0000000C   4FF48078           MOV      R8,#+256
    440            uint32_t status = NAND_READY, size = 0x00;
   \   00000010   4020               MOVS     R0,#+64
   \   00000012   0021               MOVS     R1,#+0
   \   00000014   0CE0               B.N      ??NAND_ReadSpareArea_0
    441          
    442            while((NumSpareAreaToRead != 0x0) && (addressstatus == NAND_VALID_ADDRESS))
    443            {     
    444              /*!< Page Read command and page address */
    445              *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_AREA_C;
    446          
    447              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00; 
    448              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_1st_CYCLE(ROW_ADDRESS);
    449              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_2nd_CYCLE(ROW_ADDRESS);
    450              *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_3rd_CYCLE(ROW_ADDRESS);
    451          
    452              /*!< Data Read */
    453              size = NAND_SPARE_AREA_SIZE +  (NAND_SPARE_AREA_SIZE * numsparearearead);
    454          
    455              /*!< Get Data into Buffer */
    456              for ( ;index < size; index++)
    457              {
    458                pBuffer[index] = *(__IO uint8_t *)(Bank_NAND_ADDR | DATA_AREA);
   \                     ??NAND_ReadSpareArea_1:
   \   00000016   5FF0E040           MOVS     R0,#+1879048192
   \   0000001A   0078               LDRB     R0,[R0, #+0]
   \   0000001C   2855               STRB     R0,[R5, R4]
    459              }
   \   0000001E   6D1C               ADDS     R5,R5,#+1
   \                     ??NAND_ReadSpareArea_2:
   \   00000020   8D42               CMP      R5,R1
   \   00000022   F8D3               BCC.N    ??NAND_ReadSpareArea_1
    460              
    461              numsparearearead++;
   \   00000024   761C               ADDS     R6,R6,#+1
    462              
    463              NumSpareAreaToRead--;
   \   00000026   7F1E               SUBS     R7,R7,#+1
    464          
    465              /*!< Calculate page address */
    466              addressstatus = NAND_AddressIncrement(&Address);
   \   00000028   00A8               ADD      R0,SP,#+0
   \   0000002A   ........           BL       NAND_AddressIncrement
   \   0000002E   8046               MOV      R8,R0
   \                     ??NAND_ReadSpareArea_0:
   \   00000030   002F               CMP      R7,#+0
   \   00000032   39D0               BEQ.N    ??NAND_ReadSpareArea_3
   \   00000034   4FF48070           MOV      R0,#+256
   \   00000038   8045               CMP      R8,R0
   \   0000003A   35D1               BNE.N    ??NAND_ReadSpareArea_3
   \   0000003C   ....               LDR.N    R0,??DataTable8_2  ;; 0x70010000
   \   0000003E   5021               MOVS     R1,#+80
   \   00000040   0170               STRB     R1,[R0, #+0]
   \   00000042   ....               LDR.N    R0,??DataTable8_3  ;; 0x70020000
   \   00000044   0021               MOVS     R1,#+0
   \   00000046   0170               STRB     R1,[R0, #+0]
   \   00000048   BDF80400           LDRH     R0,[SP, #+4]
   \   0000004C   BDF80210           LDRH     R1,[SP, #+2]
   \   00000050   BDF80020           LDRH     R2,[SP, #+0]
   \   00000054   4FF48063           MOV      R3,#+1024
   \   00000058   03FB0211           MLA      R1,R3,R2,R1
   \   0000005C   10EB4110           ADDS     R0,R0,R1, LSL #+5
   \   00000060   ....               LDR.N    R1,??DataTable8_3  ;; 0x70020000
   \   00000062   0870               STRB     R0,[R1, #+0]
   \   00000064   BDF80400           LDRH     R0,[SP, #+4]
   \   00000068   BDF80210           LDRH     R1,[SP, #+2]
   \   0000006C   BDF80020           LDRH     R2,[SP, #+0]
   \   00000070   4FF48063           MOV      R3,#+1024
   \   00000074   03FB0211           MLA      R1,R3,R2,R1
   \   00000078   10EB4110           ADDS     R0,R0,R1, LSL #+5
   \   0000007C   0012               ASRS     R0,R0,#+8
   \   0000007E   ....               LDR.N    R1,??DataTable8_3  ;; 0x70020000
   \   00000080   0870               STRB     R0,[R1, #+0]
   \   00000082   BDF80400           LDRH     R0,[SP, #+4]
   \   00000086   BDF80210           LDRH     R1,[SP, #+2]
   \   0000008A   BDF80020           LDRH     R2,[SP, #+0]
   \   0000008E   4FF48063           MOV      R3,#+1024
   \   00000092   03FB0211           MLA      R1,R3,R2,R1
   \   00000096   10EB4110           ADDS     R0,R0,R1, LSL #+5
   \   0000009A   0014               ASRS     R0,R0,#+16
   \   0000009C   ....               LDR.N    R1,??DataTable8_3  ;; 0x70020000
   \   0000009E   0870               STRB     R0,[R1, #+0]
   \   000000A0   3001               LSLS     R0,R6,#+4
   \   000000A2   10F11001           ADDS     R1,R0,#+16
   \   000000A6   BBE7               B.N      ??NAND_ReadSpareArea_2
    467            }
    468          
    469            status = NAND_GetStatus();
   \                     ??NAND_ReadSpareArea_3:
   \   000000A8   ........           BL       NAND_GetStatus
    470          
    471            return (status | addressstatus);
   \   000000AC   58EA0000           ORRS     R0,R8,R0
   \   000000B0   BDE8F681           POP      {R1,R2,R4-R8,PC}  ;; return
    472          }
    473          
    474          /**
    475            * @brief  This routine erase complete block from NAND FLASH
    476            * @param  Address: Any address into block to be erased
    477            * @retval New status of the NAND operation. This parameter can be:
    478            *              - NAND_TIMEOUT_ERROR: when the previous operation generate 
    479            *                a Timeout error
    480            *              - NAND_READY: when memory is ready for the next operation 
    481            */

   \                                 In section .text, align 2, keep-with-next
    482          uint32_t NAND_EraseBlock(NAND_ADDRESS Address)
    483          {
   \                     NAND_EraseBlock:
   \   00000000   03B5               PUSH     {R0,R1,LR}
   \   00000002   81B0               SUB      SP,SP,#+4
    484            *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_ERASE0;
   \   00000004   ....               LDR.N    R0,??DataTable8_2  ;; 0x70010000
   \   00000006   6021               MOVS     R1,#+96
   \   00000008   0170               STRB     R1,[R0, #+0]
    485          
    486            *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_1st_CYCLE(ROW_ADDRESS);
   \   0000000A   BDF80800           LDRH     R0,[SP, #+8]
   \   0000000E   BDF80610           LDRH     R1,[SP, #+6]
   \   00000012   BDF80420           LDRH     R2,[SP, #+4]
   \   00000016   4FF48063           MOV      R3,#+1024
   \   0000001A   03FB0211           MLA      R1,R3,R2,R1
   \   0000001E   10EB4110           ADDS     R0,R0,R1, LSL #+5
   \   00000022   ....               LDR.N    R1,??DataTable8_3  ;; 0x70020000
   \   00000024   0870               STRB     R0,[R1, #+0]
    487            *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_2nd_CYCLE(ROW_ADDRESS);
   \   00000026   BDF80800           LDRH     R0,[SP, #+8]
   \   0000002A   BDF80610           LDRH     R1,[SP, #+6]
   \   0000002E   BDF80420           LDRH     R2,[SP, #+4]
   \   00000032   4FF48063           MOV      R3,#+1024
   \   00000036   03FB0211           MLA      R1,R3,R2,R1
   \   0000003A   10EB4110           ADDS     R0,R0,R1, LSL #+5
   \   0000003E   0012               ASRS     R0,R0,#+8
   \   00000040   ....               LDR.N    R1,??DataTable8_3  ;; 0x70020000
   \   00000042   0870               STRB     R0,[R1, #+0]
    488            *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_3rd_CYCLE(ROW_ADDRESS);
   \   00000044   BDF80800           LDRH     R0,[SP, #+8]
   \   00000048   BDF80610           LDRH     R1,[SP, #+6]
   \   0000004C   BDF80420           LDRH     R2,[SP, #+4]
   \   00000050   4FF48063           MOV      R3,#+1024
   \   00000054   03FB0211           MLA      R1,R3,R2,R1
   \   00000058   10EB4110           ADDS     R0,R0,R1, LSL #+5
   \   0000005C   0014               ASRS     R0,R0,#+16
   \   0000005E   ....               LDR.N    R1,??DataTable8_3  ;; 0x70020000
   \   00000060   0870               STRB     R0,[R1, #+0]
    489          
    490            *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_ERASE1; 
   \   00000062   ....               LDR.N    R0,??DataTable8_2  ;; 0x70010000
   \   00000064   D021               MOVS     R1,#+208
   \   00000066   0170               STRB     R1,[R0, #+0]
    491          
    492            return (NAND_GetStatus());
   \   00000068   ........           BL       NAND_GetStatus
   \   0000006C   0EBD               POP      {R1-R3,PC}       ;; return
    493          }
    494          
    495          /**
    496            * @brief  This routine reset the NAND FLASH.
    497            * @param  None
    498            * @retval NAND_READY
    499            */

   \                                 In section .text, align 2, keep-with-next
    500          uint32_t NAND_Reset(void)
    501          {
    502            *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_RESET;
   \                     NAND_Reset:
   \   00000000   ....               LDR.N    R0,??DataTable8_2  ;; 0x70010000
   \   00000002   FF21               MOVS     R1,#+255
   \   00000004   0170               STRB     R1,[R0, #+0]
    503          
    504            return (NAND_READY);
   \   00000006   4020               MOVS     R0,#+64
   \   00000008   7047               BX       LR               ;; return
    505          }
    506          
    507          /**
    508            * @brief  Get the NAND operation status.
    509            * @param  None
    510            * @retval New status of the NAND operation. This parameter can be:
    511            *              - NAND_TIMEOUT_ERROR: when the previous operation generate
    512            *                a Timeout error
    513            *              - NAND_READY: when memory is ready for the next operation
    514            */

   \                                 In section .text, align 2, keep-with-next
    515          uint32_t NAND_GetStatus(void)
    516          {
   \                     NAND_GetStatus:
   \   00000000   38B5               PUSH     {R3-R5,LR}
    517            uint32_t timeout = 0x1000000, status = NAND_READY;
   \   00000002   5FF08074           MOVS     R4,#+16777216
   \   00000006   4025               MOVS     R5,#+64
    518          
    519            status = NAND_ReadStatus();
   \   00000008   ........           BL       NAND_ReadStatus
   \   0000000C   0500               MOVS     R5,R0
   \   0000000E   03E0               B.N      ??NAND_GetStatus_0
    520          
    521            /*!< Wait for a NAND operation to complete or a TIMEOUT to occur */
    522            while ((status != NAND_READY) &&( timeout != 0x00))
    523            {
    524               status = NAND_ReadStatus();
   \                     ??NAND_GetStatus_1:
   \   00000010   ........           BL       NAND_ReadStatus
   \   00000014   0500               MOVS     R5,R0
    525               timeout --;
   \   00000016   641E               SUBS     R4,R4,#+1
    526            }
   \                     ??NAND_GetStatus_0:
   \   00000018   402D               CMP      R5,#+64
   \   0000001A   01D0               BEQ.N    ??NAND_GetStatus_2
   \   0000001C   002C               CMP      R4,#+0
   \   0000001E   F7D1               BNE.N    ??NAND_GetStatus_1
    527          
    528            if(timeout == 0x00)
   \                     ??NAND_GetStatus_2:
   \   00000020   002C               CMP      R4,#+0
   \   00000022   01D1               BNE.N    ??NAND_GetStatus_3
    529            {
    530              status =  NAND_TIMEOUT_ERROR;
   \   00000024   4FF48065           MOV      R5,#+1024
    531            }
    532          
    533            /*!< Return the operation status */
    534            return (status);
   \                     ??NAND_GetStatus_3:
   \   00000028   2800               MOVS     R0,R5
   \   0000002A   32BD               POP      {R1,R4,R5,PC}    ;; return
    535          }
    536            
    537          /**
    538            * @brief  Reads the NAND memory status using the Read status command. 
    539            * @param  None
    540            * @retval The status of the NAND memory. This parameter can be:
    541            *              - NAND_BUSY: when memory is busy
    542            *              - NAND_READY: when memory is ready for the next operation
    543            *              - NAND_ERROR: when the previous operation gererates error
    544            */

   \                                 In section .text, align 2, keep-with-next
    545          uint32_t NAND_ReadStatus(void)
    546          {
    547            uint32_t data = 0x00, status = NAND_BUSY;
   \                     NAND_ReadStatus:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0020               MOVS     R0,#+0
    548          
    549            /*!< Read status operation ------------------------------------ */
    550            *(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_STATUS;
   \   00000004   ....               LDR.N    R2,??DataTable8_2  ;; 0x70010000
   \   00000006   7023               MOVS     R3,#+112
   \   00000008   1370               STRB     R3,[R2, #+0]
    551            data = *(__IO uint8_t *)(Bank_NAND_ADDR);
   \   0000000A   5FF0E042           MOVS     R2,#+1879048192
   \   0000000E   1278               LDRB     R2,[R2, #+0]
   \   00000010   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000012   1100               MOVS     R1,R2
    552          
    553            if((data & NAND_ERROR) == NAND_ERROR)
   \   00000014   CA07               LSLS     R2,R1,#+31
   \   00000016   01D5               BPL.N    ??NAND_ReadStatus_0
    554            {
    555              status = NAND_ERROR;
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   04E0               B.N      ??NAND_ReadStatus_1
    556            } 
    557            else if((data & NAND_READY) == NAND_READY)
   \                     ??NAND_ReadStatus_0:
   \   0000001C   4806               LSLS     R0,R1,#+25
   \   0000001E   01D5               BPL.N    ??NAND_ReadStatus_2
    558            {
    559              status = NAND_READY;
   \   00000020   4020               MOVS     R0,#+64
   \   00000022   00E0               B.N      ??NAND_ReadStatus_1
    560            }
    561            else
    562            {
    563              status = NAND_BUSY; 
   \                     ??NAND_ReadStatus_2:
   \   00000024   0020               MOVS     R0,#+0
    564            }
    565            
    566            return (status);
   \                     ??NAND_ReadStatus_1:
   \   00000026   7047               BX       LR               ;; return
    567          }
    568          
    569          /**
    570            * @brief  Increment the NAND memory address. 
    571            * @param  Address: address to be incremented.
    572            * @retval The new status of the increment address operation. It can be:
    573            *              - NAND_VALID_ADDRESS: When the new address is valid address
    574            *              - NAND_INVALID_ADDRESS: When the new address is invalid address   
    575            */

   \                                 In section .text, align 2, keep-with-next
    576          uint32_t NAND_AddressIncrement(NAND_ADDRESS* Address)
    577          {
    578            uint32_t status = NAND_VALID_ADDRESS;
   \                     NAND_AddressIncrement:
   \   00000000   4FF48071           MOV      R1,#+256
    579           
    580            Address->Page++;
   \   00000004   8288               LDRH     R2,[R0, #+4]
   \   00000006   521C               ADDS     R2,R2,#+1
   \   00000008   8280               STRH     R2,[R0, #+4]
    581          
    582            if(Address->Page == NAND_BLOCK_SIZE)
   \   0000000A   8288               LDRH     R2,[R0, #+4]
   \   0000000C   202A               CMP      R2,#+32
   \   0000000E   12D1               BNE.N    ??NAND_AddressIncrement_0
    583            {
    584              Address->Page = 0;
   \   00000010   0022               MOVS     R2,#+0
   \   00000012   8280               STRH     R2,[R0, #+4]
    585              Address->Block++;
   \   00000014   4288               LDRH     R2,[R0, #+2]
   \   00000016   521C               ADDS     R2,R2,#+1
   \   00000018   4280               STRH     R2,[R0, #+2]
    586              
    587              if(Address->Block == NAND_ZONE_SIZE)
   \   0000001A   4288               LDRH     R2,[R0, #+2]
   \   0000001C   B2F5806F           CMP      R2,#+1024
   \   00000020   09D1               BNE.N    ??NAND_AddressIncrement_0
    588              {
    589                Address->Block = 0;
   \   00000022   0022               MOVS     R2,#+0
   \   00000024   4280               STRH     R2,[R0, #+2]
    590                Address->Zone++;
   \   00000026   0288               LDRH     R2,[R0, #+0]
   \   00000028   521C               ADDS     R2,R2,#+1
   \   0000002A   0280               STRH     R2,[R0, #+0]
    591          
    592                if(Address->Zone == NAND_MAX_ZONE)
   \   0000002C   0088               LDRH     R0,[R0, #+0]
   \   0000002E   0428               CMP      R0,#+4
   \   00000030   01D1               BNE.N    ??NAND_AddressIncrement_0
    593                {
    594                  status = NAND_INVALID_ADDRESS;
   \   00000032   4FF40071           MOV      R1,#+512
    595                }
    596              }
    597            } 
    598            
    599            return (status);
   \                     ??NAND_AddressIncrement_0:
   \   00000036   0800               MOVS     R0,R1
   \   00000038   7047               BX       LR               ;; return
    600          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   000C0240           DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   00100240           DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   00000170           DC32     0x70010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   00000270           DC32     0x70020000
    601          
    602          /**
    603            * @}
    604            */
    605          
    606          /**
    607            * @}
    608            */
    609          
    610          /**
    611            * @}
    612            */
    613          
    614          /**
    615            * @}
    616            */
    617          
    618          /**
    619            * @}
    620            */  
    621          
    622          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function              .cstack
     --------              -------
     NAND_AddressIncrement      0
     NAND_EraseBlock           16
     NAND_GetStatus            16
     NAND_Init                 64
     NAND_ReadID                0
     NAND_ReadSmallPage        32
     NAND_ReadSpareArea        32
     NAND_ReadStatus            0
     NAND_Reset                 0
     NAND_WriteSmallPage       40
     NAND_WriteSpareArea       40


   Section sizes:

     Function/Label        Bytes
     --------------        -----
     NAND_Init              390
     NAND_ReadID             42
     NAND_WriteSmallPage    222
     NAND_ReadSmallPage     186
     NAND_WriteSpareArea    206
     NAND_ReadSpareArea     180
     NAND_EraseBlock        110
     NAND_Reset              10
     NAND_GetStatus          44
     NAND_ReadStatus         40
     NAND_AddressIncrement   58
     ??DataTable8             4
     ??DataTable8_1           4
     ??DataTable8_2           4
     ??DataTable8_3           4

 
 1 504 bytes in section .text
 
 1 504 bytes of CODE memory

Errors: none
Warnings: 1
