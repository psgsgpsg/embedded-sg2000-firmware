###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     05/Jan/2012  11:43:59 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\stm322x #
#                    g_eval_i2c_ee.c                                          #
#    Command line =  "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\stm322 #
#                    xg_eval_i2c_ee.c" -D USE_STDPERIPH_DRIVER -D STM32F2XX   #
#                    -D USE_STM3220F_EVAL -D USE_USB_OTG_FS -D                #
#                    RTC_CLOCK_SOURCE_LSE -lC "F:\¹¬ÀÛ¾÷\[ NewDTG             #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\STM3220F_EVAL\List\" #
#                     -lA "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\E #
#                    WARM\STM3220F_EVAL\List\" -o "F:\¹¬ÀÛ¾÷\[ NewDTG         #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\STM3220F_EVAL\Obj\"  #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0\arm\INC\c\DLib_Config_Full.h" -I           #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                              #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\CMSI #
#                    S\CM3\CoreSupport\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG               #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\CMSI #
#                    S\CM3\DeviceSupport\ST\STM32F2xx\" -I "F:\¹¬ÀÛ¾÷\[       #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Librari #
#                    es\STM32F2xx_StdPeriph_Driver\inc\" -I "F:\¹¬ÀÛ¾÷\[      #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utiliti #
#                    es\STM32_EVAL\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\Common\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\STM3220F_EVAL\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_OTG_Driver\inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Core\inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Class\msc\inc\" -I "F:\¹¬ÀÛ¾÷\[     #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\" -I   #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\Usb\Inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                      #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\src\" -I      #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Core\inc\" -I     #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\"   #
#                    -I "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWA #
#                    RM\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\in #
#                    c\" -Ol --use_c++_inline                                 #
#    List file    =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\List\stm322xg_eval_i2c_ee.lst               #
#    Object file  =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\Obj\stm322xg_eval_i2c_ee.o                  #
#                                                                             #
#                                                                             #
###############################################################################

F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\stm322xg_eval_i2c_ee.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm322xg_eval_i2c_ee.c
      4            * @author  MCD Application Team
      5            * @version V4.6.1
      6            * @date    18-April-2011
      7            * @brief   This file provides a set of functions needed to manage the I2C M24CXX 
      8            *          EEPROM memory mounted on STM322xG-EVAL evaluation board(MB786) RevA
      9            *          and RevB.
     10            *          
     11            *          ===================================================================      
     12            *          Note: This driver is intended for STM32F2xx families devices only.
     13            *          ===================================================================
     14            *              
     15            *          It implements a high level communication layer for read and write 
     16            *          from/to this memory. The needed STM32 hardware resources (I2C and 
     17            *          GPIO) are defined in stm322xg_eval.h file, and the initialization is 
     18            *          performed in sEE_LowLevel_Init() function declared in stm322xg_eval.c 
     19            *          file.
     20            *          You can easily tailor this driver to any other development board, 
     21            *          by just adapting the defines for hardware resources and 
     22            *          sEE_LowLevel_Init() function. 
     23            *        
     24            *          @note In this driver, basic read and write functions (sEE_ReadBuffer() 
     25            *                and sEE_WritePage()) use the DMA to perform the data transfer 
     26            *                to/from EEPROM memory (except when number of requested data is
     27            *                equal to 1). Thus, after calling these two functions, user 
     28            *                application may perform other tasks while DMA is transferring
     29            *                data. The application should then monitor the variable holding 
     30            *                the number of data in order to determine when the transfer is
     31            *                completed (variable decremented to 0). Stopping transfer tasks
     32            *                are performed into DMA interrupt handlers (which are integrated
     33            *                into this driver).
     34            *            
     35            *     +-----------------------------------------------------------------+
     36            *     |                        Pin assignment                           |                 
     37            *     +---------------------------------------+-----------+-------------+
     38            *     |  STM32 I2C Pins                       |   sEE     |   Pin       |
     39            *     +---------------------------------------+-----------+-------------+
     40            *     | .                                     |   E0(GND) |    1  (0V)  |
     41            *     | .                                     |   E1(GND) |    2  (0V)  |
     42            *     | .                                     |   E2(GND) |    3  (0V)  |
     43            *     | .                                     |   E0(VSS) |    4  (0V)  |
     44            *     | sEE_I2C_SDA_PIN/ SDA                  |   SDA     |    5        |
     45            *     | sEE_I2C_SCL_PIN/ SCL                  |   SCL     |    6        |
     46            *     | .                                     |   /WC(VDD)|    7 (3.3V) |
     47            *     | .                                     |   VDD     |    8 (3.3V) |
     48            *     +---------------------------------------+-----------+-------------+  
     49            ******************************************************************************
     50            * @attention
     51            *
     52            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     53            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     54            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     55            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     56            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     57            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     58            *
     59            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     60            ******************************************************************************  
     61            */ 
     62          
     63          /* Includes ------------------------------------------------------------------*/
     64          #include "stm322xg_eval_i2c_ee.h"
     65          #include "i2c_ee.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void EE_ENABLE(void)
   \                     EE_ENABLE:
   \   00000000   80B5               PUSH     {R7,LR}
   \   00000002   4FF48061           MOV      R1,#+1024
   \   00000006   ........           LDR.W    R0,??DataTable10  ;; 0x40021800
   \   0000000A   ........           BL       GPIO_ResetBits
   \   0000000E   01BD               POP      {R0,PC}          ;; return
     66          
     67          /** @addtogroup Utilities
     68            * @{
     69            */
     70            
     71          /** @addtogroup STM32_EVAL
     72            * @{
     73            */ 
     74          
     75          /** @addtogroup STM322xG_EVAL
     76            * @{
     77            */
     78            
     79          /** @addtogroup STM322xG_EVAL_I2C_EE
     80            * @brief      This file includes the I2C EEPROM driver of STM32-EVAL boards.
     81            * @{
     82            */ 
     83          
     84          /** @defgroup STM322xG_EVAL_I2C_EE_Private_Types
     85            * @{
     86            */ 
     87          /**
     88            * @}
     89            */ 
     90          
     91          
     92          /** @defgroup STM322xG_EVAL_I2C_EE_Private_Defines
     93            * @{
     94            */  
     95          /**
     96            * @}
     97            */ 
     98          
     99          
    100          /** @defgroup STM322xG_EVAL_I2C_EE_Private_Macros
    101            * @{
    102            */
    103          /**
    104            * @}
    105            */ 

   \                                 In section .bss, align 4
    106          DMA_InitTypeDef    sEEDMA_InitStructure; 
   \                     sEEDMA_InitStructure:
   \   00000000                      DS8 60

   \                                 In section .bss, align 4
    107          NVIC_InitTypeDef   NVIC_InitStructure;
   \                     NVIC_InitStructure:
   \   00000000                      DS8 4
    108          
    109          /** @defgroup STM322xG_EVAL_I2C_EE_Private_Variables
    110            * @{
    111            */

   \                                 In section .bss, align 2
    112          __IO uint16_t  sEEAddress = 0;   
   \                     sEEAddress:
   \   00000000                      DS8 2

   \                                 In section .data, align 4
    113          __IO uint32_t  sEETimeout = sEE_LONG_TIMEOUT;   
   \                     sEETimeout:
   \   00000000   00A00000           DC32 40960

   \                                 In section .bss, align 4
    114          __IO uint16_t* sEEDataReadPointer;   
   \                     sEEDataReadPointer:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    115          __IO uint8_t*  sEEDataWritePointer;  
   \                     sEEDataWritePointer:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    116          __IO uint8_t   sEEDataNum;
   \                     sEEDataNum:
   \   00000000                      DS8 1
    117          /**
    118            * @}
    119            */ 
    120          
    121          
    122          /** @defgroup STM322xG_EVAL_I2C_EE_Private_Function_Prototypes
    123            * @{
    124            */ 
    125          /**
    126            * @}

   \                                 In section .text, align 2, keep-with-next
    127            */ void sEE_LowLevel_DeInit(void)
    128          {
   \                     sEE_LowLevel_DeInit:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   83B0               SUB      SP,SP,#+12
    129            GPIO_InitTypeDef  GPIO_InitStructure; 
    130             
    131            /* sEE_I2C Peripheral Disable */
    132            I2C_Cmd(sEE_I2C, DISABLE);
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   0000000A   ........           BL       I2C_Cmd
    133           
    134            /* sEE_I2C DeInit */
    135            I2C_DeInit(sEE_I2C);
   \   0000000E   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   00000012   ........           BL       I2C_DeInit
    136          
    137            /*!< sEE_I2C Periph clock disable */
    138            RCC_APB1PeriphClockCmd(sEE_I2C_CLK, DISABLE);
   \   00000016   0021               MOVS     R1,#+0
   \   00000018   5FF48000           MOVS     R0,#+4194304
   \   0000001C   ........           BL       RCC_APB1PeriphClockCmd
    139              
    140            /*!< GPIO configuration */  
    141            /*!< Configure sEE_I2C pins: SCL */
    142            GPIO_InitStructure.GPIO_Pin = sEE_I2C_SCL_PIN;
   \   00000020   4FF48060           MOV      R0,#+1024
   \   00000024   0090               STR      R0,[SP, #+0]
    143            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   00000026   0020               MOVS     R0,#+0
   \   00000028   8DF80400           STRB     R0,[SP, #+4]
    144            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
   \   0000002C   0020               MOVS     R0,#+0
   \   0000002E   8DF80700           STRB     R0,[SP, #+7]
    145            GPIO_Init(sEE_I2C_SCL_GPIO_PORT, &GPIO_InitStructure);
   \   00000032   00A9               ADD      R1,SP,#+0
   \   00000034   ........           LDR.W    R0,??DataTable10_2  ;; 0x40020400
   \   00000038   ........           BL       GPIO_Init
    146          
    147            /*!< Configure sEE_I2C pins: SDA */
    148            GPIO_InitStructure.GPIO_Pin = sEE_I2C_SDA_PIN;
   \   0000003C   4FF40060           MOV      R0,#+2048
   \   00000040   0090               STR      R0,[SP, #+0]
    149            GPIO_Init(sEE_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
   \   00000042   00A9               ADD      R1,SP,#+0
   \   00000044   ........           LDR.W    R0,??DataTable10_2  ;; 0x40020400
   \   00000048   ........           BL       GPIO_Init
    150          
    151            /* Configure and enable I2C DMA TX Stream interrupt */
    152            NVIC_InitStructure.NVIC_IRQChannel = sEE_I2C_DMA_TX_IRQn;
   \   0000004C   ........           LDR.W    R0,??DataTable10_3
   \   00000050   0F21               MOVS     R1,#+15
   \   00000052   0170               STRB     R1,[R0, #+0]
    153            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = sEE_I2C_DMA_PREPRIO;
   \   00000054   ........           LDR.W    R0,??DataTable10_3
   \   00000058   0021               MOVS     R1,#+0
   \   0000005A   4170               STRB     R1,[R0, #+1]
    154            NVIC_InitStructure.NVIC_IRQChannelSubPriority = sEE_I2C_DMA_SUBPRIO;
   \   0000005C   ........           LDR.W    R0,??DataTable10_3
   \   00000060   0021               MOVS     R1,#+0
   \   00000062   8170               STRB     R1,[R0, #+2]
    155            NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
   \   00000064   ........           LDR.W    R0,??DataTable10_3
   \   00000068   0021               MOVS     R1,#+0
   \   0000006A   C170               STRB     R1,[R0, #+3]
    156            NVIC_Init(&NVIC_InitStructure);
   \   0000006C   ........           LDR.W    R0,??DataTable10_3
   \   00000070   ........           BL       NVIC_Init
    157          
    158            /* Configure and enable I2C DMA RX Stream interrupt */
    159            NVIC_InitStructure.NVIC_IRQChannel = sEE_I2C_DMA_RX_IRQn;
   \   00000074   ........           LDR.W    R0,??DataTable10_3
   \   00000078   1021               MOVS     R1,#+16
   \   0000007A   0170               STRB     R1,[R0, #+0]
    160            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = sEE_I2C_DMA_PREPRIO;
   \   0000007C   ........           LDR.W    R0,??DataTable10_3
   \   00000080   0021               MOVS     R1,#+0
   \   00000082   4170               STRB     R1,[R0, #+1]
    161            NVIC_InitStructure.NVIC_IRQChannelSubPriority = sEE_I2C_DMA_SUBPRIO;
   \   00000084   ........           LDR.W    R0,??DataTable10_3
   \   00000088   0021               MOVS     R1,#+0
   \   0000008A   8170               STRB     R1,[R0, #+2]
    162            NVIC_Init(&NVIC_InitStructure);   
   \   0000008C   ........           LDR.W    R0,??DataTable10_3
   \   00000090   ........           BL       NVIC_Init
    163            
    164            /* Disable and Deinitialize the DMA Streams */
    165            DMA_Cmd(sEE_I2C_DMA_STREAM_TX, DISABLE);
   \   00000094   0021               MOVS     R1,#+0
   \   00000096   ........           LDR.W    R0,??DataTable10_4  ;; 0x40026070
   \   0000009A   ........           BL       DMA_Cmd
    166            DMA_Cmd(sEE_I2C_DMA_STREAM_RX, DISABLE);
   \   0000009E   0021               MOVS     R1,#+0
   \   000000A0   ........           LDR.W    R0,??DataTable10_5  ;; 0x40026088
   \   000000A4   ........           BL       DMA_Cmd
    167            DMA_DeInit(sEE_I2C_DMA_STREAM_TX);
   \   000000A8   ........           LDR.W    R0,??DataTable10_4  ;; 0x40026070
   \   000000AC   ........           BL       DMA_DeInit
    168            DMA_DeInit(sEE_I2C_DMA_STREAM_RX);
   \   000000B0   ........           LDR.W    R0,??DataTable10_5  ;; 0x40026088
   \   000000B4   ........           BL       DMA_DeInit
    169          }
   \   000000B8   07BD               POP      {R0-R2,PC}       ;; return
    170          
    171          /**
    172            * @brief  Initializes peripherals used by the I2C EEPROM driver.
    173            * @param  None
    174            * @retval None
    175            */

   \                                 In section .text, align 2, keep-with-next
    176          void sEE_LowLevel_Init(void)
    177          {
   \                     sEE_LowLevel_Init:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   83B0               SUB      SP,SP,#+12
    178            GPIO_InitTypeDef  GPIO_InitStructure; 
    179             
    180            /*!< sEE_I2C Periph clock enable */
    181            RCC_APB1PeriphClockCmd(sEE_I2C_CLK, ENABLE);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   5FF48000           MOVS     R0,#+4194304
   \   0000000A   ........           BL       RCC_APB1PeriphClockCmd
    182            
    183            /*!< sEE_I2C_SCL_GPIO_CLK and sEE_I2C_SDA_GPIO_CLK Periph clock enable */
    184            RCC_AHB1PeriphClockCmd(sEE_I2C_SCL_GPIO_CLK | sEE_I2C_SDA_GPIO_CLK, ENABLE);
   \   0000000E   0121               MOVS     R1,#+1
   \   00000010   0220               MOVS     R0,#+2
   \   00000012   ........           BL       RCC_AHB1PeriphClockCmd
    185          
    186            RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
   \   00000016   0121               MOVS     R1,#+1
   \   00000018   4FF48040           MOV      R0,#+16384
   \   0000001C   ........           BL       RCC_APB2PeriphClockCmd
    187            
    188            /* Reset sEE_I2C IP */
    189            RCC_APB1PeriphResetCmd(sEE_I2C_CLK, ENABLE);
   \   00000020   0121               MOVS     R1,#+1
   \   00000022   5FF48000           MOVS     R0,#+4194304
   \   00000026   ........           BL       RCC_APB1PeriphResetCmd
    190            
    191            /* Release reset signal of sEE_I2C IP */
    192            RCC_APB1PeriphResetCmd(sEE_I2C_CLK, DISABLE);
   \   0000002A   0021               MOVS     R1,#+0
   \   0000002C   5FF48000           MOVS     R0,#+4194304
   \   00000030   ........           BL       RCC_APB1PeriphResetCmd
    193              
    194            /*!< GPIO configuration */  
    195            /*!< Configure sEE_I2C pins: SCL */   
    196            GPIO_InitStructure.GPIO_Pin = sEE_I2C_SCL_PIN;
   \   00000034   4FF48060           MOV      R0,#+1024
   \   00000038   0090               STR      R0,[SP, #+0]
    197            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   0000003A   0220               MOVS     R0,#+2
   \   0000003C   8DF80400           STRB     R0,[SP, #+4]
    198            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000040   0220               MOVS     R0,#+2
   \   00000042   8DF80500           STRB     R0,[SP, #+5]
    199            GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
   \   00000046   0120               MOVS     R0,#+1
   \   00000048   8DF80600           STRB     R0,[SP, #+6]
    200            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
   \   0000004C   0020               MOVS     R0,#+0
   \   0000004E   8DF80700           STRB     R0,[SP, #+7]
    201            GPIO_Init(sEE_I2C_SCL_GPIO_PORT, &GPIO_InitStructure);
   \   00000052   00A9               ADD      R1,SP,#+0
   \   00000054   ........           LDR.W    R0,??DataTable10_2  ;; 0x40020400
   \   00000058   ........           BL       GPIO_Init
    202          
    203            /*!< Configure sEE_I2C pins: SDA */
    204            GPIO_InitStructure.GPIO_Pin = sEE_I2C_SDA_PIN;
   \   0000005C   4FF40060           MOV      R0,#+2048
   \   00000060   0090               STR      R0,[SP, #+0]
    205            GPIO_Init(sEE_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
   \   00000062   00A9               ADD      R1,SP,#+0
   \   00000064   ........           LDR.W    R0,??DataTable10_2  ;; 0x40020400
   \   00000068   ........           BL       GPIO_Init
    206            RCC_AHB1PeriphClockCmd(EE_CHIP_ENABLE_CLK, ENABLE);
   \   0000006C   0121               MOVS     R1,#+1
   \   0000006E   4020               MOVS     R0,#+64
   \   00000070   ........           BL       RCC_AHB1PeriphClockCmd
    207            
    208            GPIO_InitStructure.GPIO_Pin = EE_CHIP_ENABLE_PIN;
   \   00000074   4FF48060           MOV      R0,#+1024
   \   00000078   0090               STR      R0,[SP, #+0]
    209            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   \   0000007A   0120               MOVS     R0,#+1
   \   0000007C   8DF80400           STRB     R0,[SP, #+4]
    210            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
   \   00000080   0120               MOVS     R0,#+1
   \   00000082   8DF80700           STRB     R0,[SP, #+7]
    211            GPIO_Init(EE_CHIP_ENABLE_PORT, &GPIO_InitStructure);
   \   00000086   00A9               ADD      R1,SP,#+0
   \   00000088   ........           LDR.W    R0,??DataTable10  ;; 0x40021800
   \   0000008C   ........           BL       GPIO_Init
    212            /* Connect PXx to I2C_SCL*/
    213            GPIO_PinAFConfig(sEE_I2C_SCL_GPIO_PORT, sEE_I2C_SCL_SOURCE, sEE_I2C_SCL_AF);
   \   00000090   0422               MOVS     R2,#+4
   \   00000092   0A21               MOVS     R1,#+10
   \   00000094   ........           LDR.W    R0,??DataTable10_2  ;; 0x40020400
   \   00000098   ........           BL       GPIO_PinAFConfig
    214          
    215            /* Connect PXx to I2C_SDA*/
    216            GPIO_PinAFConfig(sEE_I2C_SDA_GPIO_PORT, sEE_I2C_SDA_SOURCE, sEE_I2C_SDA_AF);  
   \   0000009C   0422               MOVS     R2,#+4
   \   0000009E   0B21               MOVS     R1,#+11
   \   000000A0   ........           LDR.W    R0,??DataTable10_2  ;; 0x40020400
   \   000000A4   ........           BL       GPIO_PinAFConfig
    217            
    218            /* Configure and enable I2C DMA TX Channel interrupt */
    219            NVIC_InitStructure.NVIC_IRQChannel = sEE_I2C_DMA_TX_IRQn;
   \   000000A8   ........           LDR.W    R0,??DataTable10_3
   \   000000AC   0F21               MOVS     R1,#+15
   \   000000AE   0170               STRB     R1,[R0, #+0]
    220            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = sEE_I2C_DMA_PREPRIO;
   \   000000B0   ........           LDR.W    R0,??DataTable10_3
   \   000000B4   0021               MOVS     R1,#+0
   \   000000B6   4170               STRB     R1,[R0, #+1]
    221            NVIC_InitStructure.NVIC_IRQChannelSubPriority = sEE_I2C_DMA_SUBPRIO;
   \   000000B8   ........           LDR.W    R0,??DataTable10_3
   \   000000BC   0021               MOVS     R1,#+0
   \   000000BE   8170               STRB     R1,[R0, #+2]
    222            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   000000C0   ........           LDR.W    R0,??DataTable10_3
   \   000000C4   0121               MOVS     R1,#+1
   \   000000C6   C170               STRB     R1,[R0, #+3]
    223            NVIC_Init(&NVIC_InitStructure);
   \   000000C8   ........           LDR.W    R0,??DataTable10_3
   \   000000CC   ........           BL       NVIC_Init
    224          
    225            /* Configure and enable I2C DMA RX Channel interrupt */
    226            NVIC_InitStructure.NVIC_IRQChannel = sEE_I2C_DMA_RX_IRQn;
   \   000000D0   ........           LDR.W    R0,??DataTable10_3
   \   000000D4   1021               MOVS     R1,#+16
   \   000000D6   0170               STRB     R1,[R0, #+0]
    227            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = sEE_I2C_DMA_PREPRIO;
   \   000000D8   ........           LDR.W    R0,??DataTable10_3
   \   000000DC   0021               MOVS     R1,#+0
   \   000000DE   4170               STRB     R1,[R0, #+1]
    228            NVIC_InitStructure.NVIC_IRQChannelSubPriority = sEE_I2C_DMA_SUBPRIO;
   \   000000E0   ........           LDR.W    R0,??DataTable10_3
   \   000000E4   0021               MOVS     R1,#+0
   \   000000E6   8170               STRB     R1,[R0, #+2]
    229            NVIC_Init(&NVIC_InitStructure);  
   \   000000E8   ........           LDR.W    R0,??DataTable10_3
   \   000000EC   ........           BL       NVIC_Init
    230            
    231            /*!< I2C DMA TX and RX channels configuration */
    232            /* Enable the DMA clock */
    233            RCC_AHB1PeriphClockCmd(sEE_I2C_DMA_CLK, ENABLE);
   \   000000F0   0121               MOVS     R1,#+1
   \   000000F2   5FF40010           MOVS     R0,#+2097152
   \   000000F6   ........           BL       RCC_AHB1PeriphClockCmd
    234            
    235            /* Clear any pending flag on Rx Stream  */
    236            DMA_ClearFlag(sEE_I2C_DMA_STREAM_TX, sEE_TX_DMA_FLAG_FEIF | sEE_TX_DMA_FLAG_DMEIF | sEE_TX_DMA_FLAG_TEIF | \
    237                                                 sEE_TX_DMA_FLAG_HTIF | sEE_TX_DMA_FLAG_TCIF);
   \   000000FA   ........           LDR.W    R1,??DataTable10_6  ;; 0x2000003d
   \   000000FE   ........           LDR.W    R0,??DataTable10_4  ;; 0x40026070
   \   00000102   ........           BL       DMA_ClearFlag
    238            /* Disable the EE I2C Tx DMA stream */
    239            DMA_Cmd(sEE_I2C_DMA_STREAM_TX, DISABLE);
   \   00000106   0021               MOVS     R1,#+0
   \   00000108   ........           LDR.W    R0,??DataTable10_4  ;; 0x40026070
   \   0000010C   ........           BL       DMA_Cmd
    240            /* Configure the DMA stream for the EE I2C peripheral TX direction */
    241            DMA_DeInit(sEE_I2C_DMA_STREAM_TX);
   \   00000110   ........           LDR.W    R0,??DataTable10_4  ;; 0x40026070
   \   00000114   ........           BL       DMA_DeInit
    242            sEEDMA_InitStructure.DMA_Channel = sEE_I2C_DMA_CHANNEL;
   \   00000118   ........           LDR.W    R0,??DataTable10_7
   \   0000011C   5FF00071           MOVS     R1,#+33554432
   \   00000120   0160               STR      R1,[R0, #+0]
    243            sEEDMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)sEE_I2C_DR_Address;
   \   00000122   ........           LDR.W    R0,??DataTable10_7
   \   00000126   ........           LDR.W    R1,??DataTable10_8  ;; 0x40005810
   \   0000012A   4160               STR      R1,[R0, #+4]
    244            sEEDMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)0;    /* This parameter will be configured durig communication */;
   \   0000012C   ........           LDR.W    R0,??DataTable10_7
   \   00000130   0021               MOVS     R1,#+0
   \   00000132   8160               STR      R1,[R0, #+8]
    245            sEEDMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral; /* This parameter will be configured durig communication */
   \   00000134   ........           LDR.W    R0,??DataTable10_7
   \   00000138   4021               MOVS     R1,#+64
   \   0000013A   C160               STR      R1,[R0, #+12]
    246            sEEDMA_InitStructure.DMA_BufferSize = 0xFFFF;              /* This parameter will be configured durig communication */
   \   0000013C   ........           LDR.W    R0,??DataTable10_7
   \   00000140   4FF6FF71           MOVW     R1,#+65535
   \   00000144   0161               STR      R1,[R0, #+16]
    247            sEEDMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
   \   00000146   ........           LDR.W    R0,??DataTable10_7
   \   0000014A   0021               MOVS     R1,#+0
   \   0000014C   4161               STR      R1,[R0, #+20]
    248            sEEDMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
   \   0000014E   ........           LDR.W    R0,??DataTable10_7
   \   00000152   4FF48061           MOV      R1,#+1024
   \   00000156   8161               STR      R1,[R0, #+24]
    249            sEEDMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
   \   00000158   ........           LDR.W    R0,??DataTable10_7
   \   0000015C   0021               MOVS     R1,#+0
   \   0000015E   C161               STR      R1,[R0, #+28]
    250            sEEDMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
   \   00000160   ........           LDR.W    R0,??DataTable10_7
   \   00000164   0021               MOVS     R1,#+0
   \   00000166   0162               STR      R1,[R0, #+32]
    251            sEEDMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
   \   00000168   ........           LDR.W    R0,??DataTable10_7
   \   0000016C   0021               MOVS     R1,#+0
   \   0000016E   4162               STR      R1,[R0, #+36]
    252            sEEDMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
   \   00000170   ........           LDR.W    R0,??DataTable10_7
   \   00000174   5FF44031           MOVS     R1,#+196608
   \   00000178   8162               STR      R1,[R0, #+40]
    253            sEEDMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Enable;
   \   0000017A   ........           LDR.W    R0,??DataTable10_7
   \   0000017E   0421               MOVS     R1,#+4
   \   00000180   C162               STR      R1,[R0, #+44]
    254            sEEDMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_Full;
   \   00000182   ........           LDR.W    R0,??DataTable10_7
   \   00000186   0321               MOVS     R1,#+3
   \   00000188   0163               STR      R1,[R0, #+48]
    255            sEEDMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
   \   0000018A   ........           LDR.W    R0,??DataTable10_7
   \   0000018E   0021               MOVS     R1,#+0
   \   00000190   4163               STR      R1,[R0, #+52]
    256            sEEDMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
   \   00000192   ........           LDR.W    R0,??DataTable10_7
   \   00000196   0021               MOVS     R1,#+0
   \   00000198   8163               STR      R1,[R0, #+56]
    257            DMA_Init(sEE_I2C_DMA_STREAM_TX, &sEEDMA_InitStructure);
   \   0000019A   ........           LDR.W    R1,??DataTable10_7
   \   0000019E   ........           LDR.W    R0,??DataTable10_4  ;; 0x40026070
   \   000001A2   ........           BL       DMA_Init
    258          
    259            /* Clear any pending flag on Rx Stream */
    260            DMA_ClearFlag(sEE_I2C_DMA_STREAM_RX, sEE_RX_DMA_FLAG_FEIF | sEE_RX_DMA_FLAG_DMEIF | sEE_RX_DMA_FLAG_TEIF | \
    261                                                 sEE_RX_DMA_FLAG_HTIF | sEE_RX_DMA_FLAG_TCIF);
   \   000001A6   ........           LDR.W    R1,??DataTable10_9  ;; 0x20000f40
   \   000001AA   ........           LDR.W    R0,??DataTable10_5  ;; 0x40026088
   \   000001AE   ........           BL       DMA_ClearFlag
    262            /* Disable the EE I2C DMA Rx stream */
    263            DMA_Cmd(sEE_I2C_DMA_STREAM_RX, DISABLE);
   \   000001B2   0021               MOVS     R1,#+0
   \   000001B4   ........           LDR.W    R0,??DataTable10_5  ;; 0x40026088
   \   000001B8   ........           BL       DMA_Cmd
    264            /* Configure the DMA stream for the EE I2C peripheral RX direction */
    265            DMA_DeInit(sEE_I2C_DMA_STREAM_RX);
   \   000001BC   ........           LDR.W    R0,??DataTable10_5  ;; 0x40026088
   \   000001C0   ........           BL       DMA_DeInit
    266            DMA_Init(sEE_I2C_DMA_STREAM_RX, &sEEDMA_InitStructure);
   \   000001C4   ........           LDR.W    R1,??DataTable10_7
   \   000001C8   ........           LDR.W    R0,??DataTable10_5  ;; 0x40026088
   \   000001CC   ........           BL       DMA_Init
    267            
    268            /* Enable the DMA Channels Interrupts */
    269            DMA_ITConfig(sEE_I2C_DMA_STREAM_TX, DMA_IT_TC, ENABLE);
   \   000001D0   0122               MOVS     R2,#+1
   \   000001D2   1021               MOVS     R1,#+16
   \   000001D4   ........           LDR.W    R0,??DataTable10_4  ;; 0x40026070
   \   000001D8   ........           BL       DMA_ITConfig
    270            DMA_ITConfig(sEE_I2C_DMA_STREAM_RX, DMA_IT_TC, ENABLE);      
   \   000001DC   0122               MOVS     R2,#+1
   \   000001DE   1021               MOVS     R1,#+16
   \   000001E0   ........           LDR.W    R0,??DataTable10_5  ;; 0x40026088
   \   000001E4   ........           BL       DMA_ITConfig
    271          }
   \   000001E8   07BD               POP      {R0-R2,PC}       ;; return
    272          
    273          /**
    274            * @brief  Initializes DMA channel used by the I2C EEPROM driver.
    275            * @param  None
    276            * @retval None
    277            */

   \                                 In section .text, align 2, keep-with-next
    278          void sEE_LowLevel_DMAConfig(uint32_t pBuffer, uint32_t BufferSize, uint32_t Direction)
    279          { 
   \                     sEE_LowLevel_DMAConfig:
   \   00000000   80B5               PUSH     {R7,LR}
    280            /* Initialize the DMA with the new parameters */
    281            if (Direction == sEE_DIRECTION_TX)
   \   00000002   002A               CMP      R2,#+0
   \   00000004   10D1               BNE.N    ??sEE_LowLevel_DMAConfig_0
    282            {
    283              /* Configure the DMA Tx Stream with the buffer address and the buffer size */
    284              sEEDMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)pBuffer;
   \   00000006   ........           LDR.W    R2,??DataTable10_7
   \   0000000A   9060               STR      R0,[R2, #+8]
    285              sEEDMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;    
   \   0000000C   ........           LDR.W    R0,??DataTable10_7
   \   00000010   4022               MOVS     R2,#+64
   \   00000012   C260               STR      R2,[R0, #+12]
    286              sEEDMA_InitStructure.DMA_BufferSize = (uint32_t)BufferSize;  
   \   00000014   ........           LDR.W    R0,??DataTable10_7
   \   00000018   0161               STR      R1,[R0, #+16]
    287              DMA_Init(sEE_I2C_DMA_STREAM_TX, &sEEDMA_InitStructure);  
   \   0000001A   ........           LDR.W    R1,??DataTable10_7
   \   0000001E   ........           LDR.W    R0,??DataTable10_4  ;; 0x40026070
   \   00000022   ........           BL       DMA_Init
   \   00000026   0FE0               B.N      ??sEE_LowLevel_DMAConfig_1
    288            }
    289            else
    290            { 
    291              /* Configure the DMA Rx Stream with the buffer address and the buffer size */
    292              sEEDMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)pBuffer;
   \                     ??sEE_LowLevel_DMAConfig_0:
   \   00000028   ........           LDR.W    R2,??DataTable10_7
   \   0000002C   9060               STR      R0,[R2, #+8]
    293              sEEDMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
   \   0000002E   ........           LDR.W    R0,??DataTable10_7
   \   00000032   0022               MOVS     R2,#+0
   \   00000034   C260               STR      R2,[R0, #+12]
    294              sEEDMA_InitStructure.DMA_BufferSize = (uint32_t)BufferSize;      
   \   00000036   ........           LDR.W    R0,??DataTable10_7
   \   0000003A   0161               STR      R1,[R0, #+16]
    295              DMA_Init(sEE_I2C_DMA_STREAM_RX, &sEEDMA_InitStructure);    
   \   0000003C   ........           LDR.W    R1,??DataTable10_7
   \   00000040   ........           LDR.W    R0,??DataTable10_5  ;; 0x40026088
   \   00000044   ........           BL       DMA_Init
    296            }
    297          }
   \                     ??sEE_LowLevel_DMAConfig_1:
   \   00000048   01BD               POP      {R0,PC}          ;; return
    298          
    299          /** @defgroup STM322xG_EVAL_I2C_EE_Private_Functions
    300            * @{
    301            */ 
    302          
    303          /**
    304            * @brief  DeInitializes peripherals used by the I2C EEPROM driver.
    305            * @param  None
    306            * @retval None
    307            */

   \                                 In section .text, align 2, keep-with-next
    308          void sEE_DeInit(void)
    309          {
   \                     sEE_DeInit:
   \   00000000   80B5               PUSH     {R7,LR}
    310            sEE_LowLevel_DeInit(); 
   \   00000002   ........           BL       sEE_LowLevel_DeInit
    311          }
   \   00000006   01BD               POP      {R0,PC}          ;; return
    312          
    313          /**
    314            * @brief  Initializes peripherals used by the I2C EEPROM driver.
    315            * @param  None
    316            * @retval None
    317            */

   \                                 In section .text, align 2, keep-with-next
    318          void sEE_Init(void)
    319          { 
   \                     sEE_Init:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   85B0               SUB      SP,SP,#+20
    320            I2C_InitTypeDef  I2C_InitStructure;
    321            
    322            sEE_LowLevel_Init();
   \   00000004   ........           BL       sEE_LowLevel_Init
    323            
    324            /*!< I2C configuration */
    325            /* sEE_I2C configuration */
    326            I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   ADF80400           STRH     R0,[SP, #+4]
    327            I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
   \   0000000E   4BF6FF70           MOVW     R0,#+49151
   \   00000012   ADF80600           STRH     R0,[SP, #+6]
    328            I2C_InitStructure.I2C_OwnAddress1 = I2C_SLAVE_ADDRESS7;
   \   00000016   A020               MOVS     R0,#+160
   \   00000018   ADF80800           STRH     R0,[SP, #+8]
    329            I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
   \   0000001C   4FF48060           MOV      R0,#+1024
   \   00000020   ADF80A00           STRH     R0,[SP, #+10]
    330            I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
   \   00000024   4FF48040           MOV      R0,#+16384
   \   00000028   ADF80C00           STRH     R0,[SP, #+12]
    331            I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;
   \   0000002C   ........           LDR.W    R0,??DataTable10_10  ;; 0x186a0
   \   00000030   0090               STR      R0,[SP, #+0]
    332            
    333            /* sEE_I2C Peripheral Enable */
    334            I2C_Cmd(sEE_I2C, ENABLE);
   \   00000032   0121               MOVS     R1,#+1
   \   00000034   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   00000038   ........           BL       I2C_Cmd
    335            /* Apply sEE_I2C configuration after enabling it */
    336            I2C_Init(sEE_I2C, &I2C_InitStructure);
   \   0000003C   00A9               ADD      R1,SP,#+0
   \   0000003E   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   00000042   ........           BL       I2C_Init
    337          
    338            /* Enable the sEE_I2C peripheral DMA requests */
    339            I2C_DMACmd(sEE_I2C, ENABLE);
   \   00000046   0121               MOVS     R1,#+1
   \   00000048   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   0000004C   ........           BL       I2C_DMACmd
    340            
    341          #if defined (sEE_M24C64_32)
    342            /*!< Select the EEPROM address according to the state of E0, E1, E2 pins */
    343            sEEAddress = sEE_HW_ADDRESS;  
   \   00000050   ........           LDR.W    R0,??DataTable10_11
   \   00000054   A021               MOVS     R1,#+160
   \   00000056   0180               STRH     R1,[R0, #+0]
    344          #elif defined (sEE_M24C08)
    345            /*!< depending on the sEE Address selected in the stm322xg_eval_i2c_ee.h file */
    346           #ifdef sEE_Block0_ADDRESS
    347            /*!< Select the sEE Block0 to write on */
    348            sEEAddress = sEE_Block0_ADDRESS;
    349           #endif
    350            
    351           #ifdef sEE_Block1_ADDRESS
    352            /*!< Select the sEE Block1 to write on */
    353            sEEAddress = sEE_Block1_ADDRESS;
    354           #endif
    355          
    356           #ifdef sEE_Block2_ADDRESS
    357            /*!< Select the sEE Block2 to write on */
    358            sEEAddress = sEE_Block2_ADDRESS;
    359           #endif
    360            
    361           #ifdef sEE_Block3_ADDRESS
    362            /*!< Select the sEE Block3 to write on */
    363            sEEAddress = sEE_Block3_ADDRESS;
    364           #endif 
    365          #endif /*!< sEE_M24C64_32 */    
    366          }
   \   00000058   05B0               ADD      SP,SP,#+20
   \   0000005A   00BD               POP      {PC}             ;; return
    367          
    368          /**
    369            * @brief  Reads a block of data from the EEPROM.
    370            * @param  pBuffer : pointer to the buffer that receives the data read from 
    371            *         the EEPROM.
    372            * @param  ReadAddr : EEPROM's internal address to start reading from.
    373            * @param  NumByteToRead : pointer to the variable holding number of bytes to 
    374            *         be read from the EEPROM.
    375            * 
    376            *        @note The variable pointed by NumByteToRead is reset to 0 when all the 
    377            *              data are read from the EEPROM. Application should monitor this 
    378            *              variable in order know when the transfer is complete.
    379            * 
    380            * @note When number of data to be read is higher than 1, this function just 
    381            *       configures the communication and enable the DMA channel to transfer data.
    382            *       Meanwhile, the user application may perform other tasks.
    383            *       When number of data to be read is 1, then the DMA is not used. The byte
    384            *       is read in polling mode.
    385            * 
    386            * @retval sEE_OK (0) if operation is correctly performed, else return value 
    387            *         different from sEE_OK (0) or the timeout user callback.
    388            */

   \                                 In section .text, align 2, keep-with-next
    389          uint32_t sEE_ReadBuffer(uint8_t* pBuffer, uint16_t ReadAddr, uint16_t* NumByteToRead)
    390          {  
   \                     sEE_ReadBuffer:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0E00               MOVS     R6,R1
   \   00000006   1500               MOVS     R5,R2
    391            /* Set the pointer to the Number of data to be read. This pointer will be used 
    392                by the DMA Transfer Completer interrupt Handler in order to reset the 
    393                variable to 0. User should check on this variable in order to know if the 
    394                DMA transfer has been complete or not. */
    395            sEEDataReadPointer = NumByteToRead;
   \   00000008   ........           LDR.W    R0,??DataTable10_12
   \   0000000C   0560               STR      R5,[R0, #+0]
    396            
    397            /*!< While the bus is busy */
    398            sEETimeout = sEE_LONG_TIMEOUT;
   \   0000000E   ........           LDR.W    R0,??DataTable10_13
   \   00000012   4FF42041           MOV      R1,#+40960
   \   00000016   0160               STR      R1,[R0, #+0]
    399            while(I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_BUSY))
   \                     ??sEE_ReadBuffer_0:
   \   00000018   5FF40031           MOVS     R1,#+131072
   \   0000001C   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   00000020   ........           BL       I2C_GetFlagStatus
   \   00000024   0028               CMP      R0,#+0
   \   00000026   0BD0               BEQ.N    ??sEE_ReadBuffer_1
    400            {
    401              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000028   ........           LDR.W    R0,??DataTable10_13
   \   0000002C   0068               LDR      R0,[R0, #+0]
   \   0000002E   411E               SUBS     R1,R0,#+1
   \   00000030   ........           LDR.W    R2,??DataTable10_13
   \   00000034   1160               STR      R1,[R2, #+0]
   \   00000036   0028               CMP      R0,#+0
   \   00000038   EED1               BNE.N    ??sEE_ReadBuffer_0
   \   0000003A   ........           BL       sEE_TIMEOUT_UserCallback
   \   0000003E   34E1               B.N      ??sEE_ReadBuffer_2
    402            }
    403            
    404            /*!< Send START condition */
    405            I2C_GenerateSTART(sEE_I2C, ENABLE);
   \                     ??sEE_ReadBuffer_1:
   \   00000040   0121               MOVS     R1,#+1
   \   00000042   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   00000046   ........           BL       I2C_GenerateSTART
    406            
    407            /*!< Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
    408            sEETimeout = sEE_FLAG_TIMEOUT;
   \   0000004A   ........           LDR.W    R0,??DataTable10_13
   \   0000004E   4FF48051           MOV      R1,#+4096
   \   00000052   0160               STR      R1,[R0, #+0]
    409            while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
   \                     ??sEE_ReadBuffer_3:
   \   00000054   ........           LDR.W    R1,??DataTable10_14  ;; 0x30001
   \   00000058   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   0000005C   ........           BL       I2C_CheckEvent
   \   00000060   0028               CMP      R0,#+0
   \   00000062   0BD1               BNE.N    ??sEE_ReadBuffer_4
    410            {
    411              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000064   ........           LDR.W    R0,??DataTable10_13
   \   00000068   0068               LDR      R0,[R0, #+0]
   \   0000006A   411E               SUBS     R1,R0,#+1
   \   0000006C   ........           LDR.W    R2,??DataTable10_13
   \   00000070   1160               STR      R1,[R2, #+0]
   \   00000072   0028               CMP      R0,#+0
   \   00000074   EED1               BNE.N    ??sEE_ReadBuffer_3
   \   00000076   ........           BL       sEE_TIMEOUT_UserCallback
   \   0000007A   16E1               B.N      ??sEE_ReadBuffer_2
    412            }
    413            
    414            /*!< Send EEPROM address for write */
    415            I2C_Send7bitAddress(sEE_I2C, sEEAddress, I2C_Direction_Transmitter);
   \                     ??sEE_ReadBuffer_4:
   \   0000007C   0022               MOVS     R2,#+0
   \   0000007E   ........           LDR.W    R0,??DataTable10_11
   \   00000082   0188               LDRH     R1,[R0, #+0]
   \   00000084   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000086   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   0000008A   ........           BL       I2C_Send7bitAddress
    416          
    417            /*!< Test on EV6 and clear it */
    418            sEETimeout = sEE_FLAG_TIMEOUT;
   \   0000008E   ........           LDR.W    R0,??DataTable10_13
   \   00000092   4FF48051           MOV      R1,#+4096
   \   00000096   0160               STR      R1,[R0, #+0]
    419            while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
   \                     ??sEE_ReadBuffer_5:
   \   00000098   ........           LDR.W    R1,??DataTable10_15  ;; 0x70082
   \   0000009C   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   000000A0   ........           BL       I2C_CheckEvent
   \   000000A4   0028               CMP      R0,#+0
   \   000000A6   0BD1               BNE.N    ??sEE_ReadBuffer_6
    420            {
    421              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   000000A8   ........           LDR.W    R0,??DataTable10_13
   \   000000AC   0068               LDR      R0,[R0, #+0]
   \   000000AE   411E               SUBS     R1,R0,#+1
   \   000000B0   ........           LDR.W    R2,??DataTable10_13
   \   000000B4   1160               STR      R1,[R2, #+0]
   \   000000B6   0028               CMP      R0,#+0
   \   000000B8   EED1               BNE.N    ??sEE_ReadBuffer_5
   \   000000BA   ........           BL       sEE_TIMEOUT_UserCallback
   \   000000BE   F4E0               B.N      ??sEE_ReadBuffer_2
    422            } 
    423          
    424          #ifdef sEE_M24C08  
    425            
    426            /*!< Send the EEPROM's internal address to read from: Only one byte address */
    427            I2C_SendData(sEE_I2C, ReadAddr);  
    428          
    429          #elif defined (sEE_M24C64_32)
    430          
    431            /*!< Send the EEPROM's internal address to read from: MSB of the address first */
    432            I2C_SendData(sEE_I2C, (uint8_t)((ReadAddr & 0xFF00) >> 8));    
   \                     ??sEE_ReadBuffer_6:
   \   000000C0   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000C2   310A               LSRS     R1,R6,#+8
   \   000000C4   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000C6   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   000000CA   ........           BL       I2C_SendData
    433          
    434            /*!< Test on EV8 and clear it */
    435            sEETimeout = sEE_FLAG_TIMEOUT;
   \   000000CE   ........           LDR.W    R0,??DataTable10_13
   \   000000D2   4FF48051           MOV      R1,#+4096
   \   000000D6   0160               STR      R1,[R0, #+0]
    436            while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING))
   \                     ??sEE_ReadBuffer_7:
   \   000000D8   ........           LDR.W    R1,??DataTable10_16  ;; 0x70080
   \   000000DC   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   000000E0   ........           BL       I2C_CheckEvent
   \   000000E4   0028               CMP      R0,#+0
   \   000000E6   0BD1               BNE.N    ??sEE_ReadBuffer_8
    437            {
    438              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   000000E8   ........           LDR.W    R0,??DataTable10_13
   \   000000EC   0068               LDR      R0,[R0, #+0]
   \   000000EE   411E               SUBS     R1,R0,#+1
   \   000000F0   ........           LDR.W    R2,??DataTable10_13
   \   000000F4   1160               STR      R1,[R2, #+0]
   \   000000F6   0028               CMP      R0,#+0
   \   000000F8   EED1               BNE.N    ??sEE_ReadBuffer_7
   \   000000FA   ........           BL       sEE_TIMEOUT_UserCallback
   \   000000FE   D4E0               B.N      ??sEE_ReadBuffer_2
    439            }
    440          
    441            /*!< Send the EEPROM's internal address to read from: LSB of the address */
    442            I2C_SendData(sEE_I2C, (uint8_t)(ReadAddr & 0x00FF));    
   \                     ??sEE_ReadBuffer_8:
   \   00000100   3100               MOVS     R1,R6
   \   00000102   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000104   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   00000108   ........           BL       I2C_SendData
    443            
    444          #endif /*!< sEE_M24C08 */
    445          
    446            /*!< Test on EV8 and clear it */
    447            sEETimeout = sEE_FLAG_TIMEOUT;
   \   0000010C   ........           LDR.W    R0,??DataTable10_13
   \   00000110   4FF48051           MOV      R1,#+4096
   \   00000114   0160               STR      R1,[R0, #+0]
    448            while(I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_BTF) == RESET)
   \                     ??sEE_ReadBuffer_9:
   \   00000116   ........           LDR.W    R1,??DataTable10_17  ;; 0x10000004
   \   0000011A   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   0000011E   ........           BL       I2C_GetFlagStatus
   \   00000122   0028               CMP      R0,#+0
   \   00000124   0BD1               BNE.N    ??sEE_ReadBuffer_10
    449            {
    450              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000126   ........           LDR.W    R0,??DataTable10_13
   \   0000012A   0068               LDR      R0,[R0, #+0]
   \   0000012C   411E               SUBS     R1,R0,#+1
   \   0000012E   ........           LDR.W    R2,??DataTable10_13
   \   00000132   1160               STR      R1,[R2, #+0]
   \   00000134   0028               CMP      R0,#+0
   \   00000136   EED1               BNE.N    ??sEE_ReadBuffer_9
   \   00000138   ........           BL       sEE_TIMEOUT_UserCallback
   \   0000013C   B5E0               B.N      ??sEE_ReadBuffer_2
    451            }
    452            
    453            /*!< Send STRAT condition a second time */  
    454            I2C_GenerateSTART(sEE_I2C, ENABLE);
   \                     ??sEE_ReadBuffer_10:
   \   0000013E   0121               MOVS     R1,#+1
   \   00000140   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   00000144   ........           BL       I2C_GenerateSTART
    455            
    456            /*!< Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
    457            sEETimeout = sEE_FLAG_TIMEOUT;
   \   00000148   ........           LDR.W    R0,??DataTable10_13
   \   0000014C   4FF48051           MOV      R1,#+4096
   \   00000150   0160               STR      R1,[R0, #+0]
    458            while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
   \                     ??sEE_ReadBuffer_11:
   \   00000152   ........           LDR.W    R1,??DataTable10_14  ;; 0x30001
   \   00000156   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   0000015A   ........           BL       I2C_CheckEvent
   \   0000015E   0028               CMP      R0,#+0
   \   00000160   0BD1               BNE.N    ??sEE_ReadBuffer_12
    459            {
    460              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000162   ........           LDR.W    R0,??DataTable10_13
   \   00000166   0068               LDR      R0,[R0, #+0]
   \   00000168   411E               SUBS     R1,R0,#+1
   \   0000016A   ........           LDR.W    R2,??DataTable10_13
   \   0000016E   1160               STR      R1,[R2, #+0]
   \   00000170   0028               CMP      R0,#+0
   \   00000172   EED1               BNE.N    ??sEE_ReadBuffer_11
   \   00000174   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000178   97E0               B.N      ??sEE_ReadBuffer_2
    461            } 
    462            
    463            /*!< Send EEPROM address for read */
    464            I2C_Send7bitAddress(sEE_I2C, sEEAddress, I2C_Direction_Receiver);  
   \                     ??sEE_ReadBuffer_12:
   \   0000017A   0122               MOVS     R2,#+1
   \   0000017C   ........           LDR.W    R0,??DataTable10_11
   \   00000180   0188               LDRH     R1,[R0, #+0]
   \   00000182   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000184   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   00000188   ........           BL       I2C_Send7bitAddress
    465            
    466            /* If number of data to be read is 1, then DMA couldn't be used */
    467            /* One Byte Master Reception procedure (POLLING) ---------------------------*/
    468            if ((uint16_t)(*NumByteToRead) < 2)
   \   0000018C   2888               LDRH     R0,[R5, #+0]
   \   0000018E   0228               CMP      R0,#+2
   \   00000190   62D2               BCS.N    ??sEE_ReadBuffer_13
    469            {
    470              /* Wait on ADDR flag to be set (ADDR is still not cleared at this level */
    471              sEETimeout = sEE_FLAG_TIMEOUT;
   \   00000192   ........           LDR.W    R0,??DataTable10_13
   \   00000196   4FF48051           MOV      R1,#+4096
   \   0000019A   0160               STR      R1,[R0, #+0]
    472              while(I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_ADDR) == RESET)
   \                     ??sEE_ReadBuffer_14:
   \   0000019C   ........           LDR.W    R1,??DataTable10_18  ;; 0x10000002
   \   000001A0   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   000001A4   ........           BL       I2C_GetFlagStatus
   \   000001A8   0028               CMP      R0,#+0
   \   000001AA   0BD1               BNE.N    ??sEE_ReadBuffer_15
    473              {
    474                if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   000001AC   ........           LDR.W    R0,??DataTable10_13
   \   000001B0   0068               LDR      R0,[R0, #+0]
   \   000001B2   411E               SUBS     R1,R0,#+1
   \   000001B4   ........           LDR.W    R2,??DataTable10_13
   \   000001B8   1160               STR      R1,[R2, #+0]
   \   000001BA   0028               CMP      R0,#+0
   \   000001BC   EED1               BNE.N    ??sEE_ReadBuffer_14
   \   000001BE   ........           BL       sEE_TIMEOUT_UserCallback
   \   000001C2   72E0               B.N      ??sEE_ReadBuffer_2
    475              }     
    476              
    477              /*!< Disable Acknowledgment */
    478              I2C_AcknowledgeConfig(sEE_I2C, DISABLE);   
   \                     ??sEE_ReadBuffer_15:
   \   000001C4   0021               MOVS     R1,#+0
   \   000001C6   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   000001CA   ........           BL       I2C_AcknowledgeConfig
    479              
    480              /* Clear ADDR register by reading SR1 then SR2 register (SR1 has already been read) */
    481              (void)sEE_I2C->SR2;
   \   000001CE   ........           LDR.W    R0,??DataTable10_19  ;; 0x40005818
   \   000001D2   0688               LDRH     R6,[R0, #+0]
    482              
    483              /*!< Send STOP Condition */
    484              I2C_GenerateSTOP(sEE_I2C, ENABLE);
   \   000001D4   0121               MOVS     R1,#+1
   \   000001D6   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   000001DA   ........           BL       I2C_GenerateSTOP
    485              
    486              /* Wait for the byte to be received */
    487              sEETimeout = sEE_FLAG_TIMEOUT;
   \   000001DE   ........           LDR.W    R0,??DataTable10_13
   \   000001E2   4FF48051           MOV      R1,#+4096
   \   000001E6   0160               STR      R1,[R0, #+0]
    488              while(I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_RXNE) == RESET)
   \                     ??sEE_ReadBuffer_16:
   \   000001E8   ........           LDR.W    R1,??DataTable10_20  ;; 0x10000040
   \   000001EC   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   000001F0   ........           BL       I2C_GetFlagStatus
   \   000001F4   0028               CMP      R0,#+0
   \   000001F6   0BD1               BNE.N    ??sEE_ReadBuffer_17
    489              {
    490                if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   000001F8   ........           LDR.W    R0,??DataTable10_13
   \   000001FC   0068               LDR      R0,[R0, #+0]
   \   000001FE   411E               SUBS     R1,R0,#+1
   \   00000200   ........           LDR.W    R2,??DataTable10_13
   \   00000204   1160               STR      R1,[R2, #+0]
   \   00000206   0028               CMP      R0,#+0
   \   00000208   EED1               BNE.N    ??sEE_ReadBuffer_16
   \   0000020A   ........           BL       sEE_TIMEOUT_UserCallback
   \   0000020E   4CE0               B.N      ??sEE_ReadBuffer_2
    491              }
    492              
    493              /*!< Read the byte received from the EEPROM */
    494              *pBuffer = I2C_ReceiveData(sEE_I2C);
   \                     ??sEE_ReadBuffer_17:
   \   00000210   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   00000214   ........           BL       I2C_ReceiveData
   \   00000218   2070               STRB     R0,[R4, #+0]
    495              
    496              /*!< Decrement the read bytes counter */
    497              (uint16_t)(*NumByteToRead)--;        
   \   0000021A   2888               LDRH     R0,[R5, #+0]
   \   0000021C   401E               SUBS     R0,R0,#+1
   \   0000021E   2880               STRH     R0,[R5, #+0]
    498              
    499              /* Wait to make sure that STOP control bit has been cleared */
    500              sEETimeout = sEE_FLAG_TIMEOUT;
   \   00000220   ........           LDR.W    R0,??DataTable10_13
   \   00000224   4FF48051           MOV      R1,#+4096
   \   00000228   0160               STR      R1,[R0, #+0]
    501              while(sEE_I2C->CR1 & I2C_CR1_STOP)
   \                     ??sEE_ReadBuffer_18:
   \   0000022A   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   0000022E   0088               LDRH     R0,[R0, #+0]
   \   00000230   8005               LSLS     R0,R0,#+22
   \   00000232   0BD5               BPL.N    ??sEE_ReadBuffer_19
    502              {
    503                if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000234   ........           LDR.W    R0,??DataTable10_13
   \   00000238   0068               LDR      R0,[R0, #+0]
   \   0000023A   411E               SUBS     R1,R0,#+1
   \   0000023C   ........           LDR.W    R2,??DataTable10_13
   \   00000240   1160               STR      R1,[R2, #+0]
   \   00000242   0028               CMP      R0,#+0
   \   00000244   F1D1               BNE.N    ??sEE_ReadBuffer_18
   \   00000246   ........           BL       sEE_TIMEOUT_UserCallback
   \   0000024A   2EE0               B.N      ??sEE_ReadBuffer_2
    504              }  
    505              
    506              /*!< Re-Enable Acknowledgment to be ready for another reception */
    507              I2C_AcknowledgeConfig(sEE_I2C, ENABLE);    
   \                     ??sEE_ReadBuffer_19:
   \   0000024C   0121               MOVS     R1,#+1
   \   0000024E   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   00000252   ........           BL       I2C_AcknowledgeConfig
   \   00000256   27E0               B.N      ??sEE_ReadBuffer_20
    508            }
    509            else/* More than one Byte Master Reception procedure (DMA) -----------------*/
    510            {
    511              /*!< Test on EV6 and clear it */
    512              sEETimeout = sEE_FLAG_TIMEOUT;
   \                     ??sEE_ReadBuffer_13:
   \   00000258   ........           LDR.W    R0,??DataTable10_13
   \   0000025C   4FF48051           MOV      R1,#+4096
   \   00000260   0160               STR      R1,[R0, #+0]
    513              while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
   \                     ??sEE_ReadBuffer_21:
   \   00000262   ........           LDR.W    R1,??DataTable10_21  ;; 0x30002
   \   00000266   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   0000026A   ........           BL       I2C_CheckEvent
   \   0000026E   0028               CMP      R0,#+0
   \   00000270   0BD1               BNE.N    ??sEE_ReadBuffer_22
    514              {
    515                if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000272   ........           LDR.W    R0,??DataTable10_13
   \   00000276   0068               LDR      R0,[R0, #+0]
   \   00000278   411E               SUBS     R1,R0,#+1
   \   0000027A   ........           LDR.W    R2,??DataTable10_13
   \   0000027E   1160               STR      R1,[R2, #+0]
   \   00000280   0028               CMP      R0,#+0
   \   00000282   EED1               BNE.N    ??sEE_ReadBuffer_21
   \   00000284   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000288   0FE0               B.N      ??sEE_ReadBuffer_2
    516              }  
    517              
    518              /* Configure the DMA Rx Channel with the buffer address and the buffer size */
    519              sEE_LowLevel_DMAConfig((uint32_t)pBuffer, (uint16_t)(*NumByteToRead), sEE_DIRECTION_RX);
   \                     ??sEE_ReadBuffer_22:
   \   0000028A   0122               MOVS     R2,#+1
   \   0000028C   2988               LDRH     R1,[R5, #+0]
   \   0000028E   2000               MOVS     R0,R4
   \   00000290   ........           BL       sEE_LowLevel_DMAConfig
    520              
    521              /* Inform the DMA that the next End Of Transfer Signal will be the last one */
    522              I2C_DMALastTransferCmd(sEE_I2C, ENABLE); 
   \   00000294   0121               MOVS     R1,#+1
   \   00000296   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   0000029A   ........           BL       I2C_DMALastTransferCmd
    523              
    524              /* Enable the DMA Rx Stream */
    525              DMA_Cmd(sEE_I2C_DMA_STREAM_RX, ENABLE);    
   \   0000029E   0121               MOVS     R1,#+1
   \   000002A0   ........           LDR.W    R0,??DataTable10_5  ;; 0x40026088
   \   000002A4   ........           BL       DMA_Cmd
    526            }
    527            
    528            /* If all operations OK, return sEE_OK (0) */
    529            return sEE_OK;
   \                     ??sEE_ReadBuffer_20:
   \   000002A8   0020               MOVS     R0,#+0
   \                     ??sEE_ReadBuffer_2:
   \   000002AA   70BD               POP      {R4-R6,PC}       ;; return
    530          }
    531          
    532          /**
    533            * @brief  Writes more than one byte to the EEPROM with a single WRITE cycle.
    534            *
    535            * @note   The number of bytes (combined to write start address) must not 
    536            *         cross the EEPROM page boundary. This function can only write into
    537            *         the boundaries of an EEPROM page.
    538            *         This function doesn't check on boundaries condition (in this driver 
    539            *         the function sEE_WriteBuffer() which calls sEE_WritePage() is 
    540            *         responsible of checking on Page boundaries).
    541            * 
    542            * @param  pBuffer : pointer to the buffer containing the data to be written to 
    543            *         the EEPROM.
    544            * @param  WriteAddr : EEPROM's internal address to write to.
    545            * @param  NumByteToWrite : pointer to the variable holding number of bytes to 
    546            *         be written into the EEPROM. 
    547            * 
    548            *        @note The variable pointed by NumByteToWrite is reset to 0 when all the 
    549            *              data are written to the EEPROM. Application should monitor this 
    550            *              variable in order know when the transfer is complete.
    551            * 
    552            * @note This function just configure the communication and enable the DMA 
    553            *       channel to transfer data. Meanwhile, the user application may perform 
    554            *       other tasks in parallel.
    555            * 
    556            * @retval sEE_OK (0) if operation is correctly performed, else return value 
    557            *         different from sEE_OK (0) or the timeout user callback.
    558            */

   \                                 In section .text, align 2, keep-with-next
    559          uint32_t sEE_WritePage(uint8_t* pBuffer, uint16_t WriteAddr, uint8_t* NumByteToWrite)
    560          { 
   \                     sEE_WritePage:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0E00               MOVS     R6,R1
   \   00000006   1500               MOVS     R5,R2
    561            /* Set the pointer to the Number of data to be written. This pointer will be used 
    562                by the DMA Transfer Completer interrupt Handler in order to reset the 
    563                variable to 0. User should check on this variable in order to know if the 
    564                DMA transfer has been complete or not. */
    565               sEEDataWritePointer = NumByteToWrite;  
   \   00000008   ........           LDR.W    R0,??DataTable10_22
   \   0000000C   0560               STR      R5,[R0, #+0]
    566          	EE_ENABLE();
   \   0000000E   ........           BL       EE_ENABLE
    567          	Delay(10);  
                 	^
Warning[Pe223]: function "Delay" declared implicitly
   \   00000012   0A20               MOVS     R0,#+10
   \   00000014   ........           BL       Delay
    568            /*!< While the bus is busy */
    569            sEETimeout = sEE_LONG_TIMEOUT;
   \   00000018   ........           LDR.W    R0,??DataTable10_13
   \   0000001C   4FF42041           MOV      R1,#+40960
   \   00000020   0160               STR      R1,[R0, #+0]
    570            while(I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_BUSY))
   \                     ??sEE_WritePage_0:
   \   00000022   5FF40031           MOVS     R1,#+131072
   \   00000026   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   0000002A   ........           BL       I2C_GetFlagStatus
   \   0000002E   0028               CMP      R0,#+0
   \   00000030   0BD0               BEQ.N    ??sEE_WritePage_1
    571            {
    572              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000032   ........           LDR.W    R0,??DataTable10_13
   \   00000036   0068               LDR      R0,[R0, #+0]
   \   00000038   411E               SUBS     R1,R0,#+1
   \   0000003A   ........           LDR.W    R2,??DataTable10_13
   \   0000003E   1160               STR      R1,[R2, #+0]
   \   00000040   0028               CMP      R0,#+0
   \   00000042   EED1               BNE.N    ??sEE_WritePage_0
   \   00000044   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000048   8EE0               B.N      ??sEE_WritePage_2
    573            }
    574            
    575            /*!< Send START condition */
    576            I2C_GenerateSTART(sEE_I2C, ENABLE);
   \                     ??sEE_WritePage_1:
   \   0000004A   0121               MOVS     R1,#+1
   \   0000004C   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   00000050   ........           BL       I2C_GenerateSTART
    577            
    578            /*!< Test on EV5 and clear it */
    579            sEETimeout = sEE_FLAG_TIMEOUT;
   \   00000054   ........           LDR.W    R0,??DataTable10_13
   \   00000058   4FF48051           MOV      R1,#+4096
   \   0000005C   0160               STR      R1,[R0, #+0]
    580            while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
   \                     ??sEE_WritePage_3:
   \   0000005E   ........           LDR.W    R1,??DataTable10_14  ;; 0x30001
   \   00000062   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   00000066   ........           BL       I2C_CheckEvent
   \   0000006A   0028               CMP      R0,#+0
   \   0000006C   0BD1               BNE.N    ??sEE_WritePage_4
    581            {
    582              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   0000006E   ........           LDR.W    R0,??DataTable10_13
   \   00000072   0068               LDR      R0,[R0, #+0]
   \   00000074   411E               SUBS     R1,R0,#+1
   \   00000076   ........           LDR.W    R2,??DataTable10_13
   \   0000007A   1160               STR      R1,[R2, #+0]
   \   0000007C   0028               CMP      R0,#+0
   \   0000007E   EED1               BNE.N    ??sEE_WritePage_3
   \   00000080   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000084   70E0               B.N      ??sEE_WritePage_2
    583            }
    584            
    585            /*!< Send EEPROM address for write */
    586            sEETimeout = sEE_FLAG_TIMEOUT;
   \                     ??sEE_WritePage_4:
   \   00000086   ........           LDR.W    R0,??DataTable10_13
   \   0000008A   4FF48051           MOV      R1,#+4096
   \   0000008E   0160               STR      R1,[R0, #+0]
    587            I2C_Send7bitAddress(sEE_I2C, sEEAddress, I2C_Direction_Transmitter);
   \   00000090   0022               MOVS     R2,#+0
   \   00000092   ........           LDR.W    R0,??DataTable10_11
   \   00000096   0188               LDRH     R1,[R0, #+0]
   \   00000098   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000009A   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   0000009E   ........           BL       I2C_Send7bitAddress
    588          
    589            /*!< Test on EV6 and clear it */
    590            sEETimeout = sEE_FLAG_TIMEOUT;
   \   000000A2   ........           LDR.W    R0,??DataTable10_13
   \   000000A6   4FF48051           MOV      R1,#+4096
   \   000000AA   0160               STR      R1,[R0, #+0]
    591            while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
   \                     ??sEE_WritePage_5:
   \   000000AC   ........           LDR.W    R1,??DataTable10_15  ;; 0x70082
   \   000000B0   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   000000B4   ........           BL       I2C_CheckEvent
   \   000000B8   0028               CMP      R0,#+0
   \   000000BA   0BD1               BNE.N    ??sEE_WritePage_6
    592            {
    593              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   000000BC   ........           LDR.W    R0,??DataTable10_13
   \   000000C0   0068               LDR      R0,[R0, #+0]
   \   000000C2   411E               SUBS     R1,R0,#+1
   \   000000C4   ........           LDR.W    R2,??DataTable10_13
   \   000000C8   1160               STR      R1,[R2, #+0]
   \   000000CA   0028               CMP      R0,#+0
   \   000000CC   EED1               BNE.N    ??sEE_WritePage_5
   \   000000CE   ........           BL       sEE_TIMEOUT_UserCallback
   \   000000D2   49E0               B.N      ??sEE_WritePage_2
    594            }
    595          
    596          #ifdef sEE_M24C08
    597            
    598            /*!< Send the EEPROM's internal address to write to : only one byte Address */
    599            I2C_SendData(sEE_I2C, WriteAddr);
    600            
    601          #elif defined(sEE_M24C64_32)
    602            
    603            /*!< Send the EEPROM's internal address to write to : MSB of the address first */
    604            I2C_SendData(sEE_I2C, (uint8_t)((WriteAddr & 0xFF00) >> 8));
   \                     ??sEE_WritePage_6:
   \   000000D4   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000D6   310A               LSRS     R1,R6,#+8
   \   000000D8   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000DA   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   000000DE   ........           BL       I2C_SendData
    605          
    606            /*!< Test on EV8 and clear it */
    607            sEETimeout = sEE_FLAG_TIMEOUT;  
   \   000000E2   ........           LDR.W    R0,??DataTable10_13
   \   000000E6   4FF48051           MOV      R1,#+4096
   \   000000EA   0160               STR      R1,[R0, #+0]
    608            while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING))
   \                     ??sEE_WritePage_7:
   \   000000EC   ........           LDR.W    R1,??DataTable10_16  ;; 0x70080
   \   000000F0   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   000000F4   ........           BL       I2C_CheckEvent
   \   000000F8   0028               CMP      R0,#+0
   \   000000FA   0BD1               BNE.N    ??sEE_WritePage_8
    609            {
    610              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   000000FC   ........           LDR.W    R0,??DataTable10_13
   \   00000100   0068               LDR      R0,[R0, #+0]
   \   00000102   411E               SUBS     R1,R0,#+1
   \   00000104   ........           LDR.W    R2,??DataTable10_13
   \   00000108   1160               STR      R1,[R2, #+0]
   \   0000010A   0028               CMP      R0,#+0
   \   0000010C   EED1               BNE.N    ??sEE_WritePage_7
   \   0000010E   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000112   29E0               B.N      ??sEE_WritePage_2
    611            }  
    612            
    613            /*!< Send the EEPROM's internal address to write to : LSB of the address */
    614            I2C_SendData(sEE_I2C, (uint8_t)(WriteAddr & 0x00FF));
   \                     ??sEE_WritePage_8:
   \   00000114   3100               MOVS     R1,R6
   \   00000116   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000118   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   0000011C   ........           BL       I2C_SendData
    615            
    616          #endif /*!< sEE_M24C08 */  
    617            
    618            /*!< Test on EV8 and clear it */
    619            sEETimeout = sEE_FLAG_TIMEOUT; 
   \   00000120   ........           LDR.W    R0,??DataTable10_13
   \   00000124   4FF48051           MOV      R1,#+4096
   \   00000128   0160               STR      R1,[R0, #+0]
    620            while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING))
   \                     ??sEE_WritePage_9:
   \   0000012A   ........           LDR.W    R1,??DataTable10_16  ;; 0x70080
   \   0000012E   ........           LDR.W    R0,??DataTable10_1  ;; 0x40005800
   \   00000132   ........           BL       I2C_CheckEvent
   \   00000136   0028               CMP      R0,#+0
   \   00000138   0BD1               BNE.N    ??sEE_WritePage_10
    621            {
    622              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   0000013A   ........           LDR.W    R0,??DataTable10_13
   \   0000013E   0068               LDR      R0,[R0, #+0]
   \   00000140   411E               SUBS     R1,R0,#+1
   \   00000142   ........           LDR.W    R2,??DataTable10_13
   \   00000146   1160               STR      R1,[R2, #+0]
   \   00000148   0028               CMP      R0,#+0
   \   0000014A   EED1               BNE.N    ??sEE_WritePage_9
   \   0000014C   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000150   0AE0               B.N      ??sEE_WritePage_2
    623            }  
    624            
    625            /* Configure the DMA Tx Channel with the buffer address and the buffer size */
    626            sEE_LowLevel_DMAConfig((uint32_t)pBuffer, (uint8_t)(*NumByteToWrite), sEE_DIRECTION_TX);
   \                     ??sEE_WritePage_10:
   \   00000152   0022               MOVS     R2,#+0
   \   00000154   2978               LDRB     R1,[R5, #+0]
   \   00000156   2000               MOVS     R0,R4
   \   00000158   ........           BL       sEE_LowLevel_DMAConfig
    627            
    628            /* Enable the DMA Tx Stream */
    629            DMA_Cmd(sEE_I2C_DMA_STREAM_TX, ENABLE);
   \   0000015C   0121               MOVS     R1,#+1
   \   0000015E   ........           LDR.W    R0,??DataTable10_4  ;; 0x40026070
   \   00000162   ........           BL       DMA_Cmd
    630          
    631            /* If all operations OK, return sEE_OK (0) */
    632            return sEE_OK;
   \   00000166   0020               MOVS     R0,#+0
   \                     ??sEE_WritePage_2:
   \   00000168   70BD               POP      {R4-R6,PC}       ;; return
    633          }
    634          
    635          /**
    636            * @brief  Writes buffer of data to the I2C EEPROM.
    637            * @param  pBuffer : pointer to the buffer  containing the data to be written 
    638            *         to the EEPROM.
    639            * @param  WriteAddr : EEPROM's internal address to write to.
    640            * @param  NumByteToWrite : number of bytes to write to the EEPROM.
    641            * @retval None
    642            */

   \                                 In section .text, align 2, keep-with-next
    643          void sEE_WriteBuffer(uint8_t* pBuffer, uint16_t WriteAddr, uint16_t NumByteToWrite)
    644          {
   \                     sEE_WriteBuffer:
   \   00000000   2DE9F843           PUSH     {R3-R9,LR}
   \   00000004   0600               MOVS     R6,R0
   \   00000006   0D00               MOVS     R5,R1
   \   00000008   9146               MOV      R9,R2
    645            uint8_t NumOfPage = 0, NumOfSingle = 0, count = 0;
   \   0000000A   0027               MOVS     R7,#+0
   \   0000000C   0024               MOVS     R4,#+0
   \   0000000E   5FF00008           MOVS     R8,#+0
    646            uint16_t Addr = 0;
   \   00000012   0020               MOVS     R0,#+0
    647          
    648            Addr = WriteAddr % sEE_PAGESIZE;
   \   00000014   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000016   2021               MOVS     R1,#+32
   \   00000018   95FBF1F2           SDIV     R2,R5,R1
   \   0000001C   02FB1152           MLS      R2,R2,R1,R5
   \   00000020   1000               MOVS     R0,R2
    649            count = sEE_PAGESIZE - Addr;
   \   00000022   D0F12001           RSBS     R1,R0,#+32
   \   00000026   8846               MOV      R8,R1
    650            NumOfPage =  NumByteToWrite / sEE_PAGESIZE;
   \   00000028   1FFA89F9           UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000002C   2021               MOVS     R1,#+32
   \   0000002E   99FBF1F1           SDIV     R1,R9,R1
   \   00000032   0F00               MOVS     R7,R1
    651            NumOfSingle = NumByteToWrite % sEE_PAGESIZE;
   \   00000034   1FFA89F9           UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000038   2021               MOVS     R1,#+32
   \   0000003A   99FBF1F2           SDIV     R2,R9,R1
   \   0000003E   02FB1192           MLS      R2,R2,R1,R9
   \   00000042   1400               MOVS     R4,R2
    652           
    653            /*!< If WriteAddr is sEE_PAGESIZE aligned  */
    654            if(Addr == 0) 
   \   00000044   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000046   0028               CMP      R0,#+0
   \   00000048   76D1               BNE.N    ??sEE_WriteBuffer_0
    655            {
    656              /*!< If NumByteToWrite < sEE_PAGESIZE */
    657              if(NumOfPage == 0) 
   \   0000004A   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004C   002F               CMP      R7,#+0
   \   0000004E   26D1               BNE.N    ??sEE_WriteBuffer_1
    658              {
    659                /* Store the number of data to be written */
    660                sEEDataNum = NumOfSingle;
   \   00000050   ........           LDR.W    R0,??DataTable10_23
   \   00000054   0470               STRB     R4,[R0, #+0]
    661                /* Start writing data */
    662                sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
   \   00000056   ........           LDR.W    R2,??DataTable10_23
   \   0000005A   2900               MOVS     R1,R5
   \   0000005C   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000005E   3000               MOVS     R0,R6
   \   00000060   ........           BL       sEE_WritePage
    663                /* Wait transfer through DMA to be complete */
    664                sEETimeout = sEE_LONG_TIMEOUT;
   \   00000064   ........           LDR.W    R0,??DataTable10_13
   \   00000068   4FF42041           MOV      R1,#+40960
   \   0000006C   0160               STR      R1,[R0, #+0]
    665                while (sEEDataNum > 0)
   \                     ??sEE_WriteBuffer_2:
   \   0000006E   ........           LDR.W    R0,??DataTable10_23
   \   00000072   0078               LDRB     R0,[R0, #+0]
   \   00000074   0128               CMP      R0,#+1
   \   00000076   0BD3               BCC.N    ??sEE_WriteBuffer_3
    666                {
    667                  if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
   \   00000078   ........           LDR.W    R0,??DataTable10_13
   \   0000007C   0068               LDR      R0,[R0, #+0]
   \   0000007E   411E               SUBS     R1,R0,#+1
   \   00000080   ........           LDR.W    R2,??DataTable10_13
   \   00000084   1160               STR      R1,[R2, #+0]
   \   00000086   0028               CMP      R0,#+0
   \   00000088   F1D1               BNE.N    ??sEE_WriteBuffer_2
   \   0000008A   ........           BL       sEE_TIMEOUT_UserCallback
   \   0000008E   42E1               B.N      ??sEE_WriteBuffer_4
    668                }
    669                sEE_WaitEepromStandbyState();
   \                     ??sEE_WriteBuffer_3:
   \   00000090   ........           BL       sEE_WaitEepromStandbyState
   \   00000094   3FE1               B.N      ??sEE_WriteBuffer_5
    670              }
    671              /*!< If NumByteToWrite > sEE_PAGESIZE */
    672              else  
    673              {
    674                while(NumOfPage--)
    675                {
    676                  /* Store the number of data to be written */
    677                  sEEDataNum = sEE_PAGESIZE;        
    678                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum)); 
    679                  /* Wait transfer through DMA to be complete */
    680                  sEETimeout = sEE_LONG_TIMEOUT;
    681                  while (sEEDataNum > 0)
    682                  {
    683                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
    684                  }      
    685                  sEE_WaitEepromStandbyState();
   \                     ??sEE_WriteBuffer_6:
   \   00000096   ........           BL       sEE_WaitEepromStandbyState
    686                  WriteAddr +=  sEE_PAGESIZE;
   \   0000009A   2035               ADDS     R5,R5,#+32
    687                  pBuffer += sEE_PAGESIZE;
   \   0000009C   2036               ADDS     R6,R6,#+32
   \                     ??sEE_WriteBuffer_1:
   \   0000009E   3800               MOVS     R0,R7
   \   000000A0   471E               SUBS     R7,R0,#+1
   \   000000A2   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A4   0028               CMP      R0,#+0
   \   000000A6   20D0               BEQ.N    ??sEE_WriteBuffer_7
   \   000000A8   ........           LDR.W    R0,??DataTable10_23
   \   000000AC   2021               MOVS     R1,#+32
   \   000000AE   0170               STRB     R1,[R0, #+0]
   \   000000B0   ........           LDR.W    R2,??DataTable10_23
   \   000000B4   2900               MOVS     R1,R5
   \   000000B6   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000B8   3000               MOVS     R0,R6
   \   000000BA   ........           BL       sEE_WritePage
   \   000000BE   ........           LDR.W    R0,??DataTable10_13
   \   000000C2   4FF42041           MOV      R1,#+40960
   \   000000C6   0160               STR      R1,[R0, #+0]
   \                     ??sEE_WriteBuffer_8:
   \   000000C8   ........           LDR.W    R0,??DataTable10_23
   \   000000CC   0078               LDRB     R0,[R0, #+0]
   \   000000CE   0128               CMP      R0,#+1
   \   000000D0   E1D3               BCC.N    ??sEE_WriteBuffer_6
   \   000000D2   ........           LDR.W    R0,??DataTable10_13
   \   000000D6   0068               LDR      R0,[R0, #+0]
   \   000000D8   411E               SUBS     R1,R0,#+1
   \   000000DA   ........           LDR.W    R2,??DataTable10_13
   \   000000DE   1160               STR      R1,[R2, #+0]
   \   000000E0   0028               CMP      R0,#+0
   \   000000E2   F1D1               BNE.N    ??sEE_WriteBuffer_8
   \   000000E4   ........           BL       sEE_TIMEOUT_UserCallback
   \   000000E8   15E1               B.N      ??sEE_WriteBuffer_4
    688                }
    689          
    690                if(NumOfSingle!=0)
   \                     ??sEE_WriteBuffer_7:
   \   000000EA   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000EC   002C               CMP      R4,#+0
   \   000000EE   00F01281           BEQ.W    ??sEE_WriteBuffer_5
    691                {
    692                  /* Store the number of data to be written */
    693                  sEEDataNum = NumOfSingle;          
   \   000000F2   ........           LDR.W    R0,??DataTable10_23
   \   000000F6   0470               STRB     R4,[R0, #+0]
    694                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
   \   000000F8   ........           LDR.W    R2,??DataTable10_23
   \   000000FC   2900               MOVS     R1,R5
   \   000000FE   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000100   3000               MOVS     R0,R6
   \   00000102   ........           BL       sEE_WritePage
    695                  /* Wait transfer through DMA to be complete */
    696                  sEETimeout = sEE_LONG_TIMEOUT;
   \   00000106   ........           LDR.W    R0,??DataTable10_13
   \   0000010A   4FF42041           MOV      R1,#+40960
   \   0000010E   0160               STR      R1,[R0, #+0]
    697                  while (sEEDataNum > 0)
   \                     ??sEE_WriteBuffer_9:
   \   00000110   ........           LDR.W    R0,??DataTable10_23
   \   00000114   0078               LDRB     R0,[R0, #+0]
   \   00000116   0128               CMP      R0,#+1
   \   00000118   0BD3               BCC.N    ??sEE_WriteBuffer_10
    698                  {
    699                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
   \   0000011A   ........           LDR.W    R0,??DataTable10_13
   \   0000011E   0068               LDR      R0,[R0, #+0]
   \   00000120   411E               SUBS     R1,R0,#+1
   \   00000122   ........           LDR.W    R2,??DataTable10_13
   \   00000126   1160               STR      R1,[R2, #+0]
   \   00000128   0028               CMP      R0,#+0
   \   0000012A   F1D1               BNE.N    ??sEE_WriteBuffer_9
   \   0000012C   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000130   F1E0               B.N      ??sEE_WriteBuffer_4
    700                  }    
    701                  sEE_WaitEepromStandbyState();
   \                     ??sEE_WriteBuffer_10:
   \   00000132   ........           BL       sEE_WaitEepromStandbyState
   \   00000136   EEE0               B.N      ??sEE_WriteBuffer_5
    702                }
    703              }
    704            }
    705            /*!< If WriteAddr is not sEE_PAGESIZE aligned  */
    706            else 
    707            {
    708              /*!< If NumByteToWrite < sEE_PAGESIZE */
    709              if(NumOfPage== 0) 
   \                     ??sEE_WriteBuffer_0:
   \   00000138   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000013A   002F               CMP      R7,#+0
   \   0000013C   6DD1               BNE.N    ??sEE_WriteBuffer_11
    710              {
    711                /*!< If the number of data to be written is more than the remaining space 
    712                in the current page: */
    713                if (NumByteToWrite > count)
   \   0000013E   4046               MOV      R0,R8
   \   00000140   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000142   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000144   1FFA89F9           UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000148   4845               CMP      R0,R9
   \   0000014A   49D2               BCS.N    ??sEE_WriteBuffer_12
    714                {
    715                  /* Store the number of data to be written */
    716                  sEEDataNum = count;        
   \   0000014C   ........           LDR.W    R0,??DataTable10_23
   \   00000150   80F80080           STRB     R8,[R0, #+0]
    717                  /*!< Write the data contained in same page */
    718                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
   \   00000154   ........           LDR.W    R2,??DataTable10_23
   \   00000158   2900               MOVS     R1,R5
   \   0000015A   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000015C   3000               MOVS     R0,R6
   \   0000015E   ........           BL       sEE_WritePage
    719                  /* Wait transfer through DMA to be complete */
    720                  sEETimeout = sEE_LONG_TIMEOUT;
   \   00000162   ........           LDR.W    R0,??DataTable10_13
   \   00000166   4FF42041           MOV      R1,#+40960
   \   0000016A   0160               STR      R1,[R0, #+0]
    721                  while (sEEDataNum > 0)
   \                     ??sEE_WriteBuffer_13:
   \   0000016C   ........           LDR.W    R0,??DataTable10_23
   \   00000170   0078               LDRB     R0,[R0, #+0]
   \   00000172   0128               CMP      R0,#+1
   \   00000174   0BD3               BCC.N    ??sEE_WriteBuffer_14
    722                  {
    723                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
   \   00000176   ........           LDR.W    R0,??DataTable10_13
   \   0000017A   0068               LDR      R0,[R0, #+0]
   \   0000017C   411E               SUBS     R1,R0,#+1
   \   0000017E   ........           LDR.W    R2,??DataTable10_13
   \   00000182   1160               STR      R1,[R2, #+0]
   \   00000184   0028               CMP      R0,#+0
   \   00000186   F1D1               BNE.N    ??sEE_WriteBuffer_13
   \   00000188   ........           BL       sEE_TIMEOUT_UserCallback
   \   0000018C   C3E0               B.N      ??sEE_WriteBuffer_4
    724                  }          
    725                  sEE_WaitEepromStandbyState();      
   \                     ??sEE_WriteBuffer_14:
   \   0000018E   ........           BL       sEE_WaitEepromStandbyState
    726                  
    727                  /* Store the number of data to be written */
    728                  sEEDataNum = (NumByteToWrite - count);          
   \   00000192   B9EB0800           SUBS     R0,R9,R8
   \   00000196   ........           LDR.W    R1,??DataTable10_23
   \   0000019A   0870               STRB     R0,[R1, #+0]
    729                  /*!< Write the remaining data in the following page */
    730                  sEE_WritePage((uint8_t*)(pBuffer + count), (WriteAddr + count), (uint8_t*)(&sEEDataNum));
   \   0000019C   ........           LDR.W    R2,??DataTable10_23
   \   000001A0   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001A4   18EB0501           ADDS     R1,R8,R5
   \   000001A8   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000001AA   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001AE   18EB0600           ADDS     R0,R8,R6
   \   000001B2   ........           BL       sEE_WritePage
    731                  /* Wait transfer through DMA to be complete */
    732                  sEETimeout = sEE_LONG_TIMEOUT;
   \   000001B6   ....               LDR.N    R0,??DataTable10_13
   \   000001B8   4FF42041           MOV      R1,#+40960
   \   000001BC   0160               STR      R1,[R0, #+0]
    733                  while (sEEDataNum > 0)
   \                     ??sEE_WriteBuffer_15:
   \   000001BE   ....               LDR.N    R0,??DataTable10_23
   \   000001C0   0078               LDRB     R0,[R0, #+0]
   \   000001C2   0128               CMP      R0,#+1
   \   000001C4   09D3               BCC.N    ??sEE_WriteBuffer_16
    734                  {
    735                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
   \   000001C6   ....               LDR.N    R0,??DataTable10_13
   \   000001C8   0068               LDR      R0,[R0, #+0]
   \   000001CA   411E               SUBS     R1,R0,#+1
   \   000001CC   ....               LDR.N    R2,??DataTable10_13
   \   000001CE   1160               STR      R1,[R2, #+0]
   \   000001D0   0028               CMP      R0,#+0
   \   000001D2   F4D1               BNE.N    ??sEE_WriteBuffer_15
   \   000001D4   ........           BL       sEE_TIMEOUT_UserCallback
   \   000001D8   9DE0               B.N      ??sEE_WriteBuffer_4
    736                  }     
    737                  sEE_WaitEepromStandbyState();        
   \                     ??sEE_WriteBuffer_16:
   \   000001DA   ........           BL       sEE_WaitEepromStandbyState
   \   000001DE   9AE0               B.N      ??sEE_WriteBuffer_5
    738                }      
    739                else      
    740                {
    741                  /* Store the number of data to be written */
    742                  sEEDataNum = NumOfSingle;         
   \                     ??sEE_WriteBuffer_12:
   \   000001E0   ....               LDR.N    R0,??DataTable10_23
   \   000001E2   0470               STRB     R4,[R0, #+0]
    743                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
   \   000001E4   ....               LDR.N    R2,??DataTable10_23
   \   000001E6   2900               MOVS     R1,R5
   \   000001E8   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000001EA   3000               MOVS     R0,R6
   \   000001EC   ........           BL       sEE_WritePage
    744                  /* Wait transfer through DMA to be complete */
    745                  sEETimeout = sEE_LONG_TIMEOUT;
   \   000001F0   ....               LDR.N    R0,??DataTable10_13
   \   000001F2   4FF42041           MOV      R1,#+40960
   \   000001F6   0160               STR      R1,[R0, #+0]
    746                  while (sEEDataNum > 0)
   \                     ??sEE_WriteBuffer_17:
   \   000001F8   ....               LDR.N    R0,??DataTable10_23
   \   000001FA   0078               LDRB     R0,[R0, #+0]
   \   000001FC   0128               CMP      R0,#+1
   \   000001FE   09D3               BCC.N    ??sEE_WriteBuffer_18
    747                  {
    748                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
   \   00000200   ....               LDR.N    R0,??DataTable10_13
   \   00000202   0068               LDR      R0,[R0, #+0]
   \   00000204   411E               SUBS     R1,R0,#+1
   \   00000206   ....               LDR.N    R2,??DataTable10_13
   \   00000208   1160               STR      R1,[R2, #+0]
   \   0000020A   0028               CMP      R0,#+0
   \   0000020C   F4D1               BNE.N    ??sEE_WriteBuffer_17
   \   0000020E   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000212   80E0               B.N      ??sEE_WriteBuffer_4
    749                  }          
    750                  sEE_WaitEepromStandbyState();        
   \                     ??sEE_WriteBuffer_18:
   \   00000214   ........           BL       sEE_WaitEepromStandbyState
   \   00000218   7DE0               B.N      ??sEE_WriteBuffer_5
    751                }     
    752              }
    753              /*!< If NumByteToWrite > sEE_PAGESIZE */
    754              else
    755              {
    756                NumByteToWrite -= count;
   \                     ??sEE_WriteBuffer_11:
   \   0000021A   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000021E   B9EB0809           SUBS     R9,R9,R8
    757                NumOfPage =  NumByteToWrite / sEE_PAGESIZE;
   \   00000222   1FFA89F9           UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000226   2020               MOVS     R0,#+32
   \   00000228   99FBF0F7           SDIV     R7,R9,R0
    758                NumOfSingle = NumByteToWrite % sEE_PAGESIZE;
   \   0000022C   1FFA89F9           UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000230   2020               MOVS     R0,#+32
   \   00000232   99FBF0F4           SDIV     R4,R9,R0
   \   00000236   04FB1094           MLS      R4,R4,R0,R9
    759                
    760                if(count != 0)
   \   0000023A   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000023E   B8F1000F           CMP      R8,#+0
   \   00000242   29D0               BEQ.N    ??sEE_WriteBuffer_19
    761                {  
    762                  /* Store the number of data to be written */
    763                  sEEDataNum = count;         
   \   00000244   ....               LDR.N    R0,??DataTable10_23
   \   00000246   80F80080           STRB     R8,[R0, #+0]
    764                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
   \   0000024A   ....               LDR.N    R2,??DataTable10_23
   \   0000024C   2900               MOVS     R1,R5
   \   0000024E   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000250   3000               MOVS     R0,R6
   \   00000252   ........           BL       sEE_WritePage
    765                  /* Wait transfer through DMA to be complete */
    766                  sEETimeout = sEE_LONG_TIMEOUT;
   \   00000256   ....               LDR.N    R0,??DataTable10_13
   \   00000258   4FF42041           MOV      R1,#+40960
   \   0000025C   0160               STR      R1,[R0, #+0]
    767                  while (sEEDataNum > 0)
   \                     ??sEE_WriteBuffer_20:
   \   0000025E   ....               LDR.N    R0,??DataTable10_23
   \   00000260   0078               LDRB     R0,[R0, #+0]
   \   00000262   0128               CMP      R0,#+1
   \   00000264   09D3               BCC.N    ??sEE_WriteBuffer_21
    768                  {
    769                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
   \   00000266   ....               LDR.N    R0,??DataTable10_13
   \   00000268   0068               LDR      R0,[R0, #+0]
   \   0000026A   411E               SUBS     R1,R0,#+1
   \   0000026C   ....               LDR.N    R2,??DataTable10_13
   \   0000026E   1160               STR      R1,[R2, #+0]
   \   00000270   0028               CMP      R0,#+0
   \   00000272   F4D1               BNE.N    ??sEE_WriteBuffer_20
   \   00000274   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000278   4DE0               B.N      ??sEE_WriteBuffer_4
    770                  }     
    771                  sEE_WaitEepromStandbyState();
   \                     ??sEE_WriteBuffer_21:
   \   0000027A   ........           BL       sEE_WaitEepromStandbyState
    772                  WriteAddr += count;
   \   0000027E   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000282   18EB0505           ADDS     R5,R8,R5
    773                  pBuffer += count;
   \   00000286   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000028A   18EB0606           ADDS     R6,R8,R6
   \   0000028E   03E0               B.N      ??sEE_WriteBuffer_19
    774                } 
    775                
    776                while(NumOfPage--)
    777                {
    778                  /* Store the number of data to be written */
    779                  sEEDataNum = sEE_PAGESIZE;          
    780                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
    781                  /* Wait transfer through DMA to be complete */
    782                  sEETimeout = sEE_LONG_TIMEOUT;
    783                  while (sEEDataNum > 0)
    784                  {
    785                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
    786                  }        
    787                  sEE_WaitEepromStandbyState();
   \                     ??sEE_WriteBuffer_22:
   \   00000290   ........           BL       sEE_WaitEepromStandbyState
    788                  WriteAddr +=  sEE_PAGESIZE;
   \   00000294   2035               ADDS     R5,R5,#+32
    789                  pBuffer += sEE_PAGESIZE;  
   \   00000296   2036               ADDS     R6,R6,#+32
   \                     ??sEE_WriteBuffer_19:
   \   00000298   3800               MOVS     R0,R7
   \   0000029A   471E               SUBS     R7,R0,#+1
   \   0000029C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000029E   0028               CMP      R0,#+0
   \   000002A0   1AD0               BEQ.N    ??sEE_WriteBuffer_23
   \   000002A2   ....               LDR.N    R0,??DataTable10_23
   \   000002A4   2021               MOVS     R1,#+32
   \   000002A6   0170               STRB     R1,[R0, #+0]
   \   000002A8   ....               LDR.N    R2,??DataTable10_23
   \   000002AA   2900               MOVS     R1,R5
   \   000002AC   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000002AE   3000               MOVS     R0,R6
   \   000002B0   ........           BL       sEE_WritePage
   \   000002B4   ....               LDR.N    R0,??DataTable10_13
   \   000002B6   4FF42041           MOV      R1,#+40960
   \   000002BA   0160               STR      R1,[R0, #+0]
   \                     ??sEE_WriteBuffer_24:
   \   000002BC   ....               LDR.N    R0,??DataTable10_23
   \   000002BE   0078               LDRB     R0,[R0, #+0]
   \   000002C0   0128               CMP      R0,#+1
   \   000002C2   E5D3               BCC.N    ??sEE_WriteBuffer_22
   \   000002C4   ....               LDR.N    R0,??DataTable10_13
   \   000002C6   0068               LDR      R0,[R0, #+0]
   \   000002C8   411E               SUBS     R1,R0,#+1
   \   000002CA   ....               LDR.N    R2,??DataTable10_13
   \   000002CC   1160               STR      R1,[R2, #+0]
   \   000002CE   0028               CMP      R0,#+0
   \   000002D0   F4D1               BNE.N    ??sEE_WriteBuffer_24
   \   000002D2   ........           BL       sEE_TIMEOUT_UserCallback
   \   000002D6   1EE0               B.N      ??sEE_WriteBuffer_4
    790                }
    791                if(NumOfSingle != 0)
   \                     ??sEE_WriteBuffer_23:
   \   000002D8   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002DA   002C               CMP      R4,#+0
   \   000002DC   1BD0               BEQ.N    ??sEE_WriteBuffer_5
    792                {
    793                  /* Store the number of data to be written */
    794                  sEEDataNum = NumOfSingle;           
   \   000002DE   ....               LDR.N    R0,??DataTable10_23
   \   000002E0   0470               STRB     R4,[R0, #+0]
    795                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum)); 
   \   000002E2   ....               LDR.N    R2,??DataTable10_23
   \   000002E4   2900               MOVS     R1,R5
   \   000002E6   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000002E8   3000               MOVS     R0,R6
   \   000002EA   ........           BL       sEE_WritePage
    796                  /* Wait transfer through DMA to be complete */
    797                  sEETimeout = sEE_LONG_TIMEOUT;
   \   000002EE   ....               LDR.N    R0,??DataTable10_13
   \   000002F0   4FF42041           MOV      R1,#+40960
   \   000002F4   0160               STR      R1,[R0, #+0]
    798                  while (sEEDataNum > 0)
   \                     ??sEE_WriteBuffer_25:
   \   000002F6   ....               LDR.N    R0,??DataTable10_23
   \   000002F8   0078               LDRB     R0,[R0, #+0]
   \   000002FA   0128               CMP      R0,#+1
   \   000002FC   09D3               BCC.N    ??sEE_WriteBuffer_26
    799                  {
    800                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
   \   000002FE   ....               LDR.N    R0,??DataTable10_13
   \   00000300   0068               LDR      R0,[R0, #+0]
   \   00000302   411E               SUBS     R1,R0,#+1
   \   00000304   ....               LDR.N    R2,??DataTable10_13
   \   00000306   1160               STR      R1,[R2, #+0]
   \   00000308   0028               CMP      R0,#+0
   \   0000030A   F4D1               BNE.N    ??sEE_WriteBuffer_25
   \   0000030C   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000310   01E0               B.N      ??sEE_WriteBuffer_4
    801                  }         
    802                  sEE_WaitEepromStandbyState();
   \                     ??sEE_WriteBuffer_26:
   \   00000312   ........           BL       sEE_WaitEepromStandbyState
    803                }
    804              }
    805            }  
    806          }
   \                     ??sEE_WriteBuffer_5:
   \                     ??sEE_WriteBuffer_4:
   \   00000316   BDE8F183           POP      {R0,R4-R9,PC}    ;; return
    807          
    808          /**
    809            * @brief  Wait for EEPROM Standby state.
    810            * 
    811            * @note  This function allows to wait and check that EEPROM has finished the 
    812            *        last operation. It is mostly used after Write operation: after receiving
    813            *        the buffer to be written, the EEPROM may need additional time to actually
    814            *        perform the write operation. During this time, it doesn't answer to
    815            *        I2C packets addressed to it. Once the write operation is complete
    816            *        the EEPROM responds to its address.
    817            * 
    818            * @param  None
    819            * @retval sEE_OK (0) if operation is correctly performed, else return value 
    820            *         different from sEE_OK (0) or the timeout user callback.
    821            */

   \                                 In section .text, align 2, keep-with-next
    822          uint32_t sEE_WaitEepromStandbyState(void)      
    823          {
   \                     sEE_WaitEepromStandbyState:
   \   00000000   1CB5               PUSH     {R2-R4,LR}
    824            __IO uint16_t tmpSR1 = 0;
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   ADF80000           STRH     R0,[SP, #+0]
    825            __IO uint32_t sEETrials = 0;
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   0190               STR      R0,[SP, #+4]
    826          
    827            /*!< While the bus is busy */
    828            sEETimeout = sEE_LONG_TIMEOUT;
   \   0000000C   ....               LDR.N    R0,??DataTable10_13
   \   0000000E   4FF42041           MOV      R1,#+40960
   \   00000012   0160               STR      R1,[R0, #+0]
    829            while(I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_BUSY))
   \                     ??sEE_WaitEepromStandbyState_0:
   \   00000014   5FF40031           MOVS     R1,#+131072
   \   00000018   ....               LDR.N    R0,??DataTable10_1  ;; 0x40005800
   \   0000001A   ........           BL       I2C_GetFlagStatus
   \   0000001E   0028               CMP      R0,#+0
   \   00000020   09D0               BEQ.N    ??sEE_WaitEepromStandbyState_1
    830            {
    831              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000022   ....               LDR.N    R0,??DataTable10_13
   \   00000024   0068               LDR      R0,[R0, #+0]
   \   00000026   411E               SUBS     R1,R0,#+1
   \   00000028   ....               LDR.N    R2,??DataTable10_13
   \   0000002A   1160               STR      R1,[R2, #+0]
   \   0000002C   0028               CMP      R0,#+0
   \   0000002E   F1D1               BNE.N    ??sEE_WaitEepromStandbyState_0
   \   00000030   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000034   4FE0               B.N      ??sEE_WaitEepromStandbyState_2
    832            }
    833          
    834            /* Keep looping till the slave acknowledge his address or maximum number 
    835               of trials is reached (this number is defined by sEE_MAX_TRIALS_NUMBER define
    836               in stm322xg_eval_i2c_ee.h file) */
    837            while (1)
    838            {
    839              /*!< Send START condition */
    840              I2C_GenerateSTART(sEE_I2C, ENABLE);
   \                     ??sEE_WaitEepromStandbyState_1:
   \   00000036   0121               MOVS     R1,#+1
   \   00000038   ....               LDR.N    R0,??DataTable10_1  ;; 0x40005800
   \   0000003A   ........           BL       I2C_GenerateSTART
    841          
    842              /*!< Test on EV5 and clear it */
    843              sEETimeout = sEE_FLAG_TIMEOUT;
   \   0000003E   ....               LDR.N    R0,??DataTable10_13
   \   00000040   4FF48051           MOV      R1,#+4096
   \   00000044   0160               STR      R1,[R0, #+0]
    844              while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
   \                     ??sEE_WaitEepromStandbyState_3:
   \   00000046   ....               LDR.N    R1,??DataTable10_14  ;; 0x30001
   \   00000048   ....               LDR.N    R0,??DataTable10_1  ;; 0x40005800
   \   0000004A   ........           BL       I2C_CheckEvent
   \   0000004E   0028               CMP      R0,#+0
   \   00000050   09D1               BNE.N    ??sEE_WaitEepromStandbyState_4
    845              {
    846                if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000052   ....               LDR.N    R0,??DataTable10_13
   \   00000054   0068               LDR      R0,[R0, #+0]
   \   00000056   411E               SUBS     R1,R0,#+1
   \   00000058   ....               LDR.N    R2,??DataTable10_13
   \   0000005A   1160               STR      R1,[R2, #+0]
   \   0000005C   0028               CMP      R0,#+0
   \   0000005E   F2D1               BNE.N    ??sEE_WaitEepromStandbyState_3
   \   00000060   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000064   37E0               B.N      ??sEE_WaitEepromStandbyState_2
    847              }    
    848          
    849              /*!< Send EEPROM address for write */
    850              I2C_Send7bitAddress(sEE_I2C, sEEAddress, I2C_Direction_Transmitter);
   \                     ??sEE_WaitEepromStandbyState_4:
   \   00000066   0022               MOVS     R2,#+0
   \   00000068   ....               LDR.N    R0,??DataTable10_11
   \   0000006A   0188               LDRH     R1,[R0, #+0]
   \   0000006C   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006E   ....               LDR.N    R0,??DataTable10_1  ;; 0x40005800
   \   00000070   ........           BL       I2C_Send7bitAddress
    851              
    852              /* Wait for ADDR flag to be set (Slave acknowledged his address) */
    853              sEETimeout = sEE_LONG_TIMEOUT;
   \   00000074   ....               LDR.N    R0,??DataTable10_13
   \   00000076   4FF42041           MOV      R1,#+40960
   \   0000007A   0160               STR      R1,[R0, #+0]
    854              do
    855              {     
    856                /* Get the current value of the SR1 register */
    857                tmpSR1 = sEE_I2C->SR1;
   \                     ??sEE_WaitEepromStandbyState_5:
   \   0000007C   ....               LDR.N    R0,??DataTable10_24  ;; 0x40005814
   \   0000007E   0088               LDRH     R0,[R0, #+0]
   \   00000080   ADF80000           STRH     R0,[SP, #+0]
    858                
    859                /* Update the timeout value and exit if it reach 0 */
    860                if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000084   ....               LDR.N    R0,??DataTable10_13
   \   00000086   0068               LDR      R0,[R0, #+0]
   \   00000088   411E               SUBS     R1,R0,#+1
   \   0000008A   ....               LDR.N    R2,??DataTable10_13
   \   0000008C   1160               STR      R1,[R2, #+0]
   \   0000008E   0028               CMP      R0,#+0
   \   00000090   02D1               BNE.N    ??sEE_WaitEepromStandbyState_6
   \   00000092   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000096   1EE0               B.N      ??sEE_WaitEepromStandbyState_2
    861              }
    862              /* Keep looping till the Address is acknowledged or the AF flag is 
    863                 set (address not acknowledged at time) */
    864              while((tmpSR1 & (I2C_SR1_ADDR | I2C_SR1_AF)) == 0);
   \                     ??sEE_WaitEepromStandbyState_6:
   \   00000098   BDF80000           LDRH     R0,[SP, #+0]
   \   0000009C   40F20241           MOVW     R1,#+1026
   \   000000A0   0842               TST      R0,R1
   \   000000A2   EBD0               BEQ.N    ??sEE_WaitEepromStandbyState_5
    865               
    866              /* Check if the ADDR flag has been set */
    867              if (tmpSR1 & I2C_SR1_ADDR)
   \   000000A4   BDF80000           LDRH     R0,[SP, #+0]
   \   000000A8   8007               LSLS     R0,R0,#+30
   \   000000AA   07D5               BPL.N    ??sEE_WaitEepromStandbyState_7
    868              {
    869                /* Clear ADDR Flag by reading SR1 then SR2 registers (SR1 have already 
    870                   been read) */
    871                (void)sEE_I2C->SR2;
   \   000000AC   ....               LDR.N    R0,??DataTable10_19  ;; 0x40005818
   \   000000AE   0488               LDRH     R4,[R0, #+0]
    872                
    873                /*!< STOP condition */    
    874                I2C_GenerateSTOP(sEE_I2C, ENABLE);
   \   000000B0   0121               MOVS     R1,#+1
   \   000000B2   ....               LDR.N    R0,??DataTable10_1  ;; 0x40005800
   \   000000B4   ........           BL       I2C_GenerateSTOP
    875                  
    876                /* Exit the function */
    877                return sEE_OK;
   \   000000B8   0020               MOVS     R0,#+0
   \   000000BA   0CE0               B.N      ??sEE_WaitEepromStandbyState_2
    878              }
    879              else
    880              {
    881                /*!< Clear AF flag */
    882                I2C_ClearFlag(sEE_I2C, I2C_FLAG_AF);                  
   \                     ??sEE_WaitEepromStandbyState_7:
   \   000000BC   ....               LDR.N    R1,??DataTable10_25  ;; 0x10000400
   \   000000BE   ....               LDR.N    R0,??DataTable10_1  ;; 0x40005800
   \   000000C0   ........           BL       I2C_ClearFlag
    883              }
    884              
    885              /* Check if the maximum allowed number of trials has bee reached */
    886              if (sEETrials++ == sEE_MAX_TRIALS_NUMBER)
   \   000000C4   0198               LDR      R0,[SP, #+4]
   \   000000C6   411C               ADDS     R1,R0,#+1
   \   000000C8   0191               STR      R1,[SP, #+4]
   \   000000CA   4FF49671           MOV      R1,#+300
   \   000000CE   8842               CMP      R0,R1
   \   000000D0   B1D1               BNE.N    ??sEE_WaitEepromStandbyState_1
    887              {
    888                /* If the maximum number of trials has been reached, exit the function */
    889                return sEE_TIMEOUT_UserCallback();
   \   000000D2   ........           BL       sEE_TIMEOUT_UserCallback
   \                     ??sEE_WaitEepromStandbyState_2:
   \   000000D6   16BD               POP      {R1,R2,R4,PC}    ;; return
    890              }
    891            }
    892          }
    893          
    894          /**
    895            * @brief  This function handles the DMA Tx Channel interrupt Handler.
    896            * @param  None
    897            * @retval None
    898            */

   \                                 In section .text, align 2, keep-with-next
    899          void DMA1_Stream4_IRQHandler(void)
    900          {
   \                     DMA1_Stream4_IRQHandler:
   \   00000000   80B5               PUSH     {R7,LR}
    901            /* Check if the DMA transfer is complete */
    902            if(DMA_GetFlagStatus(sEE_I2C_DMA_STREAM_TX, sEE_TX_DMA_FLAG_TCIF) != RESET)
   \   00000002   ....               LDR.N    R1,??DataTable10_26  ;; 0x20000020
   \   00000004   ....               LDR.N    R0,??DataTable10_4  ;; 0x40026070
   \   00000006   ........           BL       DMA_GetFlagStatus
   \   0000000A   0028               CMP      R0,#+0
   \   0000000C   23D0               BEQ.N    ??DMA1_Stream4_IRQHandler_0
    903            {  
    904              /* Disable the DMA Tx Stream and Clear TC flag */  
    905              DMA_Cmd(sEE_I2C_DMA_STREAM_TX, DISABLE);
   \   0000000E   0021               MOVS     R1,#+0
   \   00000010   ....               LDR.N    R0,??DataTable10_4  ;; 0x40026070
   \   00000012   ........           BL       DMA_Cmd
    906              DMA_ClearFlag(sEE_I2C_DMA_STREAM_TX, sEE_TX_DMA_FLAG_TCIF);
   \   00000016   ....               LDR.N    R1,??DataTable10_26  ;; 0x20000020
   \   00000018   ....               LDR.N    R0,??DataTable10_4  ;; 0x40026070
   \   0000001A   ........           BL       DMA_ClearFlag
    907          
    908              /*!< Wait till all data have been physically transferred on the bus */
    909              sEETimeout = sEE_LONG_TIMEOUT;
   \   0000001E   ....               LDR.N    R0,??DataTable10_13
   \   00000020   4FF42041           MOV      R1,#+40960
   \   00000024   0160               STR      R1,[R0, #+0]
   \   00000026   08E0               B.N      ??DMA1_Stream4_IRQHandler_1
    910              while(!I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_BTF))
    911              {
    912                if((sEETimeout--) == 0) sEE_TIMEOUT_UserCallback();
   \                     ??DMA1_Stream4_IRQHandler_2:
   \   00000028   ....               LDR.N    R0,??DataTable10_13
   \   0000002A   0068               LDR      R0,[R0, #+0]
   \   0000002C   411E               SUBS     R1,R0,#+1
   \   0000002E   ....               LDR.N    R2,??DataTable10_13
   \   00000030   1160               STR      R1,[R2, #+0]
   \   00000032   0028               CMP      R0,#+0
   \   00000034   01D1               BNE.N    ??DMA1_Stream4_IRQHandler_1
   \   00000036   ........           BL       sEE_TIMEOUT_UserCallback
    913              }
   \                     ??DMA1_Stream4_IRQHandler_1:
   \   0000003A   ....               LDR.N    R1,??DataTable10_17  ;; 0x10000004
   \   0000003C   ....               LDR.N    R0,??DataTable10_1  ;; 0x40005800
   \   0000003E   ........           BL       I2C_GetFlagStatus
   \   00000042   0028               CMP      R0,#+0
   \   00000044   F0D0               BEQ.N    ??DMA1_Stream4_IRQHandler_2
    914              
    915              /*!< Send STOP condition */
    916              I2C_GenerateSTOP(sEE_I2C, ENABLE);
   \   00000046   0121               MOVS     R1,#+1
   \   00000048   ....               LDR.N    R0,??DataTable10_1  ;; 0x40005800
   \   0000004A   ........           BL       I2C_GenerateSTOP
    917              
    918              /* Reset the variable holding the number of data to be written */
    919              *sEEDataWritePointer = 0;  
   \   0000004E   ....               LDR.N    R0,??DataTable10_22
   \   00000050   0068               LDR      R0,[R0, #+0]
   \   00000052   0021               MOVS     R1,#+0
   \   00000054   0170               STRB     R1,[R0, #+0]
    920            }
    921          }
   \                     ??DMA1_Stream4_IRQHandler_0:
   \   00000056   01BD               POP      {R0,PC}          ;; return
    922          
    923          /**
    924            * @brief  This function handles the DMA Rx Channel interrupt Handler.
    925            * @param  None
    926            * @retval None
    927            */

   \                                 In section .text, align 2, keep-with-next
    928          void DMA1_Stream5_IRQHandler(void)
    929          {
   \                     DMA1_Stream5_IRQHandler:
   \   00000000   80B5               PUSH     {R7,LR}
    930            /* Check if the DMA transfer is complete */
    931            if(DMA_GetFlagStatus(sEE_I2C_DMA_STREAM_RX, sEE_RX_DMA_FLAG_TCIF) != RESET)
   \   00000002   ....               LDR.N    R1,??DataTable10_27  ;; 0x20000800
   \   00000004   ....               LDR.N    R0,??DataTable10_5  ;; 0x40026088
   \   00000006   ........           BL       DMA_GetFlagStatus
   \   0000000A   0028               CMP      R0,#+0
   \   0000000C   0FD0               BEQ.N    ??DMA1_Stream5_IRQHandler_0
    932            {      
    933              /*!< Send STOP Condition */
    934              I2C_GenerateSTOP(sEE_I2C, ENABLE);    
   \   0000000E   0121               MOVS     R1,#+1
   \   00000010   ....               LDR.N    R0,??DataTable10_1  ;; 0x40005800
   \   00000012   ........           BL       I2C_GenerateSTOP
    935              
    936              /* Disable the DMA Rx Stream and Clear TC Flag */  
    937              DMA_Cmd(sEE_I2C_DMA_STREAM_RX, DISABLE);
   \   00000016   0021               MOVS     R1,#+0
   \   00000018   ....               LDR.N    R0,??DataTable10_5  ;; 0x40026088
   \   0000001A   ........           BL       DMA_Cmd
    938              DMA_ClearFlag(sEE_I2C_DMA_STREAM_RX, sEE_RX_DMA_FLAG_TCIF);
   \   0000001E   ....               LDR.N    R1,??DataTable10_27  ;; 0x20000800
   \   00000020   ....               LDR.N    R0,??DataTable10_5  ;; 0x40026088
   \   00000022   ........           BL       DMA_ClearFlag
    939              
    940              /* Reset the variable holding the number of data to be read */
    941              *sEEDataReadPointer = 0;
   \   00000026   ....               LDR.N    R0,??DataTable10_12
   \   00000028   0068               LDR      R0,[R0, #+0]
   \   0000002A   0021               MOVS     R1,#+0
   \   0000002C   0180               STRH     R1,[R0, #+0]
    942            }
    943          }
   \                     ??DMA1_Stream5_IRQHandler_0:
   \   0000002E   01BD               POP      {R0,PC}          ;; return
    944          
    945          //#ifdef USE_DEFAULT_TIMEOUT_CALLBACK
    946          /**
    947            * @brief  Basic management of the timeout situation.
    948            * @param  None.
    949            * @retval None.
    950            */

   \                                 In section .text, align 2, keep-with-next
    951          uint32_t sEE_TIMEOUT_UserCallback(void)
    952          {
    953            /* Block communication and all processes */
    954            //while (1)
    955            {   
    956            }
    957          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "sEE_TIMEOUT_UserCallback"
   \                     sEE_TIMEOUT_UserCallback:
   \   00000000   7047               BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   00180240           DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   00580040           DC32     0x40005800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   00040240           DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   ........           DC32     NVIC_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   70600240           DC32     0x40026070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   88600240           DC32     0x40026088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   3D000020           DC32     0x2000003d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   ........           DC32     sEEDMA_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   10580040           DC32     0x40005810

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   400F0020           DC32     0x20000f40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   A0860100           DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   ........           DC32     sEEAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   ........           DC32     sEEDataReadPointer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   ........           DC32     sEETimeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   01000300           DC32     0x30001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \   00000000   82000700           DC32     0x70082

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_16:
   \   00000000   80000700           DC32     0x70080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_17:
   \   00000000   04000010           DC32     0x10000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_18:
   \   00000000   02000010           DC32     0x10000002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_19:
   \   00000000   18580040           DC32     0x40005818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_20:
   \   00000000   40000010           DC32     0x10000040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_21:
   \   00000000   02000300           DC32     0x30002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_22:
   \   00000000   ........           DC32     sEEDataWritePointer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_23:
   \   00000000   ........           DC32     sEEDataNum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_24:
   \   00000000   14580040           DC32     0x40005814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_25:
   \   00000000   00040010           DC32     0x10000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_26:
   \   00000000   20000020           DC32     0x20000020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_27:
   \   00000000   00080020           DC32     0x20000800
    958          //#endif /* USE_DEFAULT_TIMEOUT_CALLBACK */
    959          
    960          /**
    961            * @}
    962            */
    963          
    964          /**
    965            * @}
    966            */
    967          
    968          /**
    969            * @}
    970            */
    971          
    972          /**
    973            * @}
    974            */
    975          
    976          /**
    977            * @}
    978            */  
    979          
    980          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                   .cstack
     --------                   -------
     DMA1_Stream4_IRQHandler         8
     DMA1_Stream5_IRQHandler         8
     EE_ENABLE                       8
     sEE_DeInit                      8
     sEE_Init                       24
     sEE_LowLevel_DMAConfig          8
     sEE_LowLevel_DeInit            16
     sEE_LowLevel_Init              16
     sEE_ReadBuffer                 16
     sEE_TIMEOUT_UserCallback        0
     sEE_WaitEepromStandbyState     16
     sEE_WriteBuffer                32
     sEE_WritePage                  16


   Section sizes:

     Function/Label             Bytes
     --------------             -----
     EE_ENABLE                    16
     sEEDMA_InitStructure         60
     NVIC_InitStructure            4
     sEEAddress                    2
     sEETimeout                    4
     sEEDataReadPointer            4
     sEEDataWritePointer           4
     sEEDataNum                    1
     sEE_LowLevel_DeInit         186
     sEE_LowLevel_Init           490
     sEE_LowLevel_DMAConfig       74
     sEE_DeInit                    8
     sEE_Init                     92
     sEE_ReadBuffer              684
     sEE_WritePage               362
     sEE_WriteBuffer             794
     sEE_WaitEepromStandbyState  216
     DMA1_Stream4_IRQHandler      88
     DMA1_Stream5_IRQHandler      48
     sEE_TIMEOUT_UserCallback      2
     ??DataTable10                 4
     ??DataTable10_1               4
     ??DataTable10_2               4
     ??DataTable10_3               4
     ??DataTable10_4               4
     ??DataTable10_5               4
     ??DataTable10_6               4
     ??DataTable10_7               4
     ??DataTable10_8               4
     ??DataTable10_9               4
     ??DataTable10_10              4
     ??DataTable10_11              4
     ??DataTable10_12              4
     ??DataTable10_13              4
     ??DataTable10_14              4
     ??DataTable10_15              4
     ??DataTable10_16              4
     ??DataTable10_17              4
     ??DataTable10_18              4
     ??DataTable10_19              4
     ??DataTable10_20              4
     ??DataTable10_21              4
     ??DataTable10_22              4
     ??DataTable10_23              4
     ??DataTable10_24              4
     ??DataTable10_25              4
     ??DataTable10_26              4
     ??DataTable10_27              4

 
    75 bytes in section .bss
     4 bytes in section .data
 3 172 bytes in section .text
 
 3 172 bytes of CODE memory
    79 bytes of DATA memory

Errors: none
Warnings: 2
