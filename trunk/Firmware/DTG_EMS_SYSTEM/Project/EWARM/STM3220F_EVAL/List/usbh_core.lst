###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     19/Jan/2012  11:08:54 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32_ #
#                    USB_HOST_Library\Core\src\usbh_core.c                    #
#    Command line =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32_ #
#                    USB_HOST_Library\Core\src\usbh_core.c -D                 #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D RTC_CLOCK_SOURCE_LSE -lC            #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\ -lA F:\Work\S&G2000\Firmware\DTG_EMS_S #
#                    YSTEM\Project\EWARM\STM3220F_EVAL\List\ -o               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\Obj\ --no_cse --no_unroll --no_inline        #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\ #
#                    EWARM\..\ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Pro #
#                    ject\EWARM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I     #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I         #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\ -I                             #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\Common\ -I                      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_OTG_Driver\inc\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Core\inc\ -I      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\msc\inc\    #
#                    -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM #
#                    \..\Usb\ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Proj #
#                    ect\EWARM\..\Usb\Inc\ -I F:\Work\S&G2000\Firmware\DTG_EM #
#                    S_SYSTEM\Project\EWARM\..\Usb\src\ -I                    #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Core\inc\ -I        #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -Ol --use_c++_inline                                     #
#    List file    =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\usbh_core.lst                           #
#    Object file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\Obj\usbh_core.o                              #
#                                                                             #
#                                                                             #
###############################################################################

F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32_USB_HOST_Library\Core\src\usbh_core.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbh_core.c 
      4            * @author  MCD Application Team
      5            * @version V2.0.0RC1
      6            * @date    18-March-2011
      7            * @brief   This file implements the functions for the core state machine process
      8            *          the enumeration and the control transfer process
      9            ******************************************************************************
     10            * @attention
     11            *
     12            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     13            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     14            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     15            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     16            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     17            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     18            *
     19            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     20            ******************************************************************************
     21            */ 
     22          /* Includes ------------------------------------------------------------------*/
     23          
     24          #include "usbh_ioreq.h"
     25          #include "usb_bsp.h"
     26          #include "usbh_hcs.h"
     27          #include "usbh_stdreq.h"
     28          #include "usbh_core.h"
     29          
     30          
     31          /** @addtogroup USBH_LIB
     32            * @{
     33            */
     34          
     35          /** @addtogroup USBH_LIB_CORE
     36          * @{
     37          */
     38          
     39          /** @defgroup USBH_CORE 
     40            * @brief TThis file handles the basic enumaration when a device is connected 
     41            *          to the host.
     42            * @{
     43            */ 
     44          
     45          /** @defgroup USBH_CORE_Private_TypesDefinitions
     46            * @{
     47            */ 
     48          void USBH_Disconnect (void *pdev); 
     49          void USBH_Connect (void *pdev); 
     50          

   \                                 In section .data, align 4
     51          USB_OTG_hPort_TypeDef  USBH_DeviceConnStatus_cb = 
   \                     USBH_DeviceConnStatus_cb:
   \   00000000   ............       DC32 USBH_Disconnect, USBH_Connect
   \              ....        
   \   00000008   00000000           DC8 0, 0, 0, 0
     52          {
     53            USBH_Disconnect,
     54            USBH_Connect,
     55            0,
     56            0,
     57            0,
     58            0
     59          };
     60          /**
     61            * @}
     62            */ 
     63          
     64          
     65          /** @defgroup USBH_CORE_Private_Defines
     66            * @{
     67            */ 
     68          /**
     69            * @}
     70            */ 
     71          
     72          
     73          /** @defgroup USBH_CORE_Private_Macros
     74            * @{
     75            */ 
     76          /**
     77            * @}
     78            */ 
     79          
     80          
     81          /** @defgroup USBH_CORE_Private_Variables
     82            * @{
     83            */ 
     84          /**
     85            * @}
     86            */ 
     87          
     88          
     89          /** @defgroup USBH_CORE_Private_FunctionPrototypes
     90            * @{
     91            */
     92          static USBH_Status USBH_HandleEnum(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost);
     93          USBH_Status USBH_HandleControl (USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost);
     94          
     95          /**
     96            * @}
     97            */ 
     98          
     99          
    100          /** @defgroup USBH_CORE_Private_Functions
    101            * @{
    102            */ 
    103          
    104          
    105          /**
    106            * @brief  USBH_Connect
    107            *         USB Connect callback function from the Interrupt. 
    108            * @param  selected device
    109            * @retval none
    110            */

   \                                 In section .text, align 2, keep-with-next
    111          void USBH_Connect (void *pdev)
    112          {
    113            USB_OTG_CORE_HANDLE *ppdev = pdev;
    114            ppdev->host.port_cb->ConnStatus = 1;
   \                     USBH_Connect:
   \   00000000   D0F88819           LDR      R1,[R0, #+2440]
   \   00000004   0122               MOVS     R2,#+1
   \   00000006   0A72               STRB     R2,[R1, #+8]
    115            ppdev->host.port_cb->ConnHandled = 0; 
   \   00000008   D0F88809           LDR      R0,[R0, #+2440]
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   8172               STRB     R1,[R0, #+10]
    116          }
   \   00000010   7047               BX       LR               ;; return
    117          
    118          /**
    119            * @brief  USBH_Disconnect
    120            *         USB Disconnect callback function from the Interrupt. 
    121            * @param  selected device
    122            * @retval none
    123            */
    124          

   \                                 In section .text, align 2, keep-with-next
    125          void USBH_Disconnect (void *pdev)
    126          {
    127            
    128            USB_OTG_CORE_HANDLE *ppdev = pdev;
    129              
    130            /* Make device Not connected flag true */
    131            ppdev->host.port_cb->DisconnStatus = 1; 
   \                     USBH_Disconnect:
   \   00000000   D0F88819           LDR      R1,[R0, #+2440]
   \   00000004   0122               MOVS     R2,#+1
   \   00000006   4A72               STRB     R2,[R1, #+9]
    132            ppdev->host.port_cb->DisconnHandled = 0;
   \   00000008   D0F88809           LDR      R0,[R0, #+2440]
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   C172               STRB     R1,[R0, #+11]
    133          }
   \   00000010   7047               BX       LR               ;; return
    134          
    135          /**
    136            * @brief  USBH_Init
    137            *         Host hardware and stack initializations 
    138            * @param  class_cb: Class callback structure address
    139            * @param  usr_cb: User callback structure address
    140            * @retval None
    141            */

   \                                 In section .text, align 2, keep-with-next
    142          void USBH_Init(USB_OTG_CORE_HANDLE *pdev,
    143                         USB_OTG_CORE_ID_TypeDef coreID,
    144                         USBH_HOST *phost,               
    145                         USBH_Class_cb_TypeDef *class_cb, 
    146                         USBH_Usr_cb_TypeDef *usr_cb)
    147          {
   \                     USBH_Init:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   0400               MOVS     R4,R0
   \   00000006   0D00               MOVS     R5,R1
   \   00000008   1600               MOVS     R6,R2
   \   0000000A   1F00               MOVS     R7,R3
   \   0000000C   DDF81880           LDR      R8,[SP, #+24]
    148               
    149            /* Hardware Init */
    150            USB_OTG_BSP_Init(pdev);  
   \   00000010   2000               MOVS     R0,R4
   \   00000012   ........           BL       USB_OTG_BSP_Init
    151            
    152            /* configure GPIO pin used for switching VBUS power */
    153            //USB_OTG_BSP_ConfigVBUS(0);  
    154            
    155            
    156            /* Host de-initializations */
    157            USBH_DeInit(pdev, phost);
   \   00000016   3100               MOVS     R1,R6
   \   00000018   2000               MOVS     R0,R4
   \   0000001A   ........           BL       USBH_DeInit
    158            
    159            /*Register class and user callbacks */
    160            phost->class_cb = class_cb;
   \   0000001E   F767               STR      R7,[R6, #+124]
    161            phost->usr_cb = usr_cb;  
   \   00000020   C6F88080           STR      R8,[R6, #+128]
    162            pdev->host.port_cb = &USBH_DeviceConnStatus_cb;
   \   00000024   ........           LDR.W    R0,??DataTable3_1
   \   00000028   C4F88809           STR      R0,[R4, #+2440]
    163            
    164            pdev->host.port_cb->ConnStatus = 0;   
   \   0000002C   D4F88809           LDR      R0,[R4, #+2440]
   \   00000030   0021               MOVS     R1,#+0
   \   00000032   0172               STRB     R1,[R0, #+8]
    165            pdev->host.port_cb->DisconnStatus = 0; 
   \   00000034   D4F88809           LDR      R0,[R4, #+2440]
   \   00000038   0021               MOVS     R1,#+0
   \   0000003A   4172               STRB     R1,[R0, #+9]
    166            
    167              
    168            /* Start the USB OTG core */     
    169             HCD_Init(pdev , coreID);
   \   0000003C   2900               MOVS     R1,R5
   \   0000003E   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000040   2000               MOVS     R0,R4
   \   00000042   ........           BL       HCD_Init
    170             
    171            /* Upon Init call usr call back */
    172            phost->usr_cb->Init();
   \   00000046   D6F88000           LDR      R0,[R6, #+128]
   \   0000004A   0068               LDR      R0,[R0, #+0]
   \   0000004C   8047               BLX      R0
    173            
    174            /* Enable Interrupts */
    175            USB_OTG_BSP_EnableInterrupt(pdev);
   \   0000004E   2000               MOVS     R0,R4
   \   00000050   ........           BL       USB_OTG_BSP_EnableInterrupt
    176          }
   \   00000054   BDE8F081           POP      {R4-R8,PC}       ;; return
    177          
    178          /**
    179            * @brief  USBH_DeInit 
    180            *         Re-Initialize Host
    181            * @param  None 
    182            * @retval status: USBH_Status
    183            */

   \                                 In section .text, align 2, keep-with-next
    184          USBH_Status USBH_DeInit(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
    185          {
   \                     USBH_DeInit:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    186            /* Software Init */
    187            
    188            phost->gState = HOST_IDLE;
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   2870               STRB     R0,[R5, #+0]
    189            phost->gStateBkp = HOST_IDLE; 
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   6870               STRB     R0,[R5, #+1]
    190            phost->EnumState = ENUM_IDLE;
   \   0000000E   0020               MOVS     R0,#+0
   \   00000010   A870               STRB     R0,[R5, #+2]
    191            phost->RequestState = CMD_SEND;  
   \   00000012   0120               MOVS     R0,#+1
   \   00000014   E870               STRB     R0,[R5, #+3]
    192            
    193            phost->Control.state = CTRL_SETUP;
   \   00000016   0120               MOVS     R0,#+1
   \   00000018   2877               STRB     R0,[R5, #+28]
    194            phost->Control.ep0size = USB_OTG_MAX_EP0_SIZE;  
   \   0000001A   4020               MOVS     R0,#+64
   \   0000001C   A871               STRB     R0,[R5, #+6]
    195            
    196            phost->device_prop.address = USBH_DEVICE_ADDRESS_DEFAULT;
   \   0000001E   0020               MOVS     R0,#+0
   \   00000020   85F82000           STRB     R0,[R5, #+32]
    197            phost->device_prop.speed = HPRT0_PRTSPD_FULL_SPEED;
   \   00000024   0120               MOVS     R0,#+1
   \   00000026   85F82100           STRB     R0,[R5, #+33]
    198            
    199            USBH_Free_Channel  (pdev, phost->Control.hc_num_in);
   \   0000002A   2979               LDRB     R1,[R5, #+4]
   \   0000002C   2000               MOVS     R0,R4
   \   0000002E   ........           BL       USBH_Free_Channel
    200            USBH_Free_Channel  (pdev, phost->Control.hc_num_out);  
   \   00000032   6979               LDRB     R1,[R5, #+5]
   \   00000034   2000               MOVS     R0,R4
   \   00000036   ........           BL       USBH_Free_Channel
    201            return USBH_OK;
   \   0000003A   0020               MOVS     R0,#+0
   \   0000003C   32BD               POP      {R1,R4,R5,PC}    ;; return
    202          }
    203          
    204          /**
    205          * @brief  USBH_Process
    206          *         USB Host core main state machine process
    207          * @param  None 
    208          * @retval None
    209          */

   \                                 In section .text, align 2, keep-with-next
    210          void USBH_Process(USB_OTG_CORE_HANDLE *pdev , USBH_HOST *phost)
    211          {
   \                     USBH_Process:
   \   00000000   30B5               PUSH     {R4,R5,LR}
   \   00000002   83B0               SUB      SP,SP,#+12
   \   00000004   0400               MOVS     R4,R0
   \   00000006   0D00               MOVS     R5,R1
    212            volatile USBH_Status status = USBH_FAIL;
   \   00000008   0220               MOVS     R0,#+2
   \   0000000A   8DF80000           STRB     R0,[SP, #+0]
    213              
    214            switch (phost->gState)
   \   0000000E   2878               LDRB     R0,[R5, #+0]
   \   00000010   0028               CMP      R0,#+0
   \   00000012   1FD0               BEQ.N    ??USBH_Process_0
   \   00000014   0128               CMP      R0,#+1
   \   00000016   15D0               BEQ.N    ??USBH_Process_1
   \   00000018   0228               CMP      R0,#+2
   \   0000001A   26D0               BEQ.N    ??USBH_Process_2
   \   0000001C   0628               CMP      R0,#+6
   \   0000001E   69D0               BEQ.N    ??USBH_Process_3
   \   00000020   0728               CMP      R0,#+7
   \   00000022   00F08680           BEQ.W    ??USBH_Process_4
   \   00000026   0828               CMP      R0,#+8
   \   00000028   00F09780           BEQ.W    ??USBH_Process_5
   \   0000002C   0928               CMP      R0,#+9
   \   0000002E   00F0A180           BEQ.W    ??USBH_Process_6
   \   00000032   0A28               CMP      R0,#+10
   \   00000034   6DD0               BEQ.N    ??USBH_Process_7
   \   00000036   0B28               CMP      R0,#+11
   \   00000038   00F0A180           BEQ.W    ??USBH_Process_8
   \   0000003C   0C28               CMP      R0,#+12
   \   0000003E   00F09F80           BEQ.W    ??USBH_Process_9
   \   00000042   ACE0               B.N      ??USBH_Process_10
    215            {
    216            case HOST_ISSUE_CORE_RESET :
    217               
    218              if ( HCD_ResetPort(pdev) == 0)
   \                     ??USBH_Process_1:
   \   00000044   2000               MOVS     R0,R4
   \   00000046   ........           BL       HCD_ResetPort
   \   0000004A   0028               CMP      R0,#+0
   \   0000004C   01D1               BNE.N    ??USBH_Process_11
    219              {
    220                phost->gState = HOST_IDLE;
   \   0000004E   0020               MOVS     R0,#+0
   \   00000050   2870               STRB     R0,[R5, #+0]
    221              }
    222              break;
   \                     ??USBH_Process_11:
   \   00000052   A4E0               B.N      ??USBH_Process_12
    223              
    224            case HOST_IDLE :
    225              
    226              if (HCD_IsDeviceConnected(pdev))  
   \                     ??USBH_Process_0:
   \   00000054   2000               MOVS     R0,R4
   \   00000056   ........           BL       HCD_IsDeviceConnected
   \   0000005A   0028               CMP      R0,#+0
   \   0000005C   04D0               BEQ.N    ??USBH_Process_13
    227              {
    228                /* Wait for USB Connect Interrupt void USBH_ISR_Connected(void) */     
    229                USBH_DeAllocate_AllChannel(pdev);
   \   0000005E   2000               MOVS     R0,R4
   \   00000060   ........           BL       USBH_DeAllocate_AllChannel
    230                phost->gState = HOST_DEV_ATTACHED;
   \   00000064   0220               MOVS     R0,#+2
   \   00000066   2870               STRB     R0,[R5, #+0]
    231              }
    232              break;
   \                     ??USBH_Process_13:
   \   00000068   99E0               B.N      ??USBH_Process_12
    233             
    234            case HOST_DEV_ATTACHED :
    235              
    236              phost->usr_cb->DeviceAttached(); 
   \                     ??USBH_Process_2:
   \   0000006A   D5F88000           LDR      R0,[R5, #+128]
   \   0000006E   8068               LDR      R0,[R0, #+8]
   \   00000070   8047               BLX      R0
    237              pdev->host.port_cb->DisconnStatus = 0; 
   \   00000072   D4F88809           LDR      R0,[R4, #+2440]
   \   00000076   0021               MOVS     R1,#+0
   \   00000078   4172               STRB     R1,[R0, #+9]
    238              pdev->host.port_cb->ConnHandled = 1;  
   \   0000007A   D4F88809           LDR      R0,[R4, #+2440]
   \   0000007E   0121               MOVS     R1,#+1
   \   00000080   8172               STRB     R1,[R0, #+10]
    239          
    240              phost->Control.hc_num_out = USBH_Alloc_Channel(pdev, 0x00);
   \   00000082   0021               MOVS     R1,#+0
   \   00000084   2000               MOVS     R0,R4
   \   00000086   ........           BL       USBH_Alloc_Channel
   \   0000008A   6871               STRB     R0,[R5, #+5]
    241              phost->Control.hc_num_in = USBH_Alloc_Channel(pdev, 0x80);  
   \   0000008C   8021               MOVS     R1,#+128
   \   0000008E   2000               MOVS     R0,R4
   \   00000090   ........           BL       USBH_Alloc_Channel
   \   00000094   2871               STRB     R0,[R5, #+4]
    242            IWDG_ReloadCounter();                   // Clear IWDG
   \   00000096   ........           BL       IWDG_ReloadCounter
    243              /* Reset USB Device */
    244              if ( HCD_ResetPort(pdev) == 0)
   \   0000009A   2000               MOVS     R0,R4
   \   0000009C   ........           BL       HCD_ResetPort
   \   000000A0   0028               CMP      R0,#+0
   \   000000A2   26D1               BNE.N    ??USBH_Process_14
    245              {
    246          //      phost->usr_cb->ResetDevice();    Call Back
    247                /*  Wait for USB USBH_ISR_PrtEnDisableChange()  
    248                Host is Now ready to start the Enumeration 
    249                */
    250                
    251                phost->device_prop.speed = HCD_GetCurrentSpeed(pdev);   // 스피드 레지스터에서 읽기
   \   000000A4   2000               MOVS     R0,R4
   \   000000A6   ........           BL       HCD_GetCurrentSpeed
   \   000000AA   85F82100           STRB     R0,[R5, #+33]
    252                
    253                phost->gState = HOST_ENUMERATION;
   \   000000AE   0620               MOVS     R0,#+6
   \   000000B0   2870               STRB     R0,[R5, #+0]
    254                phost->usr_cb->DeviceSpeedDetected(phost->device_prop.speed);   //  스피드 설정
   \   000000B2   95F82100           LDRB     R0,[R5, #+33]
   \   000000B6   D5F88010           LDR      R1,[R5, #+128]
   \   000000BA   8969               LDR      R1,[R1, #+24]
   \   000000BC   8847               BLX      R1
    255                  
    256                /* Open Control pipes */
    257                USBH_Open_Channel (pdev,
    258                                     phost->Control.hc_num_in,
    259                                     phost->device_prop.address,
    260                                     phost->device_prop.speed,
    261                                     EP_TYPE_CTRL,
    262                                     phost->Control.ep0size); 
   \   000000BE   A879               LDRB     R0,[R5, #+6]
   \   000000C0   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C2   0190               STR      R0,[SP, #+4]
   \   000000C4   0020               MOVS     R0,#+0
   \   000000C6   0090               STR      R0,[SP, #+0]
   \   000000C8   95F82130           LDRB     R3,[R5, #+33]
   \   000000CC   95F82020           LDRB     R2,[R5, #+32]
   \   000000D0   2979               LDRB     R1,[R5, #+4]
   \   000000D2   2000               MOVS     R0,R4
   \   000000D4   ........           BL       USBH_Open_Channel
    263                
    264                /* Open Control pipes */
    265                USBH_Open_Channel (pdev,
    266                                     phost->Control.hc_num_out,
    267                                     phost->device_prop.address,
    268                                     phost->device_prop.speed,
    269                                     EP_TYPE_CTRL,
    270                                     phost->Control.ep0size);          
   \   000000D8   A879               LDRB     R0,[R5, #+6]
   \   000000DA   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000DC   0190               STR      R0,[SP, #+4]
   \   000000DE   0020               MOVS     R0,#+0
   \   000000E0   0090               STR      R0,[SP, #+0]
   \   000000E2   95F82130           LDRB     R3,[R5, #+33]
   \   000000E6   95F82020           LDRB     R2,[R5, #+32]
   \   000000EA   6979               LDRB     R1,[R5, #+5]
   \   000000EC   2000               MOVS     R0,R4
   \   000000EE   ........           BL       USBH_Open_Channel
    271             }
    272              break;
   \                     ??USBH_Process_14:
   \   000000F2   54E0               B.N      ??USBH_Process_12
    273              
    274            case HOST_ENUMERATION:     
    275              /* Check for enumeration status */  
    276              if ( USBH_HandleEnum(pdev , phost) == USBH_OK)
   \                     ??USBH_Process_3:
   \   000000F4   2900               MOVS     R1,R5
   \   000000F6   2000               MOVS     R0,R4
   \   000000F8   ........           BL       USBH_HandleEnum
   \   000000FC   0028               CMP      R0,#+0
   \   000000FE   07D1               BNE.N    ??USBH_Process_15
    277              { 
    278                /* The function shall return USBH_OK when full enumeration is complete */
    279                IWDG_ReloadCounter();                   // Clear IWDG
   \   00000100   ........           BL       IWDG_ReloadCounter
    280                /* user callback for end of device basic enumeration */
    281                phost->usr_cb->EnumerationDone();
   \   00000104   D5F88000           LDR      R0,[R5, #+128]
   \   00000108   406B               LDR      R0,[R0, #+52]
   \   0000010A   8047               BLX      R0
    282                
    283                phost->gState  = HOST_USR_INPUT;    
   \   0000010C   0A20               MOVS     R0,#+10
   \   0000010E   2870               STRB     R0,[R5, #+0]
    284              }
    285              break;
   \                     ??USBH_Process_15:
   \   00000110   45E0               B.N      ??USBH_Process_12
    286              
    287            case HOST_USR_INPUT:    
    288              /*The function should return user response true to move to class state */
    289              if ( phost->usr_cb->UserInput() == USBH_USR_RESP_OK)
   \                     ??USBH_Process_7:
   \   00000112   D5F88000           LDR      R0,[R5, #+128]
   \   00000116   806B               LDR      R0,[R0, #+56]
   \   00000118   8047               BLX      R0
   \   0000011A   0128               CMP      R0,#+1
   \   0000011C   08D1               BNE.N    ??USBH_Process_16
    290              {
    291                if((phost->class_cb->Init(pdev, phost))\
    292                  == USBH_OK)
   \   0000011E   2900               MOVS     R1,R5
   \   00000120   2000               MOVS     R0,R4
   \   00000122   EA6F               LDR      R2,[R5, #+124]
   \   00000124   1268               LDR      R2,[R2, #+0]
   \   00000126   9047               BLX      R2
   \   00000128   0028               CMP      R0,#+0
   \   0000012A   01D1               BNE.N    ??USBH_Process_16
    293                {
    294                  phost->gState  = HOST_CLASS_REQUEST;     
   \   0000012C   0720               MOVS     R0,#+7
   \   0000012E   2870               STRB     R0,[R5, #+0]
    295                }     
    296              }   
    297              break;
   \                     ??USBH_Process_16:
   \   00000130   35E0               B.N      ??USBH_Process_12
    298              
    299            case HOST_CLASS_REQUEST:  
    300              /* process class standard contol requests state machine */ 
    301              status = phost->class_cb->Requests(pdev, phost);
   \                     ??USBH_Process_4:
   \   00000132   2900               MOVS     R1,R5
   \   00000134   2000               MOVS     R0,R4
   \   00000136   EA6F               LDR      R2,[R5, #+124]
   \   00000138   9268               LDR      R2,[R2, #+8]
   \   0000013A   9047               BLX      R2
   \   0000013C   8DF80000           STRB     R0,[SP, #+0]
    302              
    303               if(status == USBH_OK)
   \   00000140   9DF80000           LDRB     R0,[SP, #+0]
   \   00000144   0028               CMP      R0,#+0
   \   00000146   02D1               BNE.N    ??USBH_Process_17
    304               {
    305                 phost->gState  = HOST_CLASS;
   \   00000148   0820               MOVS     R0,#+8
   \   0000014A   2870               STRB     R0,[R5, #+0]
   \   0000014C   04E0               B.N      ??USBH_Process_18
    306               }  
    307               
    308               else
    309               {
    310                 USBH_ErrorHandle(phost, status);
   \                     ??USBH_Process_17:
   \   0000014E   9DF80010           LDRB     R1,[SP, #+0]
   \   00000152   2800               MOVS     R0,R5
   \   00000154   ........           BL       USBH_ErrorHandle
    311               }
    312           
    313              
    314              break;    
   \                     ??USBH_Process_18:
   \   00000158   21E0               B.N      ??USBH_Process_12
    315            case HOST_CLASS:   
    316              /* process class state machine */
    317              status = phost->class_cb->Machine(pdev, phost);
   \                     ??USBH_Process_5:
   \   0000015A   2900               MOVS     R1,R5
   \   0000015C   2000               MOVS     R0,R4
   \   0000015E   EA6F               LDR      R2,[R5, #+124]
   \   00000160   D268               LDR      R2,[R2, #+12]
   \   00000162   9047               BLX      R2
   \   00000164   8DF80000           STRB     R0,[SP, #+0]
    318              USBH_ErrorHandle(phost, status);
   \   00000168   9DF80010           LDRB     R1,[SP, #+0]
   \   0000016C   2800               MOVS     R0,R5
   \   0000016E   ........           BL       USBH_ErrorHandle
    319              break;       
   \   00000172   14E0               B.N      ??USBH_Process_12
    320              
    321            case HOST_CTRL_XFER:
    322              /* process control transfer state machine */
    323              USBH_HandleControl(pdev, phost);    
   \                     ??USBH_Process_6:
   \   00000174   2900               MOVS     R1,R5
   \   00000176   2000               MOVS     R0,R4
   \   00000178   ........           BL       USBH_HandleControl
    324              break;
   \   0000017C   0FE0               B.N      ??USBH_Process_12
    325              
    326            case HOST_SUSPENDED:
    327              break;
   \                     ??USBH_Process_8:
   \   0000017E   0EE0               B.N      ??USBH_Process_12
    328            
    329            case HOST_ERROR_STATE:
    330              /* Re-Initilaize Host for new Enumeration */
    331              USBH_DeInit(pdev, phost);
   \                     ??USBH_Process_9:
   \   00000180   2900               MOVS     R1,R5
   \   00000182   2000               MOVS     R0,R4
   \   00000184   ........           BL       USBH_DeInit
    332              phost->usr_cb->DeInit();
   \   00000188   D5F88000           LDR      R0,[R5, #+128]
   \   0000018C   4068               LDR      R0,[R0, #+4]
   \   0000018E   8047               BLX      R0
    333              phost->class_cb->DeInit(pdev, &phost->device_prop);
   \   00000190   15F12001           ADDS     R1,R5,#+32
   \   00000194   2000               MOVS     R0,R4
   \   00000196   EA6F               LDR      R2,[R5, #+124]
   \   00000198   5268               LDR      R2,[R2, #+4]
   \   0000019A   9047               BLX      R2
    334              break;
   \   0000019C   FFE7               B.N      ??USBH_Process_12
    335              
    336            default :
    337              break;
    338            }
    339            IWDG_ReloadCounter();                   // Clear IWDG
   \                     ??USBH_Process_10:
   \                     ??USBH_Process_12:
   \   0000019E   ........           BL       IWDG_ReloadCounter
    340            /* check device disconnection event */
    341             if (!(HCD_IsDeviceConnected(pdev)) && 
    342                 (pdev->host.port_cb->DisconnHandled == 0))
   \   000001A2   2000               MOVS     R0,R4
   \   000001A4   ........           BL       HCD_IsDeviceConnected
   \   000001A8   0028               CMP      R0,#+0
   \   000001AA   16D1               BNE.N    ??USBH_Process_19
   \   000001AC   D4F88809           LDR      R0,[R4, #+2440]
   \   000001B0   C07A               LDRB     R0,[R0, #+11]
   \   000001B2   0028               CMP      R0,#+0
   \   000001B4   11D1               BNE.N    ??USBH_Process_19
    343            { 
    344              /* Manage User disconnect operations*/
    345          //    phost->usr_cb->DeviceDisconnected();    디스플레이
    346              
    347              pdev->host.port_cb->DisconnHandled = 1; /* Handle to avoid the Re-entry*/
   \   000001B6   D4F88809           LDR      R0,[R4, #+2440]
   \   000001BA   0121               MOVS     R1,#+1
   \   000001BC   C172               STRB     R1,[R0, #+11]
    348              
    349              /* Re-Initilaize Host for new Enumeration */
    350              USBH_DeInit(pdev, phost);
   \   000001BE   2900               MOVS     R1,R5
   \   000001C0   2000               MOVS     R0,R4
   \   000001C2   ........           BL       USBH_DeInit
    351              phost->usr_cb->DeInit();
   \   000001C6   D5F88000           LDR      R0,[R5, #+128]
   \   000001CA   4068               LDR      R0,[R0, #+4]
   \   000001CC   8047               BLX      R0
    352              phost->class_cb->DeInit(pdev, &phost->device_prop);
   \   000001CE   15F12001           ADDS     R1,R5,#+32
   \   000001D2   2000               MOVS     R0,R4
   \   000001D4   EA6F               LDR      R2,[R5, #+124]
   \   000001D6   5268               LDR      R2,[R2, #+4]
   \   000001D8   9047               BLX      R2
    353            }   
    354          }
   \                     ??USBH_Process_19:
   \   000001DA   37BD               POP      {R0-R2,R4,R5,PC}  ;; return
    355          
    356          
    357          /**
    358            * @brief  USBH_ErrorHandle 
    359            *         This function handles the Error on Host side.
    360            * @param  errType : Type of Error or Busy/OK state
    361            * @retval None
    362            */

   \                                 In section .text, align 2, keep-with-next
    363          void USBH_ErrorHandle(USBH_HOST *phost, USBH_Status errType)
    364          {
   \                     USBH_ErrorHandle:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    365            /* Error unrecovered or not supported device speed */
    366            if ( (errType == USBH_ERROR_SPEED_UNKNOWN) ||
    367                 (errType == USBH_UNRECOVERED_ERROR) )
   \   00000004   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0529               CMP      R1,#+5
   \   00000008   02D0               BEQ.N    ??USBH_ErrorHandle_0
   \   0000000A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0429               CMP      R1,#+4
   \   0000000E   06D1               BNE.N    ??USBH_ErrorHandle_1
    368            {
    369              phost->usr_cb->UnrecoveredError(); 
   \                     ??USBH_ErrorHandle_0:
   \   00000010   D4F88000           LDR      R0,[R4, #+128]
   \   00000014   406C               LDR      R0,[R0, #+68]
   \   00000016   8047               BLX      R0
    370              phost->gState = HOST_ERROR_STATE;   
   \   00000018   0C20               MOVS     R0,#+12
   \   0000001A   2070               STRB     R0,[R4, #+0]
   \   0000001C   08E0               B.N      ??USBH_ErrorHandle_2
    371            }  
    372            /* USB host restart requested from application layer */
    373            else if(errType == USBH_APPLY_DEINIT)
   \                     ??USBH_ErrorHandle_1:
   \   0000001E   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0629               CMP      R1,#+6
   \   00000022   05D1               BNE.N    ??USBH_ErrorHandle_2
    374            {
    375              phost->gState = HOST_ERROR_STATE;  
   \   00000024   0C20               MOVS     R0,#+12
   \   00000026   2070               STRB     R0,[R4, #+0]
    376              /* user callback for initalization */
    377              phost->usr_cb->Init();
   \   00000028   D4F88000           LDR      R0,[R4, #+128]
   \   0000002C   0068               LDR      R0,[R0, #+0]
   \   0000002E   8047               BLX      R0
    378            } 
    379          }
   \                     ??USBH_ErrorHandle_2:
   \   00000030   10BD               POP      {R4,PC}          ;; return
    380          
    381          
    382          /**
    383            * @brief  USBH_HandleEnum 
    384            *         This function includes the complete enumeration process
    385            * @param  pdev: Selected device
    386            * @retval USBH_Status
    387            */

   \                                 In section .text, align 2, keep-with-next
    388          static USBH_Status USBH_HandleEnum(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
    389          {
   \                     USBH_HandleEnum:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   92B0               SUB      SP,SP,#+72
   \   00000004   0400               MOVS     R4,R0
   \   00000006   0D00               MOVS     R5,R1
    390            USBH_Status Status = USBH_BUSY;  
   \   00000008   0126               MOVS     R6,#+1
    391            uint8_t Local_Buffer[64];
    392            
    393            switch (phost->EnumState)
   \   0000000A   A878               LDRB     R0,[R5, #+2]
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   13D0               BEQ.N    ??USBH_HandleEnum_0
   \   00000010   0228               CMP      R0,#+2
   \   00000012   47D0               BEQ.N    ??USBH_HandleEnum_1
   \   00000014   36D3               BCC.N    ??USBH_HandleEnum_2
   \   00000016   0428               CMP      R0,#+4
   \   00000018   75D0               BEQ.N    ??USBH_HandleEnum_3
   \   0000001A   6AD3               BCC.N    ??USBH_HandleEnum_4
   \   0000001C   0628               CMP      R0,#+6
   \   0000001E   00F0A580           BEQ.W    ??USBH_HandleEnum_5
   \   00000022   C0F08480           BCC.W    ??USBH_HandleEnum_6
   \   00000026   0828               CMP      R0,#+8
   \   00000028   00F0DE80           BEQ.W    ??USBH_HandleEnum_7
   \   0000002C   C0F0BD80           BCC.W    ??USBH_HandleEnum_8
   \   00000030   0928               CMP      R0,#+9
   \   00000032   00F0E580           BEQ.W    ??USBH_HandleEnum_9
   \   00000036   E5E0               B.N      ??USBH_HandleEnum_10
    394            {
    395            case ENUM_IDLE:  
    396              /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
    397              if ( USBH_Get_DevDesc(pdev , phost, 8) == USBH_OK)
   \                     ??USBH_HandleEnum_0:
   \   00000038   0822               MOVS     R2,#+8
   \   0000003A   2900               MOVS     R1,R5
   \   0000003C   2000               MOVS     R0,R4
   \   0000003E   ........           BL       USBH_Get_DevDesc
   \   00000042   0028               CMP      R0,#+0
   \   00000044   1DD1               BNE.N    ??USBH_HandleEnum_11
    398              {
    399                phost->Control.ep0size = phost->device_prop.Dev_Desc.bMaxPacketSize;
   \   00000046   95F82900           LDRB     R0,[R5, #+41]
   \   0000004A   A871               STRB     R0,[R5, #+6]
    400                
    401                /* Issue Reset  */
    402                HCD_ResetPort(pdev);
   \   0000004C   2000               MOVS     R0,R4
   \   0000004E   ........           BL       HCD_ResetPort
    403                phost->EnumState = ENUM_GET_FULL_DEV_DESC;
   \   00000052   0120               MOVS     R0,#+1
   \   00000054   A870               STRB     R0,[R5, #+2]
    404                
    405                /* modify control channels configuration for MaxPacket size */
    406                USBH_Modify_Channel (pdev,
    407                                     phost->Control.hc_num_out,
    408                                     0,
    409                                     0,
    410                                     0,
    411                                     phost->Control.ep0size);
   \   00000056   A879               LDRB     R0,[R5, #+6]
   \   00000058   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005A   0190               STR      R0,[SP, #+4]
   \   0000005C   0020               MOVS     R0,#+0
   \   0000005E   0090               STR      R0,[SP, #+0]
   \   00000060   0023               MOVS     R3,#+0
   \   00000062   0022               MOVS     R2,#+0
   \   00000064   6979               LDRB     R1,[R5, #+5]
   \   00000066   2000               MOVS     R0,R4
   \   00000068   ........           BL       USBH_Modify_Channel
    412                
    413                USBH_Modify_Channel (pdev,
    414                                     phost->Control.hc_num_in,
    415                                     0,
    416                                     0,
    417                                     0,
    418                                     phost->Control.ep0size);      
   \   0000006C   A879               LDRB     R0,[R5, #+6]
   \   0000006E   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000070   0190               STR      R0,[SP, #+4]
   \   00000072   0020               MOVS     R0,#+0
   \   00000074   0090               STR      R0,[SP, #+0]
   \   00000076   0023               MOVS     R3,#+0
   \   00000078   0022               MOVS     R2,#+0
   \   0000007A   2979               LDRB     R1,[R5, #+4]
   \   0000007C   2000               MOVS     R0,R4
   \   0000007E   ........           BL       USBH_Modify_Channel
    419              }
    420              break;
   \                     ??USBH_HandleEnum_11:
   \   00000082   BFE0               B.N      ??USBH_HandleEnum_12
    421              
    422            case ENUM_GET_FULL_DEV_DESC:  
    423              /* Get FULL Device Desc  */
    424              if ( USBH_Get_DevDesc(pdev, phost, USB_DEVICE_DESC_SIZE)\
    425                == USBH_OK)
   \                     ??USBH_HandleEnum_2:
   \   00000084   1222               MOVS     R2,#+18
   \   00000086   2900               MOVS     R1,R5
   \   00000088   2000               MOVS     R0,R4
   \   0000008A   ........           BL       USBH_Get_DevDesc
   \   0000008E   0028               CMP      R0,#+0
   \   00000090   07D1               BNE.N    ??USBH_HandleEnum_13
    426              {
    427                /* user callback for device descriptor available */
    428                phost->usr_cb->DeviceDescAvailable(&phost->device_prop.Dev_Desc);      
   \   00000092   15F12200           ADDS     R0,R5,#+34
   \   00000096   D5F88010           LDR      R1,[R5, #+128]
   \   0000009A   C969               LDR      R1,[R1, #+28]
   \   0000009C   8847               BLX      R1
    429                phost->EnumState = ENUM_SET_ADDR;
   \   0000009E   0220               MOVS     R0,#+2
   \   000000A0   A870               STRB     R0,[R5, #+2]
    430              }
    431              break;
   \                     ??USBH_HandleEnum_13:
   \   000000A2   AFE0               B.N      ??USBH_HandleEnum_12
    432             
    433            case ENUM_SET_ADDR: 
    434              /* set address */
    435              if ( USBH_SetAddress(pdev, phost, USBH_DEVICE_ADDRESS) == USBH_OK)
   \                     ??USBH_HandleEnum_1:
   \   000000A4   0122               MOVS     R2,#+1
   \   000000A6   2900               MOVS     R1,R5
   \   000000A8   2000               MOVS     R0,R4
   \   000000AA   ........           BL       USBH_SetAddress
   \   000000AE   0028               CMP      R0,#+0
   \   000000B0   1ED1               BNE.N    ??USBH_HandleEnum_14
    436              {
    437                phost->device_prop.address = USBH_DEVICE_ADDRESS;
   \   000000B2   0120               MOVS     R0,#+1
   \   000000B4   85F82000           STRB     R0,[R5, #+32]
    438                
    439                /* user callback for device address assigned */
    440                phost->usr_cb->DeviceAddressAssigned();
   \   000000B8   D5F88000           LDR      R0,[R5, #+128]
   \   000000BC   006A               LDR      R0,[R0, #+32]
   \   000000BE   8047               BLX      R0
    441                phost->EnumState = ENUM_GET_CFG_DESC;
   \   000000C0   0320               MOVS     R0,#+3
   \   000000C2   A870               STRB     R0,[R5, #+2]
    442                
    443                /* modify control channels to update device address */
    444                USBH_Modify_Channel (pdev,
    445                                     phost->Control.hc_num_in,
    446                                     phost->device_prop.address,
    447                                     0,
    448                                     0,
    449                                     0);
   \   000000C4   0020               MOVS     R0,#+0
   \   000000C6   0190               STR      R0,[SP, #+4]
   \   000000C8   0020               MOVS     R0,#+0
   \   000000CA   0090               STR      R0,[SP, #+0]
   \   000000CC   0023               MOVS     R3,#+0
   \   000000CE   95F82020           LDRB     R2,[R5, #+32]
   \   000000D2   2979               LDRB     R1,[R5, #+4]
   \   000000D4   2000               MOVS     R0,R4
   \   000000D6   ........           BL       USBH_Modify_Channel
    450                
    451                USBH_Modify_Channel (pdev,
    452                                     phost->Control.hc_num_out,
    453                                     phost->device_prop.address,
    454                                     0,
    455                                     0,
    456                                     0);         
   \   000000DA   0020               MOVS     R0,#+0
   \   000000DC   0190               STR      R0,[SP, #+4]
   \   000000DE   0020               MOVS     R0,#+0
   \   000000E0   0090               STR      R0,[SP, #+0]
   \   000000E2   0023               MOVS     R3,#+0
   \   000000E4   95F82020           LDRB     R2,[R5, #+32]
   \   000000E8   6979               LDRB     R1,[R5, #+5]
   \   000000EA   2000               MOVS     R0,R4
   \   000000EC   ........           BL       USBH_Modify_Channel
    457              }
    458              break;
   \                     ??USBH_HandleEnum_14:
   \   000000F0   88E0               B.N      ??USBH_HandleEnum_12
    459              
    460            case ENUM_GET_CFG_DESC:  
    461              /* get standard configuration descriptor */
    462              if ( USBH_Get_CfgDesc(pdev, 
    463                                    phost,
    464                                    USB_CONFIGURATION_DESC_SIZE) == USBH_OK)
   \                     ??USBH_HandleEnum_4:
   \   000000F2   0922               MOVS     R2,#+9
   \   000000F4   2900               MOVS     R1,R5
   \   000000F6   2000               MOVS     R0,R4
   \   000000F8   ........           BL       USBH_Get_CfgDesc
   \   000000FC   0028               CMP      R0,#+0
   \   000000FE   01D1               BNE.N    ??USBH_HandleEnum_15
    465              {
    466                phost->EnumState = ENUM_GET_FULL_CFG_DESC;
   \   00000100   0420               MOVS     R0,#+4
   \   00000102   A870               STRB     R0,[R5, #+2]
    467              }
    468              break;
   \                     ??USBH_HandleEnum_15:
   \   00000104   7EE0               B.N      ??USBH_HandleEnum_12
    469              
    470            case ENUM_GET_FULL_CFG_DESC:  
    471              /* get FULL config descriptor (config, interface, endpoints) */
    472              if (USBH_Get_CfgDesc(pdev, 
    473                                   phost,
    474                                   phost->device_prop.Cfg_Desc.wTotalLength) == USBH_OK)
   \                     ??USBH_HandleEnum_3:
   \   00000106   EA8E               LDRH     R2,[R5, #+54]
   \   00000108   2900               MOVS     R1,R5
   \   0000010A   2000               MOVS     R0,R4
   \   0000010C   ........           BL       USBH_Get_CfgDesc
   \   00000110   0028               CMP      R0,#+0
   \   00000112   0BD1               BNE.N    ??USBH_HandleEnum_16
    475              {
    476                /* User callback for configuration descriptors available */
    477                phost->usr_cb->ConfigurationDescAvailable(&phost->device_prop.Cfg_Desc,
    478                                                                phost->device_prop.Itf_Desc,
    479                                                                phost->device_prop.Ep_Desc[0]);
   \   00000114   15F15002           ADDS     R2,R5,#+80
   \   00000118   15F13E01           ADDS     R1,R5,#+62
   \   0000011C   15F13400           ADDS     R0,R5,#+52
   \   00000120   D5F88030           LDR      R3,[R5, #+128]
   \   00000124   5B6A               LDR      R3,[R3, #+36]
   \   00000126   9847               BLX      R3
    480                
    481                phost->EnumState = ENUM_GET_MFC_STRING_DESC;
   \   00000128   0520               MOVS     R0,#+5
   \   0000012A   A870               STRB     R0,[R5, #+2]
    482              }
    483              break;
   \                     ??USBH_HandleEnum_16:
   \   0000012C   6AE0               B.N      ??USBH_HandleEnum_12
    484              
    485            case ENUM_GET_MFC_STRING_DESC:  
    486              if (phost->device_prop.Dev_Desc.iManufacturer != 0)
   \                     ??USBH_HandleEnum_6:
   \   0000012E   95F83000           LDRB     R0,[R5, #+48]
   \   00000132   0028               CMP      R0,#+0
   \   00000134   12D0               BEQ.N    ??USBH_HandleEnum_17
    487              { /* Check that Manufacturer String is available */
    488                
    489                if ( USBH_Get_StringDesc(pdev,
    490                                         phost,
    491                                         phost->device_prop.Dev_Desc.iManufacturer, 
    492                                         Local_Buffer , 
    493                                         0xff) == USBH_OK)
   \   00000136   FF20               MOVS     R0,#+255
   \   00000138   0090               STR      R0,[SP, #+0]
   \   0000013A   02AB               ADD      R3,SP,#+8
   \   0000013C   95F83020           LDRB     R2,[R5, #+48]
   \   00000140   2900               MOVS     R1,R5
   \   00000142   2000               MOVS     R0,R4
   \   00000144   ........           BL       USBH_Get_StringDesc
   \   00000148   0028               CMP      R0,#+0
   \   0000014A   0ED1               BNE.N    ??USBH_HandleEnum_18
    494                {
    495                  /* User callback for Manufacturing string */
    496                  phost->usr_cb->ManufacturerString(Local_Buffer);
   \   0000014C   02A8               ADD      R0,SP,#+8
   \   0000014E   D5F88010           LDR      R1,[R5, #+128]
   \   00000152   896A               LDR      R1,[R1, #+40]
   \   00000154   8847               BLX      R1
    497                  phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
   \   00000156   0620               MOVS     R0,#+6
   \   00000158   A870               STRB     R0,[R5, #+2]
   \   0000015A   06E0               B.N      ??USBH_HandleEnum_18
    498                }
    499              }
    500              else
    501              {
    502                phost->usr_cb->ManufacturerString("N/A");      
   \                     ??USBH_HandleEnum_17:
   \   0000015C   ....               ADR.N    R0,??DataTable3  ;; "N/A"
   \   0000015E   D5F88010           LDR      R1,[R5, #+128]
   \   00000162   896A               LDR      R1,[R1, #+40]
   \   00000164   8847               BLX      R1
    503                phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
   \   00000166   0620               MOVS     R0,#+6
   \   00000168   A870               STRB     R0,[R5, #+2]
    504              }
    505              break;
   \                     ??USBH_HandleEnum_18:
   \   0000016A   4BE0               B.N      ??USBH_HandleEnum_12
    506              
    507            case ENUM_GET_PRODUCT_STRING_DESC:   
    508              if (phost->device_prop.Dev_Desc.iProduct != 0)
   \                     ??USBH_HandleEnum_5:
   \   0000016C   95F83100           LDRB     R0,[R5, #+49]
   \   00000170   0028               CMP      R0,#+0
   \   00000172   12D0               BEQ.N    ??USBH_HandleEnum_19
    509              { /* Check that Product string is available */
    510                if ( USBH_Get_StringDesc(pdev,
    511                                         phost,
    512                                         phost->device_prop.Dev_Desc.iProduct, 
    513                                         Local_Buffer, 
    514                                         0xff) == USBH_OK)
   \   00000174   FF20               MOVS     R0,#+255
   \   00000176   0090               STR      R0,[SP, #+0]
   \   00000178   02AB               ADD      R3,SP,#+8
   \   0000017A   95F83120           LDRB     R2,[R5, #+49]
   \   0000017E   2900               MOVS     R1,R5
   \   00000180   2000               MOVS     R0,R4
   \   00000182   ........           BL       USBH_Get_StringDesc
   \   00000186   0028               CMP      R0,#+0
   \   00000188   0ED1               BNE.N    ??USBH_HandleEnum_20
    515                {
    516                  /* User callback for Product string */
    517                  phost->usr_cb->ProductString(Local_Buffer);
   \   0000018A   02A8               ADD      R0,SP,#+8
   \   0000018C   D5F88010           LDR      R1,[R5, #+128]
   \   00000190   C96A               LDR      R1,[R1, #+44]
   \   00000192   8847               BLX      R1
    518                  phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
   \   00000194   0720               MOVS     R0,#+7
   \   00000196   A870               STRB     R0,[R5, #+2]
   \   00000198   06E0               B.N      ??USBH_HandleEnum_20
    519                }
    520              }
    521              else
    522              {
    523                phost->usr_cb->ProductString("N/A");
   \                     ??USBH_HandleEnum_19:
   \   0000019A   ....               ADR.N    R0,??DataTable3  ;; "N/A"
   \   0000019C   D5F88010           LDR      R1,[R5, #+128]
   \   000001A0   C96A               LDR      R1,[R1, #+44]
   \   000001A2   8847               BLX      R1
    524                phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
   \   000001A4   0720               MOVS     R0,#+7
   \   000001A6   A870               STRB     R0,[R5, #+2]
    525              } 
    526              break;
   \                     ??USBH_HandleEnum_20:
   \   000001A8   2CE0               B.N      ??USBH_HandleEnum_12
    527              
    528            case ENUM_GET_SERIALNUM_STRING_DESC:   
    529              if (phost->device_prop.Dev_Desc.iSerialNumber != 0)
   \                     ??USBH_HandleEnum_8:
   \   000001AA   95F83200           LDRB     R0,[R5, #+50]
   \   000001AE   0028               CMP      R0,#+0
   \   000001B0   12D0               BEQ.N    ??USBH_HandleEnum_21
    530              { /* Check that Serial number string is available */    
    531                if ( USBH_Get_StringDesc(pdev, 
    532                                         phost,
    533                                         phost->device_prop.Dev_Desc.iSerialNumber, 
    534                                         Local_Buffer, 
    535                                         0xff) == USBH_OK)
   \   000001B2   FF20               MOVS     R0,#+255
   \   000001B4   0090               STR      R0,[SP, #+0]
   \   000001B6   02AB               ADD      R3,SP,#+8
   \   000001B8   95F83220           LDRB     R2,[R5, #+50]
   \   000001BC   2900               MOVS     R1,R5
   \   000001BE   2000               MOVS     R0,R4
   \   000001C0   ........           BL       USBH_Get_StringDesc
   \   000001C4   0028               CMP      R0,#+0
   \   000001C6   0ED1               BNE.N    ??USBH_HandleEnum_22
    536                {
    537                  /* User callback for Serial number string */
    538                  phost->usr_cb->SerialNumString(Local_Buffer);
   \   000001C8   02A8               ADD      R0,SP,#+8
   \   000001CA   D5F88010           LDR      R1,[R5, #+128]
   \   000001CE   096B               LDR      R1,[R1, #+48]
   \   000001D0   8847               BLX      R1
    539                  phost->EnumState = ENUM_SET_CONFIGURATION;
   \   000001D2   0820               MOVS     R0,#+8
   \   000001D4   A870               STRB     R0,[R5, #+2]
   \   000001D6   06E0               B.N      ??USBH_HandleEnum_22
    540                }
    541              }
    542              else
    543              {
    544                phost->usr_cb->SerialNumString("N/A");      
   \                     ??USBH_HandleEnum_21:
   \   000001D8   ....               ADR.N    R0,??DataTable3  ;; "N/A"
   \   000001DA   D5F88010           LDR      R1,[R5, #+128]
   \   000001DE   096B               LDR      R1,[R1, #+48]
   \   000001E0   8847               BLX      R1
    545                phost->EnumState = ENUM_SET_CONFIGURATION;
   \   000001E2   0820               MOVS     R0,#+8
   \   000001E4   A870               STRB     R0,[R5, #+2]
    546              }  
    547              break;
   \                     ??USBH_HandleEnum_22:
   \   000001E6   0DE0               B.N      ??USBH_HandleEnum_12
    548                
    549            case ENUM_SET_CONFIGURATION:
    550              /* set configuration  (default config) */
    551              if (USBH_SetCfg(pdev, 
    552                              phost,
    553                              phost->device_prop.Cfg_Desc.bConfigurationValue) == USBH_OK)
   \                     ??USBH_HandleEnum_7:
   \   000001E8   95F83920           LDRB     R2,[R5, #+57]
   \   000001EC   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000001EE   2900               MOVS     R1,R5
   \   000001F0   2000               MOVS     R0,R4
   \   000001F2   ........           BL       USBH_SetCfg
   \   000001F6   0028               CMP      R0,#+0
   \   000001F8   01D1               BNE.N    ??USBH_HandleEnum_23
    554              {
    555                phost->EnumState = ENUM_DEV_CONFIGURED;
   \   000001FA   0920               MOVS     R0,#+9
   \   000001FC   A870               STRB     R0,[R5, #+2]
    556              }
    557              break;
   \                     ??USBH_HandleEnum_23:
   \   000001FE   01E0               B.N      ??USBH_HandleEnum_12
    558          
    559              
    560            case ENUM_DEV_CONFIGURED:
    561              /* user callback for enumeration done */
    562              Status = USBH_OK;
   \                     ??USBH_HandleEnum_9:
   \   00000200   0026               MOVS     R6,#+0
    563              break;
   \   00000202   FFE7               B.N      ??USBH_HandleEnum_12
    564              
    565            default:
    566              break;
    567            }  
    568            return Status;
   \                     ??USBH_HandleEnum_10:
   \                     ??USBH_HandleEnum_12:
   \   00000204   3000               MOVS     R0,R6
   \   00000206   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000208   12B0               ADD      SP,SP,#+72
   \   0000020A   70BD               POP      {R4-R6,PC}       ;; return
    569          }
    570          
    571          
    572          /**
    573            * @brief  USBH_HandleControl
    574            *         Handles the USB control transfer state machine
    575            * @param  pdev: Selected device
    576            * @retval Status
    577            */

   \                                 In section .text, align 2, keep-with-next
    578          USBH_Status USBH_HandleControl (USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
    579          {
   \                     USBH_HandleControl:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0600               MOVS     R6,R0
   \   00000004   0C00               MOVS     R4,R1
    580            uint8_t direction;  
    581            static uint16_t timeout = 0;
    582            USBH_Status status = USBH_OK;
   \   00000006   0025               MOVS     R5,#+0
    583            URB_STATE URB_Status = URB_IDLE;
   \   00000008   0027               MOVS     R7,#+0
    584            
    585            phost->Control.status = CTRL_START;
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   A074               STRB     R0,[R4, #+18]
    586            IWDG_ReloadCounter();                   // Clear IWDG       
   \   0000000E   ........           BL       IWDG_ReloadCounter
    587            
    588            switch (phost->Control.state)
   \   00000012   207F               LDRB     R0,[R4, #+28]
   \   00000014   0128               CMP      R0,#+1
   \   00000016   17D0               BEQ.N    ??USBH_HandleControl_0
   \   00000018   C0F01B81           BCC.W    ??USBH_HandleControl_1
   \   0000001C   0328               CMP      R0,#+3
   \   0000001E   4FD0               BEQ.N    ??USBH_HandleControl_2
   \   00000020   1BD3               BCC.N    ??USBH_HandleControl_3
   \   00000022   0528               CMP      R0,#+5
   \   00000024   78D0               BEQ.N    ??USBH_HandleControl_4
   \   00000026   55D3               BCC.N    ??USBH_HandleControl_5
   \   00000028   0728               CMP      R0,#+7
   \   0000002A   00F0A880           BEQ.W    ??USBH_HandleControl_6
   \   0000002E   C0F08980           BCC.W    ??USBH_HandleControl_7
   \   00000032   0928               CMP      R0,#+9
   \   00000034   00F0D280           BEQ.W    ??USBH_HandleControl_8
   \   00000038   C0F0AA80           BCC.W    ??USBH_HandleControl_9
   \   0000003C   0B28               CMP      R0,#+11
   \   0000003E   00F0F980           BEQ.W    ??USBH_HandleControl_10
   \   00000042   C0F0E080           BCC.W    ??USBH_HandleControl_11
   \   00000046   04E1               B.N      ??USBH_HandleControl_1
    589            {
    590            case CTRL_SETUP:
    591              /* send a SETUP packet */
    592              USBH_CtlSendSetup     (pdev, 
    593          	                   phost->Control.setup.d8 , 
    594          	                   phost->Control.hc_num_out);  
   \                     ??USBH_HandleControl_0:
   \   00000048   6279               LDRB     R2,[R4, #+5]
   \   0000004A   14F11401           ADDS     R1,R4,#+20
   \   0000004E   3000               MOVS     R0,R6
   \   00000050   ........           BL       USBH_CtlSendSetup
    595              phost->Control.state = CTRL_SETUP_WAIT;  
   \   00000054   0220               MOVS     R0,#+2
   \   00000056   2077               STRB     R0,[R4, #+28]
    596              break; 
   \   00000058   FBE0               B.N      ??USBH_HandleControl_12
    597              
    598            case CTRL_SETUP_WAIT:
    599              
    600              URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out); 
   \                     ??USBH_HandleControl_3:
   \   0000005A   6179               LDRB     R1,[R4, #+5]
   \   0000005C   3000               MOVS     R0,R6
   \   0000005E   ........           BL       HCD_GetURB_State
   \   00000062   0700               MOVS     R7,R0
    601              /* case SETUP packet sent successfully */
    602              if(URB_Status == URB_DONE)
   \   00000064   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000066   012F               CMP      R7,#+1
   \   00000068   22D1               BNE.N    ??USBH_HandleControl_13
    603              { 
    604                direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
   \   0000006A   207D               LDRB     R0,[R4, #+20]
   \   0000006C   10F08000           ANDS     R0,R0,#0x80
    605                
    606                /* check if there is a data stage */
    607                if (phost->Control.setup.b.wLength.w != 0 )
   \   00000070   618B               LDRH     R1,[R4, #+26]
   \   00000072   0029               CMP      R1,#+0
   \   00000074   0CD0               BEQ.N    ??USBH_HandleControl_14
    608                {        
    609                  timeout = DATA_STAGE_TIMEOUT;
   \   00000076   ....               LDR.N    R1,??DataTable3_2
   \   00000078   41F28832           MOVW     R2,#+5000
   \   0000007C   0A80               STRH     R2,[R1, #+0]
    610                  if (direction == USB_D2H)
   \   0000007E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000080   8028               CMP      R0,#+128
   \   00000082   02D1               BNE.N    ??USBH_HandleControl_15
    611                  {
    612                    /* Data Direction is IN */
    613                    phost->Control.state = CTRL_DATA_IN;
   \   00000084   0320               MOVS     R0,#+3
   \   00000086   2077               STRB     R0,[R4, #+28]
   \   00000088   0DE0               B.N      ??USBH_HandleControl_16
    614                  }
    615                  else
    616                  {
    617                    /* Data Direction is OUT */
    618                    phost->Control.state = CTRL_DATA_OUT;
   \                     ??USBH_HandleControl_15:
   \   0000008A   0520               MOVS     R0,#+5
   \   0000008C   2077               STRB     R0,[R4, #+28]
   \   0000008E   0AE0               B.N      ??USBH_HandleControl_16
    619                  } 
    620                }
    621                /* No DATA stage */
    622                else
    623                {
    624                  timeout = NODATA_STAGE_TIMEOUT;
   \                     ??USBH_HandleControl_14:
   \   00000090   ....               LDR.N    R1,??DataTable3_2
   \   00000092   3222               MOVS     R2,#+50
   \   00000094   0A80               STRH     R2,[R1, #+0]
    625                  
    626                  /* If there is No Data Transfer Stage */
    627                  if (direction == USB_D2H)
   \   00000096   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000098   8028               CMP      R0,#+128
   \   0000009A   02D1               BNE.N    ??USBH_HandleControl_17
    628                  {
    629                    /* Data Direction is IN */
    630                    phost->Control.state = CTRL_STATUS_OUT;
   \   0000009C   0920               MOVS     R0,#+9
   \   0000009E   2077               STRB     R0,[R4, #+28]
   \   000000A0   01E0               B.N      ??USBH_HandleControl_16
    631                  }
    632                  else
    633                  {
    634                    /* Data Direction is OUT */
    635                    phost->Control.state = CTRL_STATUS_IN;
   \                     ??USBH_HandleControl_17:
   \   000000A2   0720               MOVS     R0,#+7
   \   000000A4   2077               STRB     R0,[R4, #+28]
    636                  } 
    637                }          
    638                /* Set the delay timer to enable timeout for data stage completion */
    639                phost->Control.timer = HCD_GetCurrentFrame(pdev);
   \                     ??USBH_HandleControl_16:
   \   000000A6   3000               MOVS     R0,R6
   \   000000A8   ........           BL       HCD_GetCurrentFrame
   \   000000AC   2082               STRH     R0,[R4, #+16]
   \   000000AE   06E0               B.N      ??USBH_HandleControl_18
    640              }
    641              else if(URB_Status == URB_ERROR)
   \                     ??USBH_HandleControl_13:
   \   000000B0   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000B2   032F               CMP      R7,#+3
   \   000000B4   03D1               BNE.N    ??USBH_HandleControl_18
    642              {
    643                phost->Control.state = CTRL_ERROR;     
   \   000000B6   0B20               MOVS     R0,#+11
   \   000000B8   2077               STRB     R0,[R4, #+28]
    644                phost->Control.status = CTRL_XACTERR;
   \   000000BA   0520               MOVS     R0,#+5
   \   000000BC   A074               STRB     R0,[R4, #+18]
    645              }    
    646              break;
   \                     ??USBH_HandleControl_18:
   \   000000BE   C8E0               B.N      ??USBH_HandleControl_12
    647              
    648            case CTRL_DATA_IN:  
    649              /* Issue an IN token */ 
    650              USBH_CtlReceiveData(pdev,
    651                                  phost->Control.buff, 
    652                                  phost->Control.length,
    653                                  phost->Control.hc_num_in);
   \                     ??USBH_HandleControl_2:
   \   000000C0   2379               LDRB     R3,[R4, #+4]
   \   000000C2   A289               LDRH     R2,[R4, #+12]
   \   000000C4   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000C6   A168               LDR      R1,[R4, #+8]
   \   000000C8   3000               MOVS     R0,R6
   \   000000CA   ........           BL       USBH_CtlReceiveData
    654           
    655              phost->Control.state = CTRL_DATA_IN_WAIT;
   \   000000CE   0420               MOVS     R0,#+4
   \   000000D0   2077               STRB     R0,[R4, #+28]
    656              break;    
   \   000000D2   BEE0               B.N      ??USBH_HandleControl_12
    657              
    658            case CTRL_DATA_IN_WAIT:
    659              
    660              URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
   \                     ??USBH_HandleControl_5:
   \   000000D4   2179               LDRB     R1,[R4, #+4]
   \   000000D6   3000               MOVS     R0,R6
   \   000000D8   ........           BL       HCD_GetURB_State
   \   000000DC   0700               MOVS     R7,R0
    661              
    662              /* check is DATA packet transfered successfully */
    663              if  (URB_Status == URB_DONE)
   \   000000DE   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000E0   012F               CMP      R7,#+1
   \   000000E2   01D1               BNE.N    ??USBH_HandleControl_19
    664              { 
    665                phost->Control.state = CTRL_STATUS_OUT;
   \   000000E4   0920               MOVS     R0,#+9
   \   000000E6   2077               STRB     R0,[R4, #+28]
    666              }
    667             
    668              /* manage error cases*/
    669              if  (URB_Status == URB_STALL) 
   \                     ??USBH_HandleControl_19:
   \   000000E8   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000EA   042F               CMP      R7,#+4
   \   000000EC   02D1               BNE.N    ??USBH_HandleControl_20
    670              { 
    671                /* In stall case, return to previous machine state*/
    672                phost->gState =   phost->gStateBkp;
   \   000000EE   6078               LDRB     R0,[R4, #+1]
   \   000000F0   2070               STRB     R0,[R4, #+0]
   \   000000F2   10E0               B.N      ??USBH_HandleControl_21
    673              }   
    674              else if (URB_Status == URB_ERROR)
   \                     ??USBH_HandleControl_20:
   \   000000F4   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000F6   032F               CMP      R7,#+3
   \   000000F8   02D1               BNE.N    ??USBH_HandleControl_22
    675              {
    676                /* Device error */
    677                phost->Control.state = CTRL_ERROR;    
   \   000000FA   0B20               MOVS     R0,#+11
   \   000000FC   2077               STRB     R0,[R4, #+28]
   \   000000FE   0AE0               B.N      ??USBH_HandleControl_21
    678              }
    679              else if ((HCD_GetCurrentFrame(pdev)- phost->Control.timer) > timeout)
   \                     ??USBH_HandleControl_22:
   \   00000100   3000               MOVS     R0,R6
   \   00000102   ........           BL       HCD_GetCurrentFrame
   \   00000106   ....               LDR.N    R1,??DataTable3_2
   \   00000108   0988               LDRH     R1,[R1, #+0]
   \   0000010A   228A               LDRH     R2,[R4, #+16]
   \   0000010C   801A               SUBS     R0,R0,R2
   \   0000010E   8142               CMP      R1,R0
   \   00000110   01D2               BCS.N    ??USBH_HandleControl_21
    680              {
    681                /* timeout for IN transfer */
    682                phost->Control.state = CTRL_ERROR; 
   \   00000112   0B20               MOVS     R0,#+11
   \   00000114   2077               STRB     R0,[R4, #+28]
    683              }   
    684              break;
   \                     ??USBH_HandleControl_21:
   \   00000116   9CE0               B.N      ??USBH_HandleControl_12
    685              
    686            case CTRL_DATA_OUT:
    687              /* Start DATA out transfer (only one DATA packet)*/
    688              
    689              pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
   \                     ??USBH_HandleControl_4:
   \   00000118   6079               LDRB     R0,[R4, #+5]
   \   0000011A   16EB4010           ADDS     R0,R6,R0, LSL #+5
   \   0000011E   6179               LDRB     R1,[R4, #+5]
   \   00000120   16EB4111           ADDS     R1,R6,R1, LSL #+5
   \   00000124   91F8A117           LDRB     R1,[R1, #+1953]
   \   00000128   91F00101           EORS     R1,R1,#0x1
   \   0000012C   80F8A117           STRB     R1,[R0, #+1953]
    690              
    691              USBH_CtlSendData (pdev,
    692                                phost->Control.buff, 
    693                                phost->Control.length , 
    694                                phost->Control.hc_num_out);
   \   00000130   6379               LDRB     R3,[R4, #+5]
   \   00000132   A289               LDRH     R2,[R4, #+12]
   \   00000134   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000136   A168               LDR      R1,[R4, #+8]
   \   00000138   3000               MOVS     R0,R6
   \   0000013A   ........           BL       USBH_CtlSendData
    695              
    696              phost->Control.state = CTRL_DATA_OUT_WAIT;
   \   0000013E   0620               MOVS     R0,#+6
   \   00000140   2077               STRB     R0,[R4, #+28]
    697              break;
   \   00000142   86E0               B.N      ??USBH_HandleControl_12
    698              
    699            case CTRL_DATA_OUT_WAIT:
    700              
    701              URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);     
   \                     ??USBH_HandleControl_7:
   \   00000144   6179               LDRB     R1,[R4, #+5]
   \   00000146   3000               MOVS     R0,R6
   \   00000148   ........           BL       HCD_GetURB_State
   \   0000014C   0700               MOVS     R7,R0
    702              if  (URB_Status == URB_DONE)
   \   0000014E   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000150   012F               CMP      R7,#+1
   \   00000152   02D1               BNE.N    ??USBH_HandleControl_23
    703              { /* If the Setup Pkt is sent successful, then change the state */
    704                phost->Control.state = CTRL_STATUS_IN;
   \   00000154   0720               MOVS     R0,#+7
   \   00000156   2077               STRB     R0,[R4, #+28]
   \   00000158   10E0               B.N      ??USBH_HandleControl_24
    705              }
    706              
    707              /* handle error cases */
    708              else if  (URB_Status == URB_STALL) 
   \                     ??USBH_HandleControl_23:
   \   0000015A   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000015C   042F               CMP      R7,#+4
   \   0000015E   02D1               BNE.N    ??USBH_HandleControl_25
    709              { 
    710                /* In stall case, return to previous machine state*/
    711                phost->gState =   phost->gStateBkp;
   \   00000160   6078               LDRB     R0,[R4, #+1]
   \   00000162   2070               STRB     R0,[R4, #+0]
   \   00000164   0AE0               B.N      ??USBH_HandleControl_24
    712              } 
    713              else if  (URB_Status == URB_NOTREADY)
   \                     ??USBH_HandleControl_25:
   \   00000166   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000168   022F               CMP      R7,#+2
   \   0000016A   02D1               BNE.N    ??USBH_HandleControl_26
    714              { 
    715                /* Nack received from device */
    716                phost->Control.state = CTRL_DATA_OUT;
   \   0000016C   0520               MOVS     R0,#+5
   \   0000016E   2077               STRB     R0,[R4, #+28]
   \   00000170   04E0               B.N      ??USBH_HandleControl_24
    717              }    
    718              else if (URB_Status == URB_ERROR)
   \                     ??USBH_HandleControl_26:
   \   00000172   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000174   032F               CMP      R7,#+3
   \   00000176   01D1               BNE.N    ??USBH_HandleControl_24
    719              {
    720                /* device error */
    721                phost->Control.state = CTRL_ERROR;      
   \   00000178   0B20               MOVS     R0,#+11
   \   0000017A   2077               STRB     R0,[R4, #+28]
    722              } 
    723              break;
   \                     ??USBH_HandleControl_24:
   \   0000017C   69E0               B.N      ??USBH_HandleControl_12
    724              
    725              
    726            case CTRL_STATUS_IN:
    727              /* Send 0 bytes out packet */
    728              USBH_CtlReceiveData (pdev,
    729                                   0,
    730                                   0,
    731                                   phost->Control.hc_num_in);
   \                     ??USBH_HandleControl_6:
   \   0000017E   2379               LDRB     R3,[R4, #+4]
   \   00000180   0022               MOVS     R2,#+0
   \   00000182   0021               MOVS     R1,#+0
   \   00000184   3000               MOVS     R0,R6
   \   00000186   ........           BL       USBH_CtlReceiveData
    732              
    733              phost->Control.state = CTRL_STATUS_IN_WAIT;
   \   0000018A   0820               MOVS     R0,#+8
   \   0000018C   2077               STRB     R0,[R4, #+28]
    734              
    735              break;
   \   0000018E   60E0               B.N      ??USBH_HandleControl_12
    736              
    737            case CTRL_STATUS_IN_WAIT:
    738              
    739              URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
   \                     ??USBH_HandleControl_9:
   \   00000190   2179               LDRB     R1,[R4, #+4]
   \   00000192   3000               MOVS     R0,R6
   \   00000194   ........           BL       HCD_GetURB_State
   \   00000198   0700               MOVS     R7,R0
    740              
    741              if  ( URB_Status == URB_DONE)
   \   0000019A   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000019C   012F               CMP      R7,#+1
   \   0000019E   02D1               BNE.N    ??USBH_HandleControl_27
    742              { /* Control transfers completed, Exit the State Machine */
    743                phost->gState =   phost->gStateBkp;
   \   000001A0   6078               LDRB     R0,[R4, #+1]
   \   000001A2   2070               STRB     R0,[R4, #+0]
   \   000001A4   19E0               B.N      ??USBH_HandleControl_28
    744              }
    745              
    746              else if (URB_Status == URB_ERROR)
   \                     ??USBH_HandleControl_27:
   \   000001A6   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001A8   032F               CMP      R7,#+3
   \   000001AA   02D1               BNE.N    ??USBH_HandleControl_29
    747              {
    748                phost->Control.state = CTRL_ERROR;  
   \   000001AC   0B20               MOVS     R0,#+11
   \   000001AE   2077               STRB     R0,[R4, #+28]
   \   000001B0   13E0               B.N      ??USBH_HandleControl_28
    749              }
    750              
    751              else if((HCD_GetCurrentFrame(pdev)\
    752                - phost->Control.timer) > timeout)
   \                     ??USBH_HandleControl_29:
   \   000001B2   3000               MOVS     R0,R6
   \   000001B4   ........           BL       HCD_GetCurrentFrame
   \   000001B8   ....               LDR.N    R1,??DataTable3_2
   \   000001BA   0988               LDRH     R1,[R1, #+0]
   \   000001BC   228A               LDRH     R2,[R4, #+16]
   \   000001BE   801A               SUBS     R0,R0,R2
   \   000001C0   8142               CMP      R1,R0
   \   000001C2   02D2               BCS.N    ??USBH_HandleControl_30
    753              {
    754                phost->Control.state = CTRL_ERROR; 
   \   000001C4   0B20               MOVS     R0,#+11
   \   000001C6   2077               STRB     R0,[R4, #+28]
   \   000001C8   07E0               B.N      ??USBH_HandleControl_28
    755              }
    756               else if(URB_Status == URB_STALL)
   \                     ??USBH_HandleControl_30:
   \   000001CA   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001CC   042F               CMP      R7,#+4
   \   000001CE   04D1               BNE.N    ??USBH_HandleControl_28
    757              {
    758                /* Control transfers completed, Exit the State Machine */
    759                phost->gState =   phost->gStateBkp;
   \   000001D0   6078               LDRB     R0,[R4, #+1]
   \   000001D2   2070               STRB     R0,[R4, #+0]
    760                phost->Control.status = CTRL_STALL;
   \   000001D4   0420               MOVS     R0,#+4
   \   000001D6   A074               STRB     R0,[R4, #+18]
    761                status = USBH_NOT_SUPPORTED;
   \   000001D8   0325               MOVS     R5,#+3
    762              }
    763              break;
   \                     ??USBH_HandleControl_28:
   \   000001DA   3AE0               B.N      ??USBH_HandleControl_12
    764              
    765            case CTRL_STATUS_OUT:
    766              pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
   \                     ??USBH_HandleControl_8:
   \   000001DC   6079               LDRB     R0,[R4, #+5]
   \   000001DE   16EB4010           ADDS     R0,R6,R0, LSL #+5
   \   000001E2   6179               LDRB     R1,[R4, #+5]
   \   000001E4   16EB4111           ADDS     R1,R6,R1, LSL #+5
   \   000001E8   91F8A117           LDRB     R1,[R1, #+1953]
   \   000001EC   91F00101           EORS     R1,R1,#0x1
   \   000001F0   80F8A117           STRB     R1,[R0, #+1953]
    767              USBH_CtlSendData (pdev,
    768                                0,
    769                                0,
    770                                phost->Control.hc_num_out);
   \   000001F4   6379               LDRB     R3,[R4, #+5]
   \   000001F6   0022               MOVS     R2,#+0
   \   000001F8   0021               MOVS     R1,#+0
   \   000001FA   3000               MOVS     R0,R6
   \   000001FC   ........           BL       USBH_CtlSendData
    771              
    772              phost->Control.state = CTRL_STATUS_OUT_WAIT;
   \   00000200   0A20               MOVS     R0,#+10
   \   00000202   2077               STRB     R0,[R4, #+28]
    773              break;
   \   00000204   25E0               B.N      ??USBH_HandleControl_12
    774              
    775            case CTRL_STATUS_OUT_WAIT: 
    776              
    777              URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);  
   \                     ??USBH_HandleControl_11:
   \   00000206   6179               LDRB     R1,[R4, #+5]
   \   00000208   3000               MOVS     R0,R6
   \   0000020A   ........           BL       HCD_GetURB_State
   \   0000020E   0700               MOVS     R7,R0
    778              if  (URB_Status == URB_DONE)
   \   00000210   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000212   012F               CMP      R7,#+1
   \   00000214   02D1               BNE.N    ??USBH_HandleControl_31
    779              { 
    780                phost->gState =   phost->gStateBkp;    
   \   00000216   6078               LDRB     R0,[R4, #+1]
   \   00000218   2070               STRB     R0,[R4, #+0]
   \   0000021A   0AE0               B.N      ??USBH_HandleControl_32
    781              }
    782              else if  (URB_Status == URB_NOTREADY)
   \                     ??USBH_HandleControl_31:
   \   0000021C   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000021E   022F               CMP      R7,#+2
   \   00000220   02D1               BNE.N    ??USBH_HandleControl_33
    783              { 
    784                phost->Control.state = CTRL_STATUS_OUT;
   \   00000222   0920               MOVS     R0,#+9
   \   00000224   2077               STRB     R0,[R4, #+28]
   \   00000226   04E0               B.N      ??USBH_HandleControl_32
    785              }      
    786              else if (URB_Status == URB_ERROR)
   \                     ??USBH_HandleControl_33:
   \   00000228   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000022A   032F               CMP      R7,#+3
   \   0000022C   01D1               BNE.N    ??USBH_HandleControl_32
    787              {
    788                phost->Control.state = CTRL_ERROR;      
   \   0000022E   0B20               MOVS     R0,#+11
   \   00000230   2077               STRB     R0,[R4, #+28]
    789              }
    790              break;
   \                     ??USBH_HandleControl_32:
   \   00000232   0EE0               B.N      ??USBH_HandleControl_12
    791              
    792            case CTRL_ERROR:
    793              /* 
    794              After a halt condition is encountered or an error is detected by the 
    795              host, a control endpoint is allowed to recover by accepting the next Setup 
    796              PID; i.e., recovery actions via some other pipe are not required for control
    797              endpoints. For the Default Control Pipe, a device reset will ultimately be 
    798              required to clear the halt or error condition if the next Setup PID is not 
    799              accepted.
    800              */
    801              if (++ phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
   \                     ??USBH_HandleControl_10:
   \   00000234   A07B               LDRB     R0,[R4, #+14]
   \   00000236   401C               ADDS     R0,R0,#+1
   \   00000238   A073               STRB     R0,[R4, #+14]
   \   0000023A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000023C   0328               CMP      R0,#+3
   \   0000023E   02D2               BCS.N    ??USBH_HandleControl_34
    802              {
    803                /* Do the transmission again, starting from SETUP Packet */
    804                phost->Control.state = CTRL_SETUP; 
   \   00000240   0120               MOVS     R0,#+1
   \   00000242   2077               STRB     R0,[R4, #+28]
   \   00000244   04E0               B.N      ??USBH_HandleControl_35
    805              }
    806              else
    807              {
    808                phost->Control.status = CTRL_FAIL;
   \                     ??USBH_HandleControl_34:
   \   00000246   0820               MOVS     R0,#+8
   \   00000248   A074               STRB     R0,[R4, #+18]
    809                phost->gState =   phost->gStateBkp;
   \   0000024A   6078               LDRB     R0,[R4, #+1]
   \   0000024C   2070               STRB     R0,[R4, #+0]
    810                
    811                status = USBH_FAIL;
   \   0000024E   0225               MOVS     R5,#+2
    812              }
    813              break;
   \                     ??USBH_HandleControl_35:
   \   00000250   FFE7               B.N      ??USBH_HandleControl_12
    814              
    815            default:
    816              break;
    817            }
    818            return status;
   \                     ??USBH_HandleControl_1:
   \                     ??USBH_HandleControl_12:
   \   00000252   2800               MOVS     R0,R5
   \   00000254   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000256   F2BD               POP      {R1,R4-R7,PC}    ;; return
    819          }

   \                                 In section .bss, align 2
   \                     ??timeout:
   \   00000000                      DS8 2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   4E2F4100           DC8      "N/A"

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   ........           DC32     USBH_DeviceConnStatus_cb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   ........           DC32     ??timeout

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "N/A">`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   4E2F4100           DC8 78, 47, 65, 0
    820          
    821          
    822          /**
    823          * @}
    824          */ 
    825          
    826          /**
    827          * @}
    828          */ 
    829          
    830          /**
    831          * @}
    832          */
    833          
    834          /**
    835          * @}
    836          */ 
    837          
    838          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
    839          
    840          
    841          
    842          

   Maximum stack usage in bytes:

     Function           .cstack
     --------           -------
     USBH_Connect            0
     USBH_DeInit            16
     USBH_Disconnect         0
     USBH_ErrorHandle        8
     USBH_HandleControl     24
     USBH_HandleEnum        88
     USBH_Init              24
     USBH_Process           24


   Section sizes:

     Function/Label           Bytes
     --------------           -----
     USBH_DeviceConnStatus_cb   12
     USBH_Connect               18
     USBH_Disconnect            18
     USBH_Init                  88
     USBH_DeInit                62
     USBH_Process              476
     USBH_ErrorHandle           50
     USBH_HandleEnum           524
     USBH_HandleControl        600
     timeout                     2
     ??DataTable3                4
     ??DataTable3_1              4
     ??DataTable3_2              4
     ?<Constant "N/A">           4

 
     2 bytes in section .bss
    12 bytes in section .data
 1 852 bytes in section .text
 
 1 852 bytes of CODE memory
    14 bytes of DATA memory

Errors: none
Warnings: none
