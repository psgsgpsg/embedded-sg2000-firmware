###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     19/Jan/2012  11:09:10 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32F #
#                    2xx_StdPeriph_Driver\src\stm32f2xx_cryp.c                #
#    Command line =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32F #
#                    2xx_StdPeriph_Driver\src\stm32f2xx_cryp.c -D             #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D RTC_CLOCK_SOURCE_LSE -lC            #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\ -lA F:\Work\S&G2000\Firmware\DTG_EMS_S #
#                    YSTEM\Project\EWARM\STM3220F_EVAL\List\ -o               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\Obj\ --no_cse --no_unroll --no_inline        #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\ #
#                    EWARM\..\ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Pro #
#                    ject\EWARM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I     #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I         #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\ -I                             #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\Common\ -I                      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_OTG_Driver\inc\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Core\inc\ -I      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\msc\inc\    #
#                    -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM #
#                    \..\Usb\ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Proj #
#                    ect\EWARM\..\Usb\Inc\ -I F:\Work\S&G2000\Firmware\DTG_EM #
#                    S_SYSTEM\Project\EWARM\..\Usb\src\ -I                    #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Core\inc\ -I        #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -Ol --use_c++_inline                                     #
#    List file    =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\stm32f2xx_cryp.lst                      #
#    Object file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\Obj\stm32f2xx_cryp.o                         #
#                                                                             #
#                                                                             #
###############################################################################

F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_cryp.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_cryp.c
      4            * @author  MCD Application Team
      5            * @version V0.0.4
      6            * @date    13-January-2011
      7            * @brief   This file provides all the Cryptographic processor (CRYP) firmware
      8            *          functions.
      9            ******************************************************************************
     10            * @attention
     11            *
     12            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     13            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     14            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     15            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     16            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     17            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     18            *
     19            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     20            ******************************************************************************
     21            */
     22          
     23          /* Includes ------------------------------------------------------------------*/
     24          #include "stm32f2xx_cryp.h"
     25          #include "stm32f2xx_rcc.h"
     26          
     27          /** @addtogroup STM32F2xx_StdPeriph_Driver
     28            * @{
     29            */
     30          
     31          
     32          
     33          /** @defgroup CRYP 
     34            * @brief CRYP driver modules
     35            * @{
     36            */ 
     37          
     38          /** @defgroup CRYP_Private_TypesDefinitions
     39            * @{
     40            */ 
     41          /**
     42            * @}
     43            */ 
     44          
     45          
     46          /** @defgroup CRYP_Private_Defines
     47            * @{
     48            */ 
     49          #define FLAG_MASK    ((uint8_t)0x1F)
     50          
     51          /**
     52            * @}
     53            */ 
     54          
     55          
     56          /** @defgroup CRYP_Private_Macros
     57            * @{
     58            */ 
     59          /**
     60            * @}
     61            */ 
     62          
     63          
     64          /** @defgroup CRYP_Private_Variables
     65            * @{
     66            */ 
     67          /**
     68            * @}
     69            */ 
     70          
     71          
     72          /** @defgroup CRYP_Private_FunctionPrototypes
     73            * @{
     74            */ 
     75          /**
     76            * @}
     77            */ 
     78          
     79          
     80          /** @defgroup CRYP_Private_Functions
     81            * @{
     82            */ 
     83          
     84          
     85          /**
     86            * @brief  Deinitializes the CRYP peripheral registers to their default reset values
     87            * @param  None
     88            * @retval None
     89            */

   \                                 In section .text, align 2, keep-with-next
     90          void CRYP_DeInit(void)
     91          {
   \                     CRYP_DeInit:
   \   00000000   80B5               PUSH     {R7,LR}
     92            /* Enable CRYP reset state */
     93            RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, ENABLE);
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   1020               MOVS     R0,#+16
   \   00000006   ........           BL       RCC_AHB2PeriphResetCmd
     94          
     95            /* Release CRYP from reset state */
     96            RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, DISABLE);
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   1020               MOVS     R0,#+16
   \   0000000E   ........           BL       RCC_AHB2PeriphResetCmd
     97          }
   \   00000012   01BD               POP      {R0,PC}          ;; return
     98          
     99          /**
    100            * @brief  Initializes the CRYP peripheral according to the specified parameters
    101            *   in the CRYP_InitStruct.
    102            * @param  CRYP_InitStruct: pointer to a CRYP_InitTypeDef structure that contains
    103            *   the configuration information for the CRYP peripheral.
    104            * @retval None
    105            */

   \                                 In section .text, align 2, keep-with-next
    106          void CRYP_Init(CRYP_InitTypeDef* CRYP_InitStruct)
    107          {
    108            /* Check the parameters */
    109            assert_param(IS_CRYP_ALGOMODE(CRYP_InitStruct->CRYP_AlgoMode));
    110            assert_param(IS_CRYP_DATATYPE(CRYP_InitStruct->CRYP_DataType));
    111            assert_param(IS_CRYP_ALGODIR(CRYP_InitStruct->CRYP_AlgoDir));
    112          	
    113            /* Select Algorithm mode*/  
    114            CRYP->CR &= ~CRYP_CR_ALGOMODE;
   \                     CRYP_Init:
   \   00000000   ....               LDR.N    R1,??DataTable10  ;; 0x50060000
   \   00000002   0968               LDR      R1,[R1, #+0]
   \   00000004   31F03801           BICS     R1,R1,#0x38
   \   00000008   ....               LDR.N    R2,??DataTable10  ;; 0x50060000
   \   0000000A   1160               STR      R1,[R2, #+0]
    115            CRYP->CR |= CRYP_InitStruct->CRYP_AlgoMode;
   \   0000000C   ....               LDR.N    R1,??DataTable10  ;; 0x50060000
   \   0000000E   0968               LDR      R1,[R1, #+0]
   \   00000010   4288               LDRH     R2,[R0, #+2]
   \   00000012   1143               ORRS     R1,R2,R1
   \   00000014   ....               LDR.N    R2,??DataTable10  ;; 0x50060000
   \   00000016   1160               STR      R1,[R2, #+0]
    116            
    117            /* Select dataType */ 
    118            CRYP->CR &= ~CRYP_CR_DATATYPE;
   \   00000018   ....               LDR.N    R1,??DataTable10  ;; 0x50060000
   \   0000001A   0968               LDR      R1,[R1, #+0]
   \   0000001C   31F0C001           BICS     R1,R1,#0xC0
   \   00000020   ....               LDR.N    R2,??DataTable10  ;; 0x50060000
   \   00000022   1160               STR      R1,[R2, #+0]
    119            CRYP->CR |= CRYP_InitStruct->CRYP_DataType;
   \   00000024   ....               LDR.N    R1,??DataTable10  ;; 0x50060000
   \   00000026   0968               LDR      R1,[R1, #+0]
   \   00000028   8288               LDRH     R2,[R0, #+4]
   \   0000002A   1143               ORRS     R1,R2,R1
   \   0000002C   ....               LDR.N    R2,??DataTable10  ;; 0x50060000
   \   0000002E   1160               STR      R1,[R2, #+0]
    120            
    121            /* select Key size (used only with AES algorithm) */
    122            if ((CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_ECB) ||
    123                (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_CBC) ||
    124                (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_CTR) ||
    125                (CRYP_InitStruct->CRYP_AlgoMode == CRYP_AlgoMode_AES_Key))
   \   00000030   4188               LDRH     R1,[R0, #+2]
   \   00000032   2029               CMP      R1,#+32
   \   00000034   08D0               BEQ.N    ??CRYP_Init_0
   \   00000036   4188               LDRH     R1,[R0, #+2]
   \   00000038   2829               CMP      R1,#+40
   \   0000003A   05D0               BEQ.N    ??CRYP_Init_0
   \   0000003C   4188               LDRH     R1,[R0, #+2]
   \   0000003E   3029               CMP      R1,#+48
   \   00000040   02D0               BEQ.N    ??CRYP_Init_0
   \   00000042   4188               LDRH     R1,[R0, #+2]
   \   00000044   3829               CMP      R1,#+56
   \   00000046   0BD1               BNE.N    ??CRYP_Init_1
    126            {
    127              assert_param(IS_CRYP_KEYSIZE(CRYP_InitStruct->CRYP_KeySize));
    128              CRYP->CR &= ~CRYP_CR_KEYSIZE;
   \                     ??CRYP_Init_0:
   \   00000048   ....               LDR.N    R1,??DataTable10  ;; 0x50060000
   \   0000004A   0968               LDR      R1,[R1, #+0]
   \   0000004C   31F44071           BICS     R1,R1,#0x300
   \   00000050   ....               LDR.N    R2,??DataTable10  ;; 0x50060000
   \   00000052   1160               STR      R1,[R2, #+0]
    129              CRYP->CR |= CRYP_InitStruct->CRYP_KeySize; /* Key size and value must be configured once the key has been prepared */
   \   00000054   ....               LDR.N    R1,??DataTable10  ;; 0x50060000
   \   00000056   0968               LDR      R1,[R1, #+0]
   \   00000058   C288               LDRH     R2,[R0, #+6]
   \   0000005A   1143               ORRS     R1,R2,R1
   \   0000005C   ....               LDR.N    R2,??DataTable10  ;; 0x50060000
   \   0000005E   1160               STR      R1,[R2, #+0]
    130            }
    131            
    132            /* Select data Direction */ 
    133            CRYP->CR &= ~CRYP_CR_ALGODIR;
   \                     ??CRYP_Init_1:
   \   00000060   ....               LDR.N    R1,??DataTable10  ;; 0x50060000
   \   00000062   0968               LDR      R1,[R1, #+0]
   \   00000064   31F00401           BICS     R1,R1,#0x4
   \   00000068   ....               LDR.N    R2,??DataTable10  ;; 0x50060000
   \   0000006A   1160               STR      R1,[R2, #+0]
    134            CRYP->CR |= CRYP_InitStruct->CRYP_AlgoDir;
   \   0000006C   ....               LDR.N    R1,??DataTable10  ;; 0x50060000
   \   0000006E   0968               LDR      R1,[R1, #+0]
   \   00000070   0088               LDRH     R0,[R0, #+0]
   \   00000072   0843               ORRS     R0,R0,R1
   \   00000074   ....               LDR.N    R1,??DataTable10  ;; 0x50060000
   \   00000076   0860               STR      R0,[R1, #+0]
    135          }
   \   00000078   7047               BX       LR               ;; return
    136          
    137          /**
    138            * @brief  Initializes the CRYP Initialization Vectors(IV) according to the
    139            *   specified parameters in the CRYP_IVInitStruct.
    140            * @param  CRYP_IVInitStruct: pointer to a CRYP_IVInitTypeDef structure that
    141            *   contains the configuration information for the CRYP Initialization Vectors(IV).
    142            * @retval None
    143            */

   \                                 In section .text, align 2, keep-with-next
    144          void CRYP_IVInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
    145          {
    146            CRYP->IV0LR = CRYP_IVInitStruct->CRYP_IV0Left;
   \                     CRYP_IVInit:
   \   00000000   ....               LDR.N    R1,??DataTable10_1  ;; 0x50060040
   \   00000002   0268               LDR      R2,[R0, #+0]
   \   00000004   0A60               STR      R2,[R1, #+0]
    147            CRYP->IV0RR = CRYP_IVInitStruct->CRYP_IV0Right;
   \   00000006   4168               LDR      R1,[R0, #+4]
   \   00000008   ....               LDR.N    R2,??DataTable10_2  ;; 0x50060044
   \   0000000A   1160               STR      R1,[R2, #+0]
    148            CRYP->IV1LR = CRYP_IVInitStruct->CRYP_IV1Left;
   \   0000000C   8168               LDR      R1,[R0, #+8]
   \   0000000E   ....               LDR.N    R2,??DataTable10_3  ;; 0x50060048
   \   00000010   1160               STR      R1,[R2, #+0]
    149            CRYP->IV1RR = CRYP_IVInitStruct->CRYP_IV1Right;
   \   00000012   C068               LDR      R0,[R0, #+12]
   \   00000014   ....               LDR.N    R1,??DataTable10_4  ;; 0x5006004c
   \   00000016   0860               STR      R0,[R1, #+0]
    150          }
   \   00000018   7047               BX       LR               ;; return
    151          
    152          /**
    153            * @brief  Initializes the CRYP Keys according to the specified parameters in
    154            *   the CRYP_KeyInitStruct.
    155            * @param  CRYP_KeyInitStruct: pointer to a CRYP_KeyInitTypeDef structure that
    156            *   contains the configuration information for the CRYP Keys.
    157            * @retval None
    158            */

   \                                 In section .text, align 2, keep-with-next
    159          void CRYP_KeyInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
    160          {
    161            /* Key Initialisation */
    162            CRYP->K0LR = CRYP_KeyInitStruct->CRYP_Key0Left;
   \                     CRYP_KeyInit:
   \   00000000   ....               LDR.N    R1,??DataTable10_5  ;; 0x50060020
   \   00000002   0268               LDR      R2,[R0, #+0]
   \   00000004   0A60               STR      R2,[R1, #+0]
    163            CRYP->K0RR = CRYP_KeyInitStruct->CRYP_Key0Right;
   \   00000006   4168               LDR      R1,[R0, #+4]
   \   00000008   ....               LDR.N    R2,??DataTable10_6  ;; 0x50060024
   \   0000000A   1160               STR      R1,[R2, #+0]
    164            CRYP->K1LR = CRYP_KeyInitStruct->CRYP_Key1Left;
   \   0000000C   8168               LDR      R1,[R0, #+8]
   \   0000000E   ....               LDR.N    R2,??DataTable10_7  ;; 0x50060028
   \   00000010   1160               STR      R1,[R2, #+0]
    165            CRYP->K1RR = CRYP_KeyInitStruct->CRYP_Key1Right;
   \   00000012   C168               LDR      R1,[R0, #+12]
   \   00000014   ....               LDR.N    R2,??DataTable10_8  ;; 0x5006002c
   \   00000016   1160               STR      R1,[R2, #+0]
    166            CRYP->K2LR = CRYP_KeyInitStruct->CRYP_Key2Left;
   \   00000018   0169               LDR      R1,[R0, #+16]
   \   0000001A   ....               LDR.N    R2,??DataTable10_9  ;; 0x50060030
   \   0000001C   1160               STR      R1,[R2, #+0]
    167            CRYP->K2RR = CRYP_KeyInitStruct->CRYP_Key2Right;
   \   0000001E   4169               LDR      R1,[R0, #+20]
   \   00000020   ....               LDR.N    R2,??DataTable10_10  ;; 0x50060034
   \   00000022   1160               STR      R1,[R2, #+0]
    168            CRYP->K3LR = CRYP_KeyInitStruct->CRYP_Key3Left;
   \   00000024   8169               LDR      R1,[R0, #+24]
   \   00000026   ....               LDR.N    R2,??DataTable10_11  ;; 0x50060038
   \   00000028   1160               STR      R1,[R2, #+0]
    169            CRYP->K3RR = CRYP_KeyInitStruct->CRYP_Key3Right;
   \   0000002A   C069               LDR      R0,[R0, #+28]
   \   0000002C   ....               LDR.N    R1,??DataTable10_12  ;; 0x5006003c
   \   0000002E   0860               STR      R0,[R1, #+0]
    170          }
   \   00000030   7047               BX       LR               ;; return
    171          
    172          /**
    173            * @brief  Fills each CRYP_InitStruct member with its default value.
    174            * @param  CRYP_InitStruct: pointer to a CRYP_InitTypeDef structure which will
    175            *   be initialized.
    176            * @retval None
    177            */

   \                                 In section .text, align 2, keep-with-next
    178          void CRYP_StructInit(CRYP_InitTypeDef* CRYP_InitStruct)
    179          {
    180            /* Initialize the CRYP_AlgoDir member */
    181            CRYP_InitStruct->CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
   \                     CRYP_StructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0180               STRH     R1,[R0, #+0]
    182            
    183            /* initialize the CRYP_AlgoMode member */
    184            CRYP_InitStruct->CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   4180               STRH     R1,[R0, #+2]
    185            
    186            /* initialize the CRYP_DataType member */
    187            CRYP_InitStruct->CRYP_DataType = CRYP_DataType_32b;
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   8180               STRH     R1,[R0, #+4]
    188            
    189            /* Initialize the CRYP_KeySize member */
    190            CRYP_InitStruct->CRYP_KeySize = CRYP_KeySize_128b;
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   C180               STRH     R1,[R0, #+6]
    191          }
   \   00000010   7047               BX       LR               ;; return
    192          
    193          /**
    194            * @brief  Fills each CRYP_IVInitStruct member with its default value.
    195            * @param  CRYP_IVInitStruct: pointer to a CRYP_IVInitTypeDef Initialization Vectors(IV) 
    196            *   structure which will be initialized.
    197            * @retval None
    198            */

   \                                 In section .text, align 2, keep-with-next
    199          void CRYP_IVStructInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
    200          {
    201            CRYP_IVInitStruct->CRYP_IV0Left = 0;
   \                     CRYP_IVStructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0160               STR      R1,[R0, #+0]
    202            CRYP_IVInitStruct->CRYP_IV0Right = 0;
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   4160               STR      R1,[R0, #+4]
    203            CRYP_IVInitStruct->CRYP_IV1Left = 0;
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   8160               STR      R1,[R0, #+8]
    204            CRYP_IVInitStruct->CRYP_IV1Right = 0;
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   C160               STR      R1,[R0, #+12]
    205          }
   \   00000010   7047               BX       LR               ;; return
    206          
    207          /**
    208            * @brief  Fills each CRYP_KeyInitStruct member with its default value.
    209            * @param  CRYP_KeyInitStruct: pointer to a CRYP_KeyInitTypeDef structure which
    210            *   will be initialized.
    211            * @retval None
    212            */

   \                                 In section .text, align 2, keep-with-next
    213          void CRYP_KeyStructInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
    214          {
    215            CRYP_KeyInitStruct->CRYP_Key0Left = 0;
   \                     CRYP_KeyStructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0160               STR      R1,[R0, #+0]
    216            CRYP_KeyInitStruct->CRYP_Key0Right = 0;
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   4160               STR      R1,[R0, #+4]
    217            CRYP_KeyInitStruct->CRYP_Key1Left = 0;
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   8160               STR      R1,[R0, #+8]
    218            CRYP_KeyInitStruct->CRYP_Key1Right = 0;
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   C160               STR      R1,[R0, #+12]
    219            CRYP_KeyInitStruct->CRYP_Key2Left = 0;
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   0161               STR      R1,[R0, #+16]
    220            CRYP_KeyInitStruct->CRYP_Key2Right = 0;
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   4161               STR      R1,[R0, #+20]
    221            CRYP_KeyInitStruct->CRYP_Key3Left = 0;
   \   00000018   0021               MOVS     R1,#+0
   \   0000001A   8161               STR      R1,[R0, #+24]
    222            CRYP_KeyInitStruct->CRYP_Key3Right = 0;
   \   0000001C   0021               MOVS     R1,#+0
   \   0000001E   C161               STR      R1,[R0, #+28]
    223          }
   \   00000020   7047               BX       LR               ;; return
    224          
    225          /**
    226            * @brief  Enables or disables the CRYP peripheral.
    227            * @param  NewState: new state of the CRYP peripheral.
    228            *   This parameter can be: ENABLE or DISABLE.
    229            * @retval None
    230            */

   \                                 In section .text, align 2, keep-with-next
    231          void CRYP_Cmd(FunctionalState NewState)
    232          {
    233            /* Check the parameters */
    234            assert_param(IS_FUNCTIONAL_STATE(NewState));
    235          
    236            if (NewState != DISABLE)
   \                     CRYP_Cmd:
   \   00000000   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0028               CMP      R0,#+0
   \   00000004   06D0               BEQ.N    ??CRYP_Cmd_0
    237            {
    238              /* Enable the Cryptographic processor */
    239              CRYP->CR |= CRYP_CR_CRYPEN;
   \   00000006   ....               LDR.N    R0,??DataTable10  ;; 0x50060000
   \   00000008   0068               LDR      R0,[R0, #+0]
   \   0000000A   50F40040           ORRS     R0,R0,#0x8000
   \   0000000E   ....               LDR.N    R1,??DataTable10  ;; 0x50060000
   \   00000010   0860               STR      R0,[R1, #+0]
   \   00000012   05E0               B.N      ??CRYP_Cmd_1
    240            }
    241            else
    242            {
    243              /* Disable the Cryptographic processor */
    244              CRYP->CR &= ~CRYP_CR_CRYPEN;
   \                     ??CRYP_Cmd_0:
   \   00000014   ....               LDR.N    R0,??DataTable10  ;; 0x50060000
   \   00000016   0068               LDR      R0,[R0, #+0]
   \   00000018   30F40040           BICS     R0,R0,#0x8000
   \   0000001C   ....               LDR.N    R1,??DataTable10  ;; 0x50060000
   \   0000001E   0860               STR      R0,[R1, #+0]
    245            }
    246          }
   \                     ??CRYP_Cmd_1:
   \   00000020   7047               BX       LR               ;; return
    247          
    248          /**
    249            * @brief  Enables or disables the CRYP DMA interface.
    250            * @param  CRYP_DMAReq: specifies the CRYP DMA transfer request to be enabled or disabled.
    251            *   This parameter can be any combination of the following values:
    252            *     @arg CRYP_DMAReq_Tx: DMA for outgoing(Tx) data transfer
    253            *     @arg CRYP_DMAReq_Rx: DMA for incoming(Rx) data transfer
    254            * @param  NewState: new state of the selected CRYP DMA transfer request.
    255            *   This parameter can be: ENABLE or DISABLE.
    256            * @retval None
    257            */

   \                                 In section .text, align 2, keep-with-next
    258          void CRYP_DMACmd(uint8_t CRYP_DMAReq, FunctionalState NewState)
    259          {
    260            /* Check the parameters */
    261            assert_param(IS_CRYP_DMAREQ(CRYP_DMAReq));
    262            assert_param(IS_FUNCTIONAL_STATE(NewState));
    263          	
    264            if (NewState != DISABLE)
   \                     CRYP_DMACmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   06D0               BEQ.N    ??CRYP_DMACmd_0
    265            {
    266              /* Enable the selected CRYP DMA request */
    267              CRYP->DMACR |= CRYP_DMAReq;
   \   00000006   ....               LDR.N    R1,??DataTable10_13  ;; 0x50060010
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0843               ORRS     R0,R0,R1
   \   0000000E   ....               LDR.N    R1,??DataTable10_13  ;; 0x50060010
   \   00000010   0860               STR      R0,[R1, #+0]
   \   00000012   07E0               B.N      ??CRYP_DMACmd_1
    268            }
    269            else
    270            {
    271              /* Disable the selected CRYP DMA request */
    272              CRYP->DMACR &= (uint16_t)~CRYP_DMAReq;
   \                     ??CRYP_DMACmd_0:
   \   00000014   ....               LDR.N    R1,??DataTable10_13  ;; 0x50060010
   \   00000016   0968               LDR      R1,[R1, #+0]
   \   00000018   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   C043               MVNS     R0,R0
   \   0000001C   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001E   0840               ANDS     R0,R0,R1
   \   00000020   ....               LDR.N    R1,??DataTable10_13  ;; 0x50060010
   \   00000022   0860               STR      R0,[R1, #+0]
    273            }
    274          }
   \                     ??CRYP_DMACmd_1:
   \   00000024   7047               BX       LR               ;; return
    275          
    276          /**
    277            * @brief  Writes data in the Data Input register (DIN).
    278            * @note   After the DIN register has been read once or several times, the FIFO 
    279            *         must be flushed (using CRYP_FIFOFlush() function).  
    280            * @param  Data: data to write in Data Input register
    281            * @retval None
    282            */

   \                                 In section .text, align 2, keep-with-next
    283          void CRYP_DataIn(uint32_t Data)
    284          {
    285            CRYP->DR = Data;
   \                     CRYP_DataIn:
   \   00000000   ....               LDR.N    R1,??DataTable10_14  ;; 0x50060008
   \   00000002   0860               STR      R0,[R1, #+0]
    286          }
   \   00000004   7047               BX       LR               ;; return
    287          
    288          /**
    289            * @brief  Returns the last data entered into the output FIFO.
    290            * @param  None
    291            * @retval Last data entered into the output FIFO.
    292            */

   \                                 In section .text, align 2, keep-with-next
    293          uint32_t CRYP_DataOut(void)
    294          {
    295            return CRYP->DOUT;
   \                     CRYP_DataOut:
   \   00000000   ....               LDR.N    R0,??DataTable10_15  ;; 0x5006000c
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   7047               BX       LR               ;; return
    296          }
    297          
    298          /**
    299            * @brief  Flushes the IN and OUT FIFOs (that is read and write pointers of the 
    300            *   FIFOs are reset)
    301            * @note   The FIFOs must be flushed only when BUSY flag is reset.  
    302            * @param  None
    303            * @retval None
    304            */

   \                                 In section .text, align 2, keep-with-next
    305          void CRYP_FIFOFlush(void)
    306          {
    307            /* Reset the read and write pointers of the FIFOs */
    308            CRYP->CR |= CRYP_CR_FFLUSH;
   \                     CRYP_FIFOFlush:
   \   00000000   ....               LDR.N    R0,??DataTable10  ;; 0x50060000
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   50F48040           ORRS     R0,R0,#0x4000
   \   00000008   ....               LDR.N    R1,??DataTable10  ;; 0x50060000
   \   0000000A   0860               STR      R0,[R1, #+0]
    309          }
   \   0000000C   7047               BX       LR               ;; return
    310          
    311          /**
    312            * @brief  Enables or disables the specified CRYP interrupts.
    313            * @param  CRYP_IT: specifies the CRYP interrupt source to be enabled or disabled.
    314            *   This parameter can be any combination of the following values:
    315            *     @arg CRYP_IT_INI: Input FIFO interrupt
    316            *     @arg CRYP_IT_OUTI: Output FIFO interrupt
    317            * @param  NewState: new state of the specified CRYP interrupt.
    318            *   This parameter can be: ENABLE or DISABLE.
    319            * @retval None
    320            */

   \                                 In section .text, align 2, keep-with-next
    321          void CRYP_ITConfig(uint8_t CRYP_IT, FunctionalState NewState)
    322          {
    323            /* Check the parameters */
    324            assert_param(IS_CRYP_CONFIG_IT(CRYP_IT));
    325            assert_param(IS_FUNCTIONAL_STATE(NewState));
    326          
    327            if (NewState != DISABLE)
   \                     CRYP_ITConfig:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   06D0               BEQ.N    ??CRYP_ITConfig_0
    328            {
    329              /* Enable the selected CRYP interrupt */
    330              CRYP->IMSCR |= CRYP_IT;
   \   00000006   ....               LDR.N    R1,??DataTable10_16  ;; 0x50060014
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0843               ORRS     R0,R0,R1
   \   0000000E   ....               LDR.N    R1,??DataTable10_16  ;; 0x50060014
   \   00000010   0860               STR      R0,[R1, #+0]
   \   00000012   06E0               B.N      ??CRYP_ITConfig_1
    331            }
    332            else
    333            {
    334              /* Disable the selected CRYP interrupt */
    335              CRYP->IMSCR &= ~CRYP_IT;
   \                     ??CRYP_ITConfig_0:
   \   00000014   ....               LDR.N    R1,??DataTable10_16  ;; 0x50060014
   \   00000016   0968               LDR      R1,[R1, #+0]
   \   00000018   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   31EA0000           BICS     R0,R1,R0
   \   0000001E   ....               LDR.N    R1,??DataTable10_16  ;; 0x50060014
   \   00000020   0860               STR      R0,[R1, #+0]
    336            }
    337          }
   \                     ??CRYP_ITConfig_1:
   \   00000022   7047               BX       LR               ;; return
    338          
    339          /**
    340            * @brief  Checks whether the specified CRYP interrupt has occurred or not.
    341            * @note   This function checks the status of the masked interrupt (i.e the 
    342            *         interrupt should be previously enabled).     
    343            * @param  CRYP_IT: specifies the CRYP (masked) interrupt source to check.
    344            *   This parameter can be one of the following values:
    345            *     @arg CRYP_IT_INI: Input FIFO interrupt
    346            *     @arg CRYP_IT_OUTI: Output FIFO interrupt
    347            * @retval The new state of CRYP_IT (SET or RESET).
    348            */

   \                                 In section .text, align 2, keep-with-next
    349          ITStatus CRYP_GetITStatus(uint8_t CRYP_IT)
    350          {
    351            ITStatus bitstatus = RESET;
   \                     CRYP_GetITStatus:
   \   00000000   0021               MOVS     R1,#+0
    352            /* Check the parameters */
    353            assert_param(IS_CRYP_GET_IT(CRYP_IT));
    354          
    355            /* Check the status of the specified CRYP interrupt */
    356            if ((CRYP->MISR & CRYP_IT) != (uint8_t)RESET)
   \   00000002   ....               LDR.N    R2,??DataTable10_17  ;; 0x5006001c
   \   00000004   1268               LDR      R2,[R2, #+0]
   \   00000006   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0242               TST      R2,R0
   \   0000000A   01D0               BEQ.N    ??CRYP_GetITStatus_0
    357            {
    358              /* CRYP_IT is set */
    359              bitstatus = SET;
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   00E0               B.N      ??CRYP_GetITStatus_1
    360            }
    361            else
    362            {
    363              /* CRYP_IT is reset */
    364              bitstatus = RESET;
   \                     ??CRYP_GetITStatus_0:
   \   00000010   0021               MOVS     R1,#+0
    365            }
    366            /* Return the CRYP_IT status */
    367            return bitstatus;
   \                     ??CRYP_GetITStatus_1:
   \   00000012   0800               MOVS     R0,R1
   \   00000014   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   7047               BX       LR               ;; return
    368          }
    369          
    370          /**
    371            * @brief  Checks whether the specified CRYP flag is set or not.
    372            * @param  CRYP_FLAG: specifies the CRYP flag to check.
    373            *   This parameter can be one of the following values:
    374            *     @arg CRYP_FLAG_IFEM: Input FIFO Empty flag.
    375            *     @arg CRYP_FLAG_IFNF: Input FIFO Not Full flag.
    376            *     @arg CRYP_FLAG_OFNE: Output FIFO Not Empty flag.
    377            *     @arg CRYP_FLAG_OFFU: Output FIFO Full flag.
    378            *     @arg CRYP_FLAG_BUSY: Busy flag.
    379            *     @arg CRYP_FLAG_OUTRIS: Output FIFO raw interrupt flag.
    380            *     @arg CRYP_FLAG_INRIS: Input FIFO raw interrupt flag.
    381            * @retval The new state of CRYP_FLAG (SET or RESET).
    382            */

   \                                 In section .text, align 2, keep-with-next
    383          FlagStatus CRYP_GetFlagStatus(uint8_t CRYP_FLAG)
    384          {
    385            FlagStatus bitstatus = RESET;
   \                     CRYP_GetFlagStatus:
   \   00000000   0021               MOVS     R1,#+0
    386            uint32_t tmp, tempreg = 0;
   \   00000002   0023               MOVS     R3,#+0
    387          
    388            /* Check the parameters */
    389            assert_param(IS_CRYP_GET_FLAG(CRYP_FLAG));
    390          
    391            /* Get the register index */
    392            tmp = (((uint8_t)CRYP_FLAG) >> 5);
   \   00000004   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   4209               LSRS     R2,R0,#+5
   \   00000008   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
    393          
    394            if (tmp == 0x00) /* The FLAG is in SR register */
   \   0000000A   002A               CMP      R2,#+0
   \   0000000C   02D1               BNE.N    ??CRYP_GetFlagStatus_0
    395            {
    396              tempreg = CRYP->SR;
   \   0000000E   ....               LDR.N    R1,??DataTable10_18  ;; 0x50060004
   \   00000010   0B68               LDR      R3,[R1, #+0]
   \   00000012   01E0               B.N      ??CRYP_GetFlagStatus_1
    397            }
    398            else /* The FLAG is in RISR register */
    399            {
    400              tempreg = CRYP->RISR;
   \                     ??CRYP_GetFlagStatus_0:
   \   00000014   ....               LDR.N    R1,??DataTable10_19  ;; 0x50060018
   \   00000016   0B68               LDR      R3,[R1, #+0]
    401            }
    402          
    403            /* Get the flag position */
    404            tmp = CRYP_FLAG & FLAG_MASK;
   \                     ??CRYP_GetFlagStatus_1:
   \   00000018   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   10F01F02           ANDS     R2,R0,#0x1F
    405           
    406            /* Check the status of the specified CRYP flag */
    407            if ((tempreg & tmp) != (uint8_t)RESET)
   \   0000001E   1342               TST      R3,R2
   \   00000020   01D0               BEQ.N    ??CRYP_GetFlagStatus_2
    408            {
    409              /* CRYP_FLAG is set */
    410              bitstatus = SET;
   \   00000022   0121               MOVS     R1,#+1
   \   00000024   00E0               B.N      ??CRYP_GetFlagStatus_3
    411            }
    412            else
    413            {
    414              /* CRYP_FLAG is reset */
    415              bitstatus = RESET;
   \                     ??CRYP_GetFlagStatus_2:
   \   00000026   0021               MOVS     R1,#+0
    416            }
    417          
    418            /* Return the CRYP_FLAG status */
    419            return  bitstatus;
   \                     ??CRYP_GetFlagStatus_3:
   \   00000028   0800               MOVS     R0,R1
   \   0000002A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   7047               BX       LR               ;; return
    420          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   00000650           DC32     0x50060000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   40000650           DC32     0x50060040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   44000650           DC32     0x50060044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   48000650           DC32     0x50060048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   4C000650           DC32     0x5006004c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   20000650           DC32     0x50060020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   24000650           DC32     0x50060024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   28000650           DC32     0x50060028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   2C000650           DC32     0x5006002c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   30000650           DC32     0x50060030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   34000650           DC32     0x50060034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   38000650           DC32     0x50060038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   3C000650           DC32     0x5006003c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   10000650           DC32     0x50060010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   08000650           DC32     0x50060008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \   00000000   0C000650           DC32     0x5006000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_16:
   \   00000000   14000650           DC32     0x50060014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_17:
   \   00000000   1C000650           DC32     0x5006001c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_18:
   \   00000000   04000650           DC32     0x50060004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_19:
   \   00000000   18000650           DC32     0x50060018
    421          
    422          /**
    423            * @}
    424            */ 
    425          
    426          
    427          /**
    428            * @}
    429            */ 
    430          
    431          
    432          /**
    433            * @}
    434            */ 
    435          
    436          
    437          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function           .cstack
     --------           -------
     CRYP_Cmd                0
     CRYP_DMACmd             0
     CRYP_DataIn             0
     CRYP_DataOut            0
     CRYP_DeInit             8
     CRYP_FIFOFlush          0
     CRYP_GetFlagStatus      0
     CRYP_GetITStatus        0
     CRYP_ITConfig           0
     CRYP_IVInit             0
     CRYP_IVStructInit       0
     CRYP_Init               0
     CRYP_KeyInit            0
     CRYP_KeyStructInit      0
     CRYP_StructInit         0


   Section sizes:

     Function/Label     Bytes
     --------------     -----
     CRYP_DeInit          20
     CRYP_Init           122
     CRYP_IVInit          26
     CRYP_KeyInit         50
     CRYP_StructInit      18
     CRYP_IVStructInit    18
     CRYP_KeyStructInit   34
     CRYP_Cmd             34
     CRYP_DMACmd          38
     CRYP_DataIn           6
     CRYP_DataOut          6
     CRYP_FIFOFlush       14
     CRYP_ITConfig        36
     CRYP_GetITStatus     24
     CRYP_GetFlagStatus   46
     ??DataTable10         4
     ??DataTable10_1       4
     ??DataTable10_2       4
     ??DataTable10_3       4
     ??DataTable10_4       4
     ??DataTable10_5       4
     ??DataTable10_6       4
     ??DataTable10_7       4
     ??DataTable10_8       4
     ??DataTable10_9       4
     ??DataTable10_10      4
     ??DataTable10_11      4
     ??DataTable10_12      4
     ??DataTable10_13      4
     ??DataTable10_14      4
     ??DataTable10_15      4
     ??DataTable10_16      4
     ??DataTable10_17      4
     ??DataTable10_18      4
     ??DataTable10_19      4

 
 572 bytes in section .text
 
 572 bytes of CODE memory

Errors: none
Warnings: none
