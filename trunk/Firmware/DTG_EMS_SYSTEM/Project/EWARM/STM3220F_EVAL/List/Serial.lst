###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     12/Jan/2012  04:01:40 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\Serial. #
#                    c                                                        #
#    Command line =  "F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\Serial #
#                    .c" -D USE_STDPERIPH_DRIVER -D STM32F2XX -D              #
#                    USE_STM3220F_EVAL -D USE_USB_OTG_FS -D                   #
#                    RTC_CLOCK_SOURCE_LSE -lC "F:\묵작업\[ NewDTG             #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\STM3220F_EVAL\List\" #
#                     -lA "F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\E #
#                    WARM\STM3220F_EVAL\List\" -o "F:\묵작업\[ NewDTG         #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\STM3220F_EVAL\Obj\"  #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0\arm\INC\c\DLib_Config_Full.h" -I           #
#                    "F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\" -I "F:\묵작업\[ NewDTG                              #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\CMSI #
#                    S\CM3\CoreSupport\" -I "F:\묵작업\[ NewDTG               #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\CMSI #
#                    S\CM3\DeviceSupport\ST\STM32F2xx\" -I "F:\묵작업\[       #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Librari #
#                    es\STM32F2xx_StdPeriph_Driver\inc\" -I "F:\묵작업\[      #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utiliti #
#                    es\STM32_EVAL\" -I "F:\묵작업\[ NewDTG                   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\Common\" -I "F:\묵작업\[ NewDTG                   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\STM3220F_EVAL\" -I "F:\묵작업\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_OTG_Driver\inc\" -I "F:\묵작업\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Core\inc\" -I "F:\묵작업\[ NewDTG   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Class\msc\inc\" -I "F:\묵작업\[     #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\" -I   #
#                    "F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\Usb\Inc\" -I "F:\묵작업\[ NewDTG                      #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\src\" -I      #
#                    "F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Core\inc\" -I     #
#                    "F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\"   #
#                    -I "F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWA #
#                    RM\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\in #
#                    c\" -Ol --use_c++_inline                                 #
#    List file    =  F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\List\Serial.lst                             #
#    Object file  =  F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\Obj\Serial.o                                #
#                                                                             #
#                                                                             #
###############################################################################

F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\Serial.c
      1          #include "Serial.h"
      2          #include "main.h"

   \                                 In section .text, align 2
   \   __intrinsic __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   1000               MOVS     R0,R2
   \   00000006   0A00               MOVS     R2,R1
   \   00000008   0100               MOVS     R1,R0
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   ........           BL       __aeabi_memset
   \   00000010   2000               MOVS     R0,R4
   \   00000012   10BD               POP      {R4,PC}          ;; return
      3          

   \                                 In section .bss, align 4
      4          struct _Serial RTX_GPS;
   \                     RTX_GPS:
   \   00000000                      DS8 2068

   \                                 In section .bss, align 4
      5          struct _Serial PC_Comm;
   \                     PC_Comm:
   \   00000000                      DS8 2068
      6          

   \                                 In section .bss, align 4
      7          struct _Serial RF_Module;
   \                     RF_Module:
   \   00000000                      DS8 2068
      8          

   \                                 In section .bss, align 4
      9          u32 KMap_Transmit_Count;
   \                     KMap_Transmit_Count:
   \   00000000                      DS8 4
     10          

   \                                 In section .text, align 2, keep-with-next
     11          void Serial_Config(void)		// Serial 초기화
     12          {
   \                     Serial_Config:
   \   00000000   80B5               PUSH     {R7,LR}
     13          	memset(&RTX_GPS  , 0x00, sizeof( RTX_GPS ) );
   \   00000002   40F61202           MOVW     R2,#+2066
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   ........           LDR.W    R0,??DataTable10
   \   0000000C   ........           BL       memset
     14          	memset(&PC_Comm  , 0x00, sizeof( PC_Comm ) );
   \   00000010   40F61202           MOVW     R2,#+2066
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   ........           LDR.W    R0,??DataTable10_1
   \   0000001A   ........           BL       memset
     15          
     16          	memset(&RF_Module  , 0x00, sizeof( RF_Module ) );     
   \   0000001E   40F61202           MOVW     R2,#+2066
   \   00000022   0021               MOVS     R1,#+0
   \   00000024   ........           LDR.W    R0,??DataTable10_2
   \   00000028   ........           BL       memset
     17               
     18          	USART1_Init(); 	//외부장치 컴퓨터와 통신
   \   0000002C   ........           BL       USART1_Init
     19          	USART2_Init();		// RF 모듈
   \   00000030   ........           BL       USART2_Init
     20          
     21          	USART4_Init();		// GPS
   \   00000034   ........           BL       USART4_Init
     22          	
     23               NVIC_Config();       
   \   00000038   ........           BL       NVIC_Config
     24          }
   \   0000003C   01BD               POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
     25          void Clear_Serial1(void)
     26          {
   \                     Clear_Serial1:
   \   00000000   80B5               PUSH     {R7,LR}
     27          	memset(&PC_Comm  , 0x00, sizeof( RF_Module ) );          
   \   00000002   40F61202           MOVW     R2,#+2066
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   ........           LDR.W    R0,??DataTable10_1
   \   0000000C   ........           BL       memset
     28          }
   \   00000010   01BD               POP      {R0,PC}          ;; return
     29          

   \                                 In section .text, align 2, keep-with-next
     30          void Clear_Serial2()
     31          {
   \                     Clear_Serial2:
   \   00000000   80B5               PUSH     {R7,LR}
     32          	memset(&RF_Module ,0,sizeof(struct _Serial));
   \   00000002   40F61202           MOVW     R2,#+2066
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   ........           LDR.W    R0,??DataTable10_2
   \   0000000C   ........           BL       memset
     33          }
   \   00000010   01BD               POP      {R0,PC}          ;; return
     34          

   \                                 In section .text, align 2, keep-with-next
     35          void Clear_Serial4(void)
     36          {
   \                     Clear_Serial4:
   \   00000000   80B5               PUSH     {R7,LR}
     37          	memset(&RTX_GPS  , 0x00, sizeof( RTX_GPS ) );     
   \   00000002   40F61202           MOVW     R2,#+2066
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   ........           LDR.W    R0,??DataTable10
   \   0000000C   ........           BL       memset
     38          }
   \   00000010   01BD               POP      {R0,PC}          ;; return
     39          
     40          /**********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     41          void NVIC_Config(void)
     42          {
   \                     NVIC_Config:
   \   00000000   80B5               PUSH     {R7,LR}
     43          	NVIC_InitTypeDef NVIC_InitStructure;
     44          	
     45          	/* Enable the USARTx Interrupt */
     46          	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
   \   00000002   2520               MOVS     R0,#+37
   \   00000004   8DF80000           STRB     R0,[SP, #+0]
     47          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   8DF80100           STRB     R0,[SP, #+1]
     48          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   0000000E   0020               MOVS     R0,#+0
   \   00000010   8DF80200           STRB     R0,[SP, #+2]
     49          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000014   0120               MOVS     R0,#+1
   \   00000016   8DF80300           STRB     R0,[SP, #+3]
     50          	NVIC_Init(&NVIC_InitStructure);
   \   0000001A   00A8               ADD      R0,SP,#+0
   \   0000001C   ........           BL       NVIC_Init
     51               	
     52          	/* Enable the USARTx Interrupt */
     53          	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
   \   00000020   2620               MOVS     R0,#+38
   \   00000022   8DF80000           STRB     R0,[SP, #+0]
     54          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
   \   00000026   0020               MOVS     R0,#+0
   \   00000028   8DF80100           STRB     R0,[SP, #+1]
     55          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   0000002C   0020               MOVS     R0,#+0
   \   0000002E   8DF80200           STRB     R0,[SP, #+2]
     56          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000032   0120               MOVS     R0,#+1
   \   00000034   8DF80300           STRB     R0,[SP, #+3]
     57          	NVIC_Init(&NVIC_InitStructure);
   \   00000038   00A8               ADD      R0,SP,#+0
   \   0000003A   ........           BL       NVIC_Init
     58               
     59          	/* Enable the USARTx Interrupt */
     60          	NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
   \   0000003E   3420               MOVS     R0,#+52
   \   00000040   8DF80000           STRB     R0,[SP, #+0]
     61          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
   \   00000044   0020               MOVS     R0,#+0
   \   00000046   8DF80100           STRB     R0,[SP, #+1]
     62          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   0000004A   0020               MOVS     R0,#+0
   \   0000004C   8DF80200           STRB     R0,[SP, #+2]
     63          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000050   0120               MOVS     R0,#+1
   \   00000052   8DF80300           STRB     R0,[SP, #+3]
     64          	NVIC_Init(&NVIC_InitStructure);
   \   00000056   00A8               ADD      R0,SP,#+0
   \   00000058   ........           BL       NVIC_Init
     65          	
     66          }        
   \   0000005C   01BD               POP      {R0,PC}          ;; return
     67          /*******************************************************************************
     68          GPS을 위한 통신초트를 초기화 한다. (UART1)
     69          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     70          void USART1_Init(void)
     71          {
   \                     USART1_Init:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   87B0               SUB      SP,SP,#+28
     72               /* 
     73               USARTx configured as follow:
     74               - BaudRate = 115200 baud  
     75               - Word Length = 8 Bits
     76               - One Stop Bit
     77               - No parity
     78               - Hardware flow control disabled (RTS and CTS signals)
     79               - Receive and transmit enabled
     80               */
     81               USART_InitTypeDef USART_InitStructure;
     82          	GPIO_InitTypeDef GPIO_InitStructure;
     83          	
     84               RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   0120               MOVS     R0,#+1
   \   00000008   ........           BL       RCC_AHB1PeriphClockCmd
     85               RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   1020               MOVS     R0,#+16
   \   00000010   ........           BL       RCC_APB2PeriphClockCmd
     86               /* Connect PXx to USARTx_Tx*/
     87               GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_USART1);
   \   00000014   0722               MOVS     R2,#+7
   \   00000016   0A21               MOVS     R1,#+10
   \   00000018   ........           LDR.W    R0,??DataTable10_3  ;; 0x40020000
   \   0000001C   ........           BL       GPIO_PinAFConfig
     88               
     89               /* Connect PXx to USARTx_Rx*/
     90               GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_USART1);
   \   00000020   0722               MOVS     R2,#+7
   \   00000022   0921               MOVS     R1,#+9
   \   00000024   ........           LDR.W    R0,??DataTable10_3  ;; 0x40020000
   \   00000028   ........           BL       GPIO_PinAFConfig
     91               
     92          	// Configure USART2 Tx (PA.2) as alternate function push-pull 
     93          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
   \   0000002C   4FF40070           MOV      R0,#+512
   \   00000030   0090               STR      R0,[SP, #+0]
     94          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000032   0220               MOVS     R0,#+2
   \   00000034   8DF80500           STRB     R0,[SP, #+5]
     95          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000038   0020               MOVS     R0,#+0
   \   0000003A   8DF80600           STRB     R0,[SP, #+6]
     96               GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   0000003E   0120               MOVS     R0,#+1
   \   00000040   8DF80700           STRB     R0,[SP, #+7]
     97               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   00000044   0220               MOVS     R0,#+2
   \   00000046   8DF80400           STRB     R0,[SP, #+4]
     98          	GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000004A   00A9               ADD      R1,SP,#+0
   \   0000004C   ........           LDR.W    R0,??DataTable10_3  ;; 0x40020000
   \   00000050   ........           BL       GPIO_Init
     99          	
    100          	// Configure USART2 Rx (PA.3) as input floating 
    101          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   00000054   4FF48060           MOV      R0,#+1024
   \   00000058   0090               STR      R0,[SP, #+0]
    102               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   0000005A   0220               MOVS     R0,#+2
   \   0000005C   8DF80400           STRB     R0,[SP, #+4]
    103          	GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000060   00A9               ADD      R1,SP,#+0
   \   00000062   ........           LDR.W    R0,??DataTable10_3  ;; 0x40020000
   \   00000066   ........           BL       GPIO_Init
    104               
    105               USART_InitStructure.USART_BaudRate = 115200;
   \   0000006A   5FF4E130           MOVS     R0,#+115200
   \   0000006E   0290               STR      R0,[SP, #+8]
    106               USART_InitStructure.USART_WordLength = USART_WordLength_8b;
   \   00000070   0020               MOVS     R0,#+0
   \   00000072   ADF80C00           STRH     R0,[SP, #+12]
    107               USART_InitStructure.USART_StopBits = USART_StopBits_1;
   \   00000076   0020               MOVS     R0,#+0
   \   00000078   ADF80E00           STRH     R0,[SP, #+14]
    108               USART_InitStructure.USART_Parity = USART_Parity_No;
   \   0000007C   0020               MOVS     R0,#+0
   \   0000007E   ADF81000           STRH     R0,[SP, #+16]
    109               USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   00000082   0020               MOVS     R0,#+0
   \   00000084   ADF81400           STRH     R0,[SP, #+20]
    110               USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   00000088   0C20               MOVS     R0,#+12
   \   0000008A   ADF81200           STRH     R0,[SP, #+18]
    111          	
    112               USART_Init(USART1, &USART_InitStructure);
   \   0000008E   02A9               ADD      R1,SP,#+8
   \   00000090   ........           LDR.W    R0,??DataTable10_4  ;; 0x40011000
   \   00000094   ........           BL       USART_Init
    113               USART_Cmd(USART1, ENABLE);
   \   00000098   0121               MOVS     R1,#+1
   \   0000009A   ........           LDR.W    R0,??DataTable10_4  ;; 0x40011000
   \   0000009E   ........           BL       USART_Cmd
    114               USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	         
   \   000000A2   0122               MOVS     R2,#+1
   \   000000A4   40F22551           MOVW     R1,#+1317
   \   000000A8   ........           LDR.W    R0,??DataTable10_4  ;; 0x40011000
   \   000000AC   ........           BL       USART_ITConfig
    115               
    116          }
   \   000000B0   07B0               ADD      SP,SP,#+28
   \   000000B2   00BD               POP      {PC}             ;; return
    117          /*******************************************************************************
    118          외부 통신을 위한 통신초트를 초기화 한다. (UART2)
    119          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    120          void USART2_Init(void)
    121          {
   \                     USART2_Init:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   87B0               SUB      SP,SP,#+28
    122               /* USARTx configured as follow:
    123               - BaudRate = 115200 baud  
    124               - Word Length = 8 Bits
    125               - One Stop Bit
    126               - No parity
    127               - Hardware flow control disabled (RTS and CTS signals)
    128               - Receive and transmit enabled
    129               */
    130               USART_InitTypeDef USART_InitStructure;
    131          	GPIO_InitTypeDef GPIO_InitStructure;
    132          	
    133               RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   0120               MOVS     R0,#+1
   \   00000008   ........           BL       RCC_AHB1PeriphClockCmd
    134               RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   5FF40030           MOVS     R0,#+131072
   \   00000012   ........           BL       RCC_APB1PeriphClockCmd
    135               /* Connect PXx to USARTx_Tx*/
    136          //     GPIO_PinAFConfig(GPIOA, GPIO_PinSource0, GPIO_AF_USART2);     
    137          //     GPIO_PinAFConfig(GPIOA, GPIO_PinSource1, GPIO_AF_USART2);        
    138               GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);
   \   00000016   0722               MOVS     R2,#+7
   \   00000018   0221               MOVS     R1,#+2
   \   0000001A   ........           LDR.W    R0,??DataTable10_3  ;; 0x40020000
   \   0000001E   ........           BL       GPIO_PinAFConfig
    139            
    140               /* Connect PXx to USARTx_Rx*/
    141               GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_USART2);
   \   00000022   0722               MOVS     R2,#+7
   \   00000024   0321               MOVS     R1,#+3
   \   00000026   ........           LDR.W    R0,??DataTable10_3  ;; 0x40020000
   \   0000002A   ........           BL       GPIO_PinAFConfig
    142          
    143               
    144               // Configure USART2 Tx (PA.2) as alternate function push-pull 
    145               GPIO_InitStructure.GPIO_Pin = /*GPIO_Pin_0 | GPIO_Pin_1 |*/ GPIO_Pin_2;
   \   0000002E   0420               MOVS     R0,#+4
   \   00000030   0090               STR      R0,[SP, #+0]
    146               GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000032   0220               MOVS     R0,#+2
   \   00000034   8DF80500           STRB     R0,[SP, #+5]
    147               GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;        
   \   00000038   0020               MOVS     R0,#+0
   \   0000003A   8DF80600           STRB     R0,[SP, #+6]
    148               GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   0000003E   0120               MOVS     R0,#+1
   \   00000040   8DF80700           STRB     R0,[SP, #+7]
    149               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;        
   \   00000044   0220               MOVS     R0,#+2
   \   00000046   8DF80400           STRB     R0,[SP, #+4]
    150               GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000004A   00A9               ADD      R1,SP,#+0
   \   0000004C   ........           LDR.W    R0,??DataTable10_3  ;; 0x40020000
   \   00000050   ........           BL       GPIO_Init
    151          	
    152               // Configure USART2 Rx (PA.3) as input floating 
    153               GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
   \   00000054   0820               MOVS     R0,#+8
   \   00000056   0090               STR      R0,[SP, #+0]
    154               
    155               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   00000058   0220               MOVS     R0,#+2
   \   0000005A   8DF80400           STRB     R0,[SP, #+4]
    156               GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000005E   00A9               ADD      R1,SP,#+0
   \   00000060   ........           LDR.W    R0,??DataTable10_3  ;; 0x40020000
   \   00000064   ........           BL       GPIO_Init
    157               
    158               USART_InitStructure.USART_BaudRate = 115200;
   \   00000068   5FF4E130           MOVS     R0,#+115200
   \   0000006C   0290               STR      R0,[SP, #+8]
    159               USART_InitStructure.USART_WordLength = USART_WordLength_8b;
   \   0000006E   0020               MOVS     R0,#+0
   \   00000070   ADF80C00           STRH     R0,[SP, #+12]
    160               USART_InitStructure.USART_StopBits = USART_StopBits_1;
   \   00000074   0020               MOVS     R0,#+0
   \   00000076   ADF80E00           STRH     R0,[SP, #+14]
    161               USART_InitStructure.USART_Parity = USART_Parity_No;
   \   0000007A   0020               MOVS     R0,#+0
   \   0000007C   ADF81000           STRH     R0,[SP, #+16]
    162               USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   00000080   0020               MOVS     R0,#+0
   \   00000082   ADF81400           STRH     R0,[SP, #+20]
    163               USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   00000086   0C20               MOVS     R0,#+12
   \   00000088   ADF81200           STRH     R0,[SP, #+18]
    164          	
    165               USART_Init(USART2, &USART_InitStructure);
   \   0000008C   02A9               ADD      R1,SP,#+8
   \   0000008E   ........           LDR.W    R0,??DataTable10_5  ;; 0x40004400
   \   00000092   ........           BL       USART_Init
    166               USART_Cmd(USART2, ENABLE);
   \   00000096   0121               MOVS     R1,#+1
   \   00000098   ........           LDR.W    R0,??DataTable10_5  ;; 0x40004400
   \   0000009C   ........           BL       USART_Cmd
    167               USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);	        
   \   000000A0   0122               MOVS     R2,#+1
   \   000000A2   40F22551           MOVW     R1,#+1317
   \   000000A6   ........           LDR.W    R0,??DataTable10_5  ;; 0x40004400
   \   000000AA   ........           BL       USART_ITConfig
    168               
    169          }
   \   000000AE   07B0               ADD      SP,SP,#+28
   \   000000B0   00BD               POP      {PC}             ;; return
    170          
    171          /*******************************************************************************
    172          GPS을 위한 통신초트를 초기화 한다. (UART4)
    173          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    174          void USART4_Init(void)
    175          {
   \                     USART4_Init:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   87B0               SUB      SP,SP,#+28
    176               /* USARTx configured as follow:
    177               - BaudRate = 9600 baud  
    178               - Word Length = 8 Bits
    179               - One Stop Bit
    180               - No parity
    181               - Hardware flow control disabled (RTS and CTS signals)
    182               - Receive and transmit enabled
    183               */
    184               USART_InitTypeDef USART_InitStructure;
    185          	GPIO_InitTypeDef GPIO_InitStructure;
    186          	
    187               RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   0420               MOVS     R0,#+4
   \   00000008   ........           BL       RCC_AHB1PeriphClockCmd
    188               RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   5FF40020           MOVS     R0,#+524288
   \   00000012   ........           BL       RCC_APB1PeriphClockCmd
    189               /* Connect PXx to USARTx_Tx*/
    190               GPIO_PinAFConfig(GPIOC, GPIO_PinSource11, GPIO_AF_UART4);
   \   00000016   0822               MOVS     R2,#+8
   \   00000018   0B21               MOVS     R1,#+11
   \   0000001A   ........           LDR.W    R0,??DataTable10_6  ;; 0x40020800
   \   0000001E   ........           BL       GPIO_PinAFConfig
    191               
    192               /* Connect PXx to USARTx_Rx*/
    193               GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_UART4);
   \   00000022   0822               MOVS     R2,#+8
   \   00000024   0A21               MOVS     R1,#+10
   \   00000026   ........           LDR.W    R0,??DataTable10_6  ;; 0x40020800
   \   0000002A   ........           BL       GPIO_PinAFConfig
    194               
    195          	// Configure USART2 Tx (PA.2) as alternate function push-pull 
    196          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   0000002E   4FF48060           MOV      R0,#+1024
   \   00000032   0090               STR      R0,[SP, #+0]
    197          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000034   0220               MOVS     R0,#+2
   \   00000036   8DF80500           STRB     R0,[SP, #+5]
    198               GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   0000003A   0020               MOVS     R0,#+0
   \   0000003C   8DF80600           STRB     R0,[SP, #+6]
    199               GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   00000040   0120               MOVS     R0,#+1
   \   00000042   8DF80700           STRB     R0,[SP, #+7]
    200               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;        
   \   00000046   0220               MOVS     R0,#+2
   \   00000048   8DF80400           STRB     R0,[SP, #+4]
    201          	GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   0000004C   00A9               ADD      R1,SP,#+0
   \   0000004E   ....               LDR.N    R0,??DataTable10_6  ;; 0x40020800
   \   00000050   ........           BL       GPIO_Init
    202          	
    203          	// Configure USART2 Rx (PA.3) as input floating 
    204          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
   \   00000054   4FF40060           MOV      R0,#+2048
   \   00000058   0090               STR      R0,[SP, #+0]
    205               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   0000005A   0220               MOVS     R0,#+2
   \   0000005C   8DF80400           STRB     R0,[SP, #+4]
    206          	GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   00000060   00A9               ADD      R1,SP,#+0
   \   00000062   ....               LDR.N    R0,??DataTable10_6  ;; 0x40020800
   \   00000064   ........           BL       GPIO_Init
    207               
    208               USART_InitStructure.USART_BaudRate = 9600;
   \   00000068   4FF41650           MOV      R0,#+9600
   \   0000006C   0290               STR      R0,[SP, #+8]
    209               USART_InitStructure.USART_WordLength = USART_WordLength_8b;
   \   0000006E   0020               MOVS     R0,#+0
   \   00000070   ADF80C00           STRH     R0,[SP, #+12]
    210               USART_InitStructure.USART_StopBits = USART_StopBits_1;
   \   00000074   0020               MOVS     R0,#+0
   \   00000076   ADF80E00           STRH     R0,[SP, #+14]
    211               USART_InitStructure.USART_Parity = USART_Parity_No;
   \   0000007A   0020               MOVS     R0,#+0
   \   0000007C   ADF81000           STRH     R0,[SP, #+16]
    212               USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   00000080   0020               MOVS     R0,#+0
   \   00000082   ADF81400           STRH     R0,[SP, #+20]
    213               USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   00000086   0C20               MOVS     R0,#+12
   \   00000088   ADF81200           STRH     R0,[SP, #+18]
    214               
    215               USART_Init(UART4, &USART_InitStructure);
   \   0000008C   02A9               ADD      R1,SP,#+8
   \   0000008E   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   00000090   ........           BL       USART_Init
    216               USART_Cmd(UART4, ENABLE);
   \   00000094   0121               MOVS     R1,#+1
   \   00000096   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   00000098   ........           BL       USART_Cmd
    217               USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);
   \   0000009C   0122               MOVS     R2,#+1
   \   0000009E   40F22551           MOVW     R1,#+1317
   \   000000A2   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   000000A4   ........           BL       USART_ITConfig
    218          }
   \   000000A8   07B0               ADD      SP,SP,#+28
   \   000000AA   00BD               POP      {PC}             ;; return
    219          

   \                                 In section .text, align 2, keep-with-next
    220          void USART1_IRQHandler(void)		// RF 데이터를 받는다.
    221          {
   \                     USART1_IRQHandler:
   \   00000000   10B5               PUSH     {R4,LR}
    222          	static unsigned char data;
    223          	struct _Serial *serial;
    224          	
    225          	//   u16   ErrorFlag = 0;
    226          	
    227          	serial = &PC_Comm;
   \   00000002   ....               LDR.N    R4,??DataTable10_1
    228          	
    229          	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
   \   00000004   40F22551           MOVW     R1,#+1317
   \   00000008   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   0000000A   ........           BL       USART_GetITStatus
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   47D0               BEQ.N    ??USART1_IRQHandler_0
    230          	{
    231          		if (USART_GetFlagStatus(USART1, USART_FLAG_ORE) != RESET) {
   \   00000012   0821               MOVS     R1,#+8
   \   00000014   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   00000016   ........           BL       USART_GetFlagStatus
   \   0000001A   0028               CMP      R0,#+0
   \   0000001C   03D0               BEQ.N    ??USART1_IRQHandler_1
    232          			USART_ClearITPendingBit(USART1, USART_FLAG_ORE);  
   \   0000001E   0821               MOVS     R1,#+8
   \   00000020   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   00000022   ........           BL       USART_ClearITPendingBit
    233                         //			ErrorFlag = 1;
    234          		}
    235          		if (USART_GetFlagStatus(USART1, USART_FLAG_NE) != RESET) {
   \                     ??USART1_IRQHandler_1:
   \   00000026   0421               MOVS     R1,#+4
   \   00000028   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   0000002A   ........           BL       USART_GetFlagStatus
   \   0000002E   0028               CMP      R0,#+0
   \   00000030   03D0               BEQ.N    ??USART1_IRQHandler_2
    236          			USART_ClearITPendingBit(USART1, USART_FLAG_NE);
   \   00000032   0421               MOVS     R1,#+4
   \   00000034   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   00000036   ........           BL       USART_ClearITPendingBit
    237                         //			ErrorFlag = 1;
    238          		}
    239          		if (USART_GetFlagStatus(USART1, USART_FLAG_FE) != RESET) {
   \                     ??USART1_IRQHandler_2:
   \   0000003A   0221               MOVS     R1,#+2
   \   0000003C   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   0000003E   ........           BL       USART_GetFlagStatus
   \   00000042   0028               CMP      R0,#+0
   \   00000044   03D0               BEQ.N    ??USART1_IRQHandler_3
    240          			USART_ClearITPendingBit(USART1, USART_FLAG_FE);
   \   00000046   0221               MOVS     R1,#+2
   \   00000048   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   0000004A   ........           BL       USART_ClearITPendingBit
    241                         //			ErrorFlag = 1;
    242          		}
    243          		if (USART_GetFlagStatus(USART1, USART_FLAG_PE) != RESET) {
   \                     ??USART1_IRQHandler_3:
   \   0000004E   0121               MOVS     R1,#+1
   \   00000050   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   00000052   ........           BL       USART_GetFlagStatus
   \   00000056   0028               CMP      R0,#+0
   \   00000058   03D0               BEQ.N    ??USART1_IRQHandler_4
    244          			USART_ClearITPendingBit(USART1, USART_FLAG_PE);
   \   0000005A   0121               MOVS     R1,#+1
   \   0000005C   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   0000005E   ........           BL       USART_ClearITPendingBit
    245                         //			ErrorFlag = 1;
    246          		}
    247                    
    248          		// 수신된 데이타를 버퍼에 넣음
    249          		data = (USART_ReceiveData(USART1) & 0xFF);
   \                     ??USART1_IRQHandler_4:
   \   00000062   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   00000064   ........           BL       USART_ReceiveData
   \   00000068   ....               LDR.N    R1,??DataTable10_8
   \   0000006A   0870               STRB     R0,[R1, #+0]
    250          		serial->rxbuf[serial->rxep] = data;
   \   0000006C   B4F80204           LDRH     R0,[R4, #+1026]
   \   00000070   ....               LDR.N    R1,??DataTable10_8
   \   00000072   0978               LDRB     R1,[R1, #+0]
   \   00000074   0155               STRB     R1,[R0, R4]
    251          		serial->rxep ++;
   \   00000076   B4F80204           LDRH     R0,[R4, #+1026]
   \   0000007A   401C               ADDS     R0,R0,#+1
   \   0000007C   A4F80204           STRH     R0,[R4, #+1026]
    252          //          serial->RxBuf_Count++;         //  메시지 버퍼큐
    253          		// 수신 버퍼를 초과하는 경우 버림
    254          		if (serial->rxep >= sizeof(serial->rxbuf)) serial->rxep = 0;
   \   00000080   B4F80204           LDRH     R0,[R4, #+1026]
   \   00000084   B0F5806F           CMP      R0,#+1024
   \   00000088   02D3               BCC.N    ??USART1_IRQHandler_5
   \   0000008A   0020               MOVS     R0,#+0
   \   0000008C   A4F80204           STRH     R0,[R4, #+1026]
    255                    
    256          		// 다음 문자는 무조건 0으로 
    257          		serial->rxbuf[serial->rxep] = 0;	
   \                     ??USART1_IRQHandler_5:
   \   00000090   B4F80204           LDRH     R0,[R4, #+1026]
   \   00000094   0021               MOVS     R1,#+0
   \   00000096   0155               STRB     R1,[R0, R4]
    258          		
    259          		/*		
    260          		data = (USART_ReceiveData(UART4) & 0xFF);			// 수신된 데이타를 버퍼에 넣음
    261          		
    262                    Buffer[BuffCnt++ ] = data;
    263          		*/
    264                    
    265          		// Clear the USART2 Receive interrupt 
    266          		USART_ClearITPendingBit(USART1, USART_IT_RXNE | USART_IT_TXE | USART_IT_ERR);
   \   00000098   40F26771           MOVW     R1,#+1895
   \   0000009C   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   0000009E   ........           BL       USART_ClearITPendingBit
    267          	} 
    268          }
   \                     ??USART1_IRQHandler_0:
   \   000000A2   10BD               POP      {R4,PC}          ;; return

   \                                 In section .bss, align 1
   \                     ??data:
   \   00000000                      DS8 1

   \                                 In section .text, align 2, keep-with-next
    269          void USART2_IRQHandler(void)		// RF 데이터를 받는다.
    270          {
   \                     USART2_IRQHandler:
   \   00000000   10B5               PUSH     {R4,LR}
    271          	static unsigned char data;
    272          	struct _Serial *serial;
    273          	
    274          	//   u16   ErrorFlag = 0;
    275          	
    276          	serial = &RF_Module;
   \   00000002   ....               LDR.N    R4,??DataTable10_2
    277          	
    278          	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
   \   00000004   40F22551           MOVW     R1,#+1317
   \   00000008   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   0000000A   ........           BL       USART_GetITStatus
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   47D0               BEQ.N    ??USART2_IRQHandler_0
    279          	{
    280          		if (USART_GetFlagStatus(USART2, USART_FLAG_ORE) != RESET) {
   \   00000012   0821               MOVS     R1,#+8
   \   00000014   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   00000016   ........           BL       USART_GetFlagStatus
   \   0000001A   0028               CMP      R0,#+0
   \   0000001C   03D0               BEQ.N    ??USART2_IRQHandler_1
    281          			USART_ClearITPendingBit(USART2, USART_FLAG_ORE);
   \   0000001E   0821               MOVS     R1,#+8
   \   00000020   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   00000022   ........           BL       USART_ClearITPendingBit
    282                         //			ErrorFlag = 1;
    283          		}
    284          		if (USART_GetFlagStatus(USART2, USART_FLAG_NE) != RESET) {
   \                     ??USART2_IRQHandler_1:
   \   00000026   0421               MOVS     R1,#+4
   \   00000028   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   0000002A   ........           BL       USART_GetFlagStatus
   \   0000002E   0028               CMP      R0,#+0
   \   00000030   03D0               BEQ.N    ??USART2_IRQHandler_2
    285          			USART_ClearITPendingBit(USART2, USART_FLAG_NE);
   \   00000032   0421               MOVS     R1,#+4
   \   00000034   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   00000036   ........           BL       USART_ClearITPendingBit
    286                         //			ErrorFlag = 1;
    287          		}
    288          		if (USART_GetFlagStatus(USART2, USART_FLAG_FE) != RESET) {
   \                     ??USART2_IRQHandler_2:
   \   0000003A   0221               MOVS     R1,#+2
   \   0000003C   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   0000003E   ........           BL       USART_GetFlagStatus
   \   00000042   0028               CMP      R0,#+0
   \   00000044   03D0               BEQ.N    ??USART2_IRQHandler_3
    289          			USART_ClearITPendingBit(USART2, USART_FLAG_FE);
   \   00000046   0221               MOVS     R1,#+2
   \   00000048   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   0000004A   ........           BL       USART_ClearITPendingBit
    290                         //			ErrorFlag = 1;
    291          		}
    292          		if (USART_GetFlagStatus(USART2, USART_FLAG_PE) != RESET) {
   \                     ??USART2_IRQHandler_3:
   \   0000004E   0121               MOVS     R1,#+1
   \   00000050   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   00000052   ........           BL       USART_GetFlagStatus
   \   00000056   0028               CMP      R0,#+0
   \   00000058   03D0               BEQ.N    ??USART2_IRQHandler_4
    293          			USART_ClearITPendingBit(USART2, USART_FLAG_PE);
   \   0000005A   0121               MOVS     R1,#+1
   \   0000005C   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   0000005E   ........           BL       USART_ClearITPendingBit
    294                         //			ErrorFlag = 1;
    295          		}
    296                    
    297          		// 수신된 데이타를 버퍼에 넣음
    298          //          if(serial->RxBuf_Count < MAX_SERIAL_BUF)
    299          //          {
    300                    data = (USART_ReceiveData(USART2) & 0xFF);
   \                     ??USART2_IRQHandler_4:
   \   00000062   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   00000064   ........           BL       USART_ReceiveData
   \   00000068   ....               LDR.N    R1,??DataTable10_9
   \   0000006A   0870               STRB     R0,[R1, #+0]
    301                    serial->rxbuf[serial->rxep] = data;
   \   0000006C   B4F80204           LDRH     R0,[R4, #+1026]
   \   00000070   ....               LDR.N    R1,??DataTable10_9
   \   00000072   0978               LDRB     R1,[R1, #+0]
   \   00000074   0155               STRB     R1,[R0, R4]
    302                    serial->rxep ++;
   \   00000076   B4F80204           LDRH     R0,[R4, #+1026]
   \   0000007A   401C               ADDS     R0,R0,#+1
   \   0000007C   A4F80204           STRH     R0,[R4, #+1026]
    303          //          serial->RxBuf_Count++;
    304                    // 수신 버퍼를 초과하는 경우 버림
    305                    if (serial->rxep >= sizeof(serial->rxbuf)) serial->rxep = 0;
   \   00000080   B4F80204           LDRH     R0,[R4, #+1026]
   \   00000084   B0F5806F           CMP      R0,#+1024
   \   00000088   02D3               BCC.N    ??USART2_IRQHandler_5
   \   0000008A   0020               MOVS     R0,#+0
   \   0000008C   A4F80204           STRH     R0,[R4, #+1026]
    306                    
    307                    // 다음 문자는 무조건 0으로 
    308                    serial->rxbuf[serial->rxep] = 0;	
   \                     ??USART2_IRQHandler_5:
   \   00000090   B4F80204           LDRH     R0,[R4, #+1026]
   \   00000094   0021               MOVS     R1,#+0
   \   00000096   0155               STRB     R1,[R0, R4]
    309          //		}
    310          		/*		
    311          		data = (USART_ReceiveData(UART4) & 0xFF);			// 수신된 데이타를 버퍼에 넣음
    312          		
    313                    Buffer[BuffCnt++ ] = data;
    314          		*/
    315                    
    316          		// Clear the USART2 Receive interrupt 
    317          		USART_ClearITPendingBit(USART2, USART_IT_RXNE | USART_IT_TXE | USART_IT_ERR);
   \   00000098   40F26771           MOVW     R1,#+1895
   \   0000009C   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   0000009E   ........           BL       USART_ClearITPendingBit
    318          	} 
    319          }
   \                     ??USART2_IRQHandler_0:
   \   000000A2   10BD               POP      {R4,PC}          ;; return

   \                                 In section .bss, align 1
   \                     ??data_1:
   \   00000000                      DS8 1
    320          

   \                                 In section .text, align 2, keep-with-next
    321          void UART4_IRQHandler(void)		// GPS 데이터를 받는다.
    322          {
   \                     UART4_IRQHandler:
   \   00000000   10B5               PUSH     {R4,LR}
    323          	static unsigned char data;
    324          	struct _Serial *serial;
    325          	
    326          	//   u16   ErrorFlag = 0;
    327          	
    328          	serial = &RTX_GPS;
   \   00000002   ....               LDR.N    R4,??DataTable10
    329          	
    330          	if(USART_GetITStatus(UART4, USART_IT_RXNE) != RESET)
   \   00000004   40F22551           MOVW     R1,#+1317
   \   00000008   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   0000000A   ........           BL       USART_GetITStatus
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   47D0               BEQ.N    ??UART4_IRQHandler_0
    331          	{
    332          		if (USART_GetFlagStatus(UART4, USART_FLAG_ORE) != RESET) {
   \   00000012   0821               MOVS     R1,#+8
   \   00000014   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   00000016   ........           BL       USART_GetFlagStatus
   \   0000001A   0028               CMP      R0,#+0
   \   0000001C   03D0               BEQ.N    ??UART4_IRQHandler_1
    333          			USART_ClearITPendingBit(UART4, USART_FLAG_ORE);
   \   0000001E   0821               MOVS     R1,#+8
   \   00000020   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   00000022   ........           BL       USART_ClearITPendingBit
    334                         //			ErrorFlag = 1;
    335          		}
    336          		if (USART_GetFlagStatus(UART4, USART_FLAG_NE) != RESET) {
   \                     ??UART4_IRQHandler_1:
   \   00000026   0421               MOVS     R1,#+4
   \   00000028   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   0000002A   ........           BL       USART_GetFlagStatus
   \   0000002E   0028               CMP      R0,#+0
   \   00000030   03D0               BEQ.N    ??UART4_IRQHandler_2
    337          			USART_ClearITPendingBit(UART4, USART_FLAG_NE);
   \   00000032   0421               MOVS     R1,#+4
   \   00000034   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   00000036   ........           BL       USART_ClearITPendingBit
    338                         //			ErrorFlag = 1;
    339          		}
    340          		if (USART_GetFlagStatus(UART4, USART_FLAG_FE) != RESET) {
   \                     ??UART4_IRQHandler_2:
   \   0000003A   0221               MOVS     R1,#+2
   \   0000003C   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   0000003E   ........           BL       USART_GetFlagStatus
   \   00000042   0028               CMP      R0,#+0
   \   00000044   03D0               BEQ.N    ??UART4_IRQHandler_3
    341          			USART_ClearITPendingBit(UART4, USART_FLAG_FE);
   \   00000046   0221               MOVS     R1,#+2
   \   00000048   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   0000004A   ........           BL       USART_ClearITPendingBit
    342                         //			ErrorFlag = 1;
    343          		}
    344          		if (USART_GetFlagStatus(UART4, USART_FLAG_PE) != RESET) {
   \                     ??UART4_IRQHandler_3:
   \   0000004E   0121               MOVS     R1,#+1
   \   00000050   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   00000052   ........           BL       USART_GetFlagStatus
   \   00000056   0028               CMP      R0,#+0
   \   00000058   03D0               BEQ.N    ??UART4_IRQHandler_4
    345          			USART_ClearITPendingBit(UART4, USART_FLAG_PE);
   \   0000005A   0121               MOVS     R1,#+1
   \   0000005C   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   0000005E   ........           BL       USART_ClearITPendingBit
    346                         //			ErrorFlag = 1;
    347          		}
    348                    
    349          		// 수신된 데이타를 버퍼에 넣음
    350          		data = (USART_ReceiveData(UART4) & 0xFF);
   \                     ??UART4_IRQHandler_4:
   \   00000062   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   00000064   ........           BL       USART_ReceiveData
   \   00000068   ....               LDR.N    R1,??DataTable10_10
   \   0000006A   0870               STRB     R0,[R1, #+0]
    351          		serial->rxbuf[serial->rxep] = data;
   \   0000006C   B4F80204           LDRH     R0,[R4, #+1026]
   \   00000070   ....               LDR.N    R1,??DataTable10_10
   \   00000072   0978               LDRB     R1,[R1, #+0]
   \   00000074   0155               STRB     R1,[R0, R4]
    352          		serial->rxep ++;
   \   00000076   B4F80204           LDRH     R0,[R4, #+1026]
   \   0000007A   401C               ADDS     R0,R0,#+1
   \   0000007C   A4F80204           STRH     R0,[R4, #+1026]
    353                    
    354          		// 수신 버퍼를 초과하는 경우 버림
    355          		if (serial->rxep >= sizeof(serial->rxbuf)) serial->rxep = 0;
   \   00000080   B4F80204           LDRH     R0,[R4, #+1026]
   \   00000084   B0F5806F           CMP      R0,#+1024
   \   00000088   02D3               BCC.N    ??UART4_IRQHandler_5
   \   0000008A   0020               MOVS     R0,#+0
   \   0000008C   A4F80204           STRH     R0,[R4, #+1026]
    356                    
    357          		// 다음 문자는 무조건 0으로 
    358          		serial->rxbuf[serial->rxep] = 0;	
   \                     ??UART4_IRQHandler_5:
   \   00000090   B4F80204           LDRH     R0,[R4, #+1026]
   \   00000094   0021               MOVS     R1,#+0
   \   00000096   0155               STRB     R1,[R0, R4]
    359          		
    360          		/*		
    361          		data = (USART_ReceiveData(UART4) & 0xFF);			// 수신된 데이타를 버퍼에 넣음
    362          		
    363                    Buffer[BuffCnt++ ] = data;
    364          		*/
    365                    
    366          		// Clear the USART2 Receive interrupt 
    367          		USART_ClearITPendingBit(UART4, USART_IT_RXNE | USART_IT_TXE | USART_IT_ERR);
   \   00000098   40F26771           MOVW     R1,#+1895
   \   0000009C   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   0000009E   ........           BL       USART_ClearITPendingBit
    368          	} 
    369          }
   \                     ??UART4_IRQHandler_0:
   \   000000A2   10BD               POP      {R4,PC}          ;; return

   \                                 In section .bss, align 1
   \                     ??data_2:
   \   00000000                      DS8 1
    370          

   \                                 In section .text, align 2, keep-with-next
    371          void puts_data(struct _Serial *serial, char *str,u32 Length)
    372          {
   \                     puts_data:
   \   00000000   30B4               PUSH     {R4,R5}
    373               u32 i;
    374               for( i = 0 ; i < Length ; i++)
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   13E0               B.N      ??puts_data_0
    375               {
    376                    serial->txbuf[serial->txep++] = *str;
   \                     ??puts_data_1:
   \   00000006   B0F80E48           LDRH     R4,[R0, #+2062]
   \   0000000A   651C               ADDS     R5,R4,#+1
   \   0000000C   A0F80E58           STRH     R5,[R0, #+2062]
   \   00000010   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000012   2418               ADDS     R4,R4,R0
   \   00000014   0D78               LDRB     R5,[R1, #+0]
   \   00000016   84F80B54           STRB     R5,[R4, #+1035]
    377                    str++;
   \   0000001A   491C               ADDS     R1,R1,#+1
    378                    
    379                    if (serial->txep >= MAX_SERIAL_BUF) serial->txep = 0;
   \   0000001C   B0F80E48           LDRH     R4,[R0, #+2062]
   \   00000020   B4F5806F           CMP      R4,#+1024
   \   00000024   02D3               BCC.N    ??puts_data_2
   \   00000026   0024               MOVS     R4,#+0
   \   00000028   A0F80E48           STRH     R4,[R0, #+2062]
    380               }
   \                     ??puts_data_2:
   \   0000002C   5B1C               ADDS     R3,R3,#+1
   \                     ??puts_data_0:
   \   0000002E   9342               CMP      R3,R2
   \   00000030   E9D3               BCC.N    ??puts_data_1
    381          }
   \   00000032   30BC               POP      {R4,R5}
   \   00000034   7047               BX       LR               ;; return
    382          

   \                                 In section .text, align 2, keep-with-next
    383          void puts_string(struct _Serial *serial, char *str)
    384          {
   \                     puts_string:
   \   00000000   12E0               B.N      ??puts_string_0
    385               while(*str) {
    386                    serial->txbuf[serial->txep++] = *str;
   \                     ??puts_string_1:
   \   00000002   B0F80E28           LDRH     R2,[R0, #+2062]
   \   00000006   531C               ADDS     R3,R2,#+1
   \   00000008   A0F80E38           STRH     R3,[R0, #+2062]
   \   0000000C   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000E   1218               ADDS     R2,R2,R0
   \   00000010   0B78               LDRB     R3,[R1, #+0]
   \   00000012   82F80B34           STRB     R3,[R2, #+1035]
    387                    str++;
   \   00000016   491C               ADDS     R1,R1,#+1
    388                    
    389                    if (serial->txep >= MAX_SERIAL_BUF) serial->txep = 0;
   \   00000018   B0F80E28           LDRH     R2,[R0, #+2062]
   \   0000001C   B2F5806F           CMP      R2,#+1024
   \   00000020   02D3               BCC.N    ??puts_string_0
   \   00000022   0022               MOVS     R2,#+0
   \   00000024   A0F80E28           STRH     R2,[R0, #+2062]
    390               }
   \                     ??puts_string_0:
   \   00000028   0A78               LDRB     R2,[R1, #+0]
   \   0000002A   002A               CMP      R2,#+0
   \   0000002C   E9D1               BNE.N    ??puts_string_1
    391          }
   \   0000002E   7047               BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    392          void puts_char(struct _Serial *serial, char str)
    393          {
    394               serial->txbuf[serial->txep++] = str;    
   \                     puts_char:
   \   00000000   B0F80E28           LDRH     R2,[R0, #+2062]
   \   00000004   531C               ADDS     R3,R2,#+1
   \   00000006   A0F80E38           STRH     R3,[R0, #+2062]
   \   0000000A   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000C   1218               ADDS     R2,R2,R0
   \   0000000E   82F80B14           STRB     R1,[R2, #+1035]
    395               if (serial->txep >= MAX_SERIAL_BUF) serial->txep = 0;
   \   00000012   B0F80E18           LDRH     R1,[R0, #+2062]
   \   00000016   B1F5806F           CMP      R1,#+1024
   \   0000001A   02D3               BCC.N    ??puts_char_0
   \   0000001C   0021               MOVS     R1,#+0
   \   0000001E   A0F80E18           STRH     R1,[R0, #+2062]
    396          }
   \                     ??puts_char_0:
   \   00000022   7047               BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    397          void SendSerial(USART_TypeDef* USARTx, struct _Serial *serial)
    398          {
   \                     SendSerial:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0500               MOVS     R5,R0
   \   00000004   0C00               MOVS     R4,R1
    399               
    400          	if (serial->txsp != serial->txep) 
   \   00000006   B4F80C08           LDRH     R0,[R4, #+2060]
   \   0000000A   B4F80E18           LDRH     R1,[R4, #+2062]
   \   0000000E   8842               CMP      R0,R1
   \   00000010   17D0               BEQ.N    ??SendSerial_0
    401               {
    402          		if (USART_GetFlagStatus(USARTx, USART_FLAG_TXE) == SET) 
   \   00000012   8021               MOVS     R1,#+128
   \   00000014   2800               MOVS     R0,R5
   \   00000016   ........           BL       USART_GetFlagStatus
   \   0000001A   0128               CMP      R0,#+1
   \   0000001C   11D1               BNE.N    ??SendSerial_0
    403                    {
    404                         USARTx->DR = (serial->txbuf[serial->txsp++] & (u16)0x01FF);
   \   0000001E   B4F80C08           LDRH     R0,[R4, #+2060]
   \   00000022   411C               ADDS     R1,R0,#+1
   \   00000024   A4F80C18           STRH     R1,[R4, #+2060]
   \   00000028   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002A   0019               ADDS     R0,R0,R4
   \   0000002C   90F80B04           LDRB     R0,[R0, #+1035]
   \   00000030   A880               STRH     R0,[R5, #+4]
    405          			if (serial->txsp >= MAX_SERIAL_BUF) 	
   \   00000032   B4F80C08           LDRH     R0,[R4, #+2060]
   \   00000036   B0F5806F           CMP      R0,#+1024
   \   0000003A   02D3               BCC.N    ??SendSerial_0
    406                              serial->txsp = 0;
   \   0000003C   0020               MOVS     R0,#+0
   \   0000003E   A4F80C08           STRH     R0,[R4, #+2060]
    407          		}
    408          	}
    409          }
   \                     ??SendSerial_0:
   \   00000042   31BD               POP      {R0,R4,R5,PC}    ;; return
    410          

   \                                 In section .text, align 2, keep-with-next
    411          void SendMessage(void)
    412          {
   \                     SendMessage:
   \   00000000   80B5               PUSH     {R7,LR}
    413               SendSerial(USART1, &PC_Comm);
   \   00000002   ....               LDR.N    R1,??DataTable10_1
   \   00000004   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   00000006   ........           BL       SendSerial
    414               SendSerial(USART2, &RF_Module);
   \   0000000A   ....               LDR.N    R1,??DataTable10_2
   \   0000000C   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   0000000E   ........           BL       SendSerial
    415          }
   \   00000012   01BD               POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   ........           DC32     RTX_GPS

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   ........           DC32     PC_Comm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   ........           DC32     RF_Module

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   00000240           DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   00100140           DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   00440040           DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   00080240           DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   004C0040           DC32     0x40004c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   ........           DC32     ??data

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   ........           DC32     ??data_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   ........           DC32     ??data_2

   Maximum stack usage in bytes:

     Function          .cstack
     --------          -------
     Clear_Serial1          8
     Clear_Serial2          8
     Clear_Serial4          8
     NVIC_Config            8
     SendMessage            8
     SendSerial            16
     Serial_Config          8
     UART4_IRQHandler       8
     USART1_IRQHandler      8
     USART1_Init           32
     USART2_IRQHandler      8
     USART2_Init           32
     USART4_Init           32
     memset                 8
     puts_char              0
     puts_data              8
     puts_string            0


   Section sizes:

     Function/Label      Bytes
     --------------      -----
     memset                20
     RTX_GPS             2068
     PC_Comm             2068
     RF_Module           2068
     KMap_Transmit_Count    4
     Serial_Config         62
     Clear_Serial1         18
     Clear_Serial2         18
     Clear_Serial4         18
     NVIC_Config           94
     USART1_Init          180
     USART2_Init          178
     USART4_Init          172
     USART1_IRQHandler    164
     data                   1
     USART2_IRQHandler    164
     data                   1
     UART4_IRQHandler     164
     data                   1
     puts_data             54
     puts_string           48
     puts_char             36
     SendSerial            68
     SendMessage           20
     ??DataTable10          4
     ??DataTable10_1        4
     ??DataTable10_2        4
     ??DataTable10_3        4
     ??DataTable10_4        4
     ??DataTable10_5        4
     ??DataTable10_6        4
     ??DataTable10_7        4
     ??DataTable10_8        4
     ??DataTable10_9        4
     ??DataTable10_10       4

 
 6 211 bytes in section .bss
 1 522 bytes in section .text
 
 1 502 bytes of CODE memory (+ 20 bytes shared)
 6 211 bytes of DATA memory

Errors: none
Warnings: none
