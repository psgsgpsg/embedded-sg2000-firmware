###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     10/May/2011  17:15:17 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4 #
#                    \STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPer #
#                    iph_Template\stm32_eval_i2c_ee.c                         #
#    Command line =  "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\stm32_eval_i2c_ee.c" -D                    #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -lC "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V #
#                    0.0.4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_S #
#                    tdPeriph_Template\EWARM\STM3220F_EVAL\List\" -lA         #
#                    "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\STM3220F_EVAL\List\" -o              #
#                    "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\STM3220F_EVAL\Obj\" --no_cse         #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Full.h" -I "D:\¹¬ÀÛ¾÷\[        #
#                    NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_S #
#                    tdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template #
#                    \EWARM\..\" -I "D:\¹¬ÀÛ¾÷\[ NewDTG                       #
#                    ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\..\..\Libraries\CMSIS\CM3\CoreSupport\" -I            #
#                    "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Libraries\CMSIS\CM3\DeviceS #
#                    upport\ST\STM32F2xx\" -I "D:\¹¬ÀÛ¾÷\[ NewDTG             #
#                    ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I   #
#                    "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Utilities\STM32_EVAL\" -I   #
#                    "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Utilities\STM32_EVAL\Common #
#                    \" -I "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib #
#                    _V0.0.4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx #
#                    _StdPeriph_Template\EWARM\..\..\..\Utilities\STM32_EVAL\ #
#                    STM3220F_EVAL\" -Ol --use_c++_inline                     #
#    List file    =  D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4 #
#                    \STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPer #
#                    iph_Template\EWARM\STM3220F_EVAL\List\stm32_eval_i2c_ee. #
#                    lst                                                      #
#    Object file  =  D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4 #
#                    \STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPer #
#                    iph_Template\EWARM\STM3220F_EVAL\Obj\stm32_eval_i2c_ee.o #
#                                                                             #
#                                                                             #
###############################################################################

D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\stm32_eval_i2c_ee.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32_eval_i2c_ee.c
      4            * @author  MCD Application Team
      5            * @version V4.6.1
      6            * @date    18-April-2011
      7            * @brief   This file provides a set of functions needed to manage the I2C M24CXX 
      8            *          EEPROM memory mounted on STM32xx-EVAL board (refer to stm32_eval.h
      9            *          to know about the boards supporting this memory). 
     10            *          
     11            *          ===================================================================      
     12            *          Note: This driver is intended for STM32F10x families devices only.
     13            *          ===================================================================
     14            *            
     15            *          It implements a high level communication layer for read and write 
     16            *          from/to this memory. The needed STM32 hardware resources (I2C and 
     17            *          GPIO) are defined in stm32xx_eval.h file, and the initialization is 
     18            *          performed in sEE_LowLevel_Init() function declared in stm32xx_eval.c 
     19            *          file.
     20            *          You can easily tailor this driver to any other development board, 
     21            *          by just adapting the defines for hardware resources and 
     22            *          sEE_LowLevel_Init() function. 
     23            *        
     24            *          @note In this driver, basic read and write functions (sEE_ReadBuffer() 
     25            *                and sEE_WritePage()) use the DMA to perform the data transfer 
     26            *                to/from EEPROM memory (except when number of requested data is
     27            *                equal to 1). Thus, after calling these two functions, user 
     28            *                application may perform other tasks while DMA is transferring
     29            *                data. The application should then monitor the variable holding 
     30            *                the number of data in order to determine when the transfer is
     31            *                completed (variable decremented to 0). Stopping transfer tasks
     32            *                are performed into DMA interrupt handlers (which are integrated
     33            *                into this driver).
     34            *            
     35            *     +-----------------------------------------------------------------+
     36            *     |                        Pin assignment                           |                 
     37            *     +---------------------------------------+-----------+-------------+
     38            *     |  STM32 I2C Pins                       |   sEE     |   Pin       |
     39            *     +---------------------------------------+-----------+-------------+
     40            *     | .                                     |   E0(GND) |    1  (0V)  |
     41            *     | .                                     |   E1(GND) |    2  (0V)  |
     42            *     | .                                     |   E2(GND) |    3  (0V)  |
     43            *     | .                                     |   E0(VSS) |    4  (0V)  |
     44            *     | sEE_I2C_SDA_PIN/ SDA                  |   SDA     |    5        |
     45            *     | sEE_I2C_SCL_PIN/ SCL                  |   SCL     |    6        |
     46            *     | .                                     |   /WC(VDD)|    7 (3.3V) |
     47            *     | .                                     |   VDD     |    8 (3.3V) |
     48            *     +---------------------------------------+-----------+-------------+  
     49            ******************************************************************************
     50            * @attention
     51            *
     52            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     53            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     54            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     55            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     56            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     57            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     58            *
     59            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     60            ******************************************************************************  
     61            */ 
     62          
     63          /* Includes ------------------------------------------------------------------*/
     64          #include "stm32_eval_i2c_ee.h"
     65          

   \                                 In section .bss, align 4
     66          DMA_InitTypeDef   sEEDMA_InitStructure;
   \                     sEEDMA_InitStructure:
   \   00000000                      DS8 60
     67          
     68          /** @addtogroup Utilities
     69            * @{
     70            */
     71            
     72          /** @addtogroup STM32_EVAL
     73            * @{
     74            */ 
     75          
     76          /** @addtogroup Common
     77            * @{
     78            */
     79            
     80          /** @addtogroup STM32_EVAL_I2C_EE
     81            * @brief      This file includes the I2C EEPROM driver of STM32-EVAL boards.
     82            * @{
     83            */ 
     84          
     85          /** @defgroup STM32_EVAL_I2C_EE_Private_Types
     86            * @{
     87            */ 
     88          /**
     89            * @}
     90            */ 
     91          
     92          
     93          /** @defgroup STM32_EVAL_I2C_EE_Private_Defines
     94            * @{
     95            */  
     96          /**
     97            * @}
     98            */ 
     99          
    100          
    101          /** @defgroup STM32_EVAL_I2C_EE_Private_Macros
    102            * @{
    103            */
    104          /**
    105            * @}
    106            */ 
    107            
    108          
    109          /** @defgroup STM32_EVAL_I2C_EE_Private_Variables
    110            * @{
    111            */

   \                                 In section .bss, align 2
    112          __IO uint16_t  sEEAddress = 0;   
   \                     sEEAddress:
   \   00000000                      DS8 2

   \                                 In section .data, align 4
    113          __IO uint32_t  sEETimeout = sEE_LONG_TIMEOUT;   
   \                     sEETimeout:
   \   00000000   00A00000           DC32 40960

   \                                 In section .bss, align 4
    114          __IO uint16_t* sEEDataReadPointer;   
   \                     sEEDataReadPointer:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    115          __IO uint8_t*  sEEDataWritePointer;  
   \                     sEEDataWritePointer:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    116          __IO uint8_t   sEEDataNum;
   \                     sEEDataNum:
   \   00000000                      DS8 1
    117          /**
    118            * @}
    119            */ 
    120          
    121          
    122          /** @defgroup STM32_EVAL_I2C_EE_Private_Function_Prototypes
    123            * @{
    124            */ 
    125          /**
    126            * @}
    127            */ 
    128          
    129          
    130          /** @defgroup STM32_EVAL_I2C_EE_Private_Functions
    131            * @{
    132            */ 
    133          

   \                                 In section .text, align 2, keep-with-next
    134          void sEE_LowLevel_Init(void)
    135          {
   \                     sEE_LowLevel_Init:
   \   00000000   E0B5               PUSH     {R5-R7,LR}
    136            GPIO_InitTypeDef  GPIO_InitStructure; 
    137                 NVIC_InitTypeDef NVIC_InitStructure;  
    138          
    139            /*!< sEE_I2C Periph clock enable */
    140            RCC_APB1PeriphClockCmd(sEE_I2C_CLK, ENABLE);
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   5FF48000           MOVS     R0,#+4194304
   \   00000008   ........           BL       RCC_APB1PeriphClockCmd
    141            
    142            /*!< sEE_I2C_SCL_GPIO_CLK and sEE_I2C_SDA_GPIO_CLK Periph clock enable */
    143            RCC_AHB1PeriphClockCmd(sEE_I2C_SCL_GPIO_CLK | sEE_I2C_SDA_GPIO_CLK, ENABLE);
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   0220               MOVS     R0,#+2
   \   00000010   ........           BL       RCC_AHB1PeriphClockCmd
    144          
    145            RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
   \   00000014   0121               MOVS     R1,#+1
   \   00000016   4FF48040           MOV      R0,#+16384
   \   0000001A   ........           BL       RCC_APB2PeriphClockCmd
    146            
    147            /* Reset sEE_I2C IP */
    148            RCC_APB1PeriphResetCmd(sEE_I2C_CLK, ENABLE);
   \   0000001E   0121               MOVS     R1,#+1
   \   00000020   5FF48000           MOVS     R0,#+4194304
   \   00000024   ........           BL       RCC_APB1PeriphResetCmd
    149            
    150            /* Release reset signal of sEE_I2C IP */
    151            RCC_APB1PeriphResetCmd(sEE_I2C_CLK, DISABLE);
   \   00000028   0021               MOVS     R1,#+0
   \   0000002A   5FF48000           MOVS     R0,#+4194304
   \   0000002E   ........           BL       RCC_APB1PeriphResetCmd
    152              
    153            /*!< GPIO configuration */  
    154            /*!< Configure sEE_I2C pins: SCL */   
    155            GPIO_InitStructure.GPIO_Pin = sEE_I2C_SCL_PIN;
   \   00000032   4FF48060           MOV      R0,#+1024
   \   00000036   0190               STR      R0,[SP, #+4]
    156            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   00000038   0220               MOVS     R0,#+2
   \   0000003A   8DF80800           STRB     R0,[SP, #+8]
    157            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000003E   0220               MOVS     R0,#+2
   \   00000040   8DF80900           STRB     R0,[SP, #+9]
    158            GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
   \   00000044   0120               MOVS     R0,#+1
   \   00000046   8DF80A00           STRB     R0,[SP, #+10]
    159            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
   \   0000004A   0020               MOVS     R0,#+0
   \   0000004C   8DF80B00           STRB     R0,[SP, #+11]
    160            GPIO_Init(sEE_I2C_SCL_GPIO_PORT, &GPIO_InitStructure);
   \   00000050   01A9               ADD      R1,SP,#+4
   \   00000052   ........           LDR.W    R0,??DataTable9  ;; 0x40020400
   \   00000056   ........           BL       GPIO_Init
    161          
    162            /*!< Configure sEE_I2C pins: SDA */
    163            GPIO_InitStructure.GPIO_Pin = sEE_I2C_SDA_PIN;
   \   0000005A   4FF40060           MOV      R0,#+2048
   \   0000005E   0190               STR      R0,[SP, #+4]
    164            GPIO_Init(sEE_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
   \   00000060   01A9               ADD      R1,SP,#+4
   \   00000062   ........           LDR.W    R0,??DataTable9  ;; 0x40020400
   \   00000066   ........           BL       GPIO_Init
    165          
    166            /* Connect PXx to I2C_SCL*/
    167            GPIO_PinAFConfig(sEE_I2C_SCL_GPIO_PORT, sEE_I2C_SCL_SOURCE, sEE_I2C_SCL_AF);
   \   0000006A   0422               MOVS     R2,#+4
   \   0000006C   0A21               MOVS     R1,#+10
   \   0000006E   ........           LDR.W    R0,??DataTable9  ;; 0x40020400
   \   00000072   ........           BL       GPIO_PinAFConfig
    168          
    169            /* Connect PXx to I2C_SDA*/
    170            GPIO_PinAFConfig(sEE_I2C_SDA_GPIO_PORT, sEE_I2C_SDA_SOURCE, sEE_I2C_SDA_AF);  
   \   00000076   0422               MOVS     R2,#+4
   \   00000078   0B21               MOVS     R1,#+11
   \   0000007A   ........           LDR.W    R0,??DataTable9  ;; 0x40020400
   \   0000007E   ........           BL       GPIO_PinAFConfig
    171            
    172            /* Configure and enable I2C DMA TX Channel interrupt */
    173            NVIC_InitStructure.NVIC_IRQChannel = sEE_I2C_DMA_TX_IRQn;
   \   00000082   1120               MOVS     R0,#+17
   \   00000084   8DF80000           STRB     R0,[SP, #+0]
    174            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = sEE_I2C_DMA_PREPRIO;
   \   00000088   0020               MOVS     R0,#+0
   \   0000008A   8DF80100           STRB     R0,[SP, #+1]
    175            NVIC_InitStructure.NVIC_IRQChannelSubPriority = sEE_I2C_DMA_SUBPRIO;
   \   0000008E   0020               MOVS     R0,#+0
   \   00000090   8DF80200           STRB     R0,[SP, #+2]
    176            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000094   0120               MOVS     R0,#+1
   \   00000096   8DF80300           STRB     R0,[SP, #+3]
    177            NVIC_Init(&NVIC_InitStructure);
   \   0000009A   00A8               ADD      R0,SP,#+0
   \   0000009C   ........           BL       NVIC_Init
    178          
    179            /* Configure and enable I2C DMA RX Channel interrupt */
    180            NVIC_InitStructure.NVIC_IRQChannel = sEE_I2C_DMA_RX_IRQn;
   \   000000A0   0B20               MOVS     R0,#+11
   \   000000A2   8DF80000           STRB     R0,[SP, #+0]
    181            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = sEE_I2C_DMA_PREPRIO;
   \   000000A6   0020               MOVS     R0,#+0
   \   000000A8   8DF80100           STRB     R0,[SP, #+1]
    182            NVIC_InitStructure.NVIC_IRQChannelSubPriority = sEE_I2C_DMA_SUBPRIO;
   \   000000AC   0020               MOVS     R0,#+0
   \   000000AE   8DF80200           STRB     R0,[SP, #+2]
    183            NVIC_Init(&NVIC_InitStructure);  
   \   000000B2   00A8               ADD      R0,SP,#+0
   \   000000B4   ........           BL       NVIC_Init
    184            
    185            /*!< I2C DMA TX and RX channels configuration */
    186            /* Enable the DMA clock */
    187            RCC_AHB1PeriphClockCmd(sEE_I2C_DMA_CLK, ENABLE);
   \   000000B8   0121               MOVS     R1,#+1
   \   000000BA   5FF40010           MOVS     R0,#+2097152
   \   000000BE   ........           BL       RCC_AHB1PeriphClockCmd
    188            
    189            /* Clear any pending flag on Rx Stream  */
    190            DMA_ClearFlag(sEE_I2C_DMA_STREAM_TX, sEE_TX_DMA_FLAG_FEIF | sEE_TX_DMA_FLAG_DMEIF | sEE_TX_DMA_FLAG_TEIF | \
    191                                                 sEE_TX_DMA_FLAG_HTIF | sEE_TX_DMA_FLAG_TCIF);
   \   000000C2   ........           LDR.W    R1,??DataTable9_1  ;; 0x203d0000
   \   000000C6   ........           LDR.W    R0,??DataTable9_2  ;; 0x400260a0
   \   000000CA   ........           BL       DMA_ClearFlag
    192            /* Disable the EE I2C Tx DMA stream */
    193            DMA_Cmd(sEE_I2C_DMA_STREAM_TX, DISABLE);
   \   000000CE   0021               MOVS     R1,#+0
   \   000000D0   ........           LDR.W    R0,??DataTable9_2  ;; 0x400260a0
   \   000000D4   ........           BL       DMA_Cmd
    194            /* Configure the DMA stream for the EE I2C peripheral TX direction */
    195            DMA_DeInit(sEE_I2C_DMA_STREAM_TX);
   \   000000D8   ........           LDR.W    R0,??DataTable9_2  ;; 0x400260a0
   \   000000DC   ........           BL       DMA_DeInit
    196            sEEDMA_InitStructure.DMA_Channel = sEE_I2C_DMA_CHANNEL;
   \   000000E0   ........           LDR.W    R0,??DataTable9_3
   \   000000E4   5FF00071           MOVS     R1,#+33554432
   \   000000E8   0160               STR      R1,[R0, #+0]
    197            sEEDMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)sEE_I2C_DR_Address;
   \   000000EA   ........           LDR.W    R0,??DataTable9_3
   \   000000EE   ........           LDR.W    R1,??DataTable9_4  ;; 0x40005410
   \   000000F2   4160               STR      R1,[R0, #+4]
    198            sEEDMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)0;    /* This parameter will be configured durig communication */;
   \   000000F4   ........           LDR.W    R0,??DataTable9_3
   \   000000F8   0021               MOVS     R1,#+0
   \   000000FA   8160               STR      R1,[R0, #+8]
    199            sEEDMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral; /* This parameter will be configured durig communication */
   \   000000FC   ........           LDR.W    R0,??DataTable9_3
   \   00000100   4021               MOVS     R1,#+64
   \   00000102   C160               STR      R1,[R0, #+12]
    200            sEEDMA_InitStructure.DMA_BufferSize = 0xFFFF;              /* This parameter will be configured durig communication */
   \   00000104   ........           LDR.W    R0,??DataTable9_3
   \   00000108   4FF6FF71           MOVW     R1,#+65535
   \   0000010C   0161               STR      R1,[R0, #+16]
    201            sEEDMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
   \   0000010E   ........           LDR.W    R0,??DataTable9_3
   \   00000112   0021               MOVS     R1,#+0
   \   00000114   4161               STR      R1,[R0, #+20]
    202            sEEDMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
   \   00000116   ........           LDR.W    R0,??DataTable9_3
   \   0000011A   4FF48061           MOV      R1,#+1024
   \   0000011E   8161               STR      R1,[R0, #+24]
    203            sEEDMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
   \   00000120   ........           LDR.W    R0,??DataTable9_3
   \   00000124   0021               MOVS     R1,#+0
   \   00000126   C161               STR      R1,[R0, #+28]
    204            sEEDMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
   \   00000128   ........           LDR.W    R0,??DataTable9_3
   \   0000012C   0021               MOVS     R1,#+0
   \   0000012E   0162               STR      R1,[R0, #+32]
    205            sEEDMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
   \   00000130   ........           LDR.W    R0,??DataTable9_3
   \   00000134   0021               MOVS     R1,#+0
   \   00000136   4162               STR      R1,[R0, #+36]
    206            sEEDMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
   \   00000138   ........           LDR.W    R0,??DataTable9_3
   \   0000013C   5FF44031           MOVS     R1,#+196608
   \   00000140   8162               STR      R1,[R0, #+40]
    207            sEEDMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Enable;
   \   00000142   ........           LDR.W    R0,??DataTable9_3
   \   00000146   0421               MOVS     R1,#+4
   \   00000148   C162               STR      R1,[R0, #+44]
    208            sEEDMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_Full;
   \   0000014A   ........           LDR.W    R0,??DataTable9_3
   \   0000014E   0321               MOVS     R1,#+3
   \   00000150   0163               STR      R1,[R0, #+48]
    209            sEEDMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
   \   00000152   ........           LDR.W    R0,??DataTable9_3
   \   00000156   0021               MOVS     R1,#+0
   \   00000158   4163               STR      R1,[R0, #+52]
    210            sEEDMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
   \   0000015A   ........           LDR.W    R0,??DataTable9_3
   \   0000015E   0021               MOVS     R1,#+0
   \   00000160   8163               STR      R1,[R0, #+56]
    211            DMA_Init(sEE_I2C_DMA_STREAM_TX, &sEEDMA_InitStructure);
   \   00000162   ........           LDR.W    R1,??DataTable9_3
   \   00000166   ........           LDR.W    R0,??DataTable9_2  ;; 0x400260a0
   \   0000016A   ........           BL       DMA_Init
    212          
    213            /* Clear any pending flag on Rx Stream */
    214            DMA_ClearFlag(sEE_I2C_DMA_STREAM_RX, sEE_RX_DMA_FLAG_FEIF | sEE_RX_DMA_FLAG_DMEIF | sEE_RX_DMA_FLAG_TEIF | \
    215                                                 sEE_RX_DMA_FLAG_HTIF | sEE_RX_DMA_FLAG_TCIF);
   \   0000016E   ........           LDR.W    R1,??DataTable9_5  ;; 0x1080003d
   \   00000172   ........           LDR.W    R0,??DataTable9_6  ;; 0x40026010
   \   00000176   ........           BL       DMA_ClearFlag
    216            /* Disable the EE I2C DMA Rx stream */
    217            DMA_Cmd(sEE_I2C_DMA_STREAM_RX, DISABLE);
   \   0000017A   0021               MOVS     R1,#+0
   \   0000017C   ........           LDR.W    R0,??DataTable9_6  ;; 0x40026010
   \   00000180   ........           BL       DMA_Cmd
    218            /* Configure the DMA stream for the EE I2C peripheral RX direction */
    219            DMA_DeInit(sEE_I2C_DMA_STREAM_RX);
   \   00000184   ........           LDR.W    R0,??DataTable9_6  ;; 0x40026010
   \   00000188   ........           BL       DMA_DeInit
    220            DMA_Init(sEE_I2C_DMA_STREAM_RX, &sEEDMA_InitStructure);
   \   0000018C   ........           LDR.W    R1,??DataTable9_3
   \   00000190   ........           LDR.W    R0,??DataTable9_6  ;; 0x40026010
   \   00000194   ........           BL       DMA_Init
    221            
    222            /* Enable the DMA Channels Interrupts */
    223            DMA_ITConfig(sEE_I2C_DMA_STREAM_TX, DMA_IT_TC, ENABLE);
   \   00000198   0122               MOVS     R2,#+1
   \   0000019A   1021               MOVS     R1,#+16
   \   0000019C   ........           LDR.W    R0,??DataTable9_2  ;; 0x400260a0
   \   000001A0   ........           BL       DMA_ITConfig
    224            DMA_ITConfig(sEE_I2C_DMA_STREAM_RX, DMA_IT_TC, ENABLE);      
   \   000001A4   0122               MOVS     R2,#+1
   \   000001A6   1021               MOVS     R1,#+16
   \   000001A8   ........           LDR.W    R0,??DataTable9_6  ;; 0x40026010
   \   000001AC   ........           BL       DMA_ITConfig
    225          }
   \   000001B0   07BD               POP      {R0-R2,PC}       ;; return
    226          
    227          /**
    228            * @brief  Initializes DMA channel used by the I2C EEPROM driver.
    229            * @param  None
    230            * @retval None
    231            */

   \                                 In section .text, align 2, keep-with-next
    232          void sEE_LowLevel_DMAConfig(uint32_t pBuffer, uint32_t BufferSize, uint32_t Direction)
    233          { 
   \                     sEE_LowLevel_DMAConfig:
   \   00000000   80B5               PUSH     {R7,LR}
    234            /* Initialize the DMA with the new parameters */
    235            if (Direction == sEE_DIRECTION_TX)
   \   00000002   002A               CMP      R2,#+0
   \   00000004   10D1               BNE.N    ??sEE_LowLevel_DMAConfig_0
    236            {
    237              /* Configure the DMA Tx Stream with the buffer address and the buffer size */
    238              sEEDMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)pBuffer;
   \   00000006   ........           LDR.W    R2,??DataTable9_3
   \   0000000A   9060               STR      R0,[R2, #+8]
    239              sEEDMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;    
   \   0000000C   ........           LDR.W    R0,??DataTable9_3
   \   00000010   4022               MOVS     R2,#+64
   \   00000012   C260               STR      R2,[R0, #+12]
    240              sEEDMA_InitStructure.DMA_BufferSize = (uint32_t)BufferSize;  
   \   00000014   ........           LDR.W    R0,??DataTable9_3
   \   00000018   0161               STR      R1,[R0, #+16]
    241              DMA_Init(sEE_I2C_DMA_STREAM_TX, &sEEDMA_InitStructure);  
   \   0000001A   ........           LDR.W    R1,??DataTable9_3
   \   0000001E   ........           LDR.W    R0,??DataTable9_2  ;; 0x400260a0
   \   00000022   ........           BL       DMA_Init
   \   00000026   0FE0               B.N      ??sEE_LowLevel_DMAConfig_1
    242            }
    243            else
    244            { 
    245              /* Configure the DMA Rx Stream with the buffer address and the buffer size */
    246              sEEDMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)pBuffer;
   \                     ??sEE_LowLevel_DMAConfig_0:
   \   00000028   ........           LDR.W    R2,??DataTable9_3
   \   0000002C   9060               STR      R0,[R2, #+8]
    247              sEEDMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
   \   0000002E   ........           LDR.W    R0,??DataTable9_3
   \   00000032   0022               MOVS     R2,#+0
   \   00000034   C260               STR      R2,[R0, #+12]
    248              sEEDMA_InitStructure.DMA_BufferSize = (uint32_t)BufferSize;      
   \   00000036   ........           LDR.W    R0,??DataTable9_3
   \   0000003A   0161               STR      R1,[R0, #+16]
    249              DMA_Init(sEE_I2C_DMA_STREAM_RX, &sEEDMA_InitStructure);    
   \   0000003C   ........           LDR.W    R1,??DataTable9_3
   \   00000040   ........           LDR.W    R0,??DataTable9_6  ;; 0x40026010
   \   00000044   ........           BL       DMA_Init
    250            }
    251          }
   \                     ??sEE_LowLevel_DMAConfig_1:
   \   00000048   01BD               POP      {R0,PC}          ;; return
    252          /**
    253            * @brief  DeInitializes peripherals used by the I2C EEPROM driver.
    254            * @param  None
    255            * @retval None
    256            */

   \                                 In section .text, align 2, keep-with-next
    257          void sEE_DeInit(void)
    258          {
   \                     sEE_DeInit:
   \   00000000   80B5               PUSH     {R7,LR}
    259            sEE_LowLevel_DeInit(); 
   \   00000002   ........           BL       sEE_LowLevel_DeInit
    260          }
   \   00000006   01BD               POP      {R0,PC}          ;; return
    261          
    262          /**
    263            * @brief  Initializes peripherals used by the I2C EEPROM driver.
    264            * @param  None
    265            * @retval None
    266            */

   \                                 In section .text, align 2, keep-with-next
    267          void sEE_Init(void)
    268          { 
   \                     sEE_Init:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   85B0               SUB      SP,SP,#+20
    269            I2C_InitTypeDef  I2C_InitStructure;
    270            
    271            sEE_LowLevel_Init();
   \   00000004   ........           BL       sEE_LowLevel_Init
    272            
    273            /*!< I2C configuration */
    274            /* sEE_I2C configuration */
    275            I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   ADF80400           STRH     R0,[SP, #+4]
    276            I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
   \   0000000E   4BF6FF70           MOVW     R0,#+49151
   \   00000012   ADF80600           STRH     R0,[SP, #+6]
    277            I2C_InitStructure.I2C_OwnAddress1 = I2C_SLAVE_ADDRESS7;
   \   00000016   A020               MOVS     R0,#+160
   \   00000018   ADF80800           STRH     R0,[SP, #+8]
    278            I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
   \   0000001C   4FF48060           MOV      R0,#+1024
   \   00000020   ADF80A00           STRH     R0,[SP, #+10]
    279            I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
   \   00000024   4FF48040           MOV      R0,#+16384
   \   00000028   ADF80C00           STRH     R0,[SP, #+12]
    280            I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;
   \   0000002C   ........           LDR.W    R0,??DataTable9_7  ;; 0x493e0
   \   00000030   0090               STR      R0,[SP, #+0]
    281            
    282            /* sEE_I2C Peripheral Enable */
    283            I2C_Cmd(sEE_I2C, ENABLE);
   \   00000032   0121               MOVS     R1,#+1
   \   00000034   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   00000038   ........           BL       I2C_Cmd
    284            /* Apply sEE_I2C configuration after enabling it */
    285            I2C_Init(sEE_I2C, &I2C_InitStructure);
   \   0000003C   00A9               ADD      R1,SP,#+0
   \   0000003E   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   00000042   ........           BL       I2C_Init
    286          
    287            /* Enable the sEE_I2C peripheral DMA requests */
    288            I2C_DMACmd(sEE_I2C, ENABLE);
   \   00000046   0121               MOVS     R1,#+1
   \   00000048   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   0000004C   ........           BL       I2C_DMACmd
    289            
    290          #if defined (sEE_M24C512)
    291            /*!< Select the EEPROM address according to the state of E0, E1, E2 pins */
    292            sEEAddress = sEE_HW_ADDRESS;  
   \   00000050   ........           LDR.W    R0,??DataTable9_9
   \   00000054   A021               MOVS     R1,#+160
   \   00000056   0180               STRH     R1,[R0, #+0]
    293          #elif defined (sEE_M24C08)
    294            /*!< depending on the sEE Address selected in the i2c_ee.h file */
    295           #ifdef sEE_Block0_ADDRESS
    296            /*!< Select the sEE Block0 to write on */
    297            sEEAddress = sEE_Block0_ADDRESS;
    298           #endif
    299            
    300           #ifdef sEE_Block1_ADDRESS
    301            /*!< Select the sEE Block1 to write on */
    302            sEEAddress = sEE_Block1_ADDRESS;
    303           #endif
    304          
    305           #ifdef sEE_Block2_ADDRESS
    306            /*!< Select the sEE Block2 to write on */
    307            sEEAddress = sEE_Block2_ADDRESS;
    308           #endif
    309            
    310           #ifdef sEE_Block3_ADDRESS
    311            /*!< Select the sEE Block3 to write on */
    312            sEEAddress = sEE_Block3_ADDRESS;
    313           #endif 
    314          #endif /*!< sEE_M24C64_32 */    
    315          }
   \   00000058   05B0               ADD      SP,SP,#+20
   \   0000005A   00BD               POP      {PC}             ;; return
    316          
    317          /**
    318            * @brief  Reads a block of data from the EEPROM.
    319            * @param  pBuffer : pointer to the buffer that receives the data read from 
    320            *         the EEPROM.
    321            * @param  ReadAddr : EEPROM's internal address to start reading from.
    322            * @param  NumByteToRead : pointer to the variable holding number of bytes to 
    323            *         be read from the EEPROM.
    324            * 
    325            *        @note The variable pointed by NumByteToRead is reset to 0 when all the 
    326            *              data are read from the EEPROM. Application should monitor this 
    327            *              variable in order know when the transfer is complete.
    328            * 
    329            * @note When number of data to be read is higher than 1, this function just 
    330            *       configures the communication and enable the DMA channel to transfer data.
    331            *       Meanwhile, the user application may perform other tasks.
    332            *       When number of data to be read is 1, then the DMA is not used. The byte
    333            *       is read in polling mode.
    334            * 
    335            * @retval sEE_OK (0) if operation is correctly performed, else return value 
    336            *         different from sEE_OK (0) or the timeout user callback.
    337            */

   \                                 In section .text, align 2, keep-with-next
    338          uint32_t sEE_ReadBuffer(uint8_t* pBuffer, uint16_t ReadAddr, uint16_t* NumByteToRead)
    339          {  
   \                     sEE_ReadBuffer:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0E00               MOVS     R6,R1
   \   00000006   1500               MOVS     R5,R2
    340            /* Set the pointer to the Number of data to be read. This pointer will be used 
    341                by the DMA Transfer Completer interrupt Handler in order to reset the 
    342                variable to 0. User should check on this variable in order to know if the 
    343                DMA transfer has been complete or not. */
    344            sEEDataReadPointer = NumByteToRead;
   \   00000008   ........           LDR.W    R0,??DataTable9_10
   \   0000000C   0560               STR      R5,[R0, #+0]
    345            
    346            /*!< While the bus is busy */
    347            sEETimeout = sEE_LONG_TIMEOUT;
   \   0000000E   ........           LDR.W    R0,??DataTable9_11
   \   00000012   4FF42041           MOV      R1,#+40960
   \   00000016   0160               STR      R1,[R0, #+0]
    348            while(I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_BUSY))
   \                     ??sEE_ReadBuffer_0:
   \   00000018   5FF40031           MOVS     R1,#+131072
   \   0000001C   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   00000020   ........           BL       I2C_GetFlagStatus
   \   00000024   0028               CMP      R0,#+0
   \   00000026   0BD0               BEQ.N    ??sEE_ReadBuffer_1
    349            {
    350              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000028   ........           LDR.W    R0,??DataTable9_11
   \   0000002C   0068               LDR      R0,[R0, #+0]
   \   0000002E   411E               SUBS     R1,R0,#+1
   \   00000030   ........           LDR.W    R2,??DataTable9_11
   \   00000034   1160               STR      R1,[R2, #+0]
   \   00000036   0028               CMP      R0,#+0
   \   00000038   EED1               BNE.N    ??sEE_ReadBuffer_0
   \   0000003A   ........           BL       sEE_TIMEOUT_UserCallback
   \   0000003E   38E1               B.N      ??sEE_ReadBuffer_2
    351            }
    352            
    353            /*!< Send START condition */
    354            I2C_GenerateSTART(sEE_I2C, ENABLE);
   \                     ??sEE_ReadBuffer_1:
   \   00000040   0121               MOVS     R1,#+1
   \   00000042   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   00000046   ........           BL       I2C_GenerateSTART
    355            
    356            /*!< Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
    357            sEETimeout = sEE_FLAG_TIMEOUT;
   \   0000004A   ........           LDR.W    R0,??DataTable9_11
   \   0000004E   4FF48051           MOV      R1,#+4096
   \   00000052   0160               STR      R1,[R0, #+0]
    358            while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
   \                     ??sEE_ReadBuffer_3:
   \   00000054   ........           LDR.W    R1,??DataTable9_12  ;; 0x30001
   \   00000058   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   0000005C   ........           BL       I2C_CheckEvent
   \   00000060   0028               CMP      R0,#+0
   \   00000062   0BD1               BNE.N    ??sEE_ReadBuffer_4
    359            {
    360              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000064   ........           LDR.W    R0,??DataTable9_11
   \   00000068   0068               LDR      R0,[R0, #+0]
   \   0000006A   411E               SUBS     R1,R0,#+1
   \   0000006C   ........           LDR.W    R2,??DataTable9_11
   \   00000070   1160               STR      R1,[R2, #+0]
   \   00000072   0028               CMP      R0,#+0
   \   00000074   EED1               BNE.N    ??sEE_ReadBuffer_3
   \   00000076   ........           BL       sEE_TIMEOUT_UserCallback
   \   0000007A   1AE1               B.N      ??sEE_ReadBuffer_2
    361            }
    362            
    363            /*!< Send EEPROM address for write */
    364            I2C_Send7bitAddress(sEE_I2C, sEEAddress, I2C_Direction_Transmitter);
   \                     ??sEE_ReadBuffer_4:
   \   0000007C   0022               MOVS     R2,#+0
   \   0000007E   ........           LDR.W    R0,??DataTable9_9
   \   00000082   0188               LDRH     R1,[R0, #+0]
   \   00000084   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000086   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   0000008A   ........           BL       I2C_Send7bitAddress
    365          
    366            /*!< Test on EV6 and clear it */
    367            sEETimeout = sEE_FLAG_TIMEOUT;
   \   0000008E   ........           LDR.W    R0,??DataTable9_11
   \   00000092   4FF48051           MOV      R1,#+4096
   \   00000096   0160               STR      R1,[R0, #+0]
    368            while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
   \                     ??sEE_ReadBuffer_5:
   \   00000098   ........           LDR.W    R1,??DataTable9_13  ;; 0x70082
   \   0000009C   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   000000A0   ........           BL       I2C_CheckEvent
   \   000000A4   0028               CMP      R0,#+0
   \   000000A6   0BD1               BNE.N    ??sEE_ReadBuffer_6
    369            {
    370              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   000000A8   ........           LDR.W    R0,??DataTable9_11
   \   000000AC   0068               LDR      R0,[R0, #+0]
   \   000000AE   411E               SUBS     R1,R0,#+1
   \   000000B0   ........           LDR.W    R2,??DataTable9_11
   \   000000B4   1160               STR      R1,[R2, #+0]
   \   000000B6   0028               CMP      R0,#+0
   \   000000B8   EED1               BNE.N    ??sEE_ReadBuffer_5
   \   000000BA   ........           BL       sEE_TIMEOUT_UserCallback
   \   000000BE   F8E0               B.N      ??sEE_ReadBuffer_2
    371            } 
    372          
    373          #ifdef sEE_M24C08  
    374            
    375            /*!< Send the EEPROM's internal address to read from: Only one byte address */
    376            I2C_SendData(sEE_I2C, ReadAddr);  
    377          
    378          #elif defined (sEE_M24C512)
    379          
    380            /*!< Send the EEPROM's internal address to read from: MSB of the address first */
    381            I2C_SendData(sEE_I2C, (uint8_t)((ReadAddr & 0xFF00) >> 8));    
   \                     ??sEE_ReadBuffer_6:
   \   000000C0   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000C2   310A               LSRS     R1,R6,#+8
   \   000000C4   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000C6   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   000000CA   ........           BL       I2C_SendData
    382          
    383            /*!< Test on EV8 and clear it */
    384            sEETimeout = sEE_FLAG_TIMEOUT;
   \   000000CE   ........           LDR.W    R0,??DataTable9_11
   \   000000D2   4FF48051           MOV      R1,#+4096
   \   000000D6   0160               STR      R1,[R0, #+0]
    385            while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
   \                     ??sEE_ReadBuffer_7:
   \   000000D8   ........           LDR.W    R1,??DataTable9_14  ;; 0x70084
   \   000000DC   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   000000E0   ........           BL       I2C_CheckEvent
   \   000000E4   0028               CMP      R0,#+0
   \   000000E6   0BD1               BNE.N    ??sEE_ReadBuffer_8
    386            {
    387              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   000000E8   ........           LDR.W    R0,??DataTable9_11
   \   000000EC   0068               LDR      R0,[R0, #+0]
   \   000000EE   411E               SUBS     R1,R0,#+1
   \   000000F0   ........           LDR.W    R2,??DataTable9_11
   \   000000F4   1160               STR      R1,[R2, #+0]
   \   000000F6   0028               CMP      R0,#+0
   \   000000F8   EED1               BNE.N    ??sEE_ReadBuffer_7
   \   000000FA   ........           BL       sEE_TIMEOUT_UserCallback
   \   000000FE   D8E0               B.N      ??sEE_ReadBuffer_2
    388            }
    389          
    390            /*!< Send the EEPROM's internal address to read from: LSB of the address */
    391            I2C_SendData(sEE_I2C, (uint8_t)(ReadAddr & 0x00FF));    
   \                     ??sEE_ReadBuffer_8:
   \   00000100   3100               MOVS     R1,R6
   \   00000102   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000104   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   00000108   ........           BL       I2C_SendData
    392            
    393          #endif /*!< sEE_M24C08 */
    394          
    395            /*!< Test on EV8 and clear it */
    396            sEETimeout = sEE_FLAG_TIMEOUT;
   \   0000010C   ........           LDR.W    R0,??DataTable9_11
   \   00000110   4FF48051           MOV      R1,#+4096
   \   00000114   0160               STR      R1,[R0, #+0]
    397            while(I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_BTF) == RESET)
   \                     ??sEE_ReadBuffer_9:
   \   00000116   ........           LDR.W    R1,??DataTable9_15  ;; 0x10000004
   \   0000011A   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   0000011E   ........           BL       I2C_GetFlagStatus
   \   00000122   0028               CMP      R0,#+0
   \   00000124   0BD1               BNE.N    ??sEE_ReadBuffer_10
    398            {
    399              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000126   ........           LDR.W    R0,??DataTable9_11
   \   0000012A   0068               LDR      R0,[R0, #+0]
   \   0000012C   411E               SUBS     R1,R0,#+1
   \   0000012E   ........           LDR.W    R2,??DataTable9_11
   \   00000132   1160               STR      R1,[R2, #+0]
   \   00000134   0028               CMP      R0,#+0
   \   00000136   EED1               BNE.N    ??sEE_ReadBuffer_9
   \   00000138   ........           BL       sEE_TIMEOUT_UserCallback
   \   0000013C   B9E0               B.N      ??sEE_ReadBuffer_2
    400            }
    401            
    402            /*!< Send STRAT condition a second time */  
    403            I2C_GenerateSTART(sEE_I2C, ENABLE);
   \                     ??sEE_ReadBuffer_10:
   \   0000013E   0121               MOVS     R1,#+1
   \   00000140   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   00000144   ........           BL       I2C_GenerateSTART
    404            
    405            /*!< Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
    406            sEETimeout = sEE_FLAG_TIMEOUT;
   \   00000148   ........           LDR.W    R0,??DataTable9_11
   \   0000014C   4FF48051           MOV      R1,#+4096
   \   00000150   0160               STR      R1,[R0, #+0]
    407            while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
   \                     ??sEE_ReadBuffer_11:
   \   00000152   ........           LDR.W    R1,??DataTable9_12  ;; 0x30001
   \   00000156   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   0000015A   ........           BL       I2C_CheckEvent
   \   0000015E   0028               CMP      R0,#+0
   \   00000160   0BD1               BNE.N    ??sEE_ReadBuffer_12
    408            {
    409              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000162   ........           LDR.W    R0,??DataTable9_11
   \   00000166   0068               LDR      R0,[R0, #+0]
   \   00000168   411E               SUBS     R1,R0,#+1
   \   0000016A   ........           LDR.W    R2,??DataTable9_11
   \   0000016E   1160               STR      R1,[R2, #+0]
   \   00000170   0028               CMP      R0,#+0
   \   00000172   EED1               BNE.N    ??sEE_ReadBuffer_11
   \   00000174   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000178   9BE0               B.N      ??sEE_ReadBuffer_2
    410            } 
    411            
    412            /*!< Send EEPROM address for read */
    413            I2C_Send7bitAddress(sEE_I2C, sEEAddress, I2C_Direction_Receiver);  
   \                     ??sEE_ReadBuffer_12:
   \   0000017A   0122               MOVS     R2,#+1
   \   0000017C   ........           LDR.W    R0,??DataTable9_9
   \   00000180   0188               LDRH     R1,[R0, #+0]
   \   00000182   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000184   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   00000188   ........           BL       I2C_Send7bitAddress
    414            
    415            /* If number of data to be read is 1, then DMA couldn't be used */
    416            /* One Byte Master Reception procedure (POLLING) ---------------------------*/
    417            if ((uint16_t)(*NumByteToRead) < 2)
   \   0000018C   2888               LDRH     R0,[R5, #+0]
   \   0000018E   0228               CMP      R0,#+2
   \   00000190   66D2               BCS.N    ??sEE_ReadBuffer_13
    418            {
    419              /* Wait on ADDR flag to be set (ADDR is still not cleared at this level */
    420              sEETimeout = sEE_FLAG_TIMEOUT;
   \   00000192   ........           LDR.W    R0,??DataTable9_11
   \   00000196   4FF48051           MOV      R1,#+4096
   \   0000019A   0160               STR      R1,[R0, #+0]
    421              while(I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_ADDR) == RESET)
   \                     ??sEE_ReadBuffer_14:
   \   0000019C   ........           LDR.W    R1,??DataTable9_16  ;; 0x10000002
   \   000001A0   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   000001A4   ........           BL       I2C_GetFlagStatus
   \   000001A8   0028               CMP      R0,#+0
   \   000001AA   0BD1               BNE.N    ??sEE_ReadBuffer_15
    422              {
    423                if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   000001AC   ........           LDR.W    R0,??DataTable9_11
   \   000001B0   0068               LDR      R0,[R0, #+0]
   \   000001B2   411E               SUBS     R1,R0,#+1
   \   000001B4   ........           LDR.W    R2,??DataTable9_11
   \   000001B8   1160               STR      R1,[R2, #+0]
   \   000001BA   0028               CMP      R0,#+0
   \   000001BC   EED1               BNE.N    ??sEE_ReadBuffer_14
   \   000001BE   ........           BL       sEE_TIMEOUT_UserCallback
   \   000001C2   76E0               B.N      ??sEE_ReadBuffer_2
    424              }     
    425              
    426              /*!< Disable Acknowledgement */
    427              I2C_AcknowledgeConfig(sEE_I2C, DISABLE);   
   \                     ??sEE_ReadBuffer_15:
   \   000001C4   0021               MOVS     R1,#+0
   \   000001C6   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   000001CA   ........           BL       I2C_AcknowledgeConfig
    428          
    429              /* Call User callback for critical section start (should typically disable interrupts) */
    430              sEE_EnterCriticalSection_UserCallback();
   \   000001CE   ........           BL       sEE_EnterCriticalSection_UserCallback
    431              
    432              /* Clear ADDR register by reading SR1 then SR2 register (SR1 has already been read) */
    433              (void)sEE_I2C->SR2;
   \   000001D2   ........           LDR.W    R0,??DataTable9_17  ;; 0x40005818
   \   000001D6   0688               LDRH     R6,[R0, #+0]
    434              
    435              /*!< Send STOP Condition */
    436              I2C_GenerateSTOP(sEE_I2C, ENABLE);
   \   000001D8   0121               MOVS     R1,#+1
   \   000001DA   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   000001DE   ........           BL       I2C_GenerateSTOP
    437             
    438              /* Call User callback for critical section end (should typically re-enable interrupts) */
    439              sEE_ExitCriticalSection_UserCallback();
   \   000001E2   ........           BL       sEE_ExitCriticalSection_UserCallback
    440              
    441              /* Wait for the byte to be received */
    442              sEETimeout = sEE_FLAG_TIMEOUT;
   \   000001E6   ........           LDR.W    R0,??DataTable9_11
   \   000001EA   4FF48051           MOV      R1,#+4096
   \   000001EE   0160               STR      R1,[R0, #+0]
    443              while(I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_RXNE) == RESET)
   \                     ??sEE_ReadBuffer_16:
   \   000001F0   ........           LDR.W    R1,??DataTable9_18  ;; 0x10000040
   \   000001F4   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   000001F8   ........           BL       I2C_GetFlagStatus
   \   000001FC   0028               CMP      R0,#+0
   \   000001FE   0BD1               BNE.N    ??sEE_ReadBuffer_17
    444              {
    445                if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000200   ........           LDR.W    R0,??DataTable9_11
   \   00000204   0068               LDR      R0,[R0, #+0]
   \   00000206   411E               SUBS     R1,R0,#+1
   \   00000208   ........           LDR.W    R2,??DataTable9_11
   \   0000020C   1160               STR      R1,[R2, #+0]
   \   0000020E   0028               CMP      R0,#+0
   \   00000210   EED1               BNE.N    ??sEE_ReadBuffer_16
   \   00000212   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000216   4CE0               B.N      ??sEE_ReadBuffer_2
    446              }
    447              
    448              /*!< Read the byte received from the EEPROM */
    449              *pBuffer = I2C_ReceiveData(sEE_I2C);
   \                     ??sEE_ReadBuffer_17:
   \   00000218   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   0000021C   ........           BL       I2C_ReceiveData
   \   00000220   2070               STRB     R0,[R4, #+0]
    450              
    451              /*!< Decrement the read bytes counter */
    452              (uint16_t)(*NumByteToRead)--;        
   \   00000222   2888               LDRH     R0,[R5, #+0]
   \   00000224   401E               SUBS     R0,R0,#+1
   \   00000226   2880               STRH     R0,[R5, #+0]
    453              
    454              /* Wait to make sure that STOP control bit has been cleared */
    455              sEETimeout = sEE_FLAG_TIMEOUT;
   \   00000228   ........           LDR.W    R0,??DataTable9_11
   \   0000022C   4FF48051           MOV      R1,#+4096
   \   00000230   0160               STR      R1,[R0, #+0]
    456              while(sEE_I2C->CR1 & I2C_CR1_STOP)
   \                     ??sEE_ReadBuffer_18:
   \   00000232   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   00000236   0088               LDRH     R0,[R0, #+0]
   \   00000238   8005               LSLS     R0,R0,#+22
   \   0000023A   0BD5               BPL.N    ??sEE_ReadBuffer_19
    457              {
    458                if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   0000023C   ........           LDR.W    R0,??DataTable9_11
   \   00000240   0068               LDR      R0,[R0, #+0]
   \   00000242   411E               SUBS     R1,R0,#+1
   \   00000244   ........           LDR.W    R2,??DataTable9_11
   \   00000248   1160               STR      R1,[R2, #+0]
   \   0000024A   0028               CMP      R0,#+0
   \   0000024C   F1D1               BNE.N    ??sEE_ReadBuffer_18
   \   0000024E   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000252   2EE0               B.N      ??sEE_ReadBuffer_2
    459              }  
    460              
    461              /*!< Re-Enable Acknowledgement to be ready for another reception */
    462              I2C_AcknowledgeConfig(sEE_I2C, ENABLE);    
   \                     ??sEE_ReadBuffer_19:
   \   00000254   0121               MOVS     R1,#+1
   \   00000256   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   0000025A   ........           BL       I2C_AcknowledgeConfig
   \   0000025E   27E0               B.N      ??sEE_ReadBuffer_20
    463            }
    464            else/* More than one Byte Master Reception procedure (DMA) -----------------*/
    465            {
    466              /*!< Test on EV6 and clear it */
    467              sEETimeout = sEE_FLAG_TIMEOUT;
   \                     ??sEE_ReadBuffer_13:
   \   00000260   ........           LDR.W    R0,??DataTable9_11
   \   00000264   4FF48051           MOV      R1,#+4096
   \   00000268   0160               STR      R1,[R0, #+0]
    468              while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
   \                     ??sEE_ReadBuffer_21:
   \   0000026A   ........           LDR.W    R1,??DataTable9_19  ;; 0x30002
   \   0000026E   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   00000272   ........           BL       I2C_CheckEvent
   \   00000276   0028               CMP      R0,#+0
   \   00000278   0BD1               BNE.N    ??sEE_ReadBuffer_22
    469              {
    470                if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   0000027A   ........           LDR.W    R0,??DataTable9_11
   \   0000027E   0068               LDR      R0,[R0, #+0]
   \   00000280   411E               SUBS     R1,R0,#+1
   \   00000282   ........           LDR.W    R2,??DataTable9_11
   \   00000286   1160               STR      R1,[R2, #+0]
   \   00000288   0028               CMP      R0,#+0
   \   0000028A   EED1               BNE.N    ??sEE_ReadBuffer_21
   \   0000028C   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000290   0FE0               B.N      ??sEE_ReadBuffer_2
    471              }  
    472              
    473              /* Configure the DMA Rx Channel with the buffer address and the buffer size */
    474              sEE_LowLevel_DMAConfig((uint32_t)pBuffer, (uint16_t)(*NumByteToRead), sEE_DIRECTION_RX);
   \                     ??sEE_ReadBuffer_22:
   \   00000292   0122               MOVS     R2,#+1
   \   00000294   2988               LDRH     R1,[R5, #+0]
   \   00000296   2000               MOVS     R0,R4
   \   00000298   ........           BL       sEE_LowLevel_DMAConfig
    475              
    476              /* Inform the DMA that the next End Of Transfer Signal will be the last one */
    477              I2C_DMALastTransferCmd(sEE_I2C, ENABLE); 
   \   0000029C   0121               MOVS     R1,#+1
   \   0000029E   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   000002A2   ........           BL       I2C_DMALastTransferCmd
    478              
    479              /* Enable the DMA Rx Channel */
    480              DMA_Cmd(sEE_I2C_DMA_STREAM_RX, ENABLE);  
   \   000002A6   0121               MOVS     R1,#+1
   \   000002A8   ........           LDR.W    R0,??DataTable9_6  ;; 0x40026010
   \   000002AC   ........           BL       DMA_Cmd
    481            }
    482            
    483            /* If all operations OK, return sEE_OK (0) */
    484            return sEE_OK;
   \                     ??sEE_ReadBuffer_20:
   \   000002B0   0020               MOVS     R0,#+0
   \                     ??sEE_ReadBuffer_2:
   \   000002B2   70BD               POP      {R4-R6,PC}       ;; return
    485          }
    486          
    487          /**
    488            * @brief  Writes more than one byte to the EEPROM with a single WRITE cycle.
    489            *
    490            * @note   The number of bytes (combined to write start address) must not 
    491            *         cross the EEPROM page boundary. This function can only write into
    492            *         the boundaries of an EEPROM page.
    493            *         This function doesn't check on boundaries condition (in this driver 
    494            *         the function sEE_WriteBuffer() which calls sEE_WritePage() is 
    495            *         responsible of checking on Page boundaries).
    496            * 
    497            * @param  pBuffer : pointer to the buffer containing the data to be written to 
    498            *         the EEPROM.
    499            * @param  WriteAddr : EEPROM's internal address to write to.
    500            * @param  NumByteToWrite : pointer to the variable holding number of bytes to 
    501            *         be written into the EEPROM. 
    502            * 
    503            *        @note The variable pointed by NumByteToWrite is reset to 0 when all the 
    504            *              data are written to the EEPROM. Application should monitor this 
    505            *              variable in order know when the transfer is complete.
    506            * 
    507            * @note This function just configure the communication and enable the DMA 
    508            *       channel to transfer data. Meanwhile, the user application may perform 
    509            *       other tasks in parallel.
    510            * 
    511            * @retval sEE_OK (0) if operation is correctly performed, else return value 
    512            *         different from sEE_OK (0) or the timeout user callback.
    513            */

   \                                 In section .text, align 2, keep-with-next
    514          uint32_t sEE_WritePage(uint8_t* pBuffer, uint16_t WriteAddr, uint8_t* NumByteToWrite)
    515          { 
   \                     sEE_WritePage:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0E00               MOVS     R6,R1
   \   00000006   1500               MOVS     R5,R2
    516            /* Set the pointer to the Number of data to be written. This pointer will be used 
    517                by the DMA Transfer Completer interrupt Handler in order to reset the 
    518                variable to 0. User should check on this variable in order to know if the 
    519                DMA transfer has been complete or not. */
    520            sEEDataWritePointer = NumByteToWrite;  
   \   00000008   ........           LDR.W    R0,??DataTable9_20
   \   0000000C   0560               STR      R5,[R0, #+0]
    521            
    522            /*!< While the bus is busy */
    523            sEETimeout = sEE_LONG_TIMEOUT;
   \   0000000E   ........           LDR.W    R0,??DataTable9_11
   \   00000012   4FF42041           MOV      R1,#+40960
   \   00000016   0160               STR      R1,[R0, #+0]
    524            while(I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_BUSY))
   \                     ??sEE_WritePage_0:
   \   00000018   5FF40031           MOVS     R1,#+131072
   \   0000001C   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   00000020   ........           BL       I2C_GetFlagStatus
   \   00000024   0028               CMP      R0,#+0
   \   00000026   0BD0               BEQ.N    ??sEE_WritePage_1
    525            {
    526              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000028   ........           LDR.W    R0,??DataTable9_11
   \   0000002C   0068               LDR      R0,[R0, #+0]
   \   0000002E   411E               SUBS     R1,R0,#+1
   \   00000030   ........           LDR.W    R2,??DataTable9_11
   \   00000034   1160               STR      R1,[R2, #+0]
   \   00000036   0028               CMP      R0,#+0
   \   00000038   EED1               BNE.N    ??sEE_WritePage_0
   \   0000003A   ........           BL       sEE_TIMEOUT_UserCallback
   \   0000003E   8EE0               B.N      ??sEE_WritePage_2
    527            }
    528            
    529            /*!< Send START condition */
    530            I2C_GenerateSTART(sEE_I2C, ENABLE);
   \                     ??sEE_WritePage_1:
   \   00000040   0121               MOVS     R1,#+1
   \   00000042   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   00000046   ........           BL       I2C_GenerateSTART
    531            
    532            /*!< Test on EV5 and clear it */
    533            sEETimeout = sEE_FLAG_TIMEOUT;
   \   0000004A   ........           LDR.W    R0,??DataTable9_11
   \   0000004E   4FF48051           MOV      R1,#+4096
   \   00000052   0160               STR      R1,[R0, #+0]
    534            while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
   \                     ??sEE_WritePage_3:
   \   00000054   ........           LDR.W    R1,??DataTable9_12  ;; 0x30001
   \   00000058   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   0000005C   ........           BL       I2C_CheckEvent
   \   00000060   0028               CMP      R0,#+0
   \   00000062   0BD1               BNE.N    ??sEE_WritePage_4
    535            {
    536              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000064   ........           LDR.W    R0,??DataTable9_11
   \   00000068   0068               LDR      R0,[R0, #+0]
   \   0000006A   411E               SUBS     R1,R0,#+1
   \   0000006C   ........           LDR.W    R2,??DataTable9_11
   \   00000070   1160               STR      R1,[R2, #+0]
   \   00000072   0028               CMP      R0,#+0
   \   00000074   EED1               BNE.N    ??sEE_WritePage_3
   \   00000076   ........           BL       sEE_TIMEOUT_UserCallback
   \   0000007A   70E0               B.N      ??sEE_WritePage_2
    537            }
    538            
    539            /*!< Send EEPROM address for write */
    540            sEETimeout = sEE_FLAG_TIMEOUT;
   \                     ??sEE_WritePage_4:
   \   0000007C   ........           LDR.W    R0,??DataTable9_11
   \   00000080   4FF48051           MOV      R1,#+4096
   \   00000084   0160               STR      R1,[R0, #+0]
    541            I2C_Send7bitAddress(sEE_I2C, sEEAddress, I2C_Direction_Transmitter);
   \   00000086   0022               MOVS     R2,#+0
   \   00000088   ........           LDR.W    R0,??DataTable9_9
   \   0000008C   0188               LDRH     R1,[R0, #+0]
   \   0000008E   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000090   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   00000094   ........           BL       I2C_Send7bitAddress
    542          
    543            /*!< Test on EV6 and clear it */
    544            sEETimeout = sEE_FLAG_TIMEOUT;
   \   00000098   ........           LDR.W    R0,??DataTable9_11
   \   0000009C   4FF48051           MOV      R1,#+4096
   \   000000A0   0160               STR      R1,[R0, #+0]
    545            while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
   \                     ??sEE_WritePage_5:
   \   000000A2   ........           LDR.W    R1,??DataTable9_13  ;; 0x70082
   \   000000A6   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   000000AA   ........           BL       I2C_CheckEvent
   \   000000AE   0028               CMP      R0,#+0
   \   000000B0   0BD1               BNE.N    ??sEE_WritePage_6
    546            {
    547              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   000000B2   ........           LDR.W    R0,??DataTable9_11
   \   000000B6   0068               LDR      R0,[R0, #+0]
   \   000000B8   411E               SUBS     R1,R0,#+1
   \   000000BA   ........           LDR.W    R2,??DataTable9_11
   \   000000BE   1160               STR      R1,[R2, #+0]
   \   000000C0   0028               CMP      R0,#+0
   \   000000C2   EED1               BNE.N    ??sEE_WritePage_5
   \   000000C4   ........           BL       sEE_TIMEOUT_UserCallback
   \   000000C8   49E0               B.N      ??sEE_WritePage_2
    548            }
    549          
    550          #ifdef sEE_M24C08
    551            
    552            /*!< Send the EEPROM's internal address to write to : only one byte Address */
    553            I2C_SendData(sEE_I2C, WriteAddr);
    554            
    555          #elif defined(sEE_M24C512)
    556            
    557            /*!< Send the EEPROM's internal address to write to : MSB of the address first */
    558            I2C_SendData(sEE_I2C, (uint8_t)((WriteAddr & 0xFF00) >> 8));
   \                     ??sEE_WritePage_6:
   \   000000CA   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000CC   310A               LSRS     R1,R6,#+8
   \   000000CE   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D0   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   000000D4   ........           BL       I2C_SendData
    559          
    560            /*!< Test on EV8 and clear it */
    561            sEETimeout = sEE_FLAG_TIMEOUT;  
   \   000000D8   ........           LDR.W    R0,??DataTable9_11
   \   000000DC   4FF48051           MOV      R1,#+4096
   \   000000E0   0160               STR      R1,[R0, #+0]
    562            while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
   \                     ??sEE_WritePage_7:
   \   000000E2   ........           LDR.W    R1,??DataTable9_14  ;; 0x70084
   \   000000E6   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   000000EA   ........           BL       I2C_CheckEvent
   \   000000EE   0028               CMP      R0,#+0
   \   000000F0   0BD1               BNE.N    ??sEE_WritePage_8
    563            {
    564              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   000000F2   ........           LDR.W    R0,??DataTable9_11
   \   000000F6   0068               LDR      R0,[R0, #+0]
   \   000000F8   411E               SUBS     R1,R0,#+1
   \   000000FA   ........           LDR.W    R2,??DataTable9_11
   \   000000FE   1160               STR      R1,[R2, #+0]
   \   00000100   0028               CMP      R0,#+0
   \   00000102   EED1               BNE.N    ??sEE_WritePage_7
   \   00000104   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000108   29E0               B.N      ??sEE_WritePage_2
    565            }  
    566            
    567            /*!< Send the EEPROM's internal address to write to : LSB of the address */
    568            I2C_SendData(sEE_I2C, (uint8_t)(WriteAddr & 0x00FF));
   \                     ??sEE_WritePage_8:
   \   0000010A   3100               MOVS     R1,R6
   \   0000010C   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000010E   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   00000112   ........           BL       I2C_SendData
    569            
    570          #endif /*!< sEE_M24C08 */  
    571            
    572            /*!< Test on EV8 and clear it */
    573            sEETimeout = sEE_FLAG_TIMEOUT; 
   \   00000116   ........           LDR.W    R0,??DataTable9_11
   \   0000011A   4FF48051           MOV      R1,#+4096
   \   0000011E   0160               STR      R1,[R0, #+0]
    574            while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
   \                     ??sEE_WritePage_9:
   \   00000120   ........           LDR.W    R1,??DataTable9_14  ;; 0x70084
   \   00000124   ........           LDR.W    R0,??DataTable9_8  ;; 0x40005800
   \   00000128   ........           BL       I2C_CheckEvent
   \   0000012C   0028               CMP      R0,#+0
   \   0000012E   0BD1               BNE.N    ??sEE_WritePage_10
    575            {
    576              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000130   ........           LDR.W    R0,??DataTable9_11
   \   00000134   0068               LDR      R0,[R0, #+0]
   \   00000136   411E               SUBS     R1,R0,#+1
   \   00000138   ........           LDR.W    R2,??DataTable9_11
   \   0000013C   1160               STR      R1,[R2, #+0]
   \   0000013E   0028               CMP      R0,#+0
   \   00000140   EED1               BNE.N    ??sEE_WritePage_9
   \   00000142   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000146   0AE0               B.N      ??sEE_WritePage_2
    577            }  
    578            
    579            /* Configure the DMA Tx Channel with the buffer address and the buffer size */
    580            sEE_LowLevel_DMAConfig((uint32_t)pBuffer, (uint8_t)(*NumByteToWrite), sEE_DIRECTION_TX);
   \                     ??sEE_WritePage_10:
   \   00000148   0022               MOVS     R2,#+0
   \   0000014A   2978               LDRB     R1,[R5, #+0]
   \   0000014C   2000               MOVS     R0,R4
   \   0000014E   ........           BL       sEE_LowLevel_DMAConfig
    581              
    582            /* Enable the DMA Tx Channel */
    583            DMA_Cmd(sEE_I2C_DMA_STREAM_TX, ENABLE);
   \   00000152   0121               MOVS     R1,#+1
   \   00000154   ........           LDR.W    R0,??DataTable9_2  ;; 0x400260a0
   \   00000158   ........           BL       DMA_Cmd
    584            
    585            /* If all operations OK, return sEE_OK (0) */
    586            return sEE_OK;
   \   0000015C   0020               MOVS     R0,#+0
   \                     ??sEE_WritePage_2:
   \   0000015E   70BD               POP      {R4-R6,PC}       ;; return
    587          }
    588          
    589          /**
    590            * @brief  Writes buffer of data to the I2C EEPROM.
    591            * @param  pBuffer : pointer to the buffer  containing the data to be written 
    592            *         to the EEPROM.
    593            * @param  WriteAddr : EEPROM's internal address to write to.
    594            * @param  NumByteToWrite : number of bytes to write to the EEPROM.
    595            * @retval None
    596            */

   \                                 In section .text, align 2, keep-with-next
    597          void sEE_WriteBuffer(uint8_t* pBuffer, uint16_t WriteAddr, uint16_t NumByteToWrite)
    598          {
   \                     sEE_WriteBuffer:
   \   00000000   2DE9F843           PUSH     {R3-R9,LR}
   \   00000004   0600               MOVS     R6,R0
   \   00000006   0D00               MOVS     R5,R1
   \   00000008   9146               MOV      R9,R2
    599            uint8_t NumOfPage = 0, NumOfSingle = 0, count = 0;
   \   0000000A   0027               MOVS     R7,#+0
   \   0000000C   0024               MOVS     R4,#+0
   \   0000000E   5FF00008           MOVS     R8,#+0
    600            uint16_t Addr = 0;
   \   00000012   0020               MOVS     R0,#+0
    601          
    602            Addr = WriteAddr % sEE_PAGESIZE;
   \   00000014   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000016   8021               MOVS     R1,#+128
   \   00000018   95FBF1F2           SDIV     R2,R5,R1
   \   0000001C   02FB1152           MLS      R2,R2,R1,R5
   \   00000020   1000               MOVS     R0,R2
    603            count = sEE_PAGESIZE - Addr;
   \   00000022   D0F18001           RSBS     R1,R0,#+128
   \   00000026   8846               MOV      R8,R1
    604            NumOfPage =  NumByteToWrite / sEE_PAGESIZE;
   \   00000028   1FFA89F9           UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000002C   8021               MOVS     R1,#+128
   \   0000002E   99FBF1F1           SDIV     R1,R9,R1
   \   00000032   0F00               MOVS     R7,R1
    605            NumOfSingle = NumByteToWrite % sEE_PAGESIZE;
   \   00000034   1FFA89F9           UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000038   8021               MOVS     R1,#+128
   \   0000003A   99FBF1F2           SDIV     R2,R9,R1
   \   0000003E   02FB1192           MLS      R2,R2,R1,R9
   \   00000042   1400               MOVS     R4,R2
    606           
    607            /*!< If WriteAddr is sEE_PAGESIZE aligned  */
    608            if(Addr == 0) 
   \   00000044   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000046   0028               CMP      R0,#+0
   \   00000048   77D1               BNE.N    ??sEE_WriteBuffer_0
    609            {
    610              /*!< If NumByteToWrite < sEE_PAGESIZE */
    611              if(NumOfPage == 0) 
   \   0000004A   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004C   002F               CMP      R7,#+0
   \   0000004E   27D1               BNE.N    ??sEE_WriteBuffer_1
    612              {
    613                /* Store the number of data to be written */
    614                sEEDataNum = NumOfSingle;
   \   00000050   ........           LDR.W    R0,??DataTable9_21
   \   00000054   0470               STRB     R4,[R0, #+0]
    615                /* Start writing data */
    616                sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
   \   00000056   ........           LDR.W    R2,??DataTable9_21
   \   0000005A   2900               MOVS     R1,R5
   \   0000005C   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000005E   3000               MOVS     R0,R6
   \   00000060   ........           BL       sEE_WritePage
    617                /* Wait transfer through DMA to be complete */
    618                sEETimeout = sEE_LONG_TIMEOUT;
   \   00000064   ........           LDR.W    R0,??DataTable9_11
   \   00000068   4FF42041           MOV      R1,#+40960
   \   0000006C   0160               STR      R1,[R0, #+0]
    619                while (sEEDataNum > 0)
   \                     ??sEE_WriteBuffer_2:
   \   0000006E   ........           LDR.W    R0,??DataTable9_21
   \   00000072   0078               LDRB     R0,[R0, #+0]
   \   00000074   0128               CMP      R0,#+1
   \   00000076   0BD3               BCC.N    ??sEE_WriteBuffer_3
    620                {
    621                  if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
   \   00000078   ........           LDR.W    R0,??DataTable9_11
   \   0000007C   0068               LDR      R0,[R0, #+0]
   \   0000007E   411E               SUBS     R1,R0,#+1
   \   00000080   ........           LDR.W    R2,??DataTable9_11
   \   00000084   1160               STR      R1,[R2, #+0]
   \   00000086   0028               CMP      R0,#+0
   \   00000088   F1D1               BNE.N    ??sEE_WriteBuffer_2
   \   0000008A   ........           BL       sEE_TIMEOUT_UserCallback
   \   0000008E   4EE1               B.N      ??sEE_WriteBuffer_4
    622                }
    623                sEE_WaitEepromStandbyState();
   \                     ??sEE_WriteBuffer_3:
   \   00000090   ........           BL       sEE_WaitEepromStandbyState
   \   00000094   4BE1               B.N      ??sEE_WriteBuffer_5
    624              }
    625              /*!< If NumByteToWrite > sEE_PAGESIZE */
    626              else  
    627              {
    628                while(NumOfPage--)
    629                {
    630                  /* Store the number of data to be written */
    631                  sEEDataNum = sEE_PAGESIZE;        
    632                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum)); 
    633                  /* Wait transfer through DMA to be complete */
    634                  sEETimeout = sEE_LONG_TIMEOUT;
    635                  while (sEEDataNum > 0)
    636                  {
    637                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
    638                  }      
    639                  sEE_WaitEepromStandbyState();
   \                     ??sEE_WriteBuffer_6:
   \   00000096   ........           BL       sEE_WaitEepromStandbyState
    640                  WriteAddr +=  sEE_PAGESIZE;
   \   0000009A   8035               ADDS     R5,R5,#+128
    641                  pBuffer += sEE_PAGESIZE;
   \   0000009C   06F28006           ADDW     R6,R6,#+128
   \                     ??sEE_WriteBuffer_1:
   \   000000A0   3800               MOVS     R0,R7
   \   000000A2   471E               SUBS     R7,R0,#+1
   \   000000A4   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A6   0028               CMP      R0,#+0
   \   000000A8   20D0               BEQ.N    ??sEE_WriteBuffer_7
   \   000000AA   ........           LDR.W    R0,??DataTable9_21
   \   000000AE   8021               MOVS     R1,#+128
   \   000000B0   0170               STRB     R1,[R0, #+0]
   \   000000B2   ........           LDR.W    R2,??DataTable9_21
   \   000000B6   2900               MOVS     R1,R5
   \   000000B8   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000BA   3000               MOVS     R0,R6
   \   000000BC   ........           BL       sEE_WritePage
   \   000000C0   ........           LDR.W    R0,??DataTable9_11
   \   000000C4   4FF42041           MOV      R1,#+40960
   \   000000C8   0160               STR      R1,[R0, #+0]
   \                     ??sEE_WriteBuffer_8:
   \   000000CA   ........           LDR.W    R0,??DataTable9_21
   \   000000CE   0078               LDRB     R0,[R0, #+0]
   \   000000D0   0128               CMP      R0,#+1
   \   000000D2   E0D3               BCC.N    ??sEE_WriteBuffer_6
   \   000000D4   ........           LDR.W    R0,??DataTable9_11
   \   000000D8   0068               LDR      R0,[R0, #+0]
   \   000000DA   411E               SUBS     R1,R0,#+1
   \   000000DC   ........           LDR.W    R2,??DataTable9_11
   \   000000E0   1160               STR      R1,[R2, #+0]
   \   000000E2   0028               CMP      R0,#+0
   \   000000E4   F1D1               BNE.N    ??sEE_WriteBuffer_8
   \   000000E6   ........           BL       sEE_TIMEOUT_UserCallback
   \   000000EA   20E1               B.N      ??sEE_WriteBuffer_4
    642                }
    643          
    644                if(NumOfSingle!=0)
   \                     ??sEE_WriteBuffer_7:
   \   000000EC   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000EE   002C               CMP      R4,#+0
   \   000000F0   00F01D81           BEQ.W    ??sEE_WriteBuffer_5
    645                {
    646                  /* Store the number of data to be written */
    647                  sEEDataNum = NumOfSingle;          
   \   000000F4   ........           LDR.W    R0,??DataTable9_21
   \   000000F8   0470               STRB     R4,[R0, #+0]
    648                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
   \   000000FA   ........           LDR.W    R2,??DataTable9_21
   \   000000FE   2900               MOVS     R1,R5
   \   00000100   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000102   3000               MOVS     R0,R6
   \   00000104   ........           BL       sEE_WritePage
    649                  /* Wait transfer through DMA to be complete */
    650                  sEETimeout = sEE_LONG_TIMEOUT;
   \   00000108   ........           LDR.W    R0,??DataTable9_11
   \   0000010C   4FF42041           MOV      R1,#+40960
   \   00000110   0160               STR      R1,[R0, #+0]
    651                  while (sEEDataNum > 0)
   \                     ??sEE_WriteBuffer_9:
   \   00000112   ........           LDR.W    R0,??DataTable9_21
   \   00000116   0078               LDRB     R0,[R0, #+0]
   \   00000118   0128               CMP      R0,#+1
   \   0000011A   0BD3               BCC.N    ??sEE_WriteBuffer_10
    652                  {
    653                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
   \   0000011C   ........           LDR.W    R0,??DataTable9_11
   \   00000120   0068               LDR      R0,[R0, #+0]
   \   00000122   411E               SUBS     R1,R0,#+1
   \   00000124   ........           LDR.W    R2,??DataTable9_11
   \   00000128   1160               STR      R1,[R2, #+0]
   \   0000012A   0028               CMP      R0,#+0
   \   0000012C   F1D1               BNE.N    ??sEE_WriteBuffer_9
   \   0000012E   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000132   FCE0               B.N      ??sEE_WriteBuffer_4
    654                  }    
    655                  sEE_WaitEepromStandbyState();
   \                     ??sEE_WriteBuffer_10:
   \   00000134   ........           BL       sEE_WaitEepromStandbyState
   \   00000138   F9E0               B.N      ??sEE_WriteBuffer_5
    656                }
    657              }
    658            }
    659            /*!< If WriteAddr is not sEE_PAGESIZE aligned  */
    660            else 
    661            {
    662              /*!< If NumByteToWrite < sEE_PAGESIZE */
    663              if(NumOfPage== 0) 
   \                     ??sEE_WriteBuffer_0:
   \   0000013A   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000013C   002F               CMP      R7,#+0
   \   0000013E   77D1               BNE.N    ??sEE_WriteBuffer_11
    664              {
    665                /*!< If the number of data to be written is more than the remaining space 
    666                in the current page: */
    667                if (NumByteToWrite > count)
   \   00000140   4046               MOV      R0,R8
   \   00000142   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000144   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000146   1FFA89F9           UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000014A   4845               CMP      R0,R9
   \   0000014C   4DD2               BCS.N    ??sEE_WriteBuffer_12
    668                {
    669                  /* Store the number of data to be written */
    670                  sEEDataNum = count;        
   \   0000014E   ........           LDR.W    R0,??DataTable9_21
   \   00000152   80F80080           STRB     R8,[R0, #+0]
    671                  /*!< Write the data conained in same page */
    672                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
   \   00000156   ........           LDR.W    R2,??DataTable9_21
   \   0000015A   2900               MOVS     R1,R5
   \   0000015C   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000015E   3000               MOVS     R0,R6
   \   00000160   ........           BL       sEE_WritePage
    673                  /* Wait transfer through DMA to be complete */
    674                  sEETimeout = sEE_LONG_TIMEOUT;
   \   00000164   ........           LDR.W    R0,??DataTable9_11
   \   00000168   4FF42041           MOV      R1,#+40960
   \   0000016C   0160               STR      R1,[R0, #+0]
    675                  while (sEEDataNum > 0)
   \                     ??sEE_WriteBuffer_13:
   \   0000016E   ........           LDR.W    R0,??DataTable9_21
   \   00000172   0078               LDRB     R0,[R0, #+0]
   \   00000174   0128               CMP      R0,#+1
   \   00000176   0BD3               BCC.N    ??sEE_WriteBuffer_14
    676                  {
    677                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
   \   00000178   ........           LDR.W    R0,??DataTable9_11
   \   0000017C   0068               LDR      R0,[R0, #+0]
   \   0000017E   411E               SUBS     R1,R0,#+1
   \   00000180   ........           LDR.W    R2,??DataTable9_11
   \   00000184   1160               STR      R1,[R2, #+0]
   \   00000186   0028               CMP      R0,#+0
   \   00000188   F1D1               BNE.N    ??sEE_WriteBuffer_13
   \   0000018A   ........           BL       sEE_TIMEOUT_UserCallback
   \   0000018E   CEE0               B.N      ??sEE_WriteBuffer_4
    678                  }          
    679                  sEE_WaitEepromStandbyState();      
   \                     ??sEE_WriteBuffer_14:
   \   00000190   ........           BL       sEE_WaitEepromStandbyState
    680                  
    681                  /* Store the number of data to be written */
    682                  sEEDataNum = (NumByteToWrite - count);          
   \   00000194   B9EB0800           SUBS     R0,R9,R8
   \   00000198   ........           LDR.W    R1,??DataTable9_21
   \   0000019C   0870               STRB     R0,[R1, #+0]
    683                  /*!< Write the remaining data in the following page */
    684                  sEE_WritePage((uint8_t*)(pBuffer + count), (WriteAddr + count), (uint8_t*)(&sEEDataNum));
   \   0000019E   ........           LDR.W    R2,??DataTable9_21
   \   000001A2   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001A6   18EB0501           ADDS     R1,R8,R5
   \   000001AA   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000001AC   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001B0   18EB0600           ADDS     R0,R8,R6
   \   000001B4   ........           BL       sEE_WritePage
    685                  /* Wait transfer through DMA to be complete */
    686                  sEETimeout = sEE_LONG_TIMEOUT;
   \   000001B8   ........           LDR.W    R0,??DataTable9_11
   \   000001BC   4FF42041           MOV      R1,#+40960
   \   000001C0   0160               STR      R1,[R0, #+0]
    687                  while (sEEDataNum > 0)
   \                     ??sEE_WriteBuffer_15:
   \   000001C2   ........           LDR.W    R0,??DataTable9_21
   \   000001C6   0078               LDRB     R0,[R0, #+0]
   \   000001C8   0128               CMP      R0,#+1
   \   000001CA   0BD3               BCC.N    ??sEE_WriteBuffer_16
    688                  {
    689                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
   \   000001CC   ........           LDR.W    R0,??DataTable9_11
   \   000001D0   0068               LDR      R0,[R0, #+0]
   \   000001D2   411E               SUBS     R1,R0,#+1
   \   000001D4   ........           LDR.W    R2,??DataTable9_11
   \   000001D8   1160               STR      R1,[R2, #+0]
   \   000001DA   0028               CMP      R0,#+0
   \   000001DC   F1D1               BNE.N    ??sEE_WriteBuffer_15
   \   000001DE   ........           BL       sEE_TIMEOUT_UserCallback
   \   000001E2   A4E0               B.N      ??sEE_WriteBuffer_4
    690                  }     
    691                  sEE_WaitEepromStandbyState();        
   \                     ??sEE_WriteBuffer_16:
   \   000001E4   ........           BL       sEE_WaitEepromStandbyState
   \   000001E8   A1E0               B.N      ??sEE_WriteBuffer_5
    692                }      
    693                else      
    694                {
    695                  /* Store the number of data to be written */
    696                  sEEDataNum = NumOfSingle;         
   \                     ??sEE_WriteBuffer_12:
   \   000001EA   ........           LDR.W    R0,??DataTable9_21
   \   000001EE   0470               STRB     R4,[R0, #+0]
    697                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
   \   000001F0   ........           LDR.W    R2,??DataTable9_21
   \   000001F4   2900               MOVS     R1,R5
   \   000001F6   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000001F8   3000               MOVS     R0,R6
   \   000001FA   ........           BL       sEE_WritePage
    698                  /* Wait transfer through DMA to be complete */
    699                  sEETimeout = sEE_LONG_TIMEOUT;
   \   000001FE   ........           LDR.W    R0,??DataTable9_11
   \   00000202   4FF42041           MOV      R1,#+40960
   \   00000206   0160               STR      R1,[R0, #+0]
    700                  while (sEEDataNum > 0)
   \                     ??sEE_WriteBuffer_17:
   \   00000208   ........           LDR.W    R0,??DataTable9_21
   \   0000020C   0078               LDRB     R0,[R0, #+0]
   \   0000020E   0128               CMP      R0,#+1
   \   00000210   0BD3               BCC.N    ??sEE_WriteBuffer_18
    701                  {
    702                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
   \   00000212   ........           LDR.W    R0,??DataTable9_11
   \   00000216   0068               LDR      R0,[R0, #+0]
   \   00000218   411E               SUBS     R1,R0,#+1
   \   0000021A   ........           LDR.W    R2,??DataTable9_11
   \   0000021E   1160               STR      R1,[R2, #+0]
   \   00000220   0028               CMP      R0,#+0
   \   00000222   F1D1               BNE.N    ??sEE_WriteBuffer_17
   \   00000224   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000228   81E0               B.N      ??sEE_WriteBuffer_4
    703                  }          
    704                  sEE_WaitEepromStandbyState();        
   \                     ??sEE_WriteBuffer_18:
   \   0000022A   ........           BL       sEE_WaitEepromStandbyState
   \   0000022E   7EE0               B.N      ??sEE_WriteBuffer_5
    705                }     
    706              }
    707              /*!< If NumByteToWrite > sEE_PAGESIZE */
    708              else
    709              {
    710                NumByteToWrite -= count;
   \                     ??sEE_WriteBuffer_11:
   \   00000230   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000234   B9EB0809           SUBS     R9,R9,R8
    711                NumOfPage =  NumByteToWrite / sEE_PAGESIZE;
   \   00000238   1FFA89F9           UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000023C   8020               MOVS     R0,#+128
   \   0000023E   99FBF0F7           SDIV     R7,R9,R0
    712                NumOfSingle = NumByteToWrite % sEE_PAGESIZE;
   \   00000242   1FFA89F9           UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000246   8020               MOVS     R0,#+128
   \   00000248   99FBF0F4           SDIV     R4,R9,R0
   \   0000024C   04FB1094           MLS      R4,R4,R0,R9
    713                
    714                if(count != 0)
   \   00000250   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000254   B8F1000F           CMP      R8,#+0
   \   00000258   2AD0               BEQ.N    ??sEE_WriteBuffer_19
    715                {  
    716                  /* Store the number of data to be written */
    717                  sEEDataNum = count;         
   \   0000025A   ....               LDR.N    R0,??DataTable9_21
   \   0000025C   80F80080           STRB     R8,[R0, #+0]
    718                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
   \   00000260   ....               LDR.N    R2,??DataTable9_21
   \   00000262   2900               MOVS     R1,R5
   \   00000264   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000266   3000               MOVS     R0,R6
   \   00000268   ........           BL       sEE_WritePage
    719                  /* Wait transfer through DMA to be complete */
    720                  sEETimeout = sEE_LONG_TIMEOUT;
   \   0000026C   ....               LDR.N    R0,??DataTable9_11
   \   0000026E   4FF42041           MOV      R1,#+40960
   \   00000272   0160               STR      R1,[R0, #+0]
    721                  while (sEEDataNum > 0)
   \                     ??sEE_WriteBuffer_20:
   \   00000274   ....               LDR.N    R0,??DataTable9_21
   \   00000276   0078               LDRB     R0,[R0, #+0]
   \   00000278   0128               CMP      R0,#+1
   \   0000027A   09D3               BCC.N    ??sEE_WriteBuffer_21
    722                  {
    723                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
   \   0000027C   ....               LDR.N    R0,??DataTable9_11
   \   0000027E   0068               LDR      R0,[R0, #+0]
   \   00000280   411E               SUBS     R1,R0,#+1
   \   00000282   ....               LDR.N    R2,??DataTable9_11
   \   00000284   1160               STR      R1,[R2, #+0]
   \   00000286   0028               CMP      R0,#+0
   \   00000288   F4D1               BNE.N    ??sEE_WriteBuffer_20
   \   0000028A   ........           BL       sEE_TIMEOUT_UserCallback
   \   0000028E   4EE0               B.N      ??sEE_WriteBuffer_4
    724                  }     
    725                  sEE_WaitEepromStandbyState();
   \                     ??sEE_WriteBuffer_21:
   \   00000290   ........           BL       sEE_WaitEepromStandbyState
    726                  WriteAddr += count;
   \   00000294   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000298   18EB0505           ADDS     R5,R8,R5
    727                  pBuffer += count;
   \   0000029C   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002A0   18EB0606           ADDS     R6,R8,R6
   \   000002A4   04E0               B.N      ??sEE_WriteBuffer_19
    728                } 
    729                
    730                while(NumOfPage--)
    731                {
    732                  /* Store the number of data to be written */
    733                  sEEDataNum = sEE_PAGESIZE;          
    734                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
    735                  /* Wait transfer through DMA to be complete */
    736                  sEETimeout = sEE_LONG_TIMEOUT;
    737                  while (sEEDataNum > 0)
    738                  {
    739                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
    740                  }        
    741                  sEE_WaitEepromStandbyState();
   \                     ??sEE_WriteBuffer_22:
   \   000002A6   ........           BL       sEE_WaitEepromStandbyState
    742                  WriteAddr +=  sEE_PAGESIZE;
   \   000002AA   8035               ADDS     R5,R5,#+128
    743                  pBuffer += sEE_PAGESIZE;  
   \   000002AC   06F28006           ADDW     R6,R6,#+128
   \                     ??sEE_WriteBuffer_19:
   \   000002B0   3800               MOVS     R0,R7
   \   000002B2   471E               SUBS     R7,R0,#+1
   \   000002B4   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002B6   0028               CMP      R0,#+0
   \   000002B8   1AD0               BEQ.N    ??sEE_WriteBuffer_23
   \   000002BA   ....               LDR.N    R0,??DataTable9_21
   \   000002BC   8021               MOVS     R1,#+128
   \   000002BE   0170               STRB     R1,[R0, #+0]
   \   000002C0   ....               LDR.N    R2,??DataTable9_21
   \   000002C2   2900               MOVS     R1,R5
   \   000002C4   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000002C6   3000               MOVS     R0,R6
   \   000002C8   ........           BL       sEE_WritePage
   \   000002CC   ....               LDR.N    R0,??DataTable9_11
   \   000002CE   4FF42041           MOV      R1,#+40960
   \   000002D2   0160               STR      R1,[R0, #+0]
   \                     ??sEE_WriteBuffer_24:
   \   000002D4   ....               LDR.N    R0,??DataTable9_21
   \   000002D6   0078               LDRB     R0,[R0, #+0]
   \   000002D8   0128               CMP      R0,#+1
   \   000002DA   E4D3               BCC.N    ??sEE_WriteBuffer_22
   \   000002DC   ....               LDR.N    R0,??DataTable9_11
   \   000002DE   0068               LDR      R0,[R0, #+0]
   \   000002E0   411E               SUBS     R1,R0,#+1
   \   000002E2   ....               LDR.N    R2,??DataTable9_11
   \   000002E4   1160               STR      R1,[R2, #+0]
   \   000002E6   0028               CMP      R0,#+0
   \   000002E8   F4D1               BNE.N    ??sEE_WriteBuffer_24
   \   000002EA   ........           BL       sEE_TIMEOUT_UserCallback
   \   000002EE   1EE0               B.N      ??sEE_WriteBuffer_4
    744                }
    745                if(NumOfSingle != 0)
   \                     ??sEE_WriteBuffer_23:
   \   000002F0   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002F2   002C               CMP      R4,#+0
   \   000002F4   1BD0               BEQ.N    ??sEE_WriteBuffer_5
    746                {
    747                  /* Store the number of data to be written */
    748                  sEEDataNum = NumOfSingle;           
   \   000002F6   ....               LDR.N    R0,??DataTable9_21
   \   000002F8   0470               STRB     R4,[R0, #+0]
    749                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum)); 
   \   000002FA   ....               LDR.N    R2,??DataTable9_21
   \   000002FC   2900               MOVS     R1,R5
   \   000002FE   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000300   3000               MOVS     R0,R6
   \   00000302   ........           BL       sEE_WritePage
    750                  /* Wait transfer through DMA to be complete */
    751                  sEETimeout = sEE_LONG_TIMEOUT;
   \   00000306   ....               LDR.N    R0,??DataTable9_11
   \   00000308   4FF42041           MOV      R1,#+40960
   \   0000030C   0160               STR      R1,[R0, #+0]
    752                  while (sEEDataNum > 0)
   \                     ??sEE_WriteBuffer_25:
   \   0000030E   ....               LDR.N    R0,??DataTable9_21
   \   00000310   0078               LDRB     R0,[R0, #+0]
   \   00000312   0128               CMP      R0,#+1
   \   00000314   09D3               BCC.N    ??sEE_WriteBuffer_26
    753                  {
    754                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
   \   00000316   ....               LDR.N    R0,??DataTable9_11
   \   00000318   0068               LDR      R0,[R0, #+0]
   \   0000031A   411E               SUBS     R1,R0,#+1
   \   0000031C   ....               LDR.N    R2,??DataTable9_11
   \   0000031E   1160               STR      R1,[R2, #+0]
   \   00000320   0028               CMP      R0,#+0
   \   00000322   F4D1               BNE.N    ??sEE_WriteBuffer_25
   \   00000324   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000328   01E0               B.N      ??sEE_WriteBuffer_4
    755                  }         
    756                  sEE_WaitEepromStandbyState();
   \                     ??sEE_WriteBuffer_26:
   \   0000032A   ........           BL       sEE_WaitEepromStandbyState
    757                }
    758              }
    759            }  
    760          }
   \                     ??sEE_WriteBuffer_5:
   \                     ??sEE_WriteBuffer_4:
   \   0000032E   BDE8F183           POP      {R0,R4-R9,PC}    ;; return
    761          
    762          /**
    763            * @brief  Wait for EEPROM Standby state.
    764            * 
    765            * @note  This function allows to wait and check that EEPROM has finished the 
    766            *        last Write operation. It is mostly used after Write operation: after 
    767            *        receiving the buffer to be written, the EEPROM may need additional 
    768            *        time to actually perform the write operation. During this time, it 
    769            *        doesn't answer to I2C packets addressed to it. Once the write operation 
    770            *        is complete the EEPROM responds to its address.
    771            *        
    772            * @note  It is not necessary to call this function after sEE_WriteBuffer() 
    773            *        function (sEE_WriteBuffer() already calls this function after each
    774            *        write page operation).    
    775            * 
    776            * @param  None
    777            * @retval sEE_OK (0) if operation is correctly performed, else return value 
    778            *         different from sEE_OK (0) or the timeout user callback.
    779            */

   \                                 In section .text, align 2, keep-with-next
    780          uint32_t sEE_WaitEepromStandbyState(void)      
    781          {
   \                     sEE_WaitEepromStandbyState:
   \   00000000   1CB5               PUSH     {R2-R4,LR}
    782            __IO uint16_t tmpSR1 = 0;
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   ADF80000           STRH     R0,[SP, #+0]
    783            __IO uint32_t sEETrials = 0;
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   0190               STR      R0,[SP, #+4]
    784          
    785            /*!< While the bus is busy */
    786            sEETimeout = sEE_LONG_TIMEOUT;
   \   0000000C   ....               LDR.N    R0,??DataTable9_11
   \   0000000E   4FF42041           MOV      R1,#+40960
   \   00000012   0160               STR      R1,[R0, #+0]
    787            while(I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_BUSY))
   \                     ??sEE_WaitEepromStandbyState_0:
   \   00000014   5FF40031           MOVS     R1,#+131072
   \   00000018   ....               LDR.N    R0,??DataTable9_8  ;; 0x40005800
   \   0000001A   ........           BL       I2C_GetFlagStatus
   \   0000001E   0028               CMP      R0,#+0
   \   00000020   09D0               BEQ.N    ??sEE_WaitEepromStandbyState_1
    788            {
    789              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000022   ....               LDR.N    R0,??DataTable9_11
   \   00000024   0068               LDR      R0,[R0, #+0]
   \   00000026   411E               SUBS     R1,R0,#+1
   \   00000028   ....               LDR.N    R2,??DataTable9_11
   \   0000002A   1160               STR      R1,[R2, #+0]
   \   0000002C   0028               CMP      R0,#+0
   \   0000002E   F1D1               BNE.N    ??sEE_WaitEepromStandbyState_0
   \   00000030   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000034   4DE0               B.N      ??sEE_WaitEepromStandbyState_2
    790            }
    791          
    792            /* Keep looping till the slave acknowledge his address or maximum number 
    793               of trials is reached (this number is defined by sEE_MAX_TRIALS_NUMBER define
    794               in stm32_eval_i2c_ee.h file) */
    795            while (1)
    796            {
    797              /*!< Send START condition */
    798              I2C_GenerateSTART(sEE_I2C, ENABLE);
   \                     ??sEE_WaitEepromStandbyState_1:
   \   00000036   0121               MOVS     R1,#+1
   \   00000038   ....               LDR.N    R0,??DataTable9_8  ;; 0x40005800
   \   0000003A   ........           BL       I2C_GenerateSTART
    799          
    800              /*!< Test on EV5 and clear it */
    801              sEETimeout = sEE_FLAG_TIMEOUT;
   \   0000003E   ....               LDR.N    R0,??DataTable9_11
   \   00000040   4FF48051           MOV      R1,#+4096
   \   00000044   0160               STR      R1,[R0, #+0]
    802              while(!I2C_CheckEvent(sEE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
   \                     ??sEE_WaitEepromStandbyState_3:
   \   00000046   ....               LDR.N    R1,??DataTable9_12  ;; 0x30001
   \   00000048   ....               LDR.N    R0,??DataTable9_8  ;; 0x40005800
   \   0000004A   ........           BL       I2C_CheckEvent
   \   0000004E   0028               CMP      R0,#+0
   \   00000050   09D1               BNE.N    ??sEE_WaitEepromStandbyState_4
    803              {
    804                if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000052   ....               LDR.N    R0,??DataTable9_11
   \   00000054   0068               LDR      R0,[R0, #+0]
   \   00000056   411E               SUBS     R1,R0,#+1
   \   00000058   ....               LDR.N    R2,??DataTable9_11
   \   0000005A   1160               STR      R1,[R2, #+0]
   \   0000005C   0028               CMP      R0,#+0
   \   0000005E   F2D1               BNE.N    ??sEE_WaitEepromStandbyState_3
   \   00000060   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000064   35E0               B.N      ??sEE_WaitEepromStandbyState_2
    805              }    
    806          
    807              /*!< Send EEPROM address for write */
    808              I2C_Send7bitAddress(sEE_I2C, sEEAddress, I2C_Direction_Transmitter);
   \                     ??sEE_WaitEepromStandbyState_4:
   \   00000066   0022               MOVS     R2,#+0
   \   00000068   ....               LDR.N    R0,??DataTable9_9
   \   0000006A   0188               LDRH     R1,[R0, #+0]
   \   0000006C   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006E   ....               LDR.N    R0,??DataTable9_8  ;; 0x40005800
   \   00000070   ........           BL       I2C_Send7bitAddress
    809              
    810              /* Wait for ADDR flag to be set (Slave acknowledged his address) */
    811              sEETimeout = sEE_LONG_TIMEOUT;
   \   00000074   ....               LDR.N    R0,??DataTable9_11
   \   00000076   4FF42041           MOV      R1,#+40960
   \   0000007A   0160               STR      R1,[R0, #+0]
    812              do
    813              {     
    814                /* Get the current value of the SR1 register */
    815                tmpSR1 = sEE_I2C->SR1;
   \                     ??sEE_WaitEepromStandbyState_5:
   \   0000007C   ....               LDR.N    R0,??DataTable9_22  ;; 0x40005814
   \   0000007E   0088               LDRH     R0,[R0, #+0]
   \   00000080   ADF80000           STRH     R0,[SP, #+0]
    816                
    817                /* Update the timeout value and exit if it reach 0 */
    818                if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
   \   00000084   ....               LDR.N    R0,??DataTable9_11
   \   00000086   0068               LDR      R0,[R0, #+0]
   \   00000088   411E               SUBS     R1,R0,#+1
   \   0000008A   ....               LDR.N    R2,??DataTable9_11
   \   0000008C   1160               STR      R1,[R2, #+0]
   \   0000008E   0028               CMP      R0,#+0
   \   00000090   02D1               BNE.N    ??sEE_WaitEepromStandbyState_6
   \   00000092   ........           BL       sEE_TIMEOUT_UserCallback
   \   00000096   1CE0               B.N      ??sEE_WaitEepromStandbyState_2
    819              }
    820              /* Keep looping till the Address is acknowledged or the AF flag is 
    821                 set (address not acknowledged at time) */
    822              while((tmpSR1 & (I2C_SR1_ADDR | I2C_SR1_AF)) == 0);
   \                     ??sEE_WaitEepromStandbyState_6:
   \   00000098   BDF80000           LDRH     R0,[SP, #+0]
   \   0000009C   40F20241           MOVW     R1,#+1026
   \   000000A0   0842               TST      R0,R1
   \   000000A2   EBD0               BEQ.N    ??sEE_WaitEepromStandbyState_5
    823               
    824              /* Check if the ADDR flag has been set */
    825              if (tmpSR1 & I2C_SR1_ADDR)
   \   000000A4   BDF80000           LDRH     R0,[SP, #+0]
   \   000000A8   8007               LSLS     R0,R0,#+30
   \   000000AA   07D5               BPL.N    ??sEE_WaitEepromStandbyState_7
    826              {
    827                /* Clear ADDR Flag by reading SR1 then SR2 registers (SR1 have already 
    828                   been read) */
    829                (void)sEE_I2C->SR2;
   \   000000AC   ....               LDR.N    R0,??DataTable9_17  ;; 0x40005818
   \   000000AE   0488               LDRH     R4,[R0, #+0]
    830                
    831                /*!< STOP condition */    
    832                I2C_GenerateSTOP(sEE_I2C, ENABLE);
   \   000000B0   0121               MOVS     R1,#+1
   \   000000B2   ....               LDR.N    R0,??DataTable9_8  ;; 0x40005800
   \   000000B4   ........           BL       I2C_GenerateSTOP
    833                  
    834                /* Exit the function */
    835                return sEE_OK;
   \   000000B8   0020               MOVS     R0,#+0
   \   000000BA   0AE0               B.N      ??sEE_WaitEepromStandbyState_2
    836              }
    837              else
    838              {
    839                /*!< Clear AF flag */
    840                I2C_ClearFlag(sEE_I2C, I2C_FLAG_AF);                  
   \                     ??sEE_WaitEepromStandbyState_7:
   \   000000BC   ....               LDR.N    R1,??DataTable9_23  ;; 0x10000400
   \   000000BE   ....               LDR.N    R0,??DataTable9_8  ;; 0x40005800
   \   000000C0   ........           BL       I2C_ClearFlag
    841              }
    842              
    843              /* Check if the maximum allowed numbe of trials has bee reached */
    844              if (sEETrials++ == sEE_MAX_TRIALS_NUMBER)
   \   000000C4   0198               LDR      R0,[SP, #+4]
   \   000000C6   411C               ADDS     R1,R0,#+1
   \   000000C8   0191               STR      R1,[SP, #+4]
   \   000000CA   9628               CMP      R0,#+150
   \   000000CC   B3D1               BNE.N    ??sEE_WaitEepromStandbyState_1
    845              {
    846                /* If the maximum number of trials has been reached, exit the function */
    847                return sEE_TIMEOUT_UserCallback();
   \   000000CE   ........           BL       sEE_TIMEOUT_UserCallback
   \                     ??sEE_WaitEepromStandbyState_2:
   \   000000D2   16BD               POP      {R1,R2,R4,PC}    ;; return
    848              }
    849            }
    850          }
    851          
    852          /**
    853            * @brief  This function handles the DMA Tx Channel interrupt Handler.
    854            * @param  None
    855            * @retval None
    856            */

   \                                 In section .text, align 2, keep-with-next
    857          void sEE_I2C_DMA_TX_IRQHandler(void)
    858          {
   \                     DMA1_Stream6_IRQHandler:
   \   00000000   80B5               PUSH     {R7,LR}
    859            /* Check if the DMA transfer is complete */
    860            if(DMA_GetFlagStatus(sEE_I2C_DMA_STREAM_TX, sEE_TX_DMA_FLAG_TCIF) != RESET)
   \   00000002   ....               LDR.N    R1,??DataTable9_24  ;; 0x20200000
   \   00000004   ....               LDR.N    R0,??DataTable9_2  ;; 0x400260a0
   \   00000006   ........           BL       DMA_GetFlagStatus
   \   0000000A   0028               CMP      R0,#+0
   \   0000000C   23D0               BEQ.N    ??DMA1_Stream6_IRQHandler_0
    861            {  
    862              /* Disable the DMA Tx Stream and Clear TC flag */  
    863              DMA_Cmd(sEE_I2C_DMA_STREAM_TX, DISABLE);
   \   0000000E   0021               MOVS     R1,#+0
   \   00000010   ....               LDR.N    R0,??DataTable9_2  ;; 0x400260a0
   \   00000012   ........           BL       DMA_Cmd
    864              DMA_ClearFlag(sEE_I2C_DMA_STREAM_TX, sEE_TX_DMA_FLAG_TCIF);
   \   00000016   ....               LDR.N    R1,??DataTable9_24  ;; 0x20200000
   \   00000018   ....               LDR.N    R0,??DataTable9_2  ;; 0x400260a0
   \   0000001A   ........           BL       DMA_ClearFlag
    865          
    866              /*!< Wait till all data have been physically transferred on the bus */
    867              sEETimeout = sEE_LONG_TIMEOUT;
   \   0000001E   ....               LDR.N    R0,??DataTable9_11
   \   00000020   4FF42041           MOV      R1,#+40960
   \   00000024   0160               STR      R1,[R0, #+0]
   \   00000026   08E0               B.N      ??DMA1_Stream6_IRQHandler_1
    868              while(!I2C_GetFlagStatus(sEE_I2C, I2C_FLAG_BTF))
    869              {
    870                if((sEETimeout--) == 0) sEE_TIMEOUT_UserCallback();
   \                     ??DMA1_Stream6_IRQHandler_2:
   \   00000028   ....               LDR.N    R0,??DataTable9_11
   \   0000002A   0068               LDR      R0,[R0, #+0]
   \   0000002C   411E               SUBS     R1,R0,#+1
   \   0000002E   ....               LDR.N    R2,??DataTable9_11
   \   00000030   1160               STR      R1,[R2, #+0]
   \   00000032   0028               CMP      R0,#+0
   \   00000034   01D1               BNE.N    ??DMA1_Stream6_IRQHandler_1
   \   00000036   ........           BL       sEE_TIMEOUT_UserCallback
    871              }
   \                     ??DMA1_Stream6_IRQHandler_1:
   \   0000003A   ....               LDR.N    R1,??DataTable9_15  ;; 0x10000004
   \   0000003C   ....               LDR.N    R0,??DataTable9_8  ;; 0x40005800
   \   0000003E   ........           BL       I2C_GetFlagStatus
   \   00000042   0028               CMP      R0,#+0
   \   00000044   F0D0               BEQ.N    ??DMA1_Stream6_IRQHandler_2
    872              
    873              /*!< Send STOP condition */
    874              I2C_GenerateSTOP(sEE_I2C, ENABLE);
   \   00000046   0121               MOVS     R1,#+1
   \   00000048   ....               LDR.N    R0,??DataTable9_8  ;; 0x40005800
   \   0000004A   ........           BL       I2C_GenerateSTOP
    875              
    876              /* Reset the variable holding the number of data to be written */
    877              *sEEDataWritePointer = 0;  
   \   0000004E   ....               LDR.N    R0,??DataTable9_20
   \   00000050   0068               LDR      R0,[R0, #+0]
   \   00000052   0021               MOVS     R1,#+0
   \   00000054   0170               STRB     R1,[R0, #+0]
    878            }
    879          }
   \                     ??DMA1_Stream6_IRQHandler_0:
   \   00000056   01BD               POP      {R0,PC}          ;; return
    880          
    881          
    882          /**
    883            * @brief  This function handles the DMA Rx Channel interrupt Handler.
    884            * @param  None
    885            * @retval None
    886            */

   \                                 In section .text, align 2, keep-with-next
    887          void sEE_I2C_DMA_RX_IRQHandler(void)
    888          {
   \                     DMA1_Stream0_IRQHandler:
   \   00000000   80B5               PUSH     {R7,LR}
    889            /* Check if the DMA transfer is complete */
    890            if(DMA_GetFlagStatus(sEE_I2C_DMA_STREAM_RX, sEE_RX_DMA_FLAG_TCIF) != RESET)
   \   00000002   ....               LDR.N    R1,??DataTable9_25  ;; 0x10000020
   \   00000004   ....               LDR.N    R0,??DataTable9_6  ;; 0x40026010
   \   00000006   ........           BL       DMA_GetFlagStatus
   \   0000000A   0028               CMP      R0,#+0
   \   0000000C   0FD0               BEQ.N    ??DMA1_Stream0_IRQHandler_0
    891            {      
    892              /*!< Send STOP Condition */
    893              I2C_GenerateSTOP(sEE_I2C, ENABLE);    
   \   0000000E   0121               MOVS     R1,#+1
   \   00000010   ....               LDR.N    R0,??DataTable9_8  ;; 0x40005800
   \   00000012   ........           BL       I2C_GenerateSTOP
    894              
    895              /* Disable the DMA Rx Stream and Clear TC Flag */  
    896              DMA_Cmd(sEE_I2C_DMA_STREAM_RX, DISABLE);
   \   00000016   0021               MOVS     R1,#+0
   \   00000018   ....               LDR.N    R0,??DataTable9_6  ;; 0x40026010
   \   0000001A   ........           BL       DMA_Cmd
    897              DMA_ClearFlag(sEE_I2C_DMA_STREAM_RX, sEE_RX_DMA_FLAG_TCIF);
   \   0000001E   ....               LDR.N    R1,??DataTable9_25  ;; 0x10000020
   \   00000020   ....               LDR.N    R0,??DataTable9_6  ;; 0x40026010
   \   00000022   ........           BL       DMA_ClearFlag
    898              
    899              /* Reset the variable holding the number of data to be read */
    900              *sEEDataReadPointer = 0;
   \   00000026   ....               LDR.N    R0,??DataTable9_10
   \   00000028   0068               LDR      R0,[R0, #+0]
   \   0000002A   0021               MOVS     R1,#+0
   \   0000002C   0180               STRH     R1,[R0, #+0]
    901            }
    902          }
   \                     ??DMA1_Stream0_IRQHandler_0:
   \   0000002E   01BD               POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    903          void sEE_LowLevel_DeInit(void)
    904          {
   \                     sEE_LowLevel_DeInit:
   \   00000000   E0B5               PUSH     {R5-R7,LR}
    905              GPIO_InitTypeDef  GPIO_InitStructure; 
    906              NVIC_InitTypeDef NVIC_InitStructure;   
    907            /* sEE_I2C Peripheral Disable */
    908              I2C_Cmd(sEE_I2C, DISABLE);
   \   00000002   0021               MOVS     R1,#+0
   \   00000004   ....               LDR.N    R0,??DataTable9_8  ;; 0x40005800
   \   00000006   ........           BL       I2C_Cmd
    909           
    910            /* sEE_I2C DeInit */
    911            I2C_DeInit(sEE_I2C);
   \   0000000A   ....               LDR.N    R0,??DataTable9_8  ;; 0x40005800
   \   0000000C   ........           BL       I2C_DeInit
    912          
    913            /*!< sEE_I2C Periph clock disable */
    914            RCC_APB1PeriphClockCmd(sEE_I2C_CLK, DISABLE);
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   5FF48000           MOVS     R0,#+4194304
   \   00000016   ........           BL       RCC_APB1PeriphClockCmd
    915              
    916            /*!< GPIO configuration */  
    917            /*!< Configure sEE_I2C pins: SCL */
    918            GPIO_InitStructure.GPIO_Pin = sEE_I2C_SCL_PIN;
   \   0000001A   4FF48060           MOV      R0,#+1024
   \   0000001E   0190               STR      R0,[SP, #+4]
    919            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   00000020   0020               MOVS     R0,#+0
   \   00000022   8DF80800           STRB     R0,[SP, #+8]
    920            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
   \   00000026   0020               MOVS     R0,#+0
   \   00000028   8DF80B00           STRB     R0,[SP, #+11]
    921            GPIO_Init(sEE_I2C_SCL_GPIO_PORT, &GPIO_InitStructure);
   \   0000002C   01A9               ADD      R1,SP,#+4
   \   0000002E   ....               LDR.N    R0,??DataTable9  ;; 0x40020400
   \   00000030   ........           BL       GPIO_Init
    922          
    923            /*!< Configure sEE_I2C pins: SDA */
    924            GPIO_InitStructure.GPIO_Pin = sEE_I2C_SDA_PIN;
   \   00000034   4FF40060           MOV      R0,#+2048
   \   00000038   0190               STR      R0,[SP, #+4]
    925            GPIO_Init(sEE_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
   \   0000003A   01A9               ADD      R1,SP,#+4
   \   0000003C   ....               LDR.N    R0,??DataTable9  ;; 0x40020400
   \   0000003E   ........           BL       GPIO_Init
    926          
    927            /* Configure and enable I2C DMA TX Stream interrupt */
    928            NVIC_InitStructure.NVIC_IRQChannel = sEE_I2C_DMA_TX_IRQn;
   \   00000042   1120               MOVS     R0,#+17
   \   00000044   8DF80000           STRB     R0,[SP, #+0]
    929            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = sEE_I2C_DMA_PREPRIO;
   \   00000048   0020               MOVS     R0,#+0
   \   0000004A   8DF80100           STRB     R0,[SP, #+1]
    930            NVIC_InitStructure.NVIC_IRQChannelSubPriority = sEE_I2C_DMA_SUBPRIO;
   \   0000004E   0020               MOVS     R0,#+0
   \   00000050   8DF80200           STRB     R0,[SP, #+2]
    931            NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
   \   00000054   0020               MOVS     R0,#+0
   \   00000056   8DF80300           STRB     R0,[SP, #+3]
    932            NVIC_Init(&NVIC_InitStructure);
   \   0000005A   00A8               ADD      R0,SP,#+0
   \   0000005C   ........           BL       NVIC_Init
    933          
    934            /* Configure and enable I2C DMA RX Stream interrupt */
    935            NVIC_InitStructure.NVIC_IRQChannel = sEE_I2C_DMA_RX_IRQn;
   \   00000060   0B20               MOVS     R0,#+11
   \   00000062   8DF80000           STRB     R0,[SP, #+0]
    936            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = sEE_I2C_DMA_PREPRIO;
   \   00000066   0020               MOVS     R0,#+0
   \   00000068   8DF80100           STRB     R0,[SP, #+1]
    937            NVIC_InitStructure.NVIC_IRQChannelSubPriority = sEE_I2C_DMA_SUBPRIO;
   \   0000006C   0020               MOVS     R0,#+0
   \   0000006E   8DF80200           STRB     R0,[SP, #+2]
    938            NVIC_Init(&NVIC_InitStructure);   
   \   00000072   00A8               ADD      R0,SP,#+0
   \   00000074   ........           BL       NVIC_Init
    939            
    940            /* Disable and Deinitialize the DMA Streams */
    941            DMA_Cmd(sEE_I2C_DMA_STREAM_TX, DISABLE);
   \   00000078   0021               MOVS     R1,#+0
   \   0000007A   ....               LDR.N    R0,??DataTable9_2  ;; 0x400260a0
   \   0000007C   ........           BL       DMA_Cmd
    942            DMA_Cmd(sEE_I2C_DMA_STREAM_RX, DISABLE);
   \   00000080   0021               MOVS     R1,#+0
   \   00000082   ....               LDR.N    R0,??DataTable9_6  ;; 0x40026010
   \   00000084   ........           BL       DMA_Cmd
    943            DMA_DeInit(sEE_I2C_DMA_STREAM_TX);
   \   00000088   ....               LDR.N    R0,??DataTable9_2  ;; 0x400260a0
   \   0000008A   ........           BL       DMA_DeInit
    944            DMA_DeInit(sEE_I2C_DMA_STREAM_RX);
   \   0000008E   ....               LDR.N    R0,??DataTable9_6  ;; 0x40026010
   \   00000090   ........           BL       DMA_DeInit
    945          }
   \   00000094   07BD               POP      {R0-R2,PC}       ;; return
    946          #ifdef USE_DEFAULT_TIMEOUT_CALLBACK
    947          /**
    948            * @brief  Basic management of the timeout situation.
    949            * @param  None.
    950            * @retval None.
    951            */
    952          uint32_t sEE_TIMEOUT_UserCallback(void)
    953          {
    954            /* Block communication and all processes */
    955            while (1)
    956            {   
    957            }
    958          }
    959          #endif /* USE_DEFAULT_TIMEOUT_CALLBACK */
    960          
    961          #ifdef USE_DEFAULT_CRITICAL_CALLBACK
    962          /**
    963            * @brief  Start critical section: these callbacks should be typically used
    964            *         to disable interrupts when entering a critical section of I2C communication
    965            *         You may use default callbacks provided into this driver by uncommenting the 
    966            *         define USE_DEFAULT_CRITICAL_CALLBACK.
    967            *         Or you can comment that line and implement these callbacks into your 
    968            *         application.
    969            * @param  None.
    970            * @retval None.
    971            */

   \                                 In section .text, align 2, keep-with-next
    972          void sEE_EnterCriticalSection_UserCallback(void)
    973          {
    974            __disable_irq();  
   \                     sEE_EnterCriticalSection_UserCallback:
   \   00000000   72B6               CPSID    I
    975          }
   \   00000002   7047               BX       LR               ;; return
    976          
    977          /**
    978            * @brief  Start and End of critical section: these callbacks should be typically used
    979            *         to re-enable interrupts when exiting a critical section of I2C communication
    980            *         You may use default callbacks provided into this driver by uncommenting the 
    981            *         define USE_DEFAULT_CRITICAL_CALLBACK.
    982            *         Or you can comment that line and implement these callbacks into your 
    983            *         application.
    984            * @param  None.
    985            * @retval None.
    986            */

   \                                 In section .text, align 2, keep-with-next
    987          void sEE_ExitCriticalSection_UserCallback(void)
    988          {
    989            __enable_irq();
   \                     sEE_ExitCriticalSection_UserCallback:
   \   00000000   62B6               CPSIE    I
    990          }
   \   00000002   7047               BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   00040240           DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   00003D20           DC32     0x203d0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   A0600240           DC32     0x400260a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   ........           DC32     sEEDMA_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   10540040           DC32     0x40005410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   3D008010           DC32     0x1080003d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   10600240           DC32     0x40026010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   E0930400           DC32     0x493e0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   00580040           DC32     0x40005800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   ........           DC32     sEEAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   ........           DC32     sEEDataReadPointer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   ........           DC32     sEETimeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   01000300           DC32     0x30001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   82000700           DC32     0x70082

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   84000700           DC32     0x70084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   04000010           DC32     0x10000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   02000010           DC32     0x10000002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   18580040           DC32     0x40005818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_18:
   \   00000000   40000010           DC32     0x10000040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_19:
   \   00000000   02000300           DC32     0x30002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_20:
   \   00000000   ........           DC32     sEEDataWritePointer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_21:
   \   00000000   ........           DC32     sEEDataNum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_22:
   \   00000000   14580040           DC32     0x40005814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_23:
   \   00000000   00040010           DC32     0x10000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_24:
   \   00000000   00002020           DC32     0x20200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_25:
   \   00000000   20000010           DC32     0x10000020
    991          #endif /* USE_DEFAULT_CRITICAL_CALLBACK */
    992          
    993          /**
    994            * @}
    995            */
    996          
    997          /**
    998            * @}
    999            */
   1000          
   1001          /**
   1002            * @}
   1003            */
   1004          
   1005          /**
   1006            * @}
   1007            */
   1008          
   1009          /**
   1010            * @}
   1011            */  
   1012          
   1013          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     DMA1_Stream0_IRQHandler             8
     DMA1_Stream6_IRQHandler             8
     sEE_DeInit                          8
     sEE_EnterCriticalSection_UserCallback
                                         0
     sEE_ExitCriticalSection_UserCallback
                                         0
     sEE_Init                           24
     sEE_LowLevel_DMAConfig              8
     sEE_LowLevel_DeInit                16
     sEE_LowLevel_Init                  16
     sEE_ReadBuffer                     16
     sEE_WaitEepromStandbyState         16
     sEE_WriteBuffer                    32
     sEE_WritePage                      16


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     sEEDMA_InitStructure             60
     sEEAddress                        2
     sEETimeout                        4
     sEEDataReadPointer                4
     sEEDataWritePointer               4
     sEEDataNum                        1
     sEE_LowLevel_Init               434
     sEE_LowLevel_DMAConfig           74
     sEE_DeInit                        8
     sEE_Init                         92
     sEE_ReadBuffer                  692
     sEE_WritePage                   352
     sEE_WriteBuffer                 818
     sEE_WaitEepromStandbyState      212
     DMA1_Stream6_IRQHandler          88
     DMA1_Stream0_IRQHandler          48
     sEE_LowLevel_DeInit             150
     sEE_EnterCriticalSection_UserCallback
                                       4
     sEE_ExitCriticalSection_UserCallback
                                       4
     ??DataTable9                      4
     ??DataTable9_1                    4
     ??DataTable9_2                    4
     ??DataTable9_3                    4
     ??DataTable9_4                    4
     ??DataTable9_5                    4
     ??DataTable9_6                    4
     ??DataTable9_7                    4
     ??DataTable9_8                    4
     ??DataTable9_9                    4
     ??DataTable9_10                   4
     ??DataTable9_11                   4
     ??DataTable9_12                   4
     ??DataTable9_13                   4
     ??DataTable9_14                   4
     ??DataTable9_15                   4
     ??DataTable9_16                   4
     ??DataTable9_17                   4
     ??DataTable9_18                   4
     ??DataTable9_19                   4
     ??DataTable9_20                   4
     ??DataTable9_21                   4
     ??DataTable9_22                   4
     ??DataTable9_23                   4
     ??DataTable9_24                   4
     ??DataTable9_25                   4

 
    71 bytes in section .bss
     4 bytes in section .data
 3 080 bytes in section .text
 
 3 080 bytes of CODE memory
    75 bytes of DATA memory

Errors: none
Warnings: none
