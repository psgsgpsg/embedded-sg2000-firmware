###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     19/Jan/2012  11:09:13 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32_ #
#                    USB_OTG_Driver\src\usb_dcd.c                             #
#    Command line =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32_ #
#                    USB_OTG_Driver\src\usb_dcd.c -D USE_STDPERIPH_DRIVER -D  #
#                    STM32F2XX -D USE_STM3220F_EVAL -D USE_USB_OTG_FS -D      #
#                    RTC_CLOCK_SOURCE_LSE -lC F:\Work\S&G2000\Firmware\DTG_EM #
#                    S_SYSTEM\Project\EWARM\STM3220F_EVAL\List\ -lA           #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\ -o F:\Work\S&G2000\Firmware\DTG_EMS_SY #
#                    STEM\Project\EWARM\STM3220F_EVAL\Obj\ --no_cse           #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Full.h" -I                     #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWA #
#                    RM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I             #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I         #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\ -I                             #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\Common\ -I                      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_OTG_Driver\inc\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Core\inc\ -I      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\msc\inc\    #
#                    -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM #
#                    \..\Usb\ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Proj #
#                    ect\EWARM\..\Usb\Inc\ -I F:\Work\S&G2000\Firmware\DTG_EM #
#                    S_SYSTEM\Project\EWARM\..\Usb\src\ -I                    #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Core\inc\ -I        #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -Ol --use_c++_inline                                     #
#    List file    =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\usb_dcd.lst                             #
#    Object file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\Obj\usb_dcd.o                                #
#                                                                             #
#                                                                             #
###############################################################################

F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32_USB_OTG_Driver\src\usb_dcd.c
      1          /**
      2            ******************************************************************************
      3            * @file    usb_dcd.c
      4            * @author  MCD Application Team
      5            * @version V2.0.0RC1
      6            * @date    18-March-2011
      7            * @brief   Peripheral Device Interface Layer
      8            ******************************************************************************
      9            * @attention 
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "usb_dcd.h"
     24          #include "usb_bsp.h"
     25          
     26          
     27          /** @addtogroup USB_OTG_DRIVER
     28          * @{
     29          */
     30          
     31          /** @defgroup USB_DCD 
     32          * @brief This file is the interface between EFSL ans Host mass-storage class
     33          * @{
     34          */
     35          
     36          
     37          /** @defgroup USB_DCD_Private_Defines
     38          * @{
     39          */ 
     40          /**
     41          * @}
     42          */ 
     43          
     44          
     45          /** @defgroup USB_DCD_Private_TypesDefinitions
     46          * @{
     47          */ 
     48          /**
     49          * @}
     50          */ 
     51          
     52          
     53          
     54          /** @defgroup USB_DCD_Private_Macros
     55          * @{
     56          */ 
     57          /**
     58          * @}
     59          */ 
     60          
     61          
     62          /** @defgroup USB_DCD_Private_Variables
     63          * @{
     64          */ 
     65          /**
     66          * @}
     67          */ 
     68          
     69          
     70          /** @defgroup USB_DCD_Private_FunctionPrototypes
     71          * @{
     72          */ 
     73          
     74          /**
     75          * @}
     76          */ 
     77          
     78          
     79          /** @defgroup USB_DCD_Private_Functions
     80          * @{
     81          */ 
     82          
     83          
     84          

   \                                 In section .text, align 2, keep-with-next
     85          void DCD_Init(USB_OTG_CORE_HANDLE *pdev , 
     86                        USB_OTG_CORE_ID_TypeDef coreID)
     87          {
   \                     DCD_Init:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
     88            uint32_t i;
     89            USB_OTG_EP *ep;
     90            
     91            USB_OTG_SelectCore (pdev , coreID);
   \   00000004   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   2000               MOVS     R0,R4
   \   00000008   ........           BL       USB_OTG_SelectCore
     92            
     93            pdev->dev.device_status = USB_OTG_DEFAULT;
   \   0000000C   0120               MOVS     R0,#+1
   \   0000000E   84F81201           STRB     R0,[R4, #+274]
     94            pdev->dev.device_address = 0;
   \   00000012   0020               MOVS     R0,#+0
   \   00000014   84F81301           STRB     R0,[R4, #+275]
     95            
     96            /* Init ep structure */
     97            for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   11E0               B.N      ??DCD_Init_0
     98            {
     99              ep = &pdev->dev.in_ep[i];
   \                     ??DCD_Init_1:
   \   0000001C   2821               MOVS     R1,#+40
   \   0000001E   01FB0041           MLA      R1,R1,R0,R4
   \   00000022   01F21811           ADDW     R1,R1,#+280
    100              /* Init ep structure */
    101              ep->is_in = 1;
   \   00000026   0122               MOVS     R2,#+1
   \   00000028   4A70               STRB     R2,[R1, #+1]
    102              ep->num = i;
   \   0000002A   0870               STRB     R0,[R1, #+0]
    103              ep->tx_fifo_num = i;
   \   0000002C   C880               STRH     R0,[R1, #+6]
    104              /* Control until ep is actvated */
    105              ep->type = EP_TYPE_CTRL;
   \   0000002E   0022               MOVS     R2,#+0
   \   00000030   CA70               STRB     R2,[R1, #+3]
    106              ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
   \   00000032   4022               MOVS     R2,#+64
   \   00000034   8A60               STR      R2,[R1, #+8]
    107              ep->xfer_buff = 0;
   \   00000036   0022               MOVS     R2,#+0
   \   00000038   CA60               STR      R2,[R1, #+12]
    108              ep->xfer_len = 0;
   \   0000003A   0022               MOVS     R2,#+0
   \   0000003C   4A61               STR      R2,[R1, #+20]
    109            }
   \   0000003E   401C               ADDS     R0,R0,#+1
   \                     ??DCD_Init_0:
   \   00000040   6178               LDRB     R1,[R4, #+1]
   \   00000042   8842               CMP      R0,R1
   \   00000044   EAD3               BCC.N    ??DCD_Init_1
    110            
    111            for (i = 0; i < pdev->cfg.dev_endpoints; i++)
   \   00000046   0020               MOVS     R0,#+0
   \   00000048   11E0               B.N      ??DCD_Init_2
    112            {
    113              ep = &pdev->dev.out_ep[i];
   \                     ??DCD_Init_3:
   \   0000004A   2821               MOVS     R1,#+40
   \   0000004C   01FB0041           MLA      R1,R1,R0,R4
   \   00000050   01F27031           ADDW     R1,R1,#+880
    114              /* Init ep structure */
    115              ep->is_in = 0;
   \   00000054   0022               MOVS     R2,#+0
   \   00000056   4A70               STRB     R2,[R1, #+1]
    116              ep->num = i;
   \   00000058   0870               STRB     R0,[R1, #+0]
    117              ep->tx_fifo_num = i;
   \   0000005A   C880               STRH     R0,[R1, #+6]
    118              /* Control until ep is activated */
    119              ep->type = EP_TYPE_CTRL;
   \   0000005C   0022               MOVS     R2,#+0
   \   0000005E   CA70               STRB     R2,[R1, #+3]
    120              ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
   \   00000060   4022               MOVS     R2,#+64
   \   00000062   8A60               STR      R2,[R1, #+8]
    121              ep->xfer_buff = 0;
   \   00000064   0022               MOVS     R2,#+0
   \   00000066   CA60               STR      R2,[R1, #+12]
    122              ep->xfer_len = 0;
   \   00000068   0022               MOVS     R2,#+0
   \   0000006A   4A61               STR      R2,[R1, #+20]
    123            }
   \   0000006C   401C               ADDS     R0,R0,#+1
   \                     ??DCD_Init_2:
   \   0000006E   6178               LDRB     R1,[R4, #+1]
   \   00000070   8842               CMP      R0,R1
   \   00000072   EAD3               BCC.N    ??DCD_Init_3
    124            
    125            USB_OTG_DisableGlobalInt(pdev);
   \   00000074   2000               MOVS     R0,R4
   \   00000076   ........           BL       USB_OTG_DisableGlobalInt
    126            
    127            /*Init the Core (common init.) */
    128            USB_OTG_CoreInit(pdev);
   \   0000007A   2000               MOVS     R0,R4
   \   0000007C   ........           BL       USB_OTG_CoreInit
    129            
    130            /* Init Device */
    131            USB_OTG_CoreInitDev(pdev);
   \   00000080   2000               MOVS     R0,R4
   \   00000082   ........           BL       USB_OTG_CoreInitDev
    132            
    133            /* Force Device Mode*/
    134            USB_OTG_SetCurrentMode(pdev, DEVICE_MODE);
   \   00000086   0021               MOVS     R1,#+0
   \   00000088   2000               MOVS     R0,R4
   \   0000008A   ........           BL       USB_OTG_SetCurrentMode
    135            
    136            /* Enable USB Global interrupt */
    137            USB_OTG_EnableGlobalInt(pdev);
   \   0000008E   2000               MOVS     R0,R4
   \   00000090   ........           BL       USB_OTG_EnableGlobalInt
    138          }
   \   00000094   10BD               POP      {R4,PC}          ;; return
    139          
    140          
    141          /**
    142          * @brief  Configure an EP
    143          * @param pdev : Device instance
    144          * @param epdesc : Endpoint Descriptor
    145          * @retval : status
    146          */

   \                                 In section .text, align 2, keep-with-next
    147          uint32_t DCD_EP_Open(USB_OTG_CORE_HANDLE *pdev , 
    148                               uint8_t ep_addr,
    149                               uint16_t ep_mps,
    150                               uint8_t ep_type)
    151          {
   \                     DCD_EP_Open:
   \   00000000   38B5               PUSH     {R3-R5,LR}
    152            USB_OTG_EP *ep;
    153            
    154            if ((ep_addr & 0x80) == 0x80)
   \   00000002   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0C06               LSLS     R4,R1,#+24
   \   00000006   08D5               BPL.N    ??DCD_EP_Open_0
    155            {
    156              ep = &pdev->dev.in_ep[ep_addr & 0x7F];
   \   00000008   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   11F07F04           ANDS     R4,R1,#0x7F
   \   0000000E   2825               MOVS     R5,#+40
   \   00000010   05FB0404           MLA      R4,R5,R4,R0
   \   00000014   04F21814           ADDW     R4,R4,#+280
   \   00000018   07E0               B.N      ??DCD_EP_Open_1
    157            }
    158            else
    159            {
    160              ep = &pdev->dev.out_ep[ep_addr & 0x7F];
   \                     ??DCD_EP_Open_0:
   \   0000001A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   11F07F04           ANDS     R4,R1,#0x7F
   \   00000020   2825               MOVS     R5,#+40
   \   00000022   05FB0404           MLA      R4,R5,R4,R0
   \   00000026   04F27034           ADDW     R4,R4,#+880
    161            }
    162            ep->num   = ep_addr & 0x7F;
   \                     ??DCD_EP_Open_1:
   \   0000002A   11F07F05           ANDS     R5,R1,#0x7F
   \   0000002E   2570               STRB     R5,[R4, #+0]
    163            
    164            ep->is_in = (0x80 & ep_addr) != 0;
   \   00000030   C1F3C011           UBFX     R1,R1,#+7,#+1
   \   00000034   11F00101           ANDS     R1,R1,#0x1
   \   00000038   6170               STRB     R1,[R4, #+1]
    165            ep->maxpacket = ep_mps;
   \   0000003A   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000003C   A260               STR      R2,[R4, #+8]
    166            ep->type = ep_type;
   \   0000003E   E370               STRB     R3,[R4, #+3]
    167            if (ep->is_in)
   \   00000040   6178               LDRB     R1,[R4, #+1]
   \   00000042   0029               CMP      R1,#+0
   \   00000044   01D0               BEQ.N    ??DCD_EP_Open_2
    168            {
    169              /* Assign a Tx FIFO */
    170              ep->tx_fifo_num = ep->num;
   \   00000046   2178               LDRB     R1,[R4, #+0]
   \   00000048   E180               STRH     R1,[R4, #+6]
    171            }
    172            /* Set initial data PID. */
    173            if (ep_type == USB_OTG_EP_BULK )
   \                     ??DCD_EP_Open_2:
   \   0000004A   DBB2               UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000004C   022B               CMP      R3,#+2
   \   0000004E   01D1               BNE.N    ??DCD_EP_Open_3
    174            {
    175              ep->data_pid_start = 0;
   \   00000050   0021               MOVS     R1,#+0
   \   00000052   2171               STRB     R1,[R4, #+4]
    176            }
    177            USB_OTG_EPActivate(pdev , ep );
   \                     ??DCD_EP_Open_3:
   \   00000054   2100               MOVS     R1,R4
   \   00000056   ........           BL       USB_OTG_EPActivate
    178            return 0;
   \   0000005A   0020               MOVS     R0,#+0
   \   0000005C   32BD               POP      {R1,R4,R5,PC}    ;; return
    179          }
    180          /**
    181          * @brief  called when an EP is disabled
    182          * @param pdev: device instance
    183          * @param ep_addr: endpoint address
    184          * @retval : status
    185          */

   \                                 In section .text, align 2, keep-with-next
    186          uint32_t DCD_EP_Close(USB_OTG_CORE_HANDLE *pdev , uint8_t  ep_addr)
    187          {
   \                     DCD_EP_Close:
   \   00000000   80B5               PUSH     {R7,LR}
    188            USB_OTG_EP *ep;
    189            
    190            if ((ep_addr&0x80) == 0x80)
   \   00000002   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0A06               LSLS     R2,R1,#+24
   \   00000006   08D5               BPL.N    ??DCD_EP_Close_0
    191            {
    192              ep = &pdev->dev.in_ep[ep_addr & 0x7F];
   \   00000008   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   11F07F02           ANDS     R2,R1,#0x7F
   \   0000000E   2823               MOVS     R3,#+40
   \   00000010   03FB0202           MLA      R2,R3,R2,R0
   \   00000014   02F21812           ADDW     R2,R2,#+280
   \   00000018   07E0               B.N      ??DCD_EP_Close_1
    193            }
    194            else
    195            {
    196              ep = &pdev->dev.out_ep[ep_addr & 0x7F];
   \                     ??DCD_EP_Close_0:
   \   0000001A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   11F07F02           ANDS     R2,R1,#0x7F
   \   00000020   2823               MOVS     R3,#+40
   \   00000022   03FB0202           MLA      R2,R3,R2,R0
   \   00000026   02F27032           ADDW     R2,R2,#+880
    197            }
    198            ep->num   = ep_addr & 0x7F;
   \                     ??DCD_EP_Close_1:
   \   0000002A   11F07F03           ANDS     R3,R1,#0x7F
   \   0000002E   1370               STRB     R3,[R2, #+0]
    199            ep->is_in = (0x80 & ep_addr) != 0;
   \   00000030   C1F3C011           UBFX     R1,R1,#+7,#+1
   \   00000034   11F00101           ANDS     R1,R1,#0x1
   \   00000038   5170               STRB     R1,[R2, #+1]
    200            USB_OTG_EPDeactivate(pdev , ep );
   \   0000003A   1100               MOVS     R1,R2
   \   0000003C   ........           BL       USB_OTG_EPDeactivate
    201            return 0;
   \   00000040   0020               MOVS     R0,#+0
   \   00000042   02BD               POP      {R1,PC}          ;; return
    202          }
    203          
    204          
    205          /**
    206          * @brief  DCD_EP_PrepareRx
    207          * @param pdev: device instance
    208          * @param ep_addr: endpoint address
    209          * @param pbuf: pointer to Rx buffer
    210          * @param buf_len: data length
    211          * @retval : status
    212          */

   \                                 In section .text, align 2, keep-with-next
    213          uint32_t   DCD_EP_PrepareRx( USB_OTG_CORE_HANDLE *pdev,
    214                                      uint8_t   ep_addr,
    215                                      uint8_t *pbuf,                        
    216                                      uint16_t  buf_len)
    217          {
   \                     DCD_EP_PrepareRx:
   \   00000000   38B5               PUSH     {R3-R5,LR}
    218            USB_OTG_EP *ep;
    219            
    220            ep = &pdev->dev.out_ep[ep_addr & 0x7F];
   \   00000002   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   11F07F04           ANDS     R4,R1,#0x7F
   \   00000008   2825               MOVS     R5,#+40
   \   0000000A   05FB0404           MLA      R4,R5,R4,R0
   \   0000000E   04F27034           ADDW     R4,R4,#+880
    221            
    222            /*setup and start the Xfer */
    223            ep->xfer_buff = pbuf;  
   \   00000012   E260               STR      R2,[R4, #+12]
    224            ep->xfer_len = buf_len;
   \   00000014   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000016   6361               STR      R3,[R4, #+20]
    225            ep->xfer_count = 0;
   \   00000018   0023               MOVS     R3,#+0
   \   0000001A   A361               STR      R3,[R4, #+24]
    226            ep->is_in = 0;
   \   0000001C   0023               MOVS     R3,#+0
   \   0000001E   6370               STRB     R3,[R4, #+1]
    227            ep->num = ep_addr & 0x7F;
   \   00000020   11F07F01           ANDS     R1,R1,#0x7F
   \   00000024   2170               STRB     R1,[R4, #+0]
    228            
    229            if (pdev->cfg.dma_enable == 1)
   \   00000026   C178               LDRB     R1,[R0, #+3]
   \   00000028   0129               CMP      R1,#+1
   \   0000002A   00D1               BNE.N    ??DCD_EP_PrepareRx_0
    230            {
    231              ep->dma_addr = (uint32_t)pbuf;  
   \   0000002C   2261               STR      R2,[R4, #+16]
    232            }
    233            
    234            if ( ep->num == 0 )
   \                     ??DCD_EP_PrepareRx_0:
   \   0000002E   2178               LDRB     R1,[R4, #+0]
   \   00000030   0029               CMP      R1,#+0
   \   00000032   03D1               BNE.N    ??DCD_EP_PrepareRx_1
    235            {
    236              USB_OTG_EP0StartXfer(pdev , ep);
   \   00000034   2100               MOVS     R1,R4
   \   00000036   ........           BL       USB_OTG_EP0StartXfer
   \   0000003A   02E0               B.N      ??DCD_EP_PrepareRx_2
    237            }
    238            else
    239            {
    240              USB_OTG_EPStartXfer(pdev, ep );
   \                     ??DCD_EP_PrepareRx_1:
   \   0000003C   2100               MOVS     R1,R4
   \   0000003E   ........           BL       USB_OTG_EPStartXfer
    241            }
    242            return 0;
   \                     ??DCD_EP_PrepareRx_2:
   \   00000042   0020               MOVS     R0,#+0
   \   00000044   32BD               POP      {R1,R4,R5,PC}    ;; return
    243          }
    244          
    245          /**
    246          * @brief  Transmit data over USB
    247          * @param pdev: device instance
    248          * @param ep_addr: endpoint address
    249          * @param pbuf: pointer to Tx buffer
    250          * @param buf_len: data length
    251          * @retval : status
    252          */

   \                                 In section .text, align 2, keep-with-next
    253          uint32_t  DCD_EP_Tx ( USB_OTG_CORE_HANDLE *pdev,
    254                               uint8_t   ep_addr,
    255                               uint8_t   *pbuf,
    256                               uint32_t   buf_len)
    257          {
   \                     DCD_EP_Tx:
   \   00000000   38B5               PUSH     {R3-R5,LR}
    258            USB_OTG_EP *ep;
    259            
    260            ep = &pdev->dev.in_ep[ep_addr & 0x7F];
   \   00000002   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   11F07F04           ANDS     R4,R1,#0x7F
   \   00000008   2825               MOVS     R5,#+40
   \   0000000A   05FB0404           MLA      R4,R5,R4,R0
   \   0000000E   04F21814           ADDW     R4,R4,#+280
    261            
    262            /* Setup and start the Transfer */
    263            ep->is_in = 1;
   \   00000012   0125               MOVS     R5,#+1
   \   00000014   6570               STRB     R5,[R4, #+1]
    264            ep->num = ep_addr & 0x7F;  
   \   00000016   11F07F01           ANDS     R1,R1,#0x7F
   \   0000001A   2170               STRB     R1,[R4, #+0]
    265            ep->xfer_buff = pbuf;
   \   0000001C   E260               STR      R2,[R4, #+12]
    266            ep->dma_addr = (uint32_t)pbuf;  
   \   0000001E   2261               STR      R2,[R4, #+16]
    267            ep->xfer_count = 0;
   \   00000020   0021               MOVS     R1,#+0
   \   00000022   A161               STR      R1,[R4, #+24]
    268            ep->xfer_len  = buf_len;
   \   00000024   6361               STR      R3,[R4, #+20]
    269            
    270            if ( ep->num == 0 )
   \   00000026   2178               LDRB     R1,[R4, #+0]
   \   00000028   0029               CMP      R1,#+0
   \   0000002A   03D1               BNE.N    ??DCD_EP_Tx_0
    271            {
    272              USB_OTG_EP0StartXfer(pdev , ep);
   \   0000002C   2100               MOVS     R1,R4
   \   0000002E   ........           BL       USB_OTG_EP0StartXfer
   \   00000032   02E0               B.N      ??DCD_EP_Tx_1
    273            }
    274            else
    275            {
    276              USB_OTG_EPStartXfer(pdev, ep );
   \                     ??DCD_EP_Tx_0:
   \   00000034   2100               MOVS     R1,R4
   \   00000036   ........           BL       USB_OTG_EPStartXfer
    277            }
    278            return 0;
   \                     ??DCD_EP_Tx_1:
   \   0000003A   0020               MOVS     R0,#+0
   \   0000003C   32BD               POP      {R1,R4,R5,PC}    ;; return
    279          }
    280          
    281          
    282          /**
    283          * @brief  Stall an endpoint.
    284          * @param pdev: device instance
    285          * @param epnum: endpoint address
    286          * @retval : status
    287          */

   \                                 In section .text, align 2, keep-with-next
    288          uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
    289          {
   \                     DCD_EP_Stall:
   \   00000000   80B5               PUSH     {R7,LR}
    290            USB_OTG_EP *ep;
    291            if ((0x80 & epnum) == 0x80)
   \   00000002   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0A06               LSLS     R2,R1,#+24
   \   00000006   08D5               BPL.N    ??DCD_EP_Stall_0
    292            {
    293              ep = &pdev->dev.in_ep[epnum & 0x7F];
   \   00000008   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   11F07F02           ANDS     R2,R1,#0x7F
   \   0000000E   2823               MOVS     R3,#+40
   \   00000010   03FB0202           MLA      R2,R3,R2,R0
   \   00000014   02F21812           ADDW     R2,R2,#+280
   \   00000018   05E0               B.N      ??DCD_EP_Stall_1
    294            }
    295            else
    296            {
    297              ep = &pdev->dev.out_ep[epnum];
   \                     ??DCD_EP_Stall_0:
   \   0000001A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   2822               MOVS     R2,#+40
   \   0000001E   02FB0102           MLA      R2,R2,R1,R0
   \   00000022   02F27032           ADDW     R2,R2,#+880
    298            }
    299          
    300            ep->is_stall = 1;
   \                     ??DCD_EP_Stall_1:
   \   00000026   0123               MOVS     R3,#+1
   \   00000028   9370               STRB     R3,[R2, #+2]
    301            ep->num   = epnum & 0x7F;
   \   0000002A   11F07F03           ANDS     R3,R1,#0x7F
   \   0000002E   1370               STRB     R3,[R2, #+0]
    302            ep->is_in = ((epnum & 0x80) == 0x80);
   \   00000030   C1F3C011           UBFX     R1,R1,#+7,#+1
   \   00000034   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   11F00101           ANDS     R1,R1,#0x1
   \   0000003A   5170               STRB     R1,[R2, #+1]
    303            
    304            USB_OTG_EPSetStall(pdev , ep);
   \   0000003C   1100               MOVS     R1,R2
   \   0000003E   ........           BL       USB_OTG_EPSetStall
    305            return (0);
   \   00000042   0020               MOVS     R0,#+0
   \   00000044   02BD               POP      {R1,PC}          ;; return
    306          }
    307          
    308          
    309          /**
    310          * @brief  Clear stall condition on endpoints.
    311          * @param pdev: device instance
    312          * @param epnum: endpoint address
    313          * @retval : status
    314          */

   \                                 In section .text, align 2, keep-with-next
    315          uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
    316          {
   \                     DCD_EP_ClrStall:
   \   00000000   80B5               PUSH     {R7,LR}
    317            USB_OTG_EP *ep;
    318            if ((0x80 & epnum) == 0x80)
   \   00000002   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0A06               LSLS     R2,R1,#+24
   \   00000006   08D5               BPL.N    ??DCD_EP_ClrStall_0
    319            {
    320              ep = &pdev->dev.in_ep[epnum & 0x7F];    
   \   00000008   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   11F07F02           ANDS     R2,R1,#0x7F
   \   0000000E   2823               MOVS     R3,#+40
   \   00000010   03FB0202           MLA      R2,R3,R2,R0
   \   00000014   02F21812           ADDW     R2,R2,#+280
   \   00000018   05E0               B.N      ??DCD_EP_ClrStall_1
    321            }
    322            else
    323            {
    324              ep = &pdev->dev.out_ep[epnum];
   \                     ??DCD_EP_ClrStall_0:
   \   0000001A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   2822               MOVS     R2,#+40
   \   0000001E   02FB0102           MLA      R2,R2,R1,R0
   \   00000022   02F27032           ADDW     R2,R2,#+880
    325            }
    326            
    327            ep->is_stall = 0;  
   \                     ??DCD_EP_ClrStall_1:
   \   00000026   0023               MOVS     R3,#+0
   \   00000028   9370               STRB     R3,[R2, #+2]
    328            ep->num   = epnum & 0x7F;
   \   0000002A   11F07F03           ANDS     R3,R1,#0x7F
   \   0000002E   1370               STRB     R3,[R2, #+0]
    329            ep->is_in = ((epnum & 0x80) == 0x80);
   \   00000030   C1F3C011           UBFX     R1,R1,#+7,#+1
   \   00000034   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   11F00101           ANDS     R1,R1,#0x1
   \   0000003A   5170               STRB     R1,[R2, #+1]
    330            
    331            USB_OTG_EPClearStall(pdev , ep);
   \   0000003C   1100               MOVS     R1,R2
   \   0000003E   ........           BL       USB_OTG_EPClearStall
    332            return (0);
   \   00000042   0020               MOVS     R0,#+0
   \   00000044   02BD               POP      {R1,PC}          ;; return
    333          }
    334          
    335          
    336          /**
    337          * @brief  This Function flushes the FIFOs.
    338          * @param pdev: device instance
    339          * @param epnum: endpoint address
    340          * @retval : status
    341          */

   \                                 In section .text, align 2, keep-with-next
    342          uint32_t  DCD_EP_Flush (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
    343          {
   \                     DCD_EP_Flush:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    344          
    345            if ((epnum & 0x80) == 0x80)
   \   00000006   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   2806               LSLS     R0,R5,#+24
   \   0000000A   06D5               BPL.N    ??DCD_EP_Flush_0
    346            {
    347              USB_OTG_FlushTxFifo(pdev, epnum & 0x7F);
   \   0000000C   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   15F07F01           ANDS     R1,R5,#0x7F
   \   00000012   2000               MOVS     R0,R4
   \   00000014   ........           BL       USB_OTG_FlushTxFifo
   \   00000018   02E0               B.N      ??DCD_EP_Flush_1
    348            }
    349            else
    350            {
    351              USB_OTG_FlushRxFifo(pdev);
   \                     ??DCD_EP_Flush_0:
   \   0000001A   2000               MOVS     R0,R4
   \   0000001C   ........           BL       USB_OTG_FlushRxFifo
    352            }
    353            
    354            DCD_EP_ClrStall(pdev, epnum);
   \                     ??DCD_EP_Flush_1:
   \   00000020   2900               MOVS     R1,R5
   \   00000022   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   2000               MOVS     R0,R4
   \   00000026   ........           BL       DCD_EP_ClrStall
    355            return (0);
   \   0000002A   0020               MOVS     R0,#+0
   \   0000002C   32BD               POP      {R1,R4,R5,PC}    ;; return
    356          }
    357          
    358          
    359          /**
    360          * @brief  This Function set USB device address
    361          * @param pdev: device instance
    362          * @param address: new device address
    363          * @retval : status
    364          */

   \                                 In section .text, align 2, keep-with-next
    365          void  DCD_EP_SetAddress (USB_OTG_CORE_HANDLE *pdev, uint8_t address)
    366          {
    367            USB_OTG_DCFG_TypeDef  dcfg;
    368            dcfg.d32 = 0;
   \                     DCD_EP_SetAddress:
   \   00000000   0022               MOVS     R2,#+0
    369            dcfg.b.devaddr = address;
   \   00000002   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   61F30A12           BFI      R2,R1,#+4,#+7
    370            USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
   \   00000008   0169               LDR      R1,[R0, #+16]
   \   0000000A   0968               LDR      R1,[R1, #+0]
   \   0000000C   1143               ORRS     R1,R2,R1
   \   0000000E   0069               LDR      R0,[R0, #+16]
   \   00000010   0160               STR      R1,[R0, #+0]
    371          }
   \   00000012   7047               BX       LR               ;; return
    372          
    373          /**
    374          * @brief  Connect device (enable internal pull-up)
    375          * @param pdev: device instance
    376          * @retval : None
    377          */

   \                                 In section .text, align 2, keep-with-next
    378          void  DCD_DevConnect (USB_OTG_CORE_HANDLE *pdev)
    379          {
   \                     DCD_DevConnect:
   \   00000000   80B5               PUSH     {R7,LR}
    380          #ifndef USE_OTG_MODE
    381            USB_OTG_DCTL_TypeDef  dctl;
    382            dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
   \   00000002   0169               LDR      R1,[R0, #+16]
   \   00000004   4968               LDR      R1,[R1, #+4]
    383            /* Connect device */
    384            dctl.b.sftdiscon  = 0;
   \   00000006   31F00201           BICS     R1,R1,#0x2
    385            USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
   \   0000000A   0069               LDR      R0,[R0, #+16]
   \   0000000C   4160               STR      R1,[R0, #+4]
    386            USB_OTG_BSP_mDelay(3);
   \   0000000E   0320               MOVS     R0,#+3
   \   00000010   ........           BL       USB_OTG_BSP_mDelay
    387          #endif
    388          }
   \   00000014   01BD               POP      {R0,PC}          ;; return
    389          
    390          
    391          /**
    392          * @brief  Disconnect device (disable internal pull-up)
    393          * @param pdev: device instance
    394          * @retval : None
    395          */

   \                                 In section .text, align 2, keep-with-next
    396          void  DCD_DevDisconnect (USB_OTG_CORE_HANDLE *pdev)
    397          {
   \                     DCD_DevDisconnect:
   \   00000000   80B5               PUSH     {R7,LR}
    398          #ifndef USE_OTG_MODE
    399            USB_OTG_DCTL_TypeDef  dctl;
    400            dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
   \   00000002   0169               LDR      R1,[R0, #+16]
   \   00000004   4968               LDR      R1,[R1, #+4]
    401            /* Disconnect device for 3ms */
    402            dctl.b.sftdiscon  = 1;
   \   00000006   51F00201           ORRS     R1,R1,#0x2
    403            USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
   \   0000000A   0069               LDR      R0,[R0, #+16]
   \   0000000C   4160               STR      R1,[R0, #+4]
    404            USB_OTG_BSP_mDelay(3);
   \   0000000E   0320               MOVS     R0,#+3
   \   00000010   ........           BL       USB_OTG_BSP_mDelay
    405          #endif
    406          }
   \   00000014   01BD               POP      {R0,PC}          ;; return
    407          
    408          /**
    409          * @}
    410          */ 
    411          
    412          /**
    413          * @}
    414          */ 
    415          
    416          /**
    417          * @}
    418          */
    419          
    420          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function          .cstack
     --------          -------
     DCD_DevConnect         8
     DCD_DevDisconnect      8
     DCD_EP_Close           8
     DCD_EP_ClrStall        8
     DCD_EP_Flush          16
     DCD_EP_Open           16
     DCD_EP_PrepareRx      16
     DCD_EP_SetAddress      0
     DCD_EP_Stall           8
     DCD_EP_Tx             16
     DCD_Init               8


   Section sizes:

     Function/Label    Bytes
     --------------    -----
     DCD_Init           150
     DCD_EP_Open         94
     DCD_EP_Close        68
     DCD_EP_PrepareRx    70
     DCD_EP_Tx           62
     DCD_EP_Stall        70
     DCD_EP_ClrStall     70
     DCD_EP_Flush        46
     DCD_EP_SetAddress   20
     DCD_DevConnect      22
     DCD_DevDisconnect   22

 
 694 bytes in section .text
 
 694 bytes of CODE memory

Errors: none
Warnings: none
