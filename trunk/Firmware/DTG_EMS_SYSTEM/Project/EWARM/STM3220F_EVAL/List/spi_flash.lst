###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     19/Jan/2012  11:08:49 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\spi_flas #
#                    h.c                                                      #
#    Command line =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\spi_flas #
#                    h.c -D USE_STDPERIPH_DRIVER -D STM32F2XX -D              #
#                    USE_STM3220F_EVAL -D USE_USB_OTG_FS -D                   #
#                    RTC_CLOCK_SOURCE_LSE -lC F:\Work\S&G2000\Firmware\DTG_EM #
#                    S_SYSTEM\Project\EWARM\STM3220F_EVAL\List\ -lA           #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\ -o F:\Work\S&G2000\Firmware\DTG_EMS_SY #
#                    STEM\Project\EWARM\STM3220F_EVAL\Obj\ --no_cse           #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Full.h" -I                     #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWA #
#                    RM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I             #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I         #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\ -I                             #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\Common\ -I                      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_OTG_Driver\inc\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Core\inc\ -I      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\msc\inc\    #
#                    -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM #
#                    \..\Usb\ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Proj #
#                    ect\EWARM\..\Usb\Inc\ -I F:\Work\S&G2000\Firmware\DTG_EM #
#                    S_SYSTEM\Project\EWARM\..\Usb\src\ -I                    #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Core\inc\ -I        #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -Ol --use_c++_inline                                     #
#    List file    =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\spi_flash.lst                           #
#    Object file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\Obj\spi_flash.o                              #
#                                                                             #
#                                                                             #
###############################################################################

F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\spi_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    SPI/SPI_FLASH/spi_flash.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    18-April-2011
      7            * @brief   This file provides a set of functions needed to manage the SPI M25Pxxx
      8            *          FLASH memory. 
      9            *            
     10            *          ===================================================================      
     11            *          Notes: 
     12            *           - There is no SPI FLASH memory available in STM322xG-EVAL board,
     13            *             to use this driver you have to build your own hardware.     
     14            *          ===================================================================
     15            *   
     16            *          It implements a high level communication layer for read and write 
     17            *          from/to this memory. The needed STM32 hardware resources (SPI and 
     18            *          GPIO) are defined in spi_flash.h file, and the initialization is 
     19            *          performed in sFLASH_LowLevel_Init() function.
     20            *            
     21            *          You can easily tailor this driver to any development board, by just
     22            *          adapting the defines for hardware resources and sFLASH_LowLevel_Init()
     23            *          function.
     24            *            
     25            *          +-----------------------------------------------------------+
     26            *          |                     Pin assignment                        |
     27            *          +-----------------------------+---------------+-------------+
     28            *          |  STM32 SPI Pins             |     sFLASH    |    Pin      |
     29            *          +-----------------------------+---------------+-------------+
     30            *          | sFLASH_CS_PIN               | ChipSelect(/S)|    1        |
     31            *          | sFLASH_SPI_MISO_PIN / MISO  |   DataOut(Q)  |    2        |
     32            *          |                             |   VCC         |    3 (3.3 V)|
     33            *          |                             |   GND         |    4 (0 V)  |
     34            *          | sFLASH_SPI_MOSI_PIN / MOSI  |   DataIn(D)   |    5        |
     35            *          | sFLASH_SPI_SCK_PIN / SCK    |   Clock(C)    |    6        |
     36            *          |                             |    VCC        |    7 (3.3 V)|
     37            *          |                             |    VCC        |    8 (3.3 V)|  
     38            *          +-----------------------------+---------------+-------------+  
     39            ******************************************************************************
     40            * @attention
     41            *
     42            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     43            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     44            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     45            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     46            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     47            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     48            *
     49            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     50            ******************************************************************************  
     51            */ 
     52          
     53          /* Includes ------------------------------------------------------------------*/
     54          #include "spi_flash.h"
     55          
     56          /** @addtogroup STM32F2xx_StdPeriph_Examples
     57            * @{
     58            */
     59          
     60          /** @addtogroup SPI_FLASH
     61            * @{
     62            */  
     63          
     64          /* Private typedef -----------------------------------------------------------*/
     65          /* Private define ------------------------------------------------------------*/
     66          /* Private macro -------------------------------------------------------------*/
     67          /* Private variables ---------------------------------------------------------*/
     68          /* Private function prototypes -----------------------------------------------*/
     69          void sFLASH_LowLevel_DeInit(void);
     70          void sFLASH_LowLevel_Init(void); 
     71          
     72          /* Private functions ---------------------------------------------------------*/
     73          
     74          /**
     75            * @brief  DeInitializes the peripherals used by the SPI FLASH driver.
     76            * @param  None
     77            * @retval None
     78            */

   \                                 In section .text, align 2, keep-with-next
     79          void sFLASH_DeInit(void)
     80          {
   \                     sFLASH_DeInit:
   \   00000000   80B5               PUSH     {R7,LR}
     81            sFLASH_LowLevel_DeInit();
   \   00000002   ........           BL       sFLASH_LowLevel_DeInit
     82          }
   \   00000006   01BD               POP      {R0,PC}          ;; return
     83          
     84          /**
     85            * @brief  Initializes the peripherals used by the SPI FLASH driver.
     86            * @param  None
     87            * @retval None
     88            */

   \                                 In section .text, align 2, keep-with-next
     89          void sFLASH_Init(void)
     90          {
   \                     sFLASH_Init:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   85B0               SUB      SP,SP,#+20
     91            SPI_InitTypeDef  SPI_InitStructure;
     92          
     93            sFLASH_LowLevel_Init();
   \   00000004   ........           BL       sFLASH_LowLevel_Init
     94              
     95            /*!< Deselect the FLASH: Chip Select high */
     96            sFLASH_CS_HIGH();
   \   00000008   4FF48061           MOV      R1,#+1024
   \   0000000C   ........           LDR.W    R0,??DataTable12  ;; 0x40021400
   \   00000010   ........           BL       GPIO_SetBits
     97          
     98            /*!< SPI configuration */
     99            SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
   \   00000014   0020               MOVS     R0,#+0
   \   00000016   ADF80000           STRH     R0,[SP, #+0]
    100            SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
   \   0000001A   4FF48270           MOV      R0,#+260
   \   0000001E   ADF80200           STRH     R0,[SP, #+2]
    101            SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
   \   00000022   0020               MOVS     R0,#+0
   \   00000024   ADF80400           STRH     R0,[SP, #+4]
    102            SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
   \   00000028   0220               MOVS     R0,#+2
   \   0000002A   ADF80600           STRH     R0,[SP, #+6]
    103            SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
   \   0000002E   0120               MOVS     R0,#+1
   \   00000030   ADF80800           STRH     R0,[SP, #+8]
    104            SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
   \   00000034   4FF40070           MOV      R0,#+512
   \   00000038   ADF80A00           STRH     R0,[SP, #+10]
    105            SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
   \   0000003C   0020               MOVS     R0,#+0
   \   0000003E   ADF80C00           STRH     R0,[SP, #+12]
    106          
    107            SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
   \   00000042   0020               MOVS     R0,#+0
   \   00000044   ADF80E00           STRH     R0,[SP, #+14]
    108            SPI_InitStructure.SPI_CRCPolynomial = 7;
   \   00000048   0720               MOVS     R0,#+7
   \   0000004A   ADF81000           STRH     R0,[SP, #+16]
    109            SPI_Init(sFLASH_SPI, &SPI_InitStructure);
   \   0000004E   00A9               ADD      R1,SP,#+0
   \   00000050   ........           LDR.W    R0,??DataTable12_1  ;; 0x40003800
   \   00000054   ........           BL       SPI_Init
    110          
    111            /*!< Enable the sFLASH_SPI  */
    112            SPI_Cmd(sFLASH_SPI, ENABLE);
   \   00000058   0121               MOVS     R1,#+1
   \   0000005A   ........           LDR.W    R0,??DataTable12_1  ;; 0x40003800
   \   0000005E   ........           BL       SPI_Cmd
    113          }
   \   00000062   05B0               ADD      SP,SP,#+20
   \   00000064   00BD               POP      {PC}             ;; return
    114          
    115          /**
    116            * @brief  Erases the specified FLASH sector.
    117            * @param  SectorAddr: address of the sector to erase.
    118            * @retval None
    119            */

   \                                 In section .text, align 2, keep-with-next
    120          void sFLASH_EraseSector(uint32_t SectorAddr)
    121          {
   \                     sFLASH_EraseSector:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    122            /*!< Send write enable instruction */
    123            sFLASH_WriteEnable();
   \   00000004   ........           BL       sFLASH_WriteEnable
    124          
    125            /*!< Sector Erase */
    126            /*!< Select the FLASH: Chip Select low */
    127            sFLASH_CS_LOW();
   \   00000008   4FF48061           MOV      R1,#+1024
   \   0000000C   ........           LDR.W    R0,??DataTable12  ;; 0x40021400
   \   00000010   ........           BL       GPIO_ResetBits
    128            /*!< Send Sector Erase instruction */
    129            sFLASH_SendByte(sFLASH_CMD_SE);
   \   00000014   D820               MOVS     R0,#+216
   \   00000016   ........           BL       sFLASH_SendByte
    130            /*!< Send SectorAddr high nibble address byte */
    131            sFLASH_SendByte((SectorAddr & 0xFF0000) >> 16);
   \   0000001A   200C               LSRS     R0,R4,#+16
   \   0000001C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   ........           BL       sFLASH_SendByte
    132            /*!< Send SectorAddr medium nibble address byte */
    133            sFLASH_SendByte((SectorAddr & 0xFF00) >> 8);
   \   00000022   200A               LSRS     R0,R4,#+8
   \   00000024   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   ........           BL       sFLASH_SendByte
    134            /*!< Send SectorAddr low nibble address byte */
    135            sFLASH_SendByte(SectorAddr & 0xFF);
   \   0000002A   2000               MOVS     R0,R4
   \   0000002C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   ........           BL       sFLASH_SendByte
    136            /*!< Deselect the FLASH: Chip Select high */
    137            sFLASH_CS_HIGH();
   \   00000032   4FF48061           MOV      R1,#+1024
   \   00000036   ........           LDR.W    R0,??DataTable12  ;; 0x40021400
   \   0000003A   ........           BL       GPIO_SetBits
    138          
    139            /*!< Wait the end of Flash writing */
    140            sFLASH_WaitForWriteEnd();
   \   0000003E   ........           BL       sFLASH_WaitForWriteEnd
    141          }
   \   00000042   10BD               POP      {R4,PC}          ;; return
    142          
    143          /**
    144            * @brief  Erases the entire FLASH.
    145            * @param  None
    146            * @retval None
    147            */

   \                                 In section .text, align 2, keep-with-next
    148          void sFLASH_EraseBulk(void)
    149          {
   \                     sFLASH_EraseBulk:
   \   00000000   80B5               PUSH     {R7,LR}
    150            /*!< Send write enable instruction */
    151            sFLASH_WriteEnable();
   \   00000002   ........           BL       sFLASH_WriteEnable
    152          
    153            /*!< Bulk Erase */
    154            /*!< Select the FLASH: Chip Select low */
    155            sFLASH_CS_LOW();
   \   00000006   4FF48061           MOV      R1,#+1024
   \   0000000A   ........           LDR.W    R0,??DataTable12  ;; 0x40021400
   \   0000000E   ........           BL       GPIO_ResetBits
    156            /*!< Send Bulk Erase instruction  */
    157            sFLASH_SendByte(sFLASH_CMD_BE);
   \   00000012   C720               MOVS     R0,#+199
   \   00000014   ........           BL       sFLASH_SendByte
    158            /*!< Deselect the FLASH: Chip Select high */
    159            sFLASH_CS_HIGH();
   \   00000018   4FF48061           MOV      R1,#+1024
   \   0000001C   ........           LDR.W    R0,??DataTable12  ;; 0x40021400
   \   00000020   ........           BL       GPIO_SetBits
    160          
    161            /*!< Wait the end of Flash writing */
    162            sFLASH_WaitForWriteEnd();
   \   00000024   ........           BL       sFLASH_WaitForWriteEnd
    163          }
   \   00000028   01BD               POP      {R0,PC}          ;; return
    164          
    165          /**
    166            * @brief  Writes more than one byte to the FLASH with a single WRITE cycle 
    167            *         (Page WRITE sequence).
    168            * @note   The number of byte can't exceed the FLASH page size.
    169            * @param  pBuffer: pointer to the buffer  containing the data to be written
    170            *         to the FLASH.
    171            * @param  WriteAddr: FLASH's internal address to write to.
    172            * @param  NumByteToWrite: number of bytes to write to the FLASH, must be equal
    173            *         or less than "sFLASH_PAGESIZE" value.
    174            * @retval None
    175            */

   \                                 In section .text, align 2, keep-with-next
    176          void sFLASH_WritePage(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite)
    177          {
   \                     sFLASH_WritePage:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    178            /*!< Enable the write access to the FLASH */
    179            sFLASH_WriteEnable();
   \   00000008   ........           BL       sFLASH_WriteEnable
    180          
    181            /*!< Select the FLASH: Chip Select low */
    182            sFLASH_CS_LOW();
   \   0000000C   4FF48061           MOV      R1,#+1024
   \   00000010   ........           LDR.W    R0,??DataTable12  ;; 0x40021400
   \   00000014   ........           BL       GPIO_ResetBits
    183            /*!< Send "Write to Memory " instruction */
    184            sFLASH_SendByte(sFLASH_CMD_WRITE);
   \   00000018   0220               MOVS     R0,#+2
   \   0000001A   ........           BL       sFLASH_SendByte
    185            /*!< Send WriteAddr high nibble address byte to write to */
    186            sFLASH_SendByte((WriteAddr & 0xFF0000) >> 16);
   \   0000001E   280C               LSRS     R0,R5,#+16
   \   00000020   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   ........           BL       sFLASH_SendByte
    187            /*!< Send WriteAddr medium nibble address byte to write to */
    188            sFLASH_SendByte((WriteAddr & 0xFF00) >> 8);
   \   00000026   280A               LSRS     R0,R5,#+8
   \   00000028   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   ........           BL       sFLASH_SendByte
    189            /*!< Send WriteAddr low nibble address byte to write to */
    190            sFLASH_SendByte(WriteAddr & 0xFF);
   \   0000002E   2800               MOVS     R0,R5
   \   00000030   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   ........           BL       sFLASH_SendByte
   \   00000036   03E0               B.N      ??sFLASH_WritePage_0
    191          
    192            /*!< while there is data to be written on the FLASH */
    193            while (NumByteToWrite--)
    194            {
    195              /*!< Send the current byte */
    196              sFLASH_SendByte(*pBuffer);
   \                     ??sFLASH_WritePage_1:
   \   00000038   2078               LDRB     R0,[R4, #+0]
   \   0000003A   ........           BL       sFLASH_SendByte
    197              /*!< Point on the next byte to be written */
    198              pBuffer++;
   \   0000003E   641C               ADDS     R4,R4,#+1
    199            }
   \                     ??sFLASH_WritePage_0:
   \   00000040   3000               MOVS     R0,R6
   \   00000042   461E               SUBS     R6,R0,#+1
   \   00000044   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000046   0028               CMP      R0,#+0
   \   00000048   F6D1               BNE.N    ??sFLASH_WritePage_1
    200          
    201            /*!< Deselect the FLASH: Chip Select high */
    202            sFLASH_CS_HIGH();
   \   0000004A   4FF48061           MOV      R1,#+1024
   \   0000004E   ........           LDR.W    R0,??DataTable12  ;; 0x40021400
   \   00000052   ........           BL       GPIO_SetBits
    203          
    204            /*!< Wait the end of Flash writing */
    205            sFLASH_WaitForWriteEnd();
   \   00000056   ........           BL       sFLASH_WaitForWriteEnd
    206          }
   \   0000005A   70BD               POP      {R4-R6,PC}       ;; return
    207          
    208          /**
    209            * @brief  Writes block of data to the FLASH. In this function, the number of
    210            *         WRITE cycles are reduced, using Page WRITE sequence.
    211            * @param  pBuffer: pointer to the buffer  containing the data to be written
    212            *         to the FLASH.
    213            * @param  WriteAddr: FLASH's internal address to write to.
    214            * @param  NumByteToWrite: number of bytes to write to the FLASH.
    215            * @retval None
    216            */

   \                                 In section .text, align 2, keep-with-next
    217          void sFLASH_WriteBuffer(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite)
    218          {
   \                     sFLASH_WriteBuffer:
   \   00000000   2DE9F843           PUSH     {R3-R9,LR}
   \   00000004   0600               MOVS     R6,R0
   \   00000006   0D00               MOVS     R5,R1
    219            uint8_t NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0, temp = 0;
   \   00000008   0027               MOVS     R7,#+0
   \   0000000A   0024               MOVS     R4,#+0
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   5FF00008           MOVS     R8,#+0
   \   00000012   5FF00009           MOVS     R9,#+0
    220          
    221            Addr = WriteAddr % sFLASH_SPI_PAGESIZE;
   \   00000016   4FF48071           MOV      R1,#+256
   \   0000001A   B5FBF1F3           UDIV     R3,R5,R1
   \   0000001E   03FB1153           MLS      R3,R3,R1,R5
   \   00000022   1800               MOVS     R0,R3
    222            count = sFLASH_SPI_PAGESIZE - Addr;
   \   00000024   4142               RSBS     R1,R0,#+0
   \   00000026   8846               MOV      R8,R1
    223            NumOfPage =  NumByteToWrite / sFLASH_SPI_PAGESIZE;
   \   00000028   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000002A   4FF48071           MOV      R1,#+256
   \   0000002E   92FBF1F1           SDIV     R1,R2,R1
   \   00000032   0F00               MOVS     R7,R1
    224            NumOfSingle = NumByteToWrite % sFLASH_SPI_PAGESIZE;
   \   00000034   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000036   4FF48071           MOV      R1,#+256
   \   0000003A   92FBF1F3           SDIV     R3,R2,R1
   \   0000003E   03FB1123           MLS      R3,R3,R1,R2
   \   00000042   1C00               MOVS     R4,R3
    225            
    226            
    227          
    228            if (Addr == 0) /*!< WriteAddr is sFLASH_PAGESIZE aligned  */
   \   00000044   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0028               CMP      R0,#+0
   \   00000048   1FD1               BNE.N    ??sFLASH_WriteBuffer_0
    229            {
    230              if (NumOfPage == 0) /*!< NumByteToWrite < sFLASH_PAGESIZE */
   \   0000004A   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004C   002F               CMP      R7,#+0
   \   0000004E   0FD1               BNE.N    ??sFLASH_WriteBuffer_1
    231              {
    232                sFLASH_WritePage(pBuffer, WriteAddr, NumByteToWrite);
   \   00000050   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000052   2900               MOVS     R1,R5
   \   00000054   3000               MOVS     R0,R6
   \   00000056   ........           BL       sFLASH_WritePage
   \   0000005A   79E0               B.N      ??sFLASH_WriteBuffer_2
    233              }
    234              else /*!< NumByteToWrite > sFLASH_PAGESIZE */
    235              {
    236                while (NumOfPage--)
    237                {
    238                  sFLASH_WritePage(pBuffer, WriteAddr, sFLASH_SPI_PAGESIZE);
   \                     ??sFLASH_WriteBuffer_3:
   \   0000005C   4FF48072           MOV      R2,#+256
   \   00000060   2900               MOVS     R1,R5
   \   00000062   3000               MOVS     R0,R6
   \   00000064   ........           BL       sFLASH_WritePage
    239                  WriteAddr +=  sFLASH_SPI_PAGESIZE;
   \   00000068   05F20015           ADDW     R5,R5,#+256
    240                  pBuffer += sFLASH_SPI_PAGESIZE;
   \   0000006C   06F20016           ADDW     R6,R6,#+256
    241                }
   \                     ??sFLASH_WriteBuffer_1:
   \   00000070   3800               MOVS     R0,R7
   \   00000072   471E               SUBS     R7,R0,#+1
   \   00000074   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0028               CMP      R0,#+0
   \   00000078   F0D1               BNE.N    ??sFLASH_WriteBuffer_3
    242          
    243                sFLASH_WritePage(pBuffer, WriteAddr, NumOfSingle);
   \   0000007A   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007C   2200               MOVS     R2,R4
   \   0000007E   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000080   2900               MOVS     R1,R5
   \   00000082   3000               MOVS     R0,R6
   \   00000084   ........           BL       sFLASH_WritePage
   \   00000088   62E0               B.N      ??sFLASH_WriteBuffer_2
    244              }
    245            }
    246            else /*!< WriteAddr is not sFLASH_PAGESIZE aligned  */
    247            {
    248              if (NumOfPage == 0) /*!< NumByteToWrite < sFLASH_PAGESIZE */
   \                     ??sFLASH_WriteBuffer_0:
   \   0000008A   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000008C   002F               CMP      R7,#+0
   \   0000008E   25D1               BNE.N    ??sFLASH_WriteBuffer_4
    249              {
    250                if (NumOfSingle > count) /*!< (NumByteToWrite + WriteAddr) > sFLASH_PAGESIZE */
   \   00000090   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000094   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000096   A045               CMP      R8,R4
   \   00000098   1AD2               BCS.N    ??sFLASH_WriteBuffer_5
    251                {
    252                  temp = NumOfSingle - count;
   \   0000009A   B4EB0809           SUBS     R9,R4,R8
    253          
    254                  sFLASH_WritePage(pBuffer, WriteAddr, count);
   \   0000009E   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000A2   4246               MOV      R2,R8
   \   000000A4   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000A6   2900               MOVS     R1,R5
   \   000000A8   3000               MOVS     R0,R6
   \   000000AA   ........           BL       sFLASH_WritePage
    255                  WriteAddr +=  count;
   \   000000AE   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000B2   18EB0505           ADDS     R5,R8,R5
    256                  pBuffer += count;
   \   000000B6   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000BA   18EB0606           ADDS     R6,R8,R6
    257          
    258                  sFLASH_WritePage(pBuffer, WriteAddr, temp);
   \   000000BE   5FFA89F9           UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000C2   4A46               MOV      R2,R9
   \   000000C4   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000C6   2900               MOVS     R1,R5
   \   000000C8   3000               MOVS     R0,R6
   \   000000CA   ........           BL       sFLASH_WritePage
   \   000000CE   3FE0               B.N      ??sFLASH_WriteBuffer_2
    259                }
    260                else
    261                {
    262                  sFLASH_WritePage(pBuffer, WriteAddr, NumByteToWrite);
   \                     ??sFLASH_WriteBuffer_5:
   \   000000D0   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000D2   2900               MOVS     R1,R5
   \   000000D4   3000               MOVS     R0,R6
   \   000000D6   ........           BL       sFLASH_WritePage
   \   000000DA   39E0               B.N      ??sFLASH_WriteBuffer_2
    263                }
    264              }
    265              else /*!< NumByteToWrite > sFLASH_PAGESIZE */
    266              {
    267                NumByteToWrite -= count;
   \                     ??sFLASH_WriteBuffer_4:
   \   000000DC   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000E0   B2EB0802           SUBS     R2,R2,R8
    268                NumOfPage =  NumByteToWrite / sFLASH_SPI_PAGESIZE;
   \   000000E4   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000E6   4FF48070           MOV      R0,#+256
   \   000000EA   92FBF0F7           SDIV     R7,R2,R0
    269                NumOfSingle = NumByteToWrite % sFLASH_SPI_PAGESIZE;
   \   000000EE   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000F0   4FF48070           MOV      R0,#+256
   \   000000F4   92FBF0F4           SDIV     R4,R2,R0
   \   000000F8   04FB1024           MLS      R4,R4,R0,R2
    270          
    271                sFLASH_WritePage(pBuffer, WriteAddr, count);
   \   000000FC   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000100   4246               MOV      R2,R8
   \   00000102   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000104   2900               MOVS     R1,R5
   \   00000106   3000               MOVS     R0,R6
   \   00000108   ........           BL       sFLASH_WritePage
    272                WriteAddr +=  count;
   \   0000010C   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000110   18EB0505           ADDS     R5,R8,R5
    273                pBuffer += count;
   \   00000114   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000118   18EB0606           ADDS     R6,R8,R6
   \   0000011C   09E0               B.N      ??sFLASH_WriteBuffer_6
    274          
    275                while (NumOfPage--)
    276                {
    277                  sFLASH_WritePage(pBuffer, WriteAddr, sFLASH_SPI_PAGESIZE);
   \                     ??sFLASH_WriteBuffer_7:
   \   0000011E   4FF48072           MOV      R2,#+256
   \   00000122   2900               MOVS     R1,R5
   \   00000124   3000               MOVS     R0,R6
   \   00000126   ........           BL       sFLASH_WritePage
    278                  WriteAddr +=  sFLASH_SPI_PAGESIZE;
   \   0000012A   05F20015           ADDW     R5,R5,#+256
    279                  pBuffer += sFLASH_SPI_PAGESIZE;
   \   0000012E   06F20016           ADDW     R6,R6,#+256
    280                }
   \                     ??sFLASH_WriteBuffer_6:
   \   00000132   3800               MOVS     R0,R7
   \   00000134   471E               SUBS     R7,R0,#+1
   \   00000136   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000138   0028               CMP      R0,#+0
   \   0000013A   F0D1               BNE.N    ??sFLASH_WriteBuffer_7
    281          
    282                if (NumOfSingle != 0)
   \   0000013C   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000013E   002C               CMP      R4,#+0
   \   00000140   06D0               BEQ.N    ??sFLASH_WriteBuffer_2
    283                {
    284                  sFLASH_WritePage(pBuffer, WriteAddr, NumOfSingle);
   \   00000142   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000144   2200               MOVS     R2,R4
   \   00000146   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000148   2900               MOVS     R1,R5
   \   0000014A   3000               MOVS     R0,R6
   \   0000014C   ........           BL       sFLASH_WritePage
    285                }
    286              }
    287            }
    288          }
   \                     ??sFLASH_WriteBuffer_2:
   \   00000150   BDE8F183           POP      {R0,R4-R9,PC}    ;; return
    289          
    290          /**
    291            * @brief  Reads a block of data from the FLASH.
    292            * @param  pBuffer: pointer to the buffer that receives the data read from the FLASH.
    293            * @param  ReadAddr: FLASH's internal address to read from.
    294            * @param  NumByteToRead: number of bytes to read from the FLASH.
    295            * @retval None
    296            */

   \                                 In section .text, align 2, keep-with-next
    297          void sFLASH_ReadBuffer(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t NumByteToRead)
    298          {
   \                     sFLASH_ReadBuffer:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    299            /*!< Select the FLASH: Chip Select low */
    300            sFLASH_CS_LOW();
   \   00000008   4FF48061           MOV      R1,#+1024
   \   0000000C   ....               LDR.N    R0,??DataTable12  ;; 0x40021400
   \   0000000E   ........           BL       GPIO_ResetBits
    301          
    302            /*!< Send "Read from Memory " instruction */
    303            sFLASH_SendByte(sFLASH_CMD_READ);
   \   00000012   0320               MOVS     R0,#+3
   \   00000014   ........           BL       sFLASH_SendByte
    304          
    305            /*!< Send ReadAddr high nibble address byte to read from */
    306            sFLASH_SendByte((ReadAddr & 0xFF0000) >> 16);
   \   00000018   280C               LSRS     R0,R5,#+16
   \   0000001A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   ........           BL       sFLASH_SendByte
    307            /*!< Send ReadAddr medium nibble address byte to read from */
    308            sFLASH_SendByte((ReadAddr& 0xFF00) >> 8);
   \   00000020   280A               LSRS     R0,R5,#+8
   \   00000022   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   ........           BL       sFLASH_SendByte
    309            /*!< Send ReadAddr low nibble address byte to read from */
    310            sFLASH_SendByte(ReadAddr & 0xFF);
   \   00000028   2800               MOVS     R0,R5
   \   0000002A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   ........           BL       sFLASH_SendByte
   \   00000030   04E0               B.N      ??sFLASH_ReadBuffer_0
    311          
    312            while (NumByteToRead--) /*!< while there is data to be read */
    313            {
    314              /*!< Read a byte from the FLASH */
    315              *pBuffer = sFLASH_SendByte(sFLASH_DUMMY_BYTE);
   \                     ??sFLASH_ReadBuffer_1:
   \   00000032   A520               MOVS     R0,#+165
   \   00000034   ........           BL       sFLASH_SendByte
   \   00000038   2070               STRB     R0,[R4, #+0]
    316              /*!< Point to the next location where the byte read will be saved */
    317              pBuffer++;
   \   0000003A   641C               ADDS     R4,R4,#+1
    318            }
   \                     ??sFLASH_ReadBuffer_0:
   \   0000003C   3000               MOVS     R0,R6
   \   0000003E   461E               SUBS     R6,R0,#+1
   \   00000040   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0028               CMP      R0,#+0
   \   00000044   F5D1               BNE.N    ??sFLASH_ReadBuffer_1
    319          
    320            /*!< Deselect the FLASH: Chip Select high */
    321            sFLASH_CS_HIGH();
   \   00000046   4FF48061           MOV      R1,#+1024
   \   0000004A   ....               LDR.N    R0,??DataTable12  ;; 0x40021400
   \   0000004C   ........           BL       GPIO_SetBits
    322          }
   \   00000050   70BD               POP      {R4-R6,PC}       ;; return
    323          
    324          /**
    325            * @brief  Reads FLASH identification.
    326            * @param  None
    327            * @retval FLASH identification
    328            */

   \                                 In section .text, align 2, keep-with-next
    329          uint32_t sFLASH_ReadID(void)
    330          {
   \                     sFLASH_ReadID:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
    331            uint32_t Temp = 0, Temp0 = 0, Temp1 = 0, Temp2 = 0;
   \   00000002   0024               MOVS     R4,#+0
   \   00000004   0025               MOVS     R5,#+0
   \   00000006   0026               MOVS     R6,#+0
   \   00000008   0027               MOVS     R7,#+0
    332          
    333            /*!< Select the FLASH: Chip Select low */
    334            sFLASH_CS_LOW();
   \   0000000A   4FF48061           MOV      R1,#+1024
   \   0000000E   ....               LDR.N    R0,??DataTable12  ;; 0x40021400
   \   00000010   ........           BL       GPIO_ResetBits
    335          
    336            /*!< Send "RDID " instruction */
    337            sFLASH_SendByte(0x9F);
   \   00000014   9F20               MOVS     R0,#+159
   \   00000016   ........           BL       sFLASH_SendByte
    338          
    339            /*!< Read a byte from the FLASH */
    340            Temp0 = sFLASH_SendByte(sFLASH_DUMMY_BYTE);
   \   0000001A   A520               MOVS     R0,#+165
   \   0000001C   ........           BL       sFLASH_SendByte
   \   00000020   0500               MOVS     R5,R0
    341          
    342            /*!< Read a byte from the FLASH */
    343            Temp1 = sFLASH_SendByte(sFLASH_DUMMY_BYTE);
   \   00000022   A520               MOVS     R0,#+165
   \   00000024   ........           BL       sFLASH_SendByte
   \   00000028   0600               MOVS     R6,R0
    344          
    345            /*!< Read a byte from the FLASH */
    346            Temp2 = sFLASH_SendByte(sFLASH_DUMMY_BYTE);
   \   0000002A   A520               MOVS     R0,#+165
   \   0000002C   ........           BL       sFLASH_SendByte
   \   00000030   0700               MOVS     R7,R0
    347          
    348            /*!< Deselect the FLASH: Chip Select high */
    349            sFLASH_CS_HIGH();
   \   00000032   4FF48061           MOV      R1,#+1024
   \   00000036   ....               LDR.N    R0,??DataTable12  ;; 0x40021400
   \   00000038   ........           BL       GPIO_SetBits
    350          
    351            Temp = (Temp0 << 16) | (Temp1 << 8) | Temp2;
   \   0000003C   3002               LSLS     R0,R6,#+8
   \   0000003E   50EA0540           ORRS     R0,R0,R5, LSL #+16
   \   00000042   3843               ORRS     R0,R7,R0
   \   00000044   0400               MOVS     R4,R0
    352          
    353            return Temp;
   \   00000046   2000               MOVS     R0,R4
   \   00000048   F2BD               POP      {R1,R4-R7,PC}    ;; return
    354          }
    355          
    356          /**
    357            * @brief  Initiates a read data byte (READ) sequence from the Flash.
    358            *   This is done by driving the /CS line low to select the device, then the READ
    359            *   instruction is transmitted followed by 3 bytes address. This function exit
    360            *   and keep the /CS line low, so the Flash still being selected. With this
    361            *   technique the whole content of the Flash is read with a single READ instruction.
    362            * @param  ReadAddr: FLASH's internal address to read from.
    363            * @retval None
    364            */

   \                                 In section .text, align 2, keep-with-next
    365          void sFLASH_StartReadSequence(uint32_t ReadAddr)
    366          {
   \                     sFLASH_StartReadSequence:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    367            /*!< Select the FLASH: Chip Select low */
    368            sFLASH_CS_LOW();
   \   00000004   4FF48061           MOV      R1,#+1024
   \   00000008   ....               LDR.N    R0,??DataTable12  ;; 0x40021400
   \   0000000A   ........           BL       GPIO_ResetBits
    369          
    370            /*!< Send "Read from Memory " instruction */
    371            sFLASH_SendByte(sFLASH_CMD_READ);
   \   0000000E   0320               MOVS     R0,#+3
   \   00000010   ........           BL       sFLASH_SendByte
    372          
    373            /*!< Send the 24-bit address of the address to read from -------------------*/
    374            /*!< Send ReadAddr high nibble address byte */
    375            sFLASH_SendByte((ReadAddr & 0xFF0000) >> 16);
   \   00000014   200C               LSRS     R0,R4,#+16
   \   00000016   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   ........           BL       sFLASH_SendByte
    376            /*!< Send ReadAddr medium nibble address byte */
    377            sFLASH_SendByte((ReadAddr& 0xFF00) >> 8);
   \   0000001C   200A               LSRS     R0,R4,#+8
   \   0000001E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   ........           BL       sFLASH_SendByte
    378            /*!< Send ReadAddr low nibble address byte */
    379            sFLASH_SendByte(ReadAddr & 0xFF);
   \   00000024   2000               MOVS     R0,R4
   \   00000026   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   ........           BL       sFLASH_SendByte
    380          }
   \   0000002C   10BD               POP      {R4,PC}          ;; return
    381          
    382          /**
    383            * @brief  Reads a byte from the SPI Flash.
    384            * @note   This function must be used only if the Start_Read_Sequence function
    385            *         has been previously called.
    386            * @param  None
    387            * @retval Byte Read from the SPI Flash.
    388            */

   \                                 In section .text, align 2, keep-with-next
    389          uint8_t sFLASH_ReadByte(void)
    390          {
   \                     sFLASH_ReadByte:
   \   00000000   80B5               PUSH     {R7,LR}
    391            return (sFLASH_SendByte(sFLASH_DUMMY_BYTE));
   \   00000002   A520               MOVS     R0,#+165
   \   00000004   ........           BL       sFLASH_SendByte
   \   00000008   02BD               POP      {R1,PC}          ;; return
    392          }
    393          
    394          /**
    395            * @brief  Sends a byte through the SPI interface and return the byte received
    396            *         from the SPI bus.
    397            * @param  byte: byte to send.
    398            * @retval The value of the received byte.
    399            */

   \                                 In section .text, align 2, keep-with-next
    400          uint8_t sFLASH_SendByte(u8 byte)
    401          {
   \                     sFLASH_SendByte:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    402            /*!< Loop while DR register in not emplty */
    403            while (SPI_I2S_GetFlagStatus(sFLASH_SPI, SPI_I2S_FLAG_TXE) == RESET);
   \                     ??sFLASH_SendByte_0:
   \   00000004   0221               MOVS     R1,#+2
   \   00000006   ....               LDR.N    R0,??DataTable12_1  ;; 0x40003800
   \   00000008   ........           BL       SPI_I2S_GetFlagStatus
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   F9D0               BEQ.N    ??sFLASH_SendByte_0
    404          
    405            /*!< Send byte through the SPI1 peripheral */
    406            SPI_I2S_SendData(sFLASH_SPI, byte);
   \   00000010   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   2100               MOVS     R1,R4
   \   00000014   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000016   ....               LDR.N    R0,??DataTable12_1  ;; 0x40003800
   \   00000018   ........           BL       SPI_I2S_SendData
    407          
    408            /*!< Wait to receive a byte */
    409            while (SPI_I2S_GetFlagStatus(sFLASH_SPI, SPI_I2S_FLAG_RXNE) == RESET);
   \                     ??sFLASH_SendByte_1:
   \   0000001C   0121               MOVS     R1,#+1
   \   0000001E   ....               LDR.N    R0,??DataTable12_1  ;; 0x40003800
   \   00000020   ........           BL       SPI_I2S_GetFlagStatus
   \   00000024   0028               CMP      R0,#+0
   \   00000026   F9D0               BEQ.N    ??sFLASH_SendByte_1
    410          
    411            /*!< Return the byte read from the SPI bus */
    412            return SPI_I2S_ReceiveData(sFLASH_SPI);
   \   00000028   ....               LDR.N    R0,??DataTable12_1  ;; 0x40003800
   \   0000002A   ........           BL       SPI_I2S_ReceiveData
   \   0000002E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   10BD               POP      {R4,PC}          ;; return
    413          }
    414          
    415          /**
    416            * @brief  Sends a Half Word through the SPI interface and return the Half Word
    417            *         received from the SPI bus.
    418            * @param  HalfWord: Half Word to send.
    419            * @retval The value of the received Half Word.
    420            */

   \                                 In section .text, align 2, keep-with-next
    421          uint16_t sFLASH_SendHalfWord(uint16_t HalfWord)
    422          {
   \                     sFLASH_SendHalfWord:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    423            /*!< Loop while DR register in not emplty */
    424            while (SPI_I2S_GetFlagStatus(sFLASH_SPI, SPI_I2S_FLAG_TXE) == RESET);
   \                     ??sFLASH_SendHalfWord_0:
   \   00000004   0221               MOVS     R1,#+2
   \   00000006   ....               LDR.N    R0,??DataTable12_1  ;; 0x40003800
   \   00000008   ........           BL       SPI_I2S_GetFlagStatus
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   F9D0               BEQ.N    ??sFLASH_SendHalfWord_0
    425          
    426            /*!< Send Half Word through the sFLASH peripheral */
    427            SPI_I2S_SendData(sFLASH_SPI, HalfWord);
   \   00000010   2100               MOVS     R1,R4
   \   00000012   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000014   ....               LDR.N    R0,??DataTable12_1  ;; 0x40003800
   \   00000016   ........           BL       SPI_I2S_SendData
    428          
    429            /*!< Wait to receive a Half Word */
    430            while (SPI_I2S_GetFlagStatus(sFLASH_SPI, SPI_I2S_FLAG_RXNE) == RESET);
   \                     ??sFLASH_SendHalfWord_1:
   \   0000001A   0121               MOVS     R1,#+1
   \   0000001C   ....               LDR.N    R0,??DataTable12_1  ;; 0x40003800
   \   0000001E   ........           BL       SPI_I2S_GetFlagStatus
   \   00000022   0028               CMP      R0,#+0
   \   00000024   F9D0               BEQ.N    ??sFLASH_SendHalfWord_1
    431          
    432            /*!< Return the Half Word read from the SPI bus */
    433            return SPI_I2S_ReceiveData(sFLASH_SPI);
   \   00000026   ....               LDR.N    R0,??DataTable12_1  ;; 0x40003800
   \   00000028   ........           BL       SPI_I2S_ReceiveData
   \   0000002C   10BD               POP      {R4,PC}          ;; return
    434          }
    435          
    436          /**
    437            * @brief  Enables the write access to the FLASH.
    438            * @param  None
    439            * @retval None
    440            */

   \                                 In section .text, align 2, keep-with-next
    441          void sFLASH_WriteEnable(void)
    442          {
   \                     sFLASH_WriteEnable:
   \   00000000   80B5               PUSH     {R7,LR}
    443                 sFLASH_CS_LOW();
   \   00000002   4FF48061           MOV      R1,#+1024
   \   00000006   ....               LDR.N    R0,??DataTable12  ;; 0x40021400
   \   00000008   ........           BL       GPIO_ResetBits
    444                 
    445                 sFLASH_SendByte(sFLASH_CMD_WRSR); 
   \   0000000C   0120               MOVS     R0,#+1
   \   0000000E   ........           BL       sFLASH_SendByte
    446                 
    447                 sFLASH_SendByte(0x0);     
   \   00000012   0020               MOVS     R0,#+0
   \   00000014   ........           BL       sFLASH_SendByte
    448                 
    449                 sFLASH_CS_HIGH();
   \   00000018   4FF48061           MOV      R1,#+1024
   \   0000001C   ....               LDR.N    R0,??DataTable12  ;; 0x40021400
   \   0000001E   ........           BL       GPIO_SetBits
    450               
    451            /*!< Select the FLASH: Chip Select low */
    452            sFLASH_CS_LOW();
   \   00000022   4FF48061           MOV      R1,#+1024
   \   00000026   ....               LDR.N    R0,??DataTable12  ;; 0x40021400
   \   00000028   ........           BL       GPIO_ResetBits
    453          
    454            /*!< Send "Write Enable" instruction */ 
    455            sFLASH_SendByte(sFLASH_CMD_WREN);
   \   0000002C   0620               MOVS     R0,#+6
   \   0000002E   ........           BL       sFLASH_SendByte
    456          
    457            /*!< Deselect the FLASH: Chip Select high */
    458            sFLASH_CS_HIGH();
   \   00000032   4FF48061           MOV      R1,#+1024
   \   00000036   ....               LDR.N    R0,??DataTable12  ;; 0x40021400
   \   00000038   ........           BL       GPIO_SetBits
    459          }
   \   0000003C   01BD               POP      {R0,PC}          ;; return
    460          
    461          /**
    462            * @brief  Polls the status of the Write In Progress (WIP) flag in the FLASH's
    463            *         status register and loop until write opertaion has completed.
    464            * @param  None
    465            * @retval None
    466            */

   \                                 In section .text, align 2, keep-with-next
    467          void sFLASH_WaitForWriteEnd(void)
    468          {
   \                     sFLASH_WaitForWriteEnd:
   \   00000000   10B5               PUSH     {R4,LR}
    469            uint8_t flashstatus = 0;
   \   00000002   0024               MOVS     R4,#+0
    470          
    471            /*!< Select the FLASH: Chip Select low */
    472            sFLASH_CS_LOW();
   \   00000004   4FF48061           MOV      R1,#+1024
   \   00000008   ....               LDR.N    R0,??DataTable12  ;; 0x40021400
   \   0000000A   ........           BL       GPIO_ResetBits
    473          
    474            /*!< Send "Read Status Register" instruction */
    475            sFLASH_SendByte(sFLASH_CMD_RDSR);
   \   0000000E   0520               MOVS     R0,#+5
   \   00000010   ........           BL       sFLASH_SendByte
    476          
    477            /*!< Loop as long as the memory is busy with a write cycle */
    478            do
    479            {
    480              /*!< Send a dummy byte to generate the clock needed by the FLASH
    481              and put the value of the status register in FLASH_Status variable */
    482              flashstatus = sFLASH_SendByte(sFLASH_DUMMY_BYTE);
   \                     ??sFLASH_WaitForWriteEnd_0:
   \   00000014   A520               MOVS     R0,#+165
   \   00000016   ........           BL       sFLASH_SendByte
   \   0000001A   0400               MOVS     R4,R0
    483          
    484            }
    485            while ((flashstatus & sFLASH_WIP_FLAG) == SET); /* Write in progress */
   \   0000001C   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   E007               LSLS     R0,R4,#+31
   \   00000020   F8D4               BMI.N    ??sFLASH_WaitForWriteEnd_0
    486          
    487            /*!< Deselect the FLASH: Chip Select high */
    488            sFLASH_CS_HIGH();
   \   00000022   4FF48061           MOV      R1,#+1024
   \   00000026   ....               LDR.N    R0,??DataTable12  ;; 0x40021400
   \   00000028   ........           BL       GPIO_SetBits
    489          }
   \   0000002C   10BD               POP      {R4,PC}          ;; return
    490          
    491          /**
    492            * @brief  Initializes the peripherals used by the SPI FLASH driver.
    493            * @param  None
    494            * @retval None
    495            */

   \                                 In section .text, align 2, keep-with-next
    496          void sFLASH_LowLevel_Init(void)
    497          {
   \                     sFLASH_LowLevel_Init:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   83B0               SUB      SP,SP,#+12
    498            GPIO_InitTypeDef GPIO_InitStructure;
    499          
    500            /*!< Enable the SPI clock */
    501            sFLASH_SPI_CLK_INIT(sFLASH_SPI_CLK, ENABLE);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   4FF48040           MOV      R0,#+16384
   \   0000000A   ........           BL       RCC_APB1PeriphClockCmd
    502          
    503            /*!< Enable GPIO clocks */
    504            RCC_AHB1PeriphClockCmd(sFLASH_SPI_SCK_GPIO_CLK | sFLASH_SPI_MISO_GPIO_CLK | 
    505                                   sFLASH_SPI_MOSI_GPIO_CLK | sFLASH_CS_GPIO_CLK, ENABLE);
   \   0000000E   0121               MOVS     R1,#+1
   \   00000010   2220               MOVS     R0,#+34
   \   00000012   ........           BL       RCC_AHB1PeriphClockCmd
    506            
    507            /*!< SPI pins configuration *************************************************/
    508          
    509            /*!< Connect SPI pins to AF5 */  
    510            GPIO_PinAFConfig(sFLASH_SPI_SCK_GPIO_PORT, sFLASH_SPI_SCK_SOURCE, sFLASH_SPI_SCK_AF);
   \   00000016   0522               MOVS     R2,#+5
   \   00000018   0D21               MOVS     R1,#+13
   \   0000001A   ....               LDR.N    R0,??DataTable12_2  ;; 0x40020400
   \   0000001C   ........           BL       GPIO_PinAFConfig
    511            GPIO_PinAFConfig(sFLASH_SPI_MISO_GPIO_PORT, sFLASH_SPI_MISO_SOURCE, sFLASH_SPI_MISO_AF);
   \   00000020   0522               MOVS     R2,#+5
   \   00000022   0F21               MOVS     R1,#+15
   \   00000024   ....               LDR.N    R0,??DataTable12_2  ;; 0x40020400
   \   00000026   ........           BL       GPIO_PinAFConfig
    512            GPIO_PinAFConfig(sFLASH_SPI_MOSI_GPIO_PORT, sFLASH_SPI_MOSI_SOURCE, sFLASH_SPI_MOSI_AF);
   \   0000002A   0522               MOVS     R2,#+5
   \   0000002C   0E21               MOVS     R1,#+14
   \   0000002E   ....               LDR.N    R0,??DataTable12_2  ;; 0x40020400
   \   00000030   ........           BL       GPIO_PinAFConfig
    513          
    514            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   00000034   0220               MOVS     R0,#+2
   \   00000036   8DF80400           STRB     R0,[SP, #+4]
    515            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000003A   0220               MOVS     R0,#+2
   \   0000003C   8DF80500           STRB     R0,[SP, #+5]
    516            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000040   0020               MOVS     R0,#+0
   \   00000042   8DF80600           STRB     R0,[SP, #+6]
    517          //  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
    518            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
   \   00000046   0020               MOVS     R0,#+0
   \   00000048   8DF80700           STRB     R0,[SP, #+7]
    519                  
    520            /*!< SPI SCK pin configuration */
    521            GPIO_InitStructure.GPIO_Pin = sFLASH_SPI_SCK_PIN;
   \   0000004C   4FF40050           MOV      R0,#+8192
   \   00000050   0090               STR      R0,[SP, #+0]
    522            GPIO_Init(sFLASH_SPI_SCK_GPIO_PORT, &GPIO_InitStructure);
   \   00000052   00A9               ADD      R1,SP,#+0
   \   00000054   ....               LDR.N    R0,??DataTable12_2  ;; 0x40020400
   \   00000056   ........           BL       GPIO_Init
    523          
    524            /*!< SPI MOSI pin configuration */
    525            GPIO_InitStructure.GPIO_Pin =  sFLASH_SPI_MOSI_PIN;
   \   0000005A   4FF48040           MOV      R0,#+16384
   \   0000005E   0090               STR      R0,[SP, #+0]
    526            GPIO_Init(sFLASH_SPI_MOSI_GPIO_PORT, &GPIO_InitStructure);
   \   00000060   00A9               ADD      R1,SP,#+0
   \   00000062   ....               LDR.N    R0,??DataTable12_2  ;; 0x40020400
   \   00000064   ........           BL       GPIO_Init
    527          
    528            /*!< SPI MISO pin configuration */
    529            GPIO_InitStructure.GPIO_Pin =  sFLASH_SPI_MISO_PIN;
   \   00000068   4FF40040           MOV      R0,#+32768
   \   0000006C   0090               STR      R0,[SP, #+0]
    530            GPIO_Init(sFLASH_SPI_MISO_GPIO_PORT, &GPIO_InitStructure);
   \   0000006E   00A9               ADD      R1,SP,#+0
   \   00000070   ....               LDR.N    R0,??DataTable12_2  ;; 0x40020400
   \   00000072   ........           BL       GPIO_Init
    531          
    532            /*!< Configure sFLASH Card CS pin in output pushpull mode ********************/
    533            GPIO_InitStructure.GPIO_Pin = sFLASH_CS_PIN;
   \   00000076   4FF48060           MOV      R0,#+1024
   \   0000007A   0090               STR      R0,[SP, #+0]
    534            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   \   0000007C   0120               MOVS     R0,#+1
   \   0000007E   8DF80400           STRB     R0,[SP, #+4]
    535            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000082   0020               MOVS     R0,#+0
   \   00000084   8DF80600           STRB     R0,[SP, #+6]
    536            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000088   0220               MOVS     R0,#+2
   \   0000008A   8DF80500           STRB     R0,[SP, #+5]
    537          //  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    538            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;  
   \   0000008E   0120               MOVS     R0,#+1
   \   00000090   8DF80700           STRB     R0,[SP, #+7]
    539            GPIO_Init(sFLASH_CS_GPIO_PORT, &GPIO_InitStructure);
   \   00000094   00A9               ADD      R1,SP,#+0
   \   00000096   ....               LDR.N    R0,??DataTable12  ;; 0x40021400
   \   00000098   ........           BL       GPIO_Init
    540          
    541          
    542          }
   \   0000009C   07BD               POP      {R0-R2,PC}       ;; return
    543          
    544          /**
    545            * @brief  DeInitializes the peripherals used by the SPI FLASH driver.
    546            * @param  None
    547            * @retval None
    548            */

   \                                 In section .text, align 2, keep-with-next
    549          void sFLASH_LowLevel_DeInit(void)
    550          {
   \                     sFLASH_LowLevel_DeInit:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   83B0               SUB      SP,SP,#+12
    551            GPIO_InitTypeDef GPIO_InitStructure;
    552          
    553            /*!< Disable the sFLASH_SPI  ************************************************/
    554            SPI_Cmd(sFLASH_SPI, DISABLE);
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   ....               LDR.N    R0,??DataTable12_1  ;; 0x40003800
   \   00000008   ........           BL       SPI_Cmd
    555            
    556            /*!< DeInitializes the sFLASH_SPI *******************************************/
    557            SPI_I2S_DeInit(sFLASH_SPI);
   \   0000000C   ....               LDR.N    R0,??DataTable12_1  ;; 0x40003800
   \   0000000E   ........           BL       SPI_I2S_DeInit
    558            
    559            /*!< sFLASH_SPI Periph clock disable ****************************************/
    560            sFLASH_SPI_CLK_INIT(sFLASH_SPI_CLK, DISABLE);
   \   00000012   0021               MOVS     R1,#+0
   \   00000014   4FF48040           MOV      R0,#+16384
   \   00000018   ........           BL       RCC_APB1PeriphClockCmd
    561                
    562            /*!< Configure all pins used by the SPI as input floating *******************/
    563            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   0000001C   0020               MOVS     R0,#+0
   \   0000001E   8DF80400           STRB     R0,[SP, #+4]
    564            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
   \   00000022   0020               MOVS     R0,#+0
   \   00000024   8DF80700           STRB     R0,[SP, #+7]
    565          
    566            GPIO_InitStructure.GPIO_Pin = sFLASH_SPI_SCK_PIN;
   \   00000028   4FF40050           MOV      R0,#+8192
   \   0000002C   0090               STR      R0,[SP, #+0]
    567            GPIO_Init(sFLASH_SPI_SCK_GPIO_PORT, &GPIO_InitStructure);
   \   0000002E   00A9               ADD      R1,SP,#+0
   \   00000030   ....               LDR.N    R0,??DataTable12_2  ;; 0x40020400
   \   00000032   ........           BL       GPIO_Init
    568          
    569            GPIO_InitStructure.GPIO_Pin = sFLASH_SPI_MISO_PIN;
   \   00000036   4FF40040           MOV      R0,#+32768
   \   0000003A   0090               STR      R0,[SP, #+0]
    570            GPIO_Init(sFLASH_SPI_MISO_GPIO_PORT, &GPIO_InitStructure);
   \   0000003C   00A9               ADD      R1,SP,#+0
   \   0000003E   ....               LDR.N    R0,??DataTable12_2  ;; 0x40020400
   \   00000040   ........           BL       GPIO_Init
    571          
    572            GPIO_InitStructure.GPIO_Pin = sFLASH_SPI_MOSI_PIN;
   \   00000044   4FF48040           MOV      R0,#+16384
   \   00000048   0090               STR      R0,[SP, #+0]
    573            GPIO_Init(sFLASH_SPI_MOSI_GPIO_PORT, &GPIO_InitStructure);
   \   0000004A   00A9               ADD      R1,SP,#+0
   \   0000004C   ....               LDR.N    R0,??DataTable12_2  ;; 0x40020400
   \   0000004E   ........           BL       GPIO_Init
    574          
    575            GPIO_InitStructure.GPIO_Pin = sFLASH_CS_PIN;
   \   00000052   4FF48060           MOV      R0,#+1024
   \   00000056   0090               STR      R0,[SP, #+0]
    576            GPIO_Init(sFLASH_CS_GPIO_PORT, &GPIO_InitStructure);
   \   00000058   00A9               ADD      R1,SP,#+0
   \   0000005A   ....               LDR.N    R0,??DataTable12  ;; 0x40021400
   \   0000005C   ........           BL       GPIO_Init
    577          }
   \   00000060   07BD               POP      {R0-R2,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   00140240           DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   00380040           DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   00040240           DC32     0x40020400
    578          
    579          /**
    580            * @}
    581            */
    582          
    583          /**
    584            * @}
    585            */
    586          
    587          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                 .cstack
     --------                 -------
     sFLASH_DeInit                 8
     sFLASH_EraseBulk              8
     sFLASH_EraseSector            8
     sFLASH_Init                  24
     sFLASH_LowLevel_DeInit       16
     sFLASH_LowLevel_Init         16
     sFLASH_ReadBuffer            16
     sFLASH_ReadByte               8
     sFLASH_ReadID                24
     sFLASH_SendByte               8
     sFLASH_SendHalfWord           8
     sFLASH_StartReadSequence      8
     sFLASH_WaitForWriteEnd        8
     sFLASH_WriteBuffer           32
     sFLASH_WriteEnable            8
     sFLASH_WritePage             16


   Section sizes:

     Function/Label           Bytes
     --------------           -----
     sFLASH_DeInit               8
     sFLASH_Init               102
     sFLASH_EraseSector         68
     sFLASH_EraseBulk           42
     sFLASH_WritePage           92
     sFLASH_WriteBuffer        340
     sFLASH_ReadBuffer          82
     sFLASH_ReadID              74
     sFLASH_StartReadSequence   46
     sFLASH_ReadByte            10
     sFLASH_SendByte            50
     sFLASH_SendHalfWord        46
     sFLASH_WriteEnable         62
     sFLASH_WaitForWriteEnd     46
     sFLASH_LowLevel_Init      158
     sFLASH_LowLevel_DeInit     98
     ??DataTable12               4
     ??DataTable12_1             4
     ??DataTable12_2             4

 
 1 336 bytes in section .text
 
 1 336 bytes of CODE memory

Errors: none
Warnings: none
