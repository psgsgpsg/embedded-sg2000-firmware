###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     19/Jan/2012  11:09:01 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32F #
#                    2xx_StdPeriph_Driver\src\stm32f2xx_tim.c                 #
#    Command line =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32F #
#                    2xx_StdPeriph_Driver\src\stm32f2xx_tim.c -D              #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D RTC_CLOCK_SOURCE_LSE -lC            #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\ -lA F:\Work\S&G2000\Firmware\DTG_EMS_S #
#                    YSTEM\Project\EWARM\STM3220F_EVAL\List\ -o               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\Obj\ --no_cse --no_unroll --no_inline        #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\ #
#                    EWARM\..\ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Pro #
#                    ject\EWARM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I     #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I         #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\ -I                             #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\Common\ -I                      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_OTG_Driver\inc\ -I               #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Core\inc\ -I      #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\msc\inc\    #
#                    -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM #
#                    \..\Usb\ -I F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Proj #
#                    ect\EWARM\..\Usb\Inc\ -I F:\Work\S&G2000\Firmware\DTG_EM #
#                    S_SYSTEM\Project\EWARM\..\Usb\src\ -I                    #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Core\inc\ -I        #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\ -I   #
#                    F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\.. #
#                    \..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\    #
#                    -Ol --use_c++_inline                                     #
#    List file    =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\List\stm32f2xx_tim.lst                       #
#    Object file  =  F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Project\EWARM\ST #
#                    M3220F_EVAL\Obj\stm32f2xx_tim.o                          #
#                                                                             #
#                                                                             #
###############################################################################

F:\Work\S&G2000\Firmware\DTG_EMS_SYSTEM\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_tim.c
      4            * @author  MCD Application Team
      5            * @version V0.0.4
      6            * @date    13-January-2011
      7            * @brief   This file provides all the TIM firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f2xx_tim.h"
     24          #include "stm32f2xx_rcc.h"
     25          
     26          /** @addtogroup STM32F2xx_StdPeriph_Driver
     27            * @{
     28            */
     29          
     30          /** @defgroup TIM 
     31            * @brief TIM driver modules
     32            * @{
     33            */
     34          
     35          /** @defgroup TIM_Private_TypesDefinitions
     36            * @{
     37            */
     38          
     39          /**
     40            * @}
     41            */
     42          
     43          /** @defgroup TIM_Private_Defines
     44            * @{
     45            */
     46          
     47          /* ---------------------- TIM registers bit mask ------------------------ */
     48          #define SMCR_ETR_Mask               ((uint16_t)0x00FF) 
     49          #define CCMR_Offset                 ((uint16_t)0x0018)
     50          #define CCER_CCE_Set                ((uint16_t)0x0001)  
     51          #define	CCER_CCNE_Set               ((uint16_t)0x0004) 
     52          #define CCMR_OC13M_Mask             ((uint16_t)0xFF8F)
     53          #define CCMR_OC24M_Mask             ((uint16_t)0x8FFF) 
     54          /**
     55            * @}
     56            */
     57          
     58          /** @defgroup TIM_Private_Macros
     59            * @{
     60            */
     61          
     62          /**
     63            * @}
     64            */
     65          
     66          /** @defgroup TIM_Private_Variables
     67            * @{
     68            */
     69          
     70          /**
     71            * @}
     72            */
     73          
     74          /** @defgroup TIM_Private_FunctionPrototypes
     75            * @{
     76            */
     77          
     78          static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
     79                                 uint16_t TIM_ICFilter);
     80          static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
     81                                 uint16_t TIM_ICFilter);
     82          static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
     83                                 uint16_t TIM_ICFilter);
     84          static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
     85                                 uint16_t TIM_ICFilter);
     86          /**
     87            * @}
     88            */
     89          
     90          /** @defgroup TIM_Private_Macros
     91            * @{
     92            */
     93          
     94          /**
     95            * @}
     96            */
     97          
     98          /** @defgroup TIM_Private_Variables
     99            * @{
    100            */
    101          
    102          /**
    103            * @}
    104            */
    105          
    106          /** @defgroup TIM_Private_FunctionPrototypes
    107            * @{
    108            */
    109          
    110          /**
    111            * @}
    112            */
    113          
    114          /** @defgroup TIM_Private_Functions
    115            * @{
    116            */
    117          
    118          /**
    119            * @brief  Deinitializes the TIMx peripheral registers to their default reset values.
    120            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    121            * @retval None
    122          
    123            */

   \                                 In section .text, align 2, keep-with-next
    124          void TIM_DeInit(TIM_TypeDef* TIMx)
    125          {
   \                     TIM_DeInit:
   \   00000000   80B5               PUSH     {R7,LR}
    126            /* Check the parameters */
    127            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    128           
    129            if (TIMx == TIM1)
   \   00000002   ........           LDR.W    R1,??DataTable5  ;; 0x40010000
   \   00000006   8842               CMP      R0,R1
   \   00000008   08D1               BNE.N    ??TIM_DeInit_0
    130            {
    131              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
   \   0000000A   0121               MOVS     R1,#+1
   \   0000000C   0120               MOVS     R0,#+1
   \   0000000E   ........           BL       RCC_APB2PeriphResetCmd
    132              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
   \   00000012   0021               MOVS     R1,#+0
   \   00000014   0120               MOVS     R0,#+1
   \   00000016   ........           BL       RCC_APB2PeriphResetCmd
   \   0000001A   A5E0               B.N      ??TIM_DeInit_1
    133            } 
    134            else if (TIMx == TIM2) 
   \                     ??TIM_DeInit_0:
   \   0000001C   B0F1804F           CMP      R0,#+1073741824
   \   00000020   08D1               BNE.N    ??TIM_DeInit_2
    135            {     
    136              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
   \   00000022   0121               MOVS     R1,#+1
   \   00000024   0120               MOVS     R0,#+1
   \   00000026   ........           BL       RCC_APB1PeriphResetCmd
    137              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
   \   0000002A   0021               MOVS     R1,#+0
   \   0000002C   0120               MOVS     R0,#+1
   \   0000002E   ........           BL       RCC_APB1PeriphResetCmd
   \   00000032   99E0               B.N      ??TIM_DeInit_1
    138            }  
    139            else if (TIMx == TIM3)
   \                     ??TIM_DeInit_2:
   \   00000034   ........           LDR.W    R1,??DataTable5_1  ;; 0x40000400
   \   00000038   8842               CMP      R0,R1
   \   0000003A   08D1               BNE.N    ??TIM_DeInit_3
    140            { 
    141              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
   \   0000003C   0121               MOVS     R1,#+1
   \   0000003E   0220               MOVS     R0,#+2
   \   00000040   ........           BL       RCC_APB1PeriphResetCmd
    142              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
   \   00000044   0021               MOVS     R1,#+0
   \   00000046   0220               MOVS     R0,#+2
   \   00000048   ........           BL       RCC_APB1PeriphResetCmd
   \   0000004C   8CE0               B.N      ??TIM_DeInit_1
    143            }  
    144            else if (TIMx == TIM4)
   \                     ??TIM_DeInit_3:
   \   0000004E   ........           LDR.W    R1,??DataTable5_2  ;; 0x40000800
   \   00000052   8842               CMP      R0,R1
   \   00000054   08D1               BNE.N    ??TIM_DeInit_4
    145            { 
    146              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
   \   00000056   0121               MOVS     R1,#+1
   \   00000058   0420               MOVS     R0,#+4
   \   0000005A   ........           BL       RCC_APB1PeriphResetCmd
    147              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
   \   0000005E   0021               MOVS     R1,#+0
   \   00000060   0420               MOVS     R0,#+4
   \   00000062   ........           BL       RCC_APB1PeriphResetCmd
   \   00000066   7FE0               B.N      ??TIM_DeInit_1
    148            }  
    149            else if (TIMx == TIM5)
   \                     ??TIM_DeInit_4:
   \   00000068   ........           LDR.W    R1,??DataTable5_3  ;; 0x40000c00
   \   0000006C   8842               CMP      R0,R1
   \   0000006E   08D1               BNE.N    ??TIM_DeInit_5
    150            {      
    151              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
   \   00000070   0121               MOVS     R1,#+1
   \   00000072   0820               MOVS     R0,#+8
   \   00000074   ........           BL       RCC_APB1PeriphResetCmd
    152              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
   \   00000078   0021               MOVS     R1,#+0
   \   0000007A   0820               MOVS     R0,#+8
   \   0000007C   ........           BL       RCC_APB1PeriphResetCmd
   \   00000080   72E0               B.N      ??TIM_DeInit_1
    153            }  
    154            else if (TIMx == TIM6)  
   \                     ??TIM_DeInit_5:
   \   00000082   ....               LDR.N    R1,??DataTable5_4  ;; 0x40001000
   \   00000084   8842               CMP      R0,R1
   \   00000086   08D1               BNE.N    ??TIM_DeInit_6
    155            {    
    156              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
   \   00000088   0121               MOVS     R1,#+1
   \   0000008A   1020               MOVS     R0,#+16
   \   0000008C   ........           BL       RCC_APB1PeriphResetCmd
    157              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
   \   00000090   0021               MOVS     R1,#+0
   \   00000092   1020               MOVS     R0,#+16
   \   00000094   ........           BL       RCC_APB1PeriphResetCmd
   \   00000098   66E0               B.N      ??TIM_DeInit_1
    158            }  
    159            else if (TIMx == TIM7)
   \                     ??TIM_DeInit_6:
   \   0000009A   ....               LDR.N    R1,??DataTable5_5  ;; 0x40001400
   \   0000009C   8842               CMP      R0,R1
   \   0000009E   08D1               BNE.N    ??TIM_DeInit_7
    160            {      
    161              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
   \   000000A0   0121               MOVS     R1,#+1
   \   000000A2   2020               MOVS     R0,#+32
   \   000000A4   ........           BL       RCC_APB1PeriphResetCmd
    162              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
   \   000000A8   0021               MOVS     R1,#+0
   \   000000AA   2020               MOVS     R0,#+32
   \   000000AC   ........           BL       RCC_APB1PeriphResetCmd
   \   000000B0   5AE0               B.N      ??TIM_DeInit_1
    163            }  
    164            else if (TIMx == TIM8)
   \                     ??TIM_DeInit_7:
   \   000000B2   ....               LDR.N    R1,??DataTable5_6  ;; 0x40010400
   \   000000B4   8842               CMP      R0,R1
   \   000000B6   08D1               BNE.N    ??TIM_DeInit_8
    165            {      
    166              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
   \   000000B8   0121               MOVS     R1,#+1
   \   000000BA   0220               MOVS     R0,#+2
   \   000000BC   ........           BL       RCC_APB2PeriphResetCmd
    167              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
   \   000000C0   0021               MOVS     R1,#+0
   \   000000C2   0220               MOVS     R0,#+2
   \   000000C4   ........           BL       RCC_APB2PeriphResetCmd
   \   000000C8   4EE0               B.N      ??TIM_DeInit_1
    168            }  
    169            else if (TIMx == TIM9)
   \                     ??TIM_DeInit_8:
   \   000000CA   ....               LDR.N    R1,??DataTable5_7  ;; 0x40014000
   \   000000CC   8842               CMP      R0,R1
   \   000000CE   0AD1               BNE.N    ??TIM_DeInit_9
    170            {      
    171              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
   \   000000D0   0121               MOVS     R1,#+1
   \   000000D2   5FF48030           MOVS     R0,#+65536
   \   000000D6   ........           BL       RCC_APB2PeriphResetCmd
    172              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
   \   000000DA   0021               MOVS     R1,#+0
   \   000000DC   5FF48030           MOVS     R0,#+65536
   \   000000E0   ........           BL       RCC_APB2PeriphResetCmd
   \   000000E4   40E0               B.N      ??TIM_DeInit_1
    173             }  
    174            else if (TIMx == TIM10)
   \                     ??TIM_DeInit_9:
   \   000000E6   ....               LDR.N    R1,??DataTable5_8  ;; 0x40014400
   \   000000E8   8842               CMP      R0,R1
   \   000000EA   0AD1               BNE.N    ??TIM_DeInit_10
    175            {      
    176              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
   \   000000EC   0121               MOVS     R1,#+1
   \   000000EE   5FF40030           MOVS     R0,#+131072
   \   000000F2   ........           BL       RCC_APB2PeriphResetCmd
    177              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
   \   000000F6   0021               MOVS     R1,#+0
   \   000000F8   5FF40030           MOVS     R0,#+131072
   \   000000FC   ........           BL       RCC_APB2PeriphResetCmd
   \   00000100   32E0               B.N      ??TIM_DeInit_1
    178            }  
    179            else if (TIMx == TIM11) 
   \                     ??TIM_DeInit_10:
   \   00000102   ....               LDR.N    R1,??DataTable5_9  ;; 0x40014800
   \   00000104   8842               CMP      R0,R1
   \   00000106   0AD1               BNE.N    ??TIM_DeInit_11
    180            {     
    181              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
   \   00000108   0121               MOVS     R1,#+1
   \   0000010A   5FF48020           MOVS     R0,#+262144
   \   0000010E   ........           BL       RCC_APB2PeriphResetCmd
    182              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
   \   00000112   0021               MOVS     R1,#+0
   \   00000114   5FF48020           MOVS     R0,#+262144
   \   00000118   ........           BL       RCC_APB2PeriphResetCmd
   \   0000011C   24E0               B.N      ??TIM_DeInit_1
    183            }  
    184            else if (TIMx == TIM12)
   \                     ??TIM_DeInit_11:
   \   0000011E   ....               LDR.N    R1,??DataTable5_10  ;; 0x40001800
   \   00000120   8842               CMP      R0,R1
   \   00000122   08D1               BNE.N    ??TIM_DeInit_12
    185            {      
    186              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
   \   00000124   0121               MOVS     R1,#+1
   \   00000126   4020               MOVS     R0,#+64
   \   00000128   ........           BL       RCC_APB1PeriphResetCmd
    187              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
   \   0000012C   0021               MOVS     R1,#+0
   \   0000012E   4020               MOVS     R0,#+64
   \   00000130   ........           BL       RCC_APB1PeriphResetCmd
   \   00000134   18E0               B.N      ??TIM_DeInit_1
    188            }  
    189            else if (TIMx == TIM13) 
   \                     ??TIM_DeInit_12:
   \   00000136   ....               LDR.N    R1,??DataTable5_11  ;; 0x40001c00
   \   00000138   8842               CMP      R0,R1
   \   0000013A   08D1               BNE.N    ??TIM_DeInit_13
    190            {       
    191              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
   \   0000013C   0121               MOVS     R1,#+1
   \   0000013E   8020               MOVS     R0,#+128
   \   00000140   ........           BL       RCC_APB1PeriphResetCmd
    192              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
   \   00000144   0021               MOVS     R1,#+0
   \   00000146   8020               MOVS     R0,#+128
   \   00000148   ........           BL       RCC_APB1PeriphResetCmd
   \   0000014C   0CE0               B.N      ??TIM_DeInit_1
    193            }  
    194            else
    195            { 
    196              if (TIMx == TIM14) 
   \                     ??TIM_DeInit_13:
   \   0000014E   ....               LDR.N    R1,??DataTable5_12  ;; 0x40002000
   \   00000150   8842               CMP      R0,R1
   \   00000152   09D1               BNE.N    ??TIM_DeInit_1
    197              {     
    198                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
   \   00000154   0121               MOVS     R1,#+1
   \   00000156   4FF48070           MOV      R0,#+256
   \   0000015A   ........           BL       RCC_APB1PeriphResetCmd
    199                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
   \   0000015E   0021               MOVS     R1,#+0
   \   00000160   4FF48070           MOV      R0,#+256
   \   00000164   ........           BL       RCC_APB1PeriphResetCmd
    200              }   
    201            }
    202          }
   \                     ??TIM_DeInit_1:
   \   00000168   01BD               POP      {R0,PC}          ;; return
    203          
    204          /**
    205            * @brief  Initializes the TIMx Time Base Unit peripheral according to 
    206            *   the specified parameters in the TIM_TimeBaseInitStruct.
    207            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14  
    208            *   to select the TIM peripheral.
    209            * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
    210            *   structure that contains the configuration information for the specified TIM peripheral.
    211            * @retval None
    212            */

   \                                 In section .text, align 2, keep-with-next
    213          void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    214          {
    215            uint16_t tmpcr1 = 0;
   \                     TIM_TimeBaseInit:
   \   00000000   0022               MOVS     R2,#+0
    216          
    217            /* Check the parameters */
    218            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    219            assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
    220            assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
    221          
    222            tmpcr1 = TIMx->CR1;  
   \   00000002   0388               LDRH     R3,[R0, #+0]
   \   00000004   1A00               MOVS     R2,R3
    223          
    224            if(((*(uint32_t*)&TIMx) == TIM1_BASE) || ((*(uint32_t*)&TIMx) == TIM8_BASE)||
    225               ((*(uint32_t*)&TIMx) == TIM2_BASE) || ((*(uint32_t*)&TIMx) == TIM3_BASE)||
    226               ((*(uint32_t*)&TIMx) == TIM4_BASE) || ((*(uint32_t*)&TIMx) == TIM5_BASE)) 
   \   00000006   ....               LDR.N    R3,??DataTable5  ;; 0x40010000
   \   00000008   9842               CMP      R0,R3
   \   0000000A   0ED0               BEQ.N    ??TIM_TimeBaseInit_0
   \   0000000C   ....               LDR.N    R3,??DataTable5_6  ;; 0x40010400
   \   0000000E   9842               CMP      R0,R3
   \   00000010   0BD0               BEQ.N    ??TIM_TimeBaseInit_0
   \   00000012   B0F1804F           CMP      R0,#+1073741824
   \   00000016   08D0               BEQ.N    ??TIM_TimeBaseInit_0
   \   00000018   ....               LDR.N    R3,??DataTable5_1  ;; 0x40000400
   \   0000001A   9842               CMP      R0,R3
   \   0000001C   05D0               BEQ.N    ??TIM_TimeBaseInit_0
   \   0000001E   ....               LDR.N    R3,??DataTable5_2  ;; 0x40000800
   \   00000020   9842               CMP      R0,R3
   \   00000022   02D0               BEQ.N    ??TIM_TimeBaseInit_0
   \   00000024   ....               LDR.N    R3,??DataTable5_3  ;; 0x40000c00
   \   00000026   9842               CMP      R0,R3
   \   00000028   04D1               BNE.N    ??TIM_TimeBaseInit_1
    227            {
    228              /* Select the Counter Mode */
    229              tmpcr1 &= (~(TIM_CR1_DIR | TIM_CR1_CMS));
   \                     ??TIM_TimeBaseInit_0:
   \   0000002A   4FF68F73           MOVW     R3,#+65423
   \   0000002E   1A40               ANDS     R2,R3,R2
    230              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
   \   00000030   4B88               LDRH     R3,[R1, #+2]
   \   00000032   1A43               ORRS     R2,R3,R2
    231            }
    232           
    233            if(((*(uint32_t*)&TIMx) != TIM6_BASE) && ((*(uint32_t*)&TIMx) != TIM7_BASE))
   \                     ??TIM_TimeBaseInit_1:
   \   00000034   ....               LDR.N    R3,??DataTable5_4  ;; 0x40001000
   \   00000036   9842               CMP      R0,R3
   \   00000038   07D0               BEQ.N    ??TIM_TimeBaseInit_2
   \   0000003A   ....               LDR.N    R3,??DataTable5_5  ;; 0x40001400
   \   0000003C   9842               CMP      R0,R3
   \   0000003E   04D0               BEQ.N    ??TIM_TimeBaseInit_2
    234            {
    235              /* Set the clock division */
    236              tmpcr1 &= (~TIM_CR1_CKD);
   \   00000040   4FF6FF43           MOVW     R3,#+64767
   \   00000044   1A40               ANDS     R2,R3,R2
    237              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
   \   00000046   0B89               LDRH     R3,[R1, #+8]
   \   00000048   1A43               ORRS     R2,R3,R2
    238            }
    239          
    240            TIMx->CR1 = tmpcr1;
   \                     ??TIM_TimeBaseInit_2:
   \   0000004A   0280               STRH     R2,[R0, #+0]
    241          
    242            /* Set the Autoreload value */
    243            TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
   \   0000004C   4A68               LDR      R2,[R1, #+4]
   \   0000004E   C262               STR      R2,[R0, #+44]
    244           
    245            /* Set the Prescaler value */
    246            TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
   \   00000050   0A88               LDRH     R2,[R1, #+0]
   \   00000052   0285               STRH     R2,[R0, #+40]
    247              
    248            if (((*(uint32_t*)&TIMx) == TIM1_BASE) || ((*(uint32_t*)&TIMx) == TIM8_BASE))  
   \   00000054   ....               LDR.N    R2,??DataTable5  ;; 0x40010000
   \   00000056   9042               CMP      R0,R2
   \   00000058   02D0               BEQ.N    ??TIM_TimeBaseInit_3
   \   0000005A   ....               LDR.N    R2,??DataTable5_6  ;; 0x40010400
   \   0000005C   9042               CMP      R0,R2
   \   0000005E   01D1               BNE.N    ??TIM_TimeBaseInit_4
    249            {
    250              /* Set the Repetition Counter value */
    251              TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
   \                     ??TIM_TimeBaseInit_3:
   \   00000060   897A               LDRB     R1,[R1, #+10]
   \   00000062   0186               STRH     R1,[R0, #+48]
    252            }
    253          
    254            /* Generate an update event to reload the Prescaler 
    255               and the repetition counter(only for TIM1 and TIM8) value immediatly */
    256            TIMx->EGR = TIM_PSCReloadMode_Immediate;          
   \                     ??TIM_TimeBaseInit_4:
   \   00000064   0121               MOVS     R1,#+1
   \   00000066   8182               STRH     R1,[R0, #+20]
    257          }
   \   00000068   7047               BX       LR               ;; return
    258          
    259          /**
    260            * @brief  Initializes the TIMx Channel1 according to the specified
    261            *   parameters in the TIM_OCInitStruct.
    262            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14 
    263            *   to select the TIM peripheral.
    264            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    265            *   that contains the configuration information for the specified TIM peripheral.
    266            * @retval None
    267            */

   \                                 In section .text, align 2, keep-with-next
    268          void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    269          {
   \                     TIM_OC1Init:
   \   00000000   70B4               PUSH     {R4-R6}
    270            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   0024               MOVS     R4,#+0
   \   00000006   0022               MOVS     R2,#+0
    271             
    272            /* Check the parameters */
    273            assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
    274            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    275            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    276            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    277            /* Disable the Channel 1: Reset the CC1E Bit */
    278            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000008   058C               LDRH     R5,[R0, #+32]
   \   0000000A   4FF6FE76           MOVW     R6,#+65534
   \   0000000E   3540               ANDS     R5,R6,R5
   \   00000010   0584               STRH     R5,[R0, #+32]
    279            
    280            /* Get the TIMx CCER register value */
    281            tmpccer = TIMx->CCER;
   \   00000012   058C               LDRH     R5,[R0, #+32]
   \   00000014   2C00               MOVS     R4,R5
    282            /* Get the TIMx CR2 register value */
    283            tmpcr2 =  TIMx->CR2;
   \   00000016   8588               LDRH     R5,[R0, #+4]
   \   00000018   2A00               MOVS     R2,R5
    284            
    285            /* Get the TIMx CCMR1 register value */
    286            tmpccmrx = TIMx->CCMR1;
   \   0000001A   058B               LDRH     R5,[R0, #+24]
   \   0000001C   2B00               MOVS     R3,R5
    287              
    288            /* Reset the Output Compare Mode Bits */
    289            tmpccmrx &= ~TIM_CCMR1_OC1M;
   \   0000001E   4FF68F75           MOVW     R5,#+65423
   \   00000022   2B40               ANDS     R3,R5,R3
    290            tmpccmrx &= ~TIM_CCMR1_CC1S;
   \   00000024   4FF6FC75           MOVW     R5,#+65532
   \   00000028   2B40               ANDS     R3,R5,R3
    291            /* Select the Output Compare Mode */
    292            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
   \   0000002A   0D88               LDRH     R5,[R1, #+0]
   \   0000002C   2B43               ORRS     R3,R5,R3
    293            
    294            /* Reset the Output Polarity level */
    295            tmpccer &= ~TIM_CCER_CC1P;
   \   0000002E   4FF6FD75           MOVW     R5,#+65533
   \   00000032   2C40               ANDS     R4,R5,R4
    296            /* Set the Output Compare Polarity */
    297            tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
   \   00000034   8D89               LDRH     R5,[R1, #+12]
   \   00000036   2C43               ORRS     R4,R5,R4
    298            
    299            /* Set the Output State */
    300            tmpccer |= TIM_OCInitStruct->TIM_OutputState;
   \   00000038   4D88               LDRH     R5,[R1, #+2]
   \   0000003A   2C43               ORRS     R4,R5,R4
    301              
    302            if((*(uint32_t*)&TIMx == TIM1_BASE) || (*(uint32_t*)&TIMx == TIM8_BASE))
   \   0000003C   ....               LDR.N    R5,??DataTable5  ;; 0x40010000
   \   0000003E   A842               CMP      R0,R5
   \   00000040   02D0               BEQ.N    ??TIM_OC1Init_0
   \   00000042   ....               LDR.N    R5,??DataTable5_6  ;; 0x40010400
   \   00000044   A842               CMP      R0,R5
   \   00000046   13D1               BNE.N    ??TIM_OC1Init_1
    303            {
    304              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    305              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    306              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    307              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    308              
    309              /* Reset the Output N Polarity level */
    310              tmpccer &= ~TIM_CCER_CC1NP;
   \                     ??TIM_OC1Init_0:
   \   00000048   4FF6F775           MOVW     R5,#+65527
   \   0000004C   2C40               ANDS     R4,R5,R4
    311              /* Set the Output N Polarity */
    312              tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
   \   0000004E   CD89               LDRH     R5,[R1, #+14]
   \   00000050   2C43               ORRS     R4,R5,R4
    313              /* Reset the Output N State */
    314              tmpccer &= ~TIM_CCER_CC1NE;
   \   00000052   4FF6FB75           MOVW     R5,#+65531
   \   00000056   2C40               ANDS     R4,R5,R4
    315              
    316              /* Set the Output N State */
    317              tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
   \   00000058   8D88               LDRH     R5,[R1, #+4]
   \   0000005A   2C43               ORRS     R4,R5,R4
    318              /* Reset the Ouput Compare and Output Compare N IDLE State */
    319              tmpcr2 &= ~TIM_CR2_OIS1;
   \   0000005C   4FF6FF65           MOVW     R5,#+65279
   \   00000060   2A40               ANDS     R2,R5,R2
    320              tmpcr2 &= ~TIM_CR2_OIS1N;
   \   00000062   4FF6FF55           MOVW     R5,#+65023
   \   00000066   2A40               ANDS     R2,R5,R2
    321              /* Set the Output Idle state */
    322              tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
   \   00000068   0D8A               LDRH     R5,[R1, #+16]
   \   0000006A   2A43               ORRS     R2,R5,R2
    323              /* Set the Output N Idle state */
    324              tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
   \   0000006C   4D8A               LDRH     R5,[R1, #+18]
   \   0000006E   2A43               ORRS     R2,R5,R2
    325            }
    326            /* Write to TIMx CR2 */
    327            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC1Init_1:
   \   00000070   8280               STRH     R2,[R0, #+4]
    328            
    329            /* Write to TIMx CCMR1 */
    330            TIMx->CCMR1 = tmpccmrx;
   \   00000072   0383               STRH     R3,[R0, #+24]
    331            
    332            /* Set the Capture Compare Register value */
    333            TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
   \   00000074   8968               LDR      R1,[R1, #+8]
   \   00000076   4163               STR      R1,[R0, #+52]
    334            
    335            /* Write to TIMx CCER */
    336            TIMx->CCER = tmpccer;
   \   00000078   0484               STRH     R4,[R0, #+32]
    337          }
   \   0000007A   70BC               POP      {R4-R6}
   \   0000007C   7047               BX       LR               ;; return
    338          
    339          /**
    340            * @brief  Initializes the TIMx Channel2 according to the specified
    341            *   parameters in the TIM_OCInitStruct.
    342            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
    343            *   peripheral.
    344            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    345            *   that contains the configuration information for the specified TIM peripheral.
    346            * @retval None
    347            * @retval : None
    348            */

   \                                 In section .text, align 2, keep-with-next
    349          void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    350          {
   \                     TIM_OC2Init:
   \   00000000   70B4               PUSH     {R4-R6}
    351            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   0024               MOVS     R4,#+0
   \   00000006   0022               MOVS     R2,#+0
    352             
    353            /* Check the parameters */
    354            assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
    355            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    356            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    357            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    358            /* Disable the Channel 2: Reset the CC2E Bit */
    359            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000008   058C               LDRH     R5,[R0, #+32]
   \   0000000A   4FF6EF76           MOVW     R6,#+65519
   \   0000000E   3540               ANDS     R5,R6,R5
   \   00000010   0584               STRH     R5,[R0, #+32]
    360            
    361            /* Get the TIMx CCER register value */  
    362            tmpccer = TIMx->CCER;
   \   00000012   058C               LDRH     R5,[R0, #+32]
   \   00000014   2C00               MOVS     R4,R5
    363            /* Get the TIMx CR2 register value */
    364            tmpcr2 =  TIMx->CR2;
   \   00000016   8588               LDRH     R5,[R0, #+4]
   \   00000018   2A00               MOVS     R2,R5
    365            
    366            /* Get the TIMx CCMR1 register value */
    367            tmpccmrx = TIMx->CCMR1;
   \   0000001A   058B               LDRH     R5,[R0, #+24]
   \   0000001C   2B00               MOVS     R3,R5
    368              
    369            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    370            tmpccmrx &= ~TIM_CCMR1_OC2M;
   \   0000001E   48F6FF75           MOVW     R5,#+36863
   \   00000022   2B40               ANDS     R3,R5,R3
    371            tmpccmrx &= ~TIM_CCMR1_CC2S;
   \   00000024   4FF6FF45           MOVW     R5,#+64767
   \   00000028   2B40               ANDS     R3,R5,R3
    372            
    373            /* Select the Output Compare Mode */
    374            tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
   \   0000002A   0D88               LDRH     R5,[R1, #+0]
   \   0000002C   53EA0523           ORRS     R3,R3,R5, LSL #+8
    375            
    376            /* Reset the Output Polarity level */
    377            tmpccer &= ~TIM_CCER_CC2P;
   \   00000030   4FF6DF75           MOVW     R5,#+65503
   \   00000034   2C40               ANDS     R4,R5,R4
    378            /* Set the Output Compare Polarity */
    379            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
   \   00000036   8D89               LDRH     R5,[R1, #+12]
   \   00000038   54EA0514           ORRS     R4,R4,R5, LSL #+4
    380            
    381            /* Set the Output State */
    382            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
   \   0000003C   4D88               LDRH     R5,[R1, #+2]
   \   0000003E   54EA0514           ORRS     R4,R4,R5, LSL #+4
    383              
    384            if((*(uint32_t*)&TIMx == TIM1_BASE) || (*(uint32_t*)&TIMx == TIM8_BASE))
   \   00000042   ....               LDR.N    R5,??DataTable5  ;; 0x40010000
   \   00000044   A842               CMP      R0,R5
   \   00000046   02D0               BEQ.N    ??TIM_OC2Init_0
   \   00000048   ....               LDR.N    R5,??DataTable5_6  ;; 0x40010400
   \   0000004A   A842               CMP      R0,R5
   \   0000004C   17D1               BNE.N    ??TIM_OC2Init_1
    385            {
    386              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    387              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    388              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    389              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    390              
    391              /* Reset the Output N Polarity level */
    392              tmpccer &= ~TIM_CCER_CC2NP;
   \                     ??TIM_OC2Init_0:
   \   0000004E   4FF67F75           MOVW     R5,#+65407
   \   00000052   2C40               ANDS     R4,R5,R4
    393              /* Set the Output N Polarity */
    394              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
   \   00000054   CD89               LDRH     R5,[R1, #+14]
   \   00000056   54EA0514           ORRS     R4,R4,R5, LSL #+4
    395              /* Reset the Output N State */
    396              tmpccer &= ~TIM_CCER_CC2NE;
   \   0000005A   4FF6BF75           MOVW     R5,#+65471
   \   0000005E   2C40               ANDS     R4,R5,R4
    397              
    398              /* Set the Output N State */
    399              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
   \   00000060   8D88               LDRH     R5,[R1, #+4]
   \   00000062   54EA0514           ORRS     R4,R4,R5, LSL #+4
    400              /* Reset the Ouput Compare and Output Compare N IDLE State */
    401              tmpcr2 &= ~TIM_CR2_OIS2;
   \   00000066   4FF6FF35           MOVW     R5,#+64511
   \   0000006A   2A40               ANDS     R2,R5,R2
    402              tmpcr2 &= ~TIM_CR2_OIS2N;
   \   0000006C   4FF2FF75           MOVW     R5,#+63487
   \   00000070   2A40               ANDS     R2,R5,R2
    403              /* Set the Output Idle state */
    404              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
   \   00000072   0D8A               LDRH     R5,[R1, #+16]
   \   00000074   52EA8502           ORRS     R2,R2,R5, LSL #+2
    405              /* Set the Output N Idle state */
    406              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
   \   00000078   4D8A               LDRH     R5,[R1, #+18]
   \   0000007A   52EA8502           ORRS     R2,R2,R5, LSL #+2
    407            }
    408            /* Write to TIMx CR2 */
    409            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC2Init_1:
   \   0000007E   8280               STRH     R2,[R0, #+4]
    410            
    411            /* Write to TIMx CCMR1 */
    412            TIMx->CCMR1 = tmpccmrx;
   \   00000080   0383               STRH     R3,[R0, #+24]
    413            
    414            /* Set the Capture Compare Register value */
    415            TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
   \   00000082   8968               LDR      R1,[R1, #+8]
   \   00000084   8163               STR      R1,[R0, #+56]
    416            
    417            /* Write to TIMx CCER */
    418            TIMx->CCER = tmpccer;
   \   00000086   0484               STRH     R4,[R0, #+32]
    419          }
   \   00000088   70BC               POP      {R4-R6}
   \   0000008A   7047               BX       LR               ;; return
    420          
    421          /**
    422            * @brief  Initializes the TIMx Channel3 according to the specified
    423            *   parameters in the TIM_OCInitStruct.
    424            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
    425            *   peripheral.
    426            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    427            *   that contains the configuration information for the specified TIM peripheral.
    428            * @retval None
    429            */

   \                                 In section .text, align 2, keep-with-next
    430          void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    431          {
   \                     TIM_OC3Init:
   \   00000000   70B4               PUSH     {R4-R6}
    432            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   0024               MOVS     R4,#+0
   \   00000006   0022               MOVS     R2,#+0
    433             
    434            /* Check the parameters */
    435            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
    436            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    437            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    438            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    439            /* Disable the Channel 2: Reset the CC2E Bit */
    440            TIMx->CCER &= ~TIM_CCER_CC3E;
   \   00000008   058C               LDRH     R5,[R0, #+32]
   \   0000000A   4FF6FF66           MOVW     R6,#+65279
   \   0000000E   3540               ANDS     R5,R6,R5
   \   00000010   0584               STRH     R5,[R0, #+32]
    441            
    442            /* Get the TIMx CCER register value */
    443            tmpccer = TIMx->CCER;
   \   00000012   058C               LDRH     R5,[R0, #+32]
   \   00000014   2C00               MOVS     R4,R5
    444            /* Get the TIMx CR2 register value */
    445            tmpcr2 =  TIMx->CR2;
   \   00000016   8588               LDRH     R5,[R0, #+4]
   \   00000018   2A00               MOVS     R2,R5
    446            
    447            /* Get the TIMx CCMR2 register value */
    448            tmpccmrx = TIMx->CCMR2;
   \   0000001A   858B               LDRH     R5,[R0, #+28]
   \   0000001C   2B00               MOVS     R3,R5
    449              
    450            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    451            tmpccmrx &= ~TIM_CCMR2_OC3M;
   \   0000001E   4FF68F75           MOVW     R5,#+65423
   \   00000022   2B40               ANDS     R3,R5,R3
    452            tmpccmrx &= ~TIM_CCMR2_CC3S;  
   \   00000024   4FF6FC75           MOVW     R5,#+65532
   \   00000028   2B40               ANDS     R3,R5,R3
    453            /* Select the Output Compare Mode */
    454            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
   \   0000002A   0D88               LDRH     R5,[R1, #+0]
   \   0000002C   2B43               ORRS     R3,R5,R3
    455            
    456            /* Reset the Output Polarity level */
    457            tmpccer &= ~TIM_CCER_CC3P;
   \   0000002E   4FF6FF55           MOVW     R5,#+65023
   \   00000032   2C40               ANDS     R4,R5,R4
    458            /* Set the Output Compare Polarity */
    459            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
   \   00000034   8D89               LDRH     R5,[R1, #+12]
   \   00000036   54EA0524           ORRS     R4,R4,R5, LSL #+8
    460            
    461            /* Set the Output State */
    462            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
   \   0000003A   4D88               LDRH     R5,[R1, #+2]
   \   0000003C   54EA0524           ORRS     R4,R4,R5, LSL #+8
    463              
    464            if((*(uint32_t*)&TIMx == TIM1_BASE) || (*(uint32_t*)&TIMx == TIM8_BASE))
   \   00000040   ....               LDR.N    R5,??DataTable5  ;; 0x40010000
   \   00000042   A842               CMP      R0,R5
   \   00000044   02D0               BEQ.N    ??TIM_OC3Init_0
   \   00000046   ....               LDR.N    R5,??DataTable5_6  ;; 0x40010400
   \   00000048   A842               CMP      R0,R5
   \   0000004A   17D1               BNE.N    ??TIM_OC3Init_1
    465            {
    466              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    467              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    468              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    469              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    470              
    471              /* Reset the Output N Polarity level */
    472              tmpccer &= ~TIM_CCER_CC3NP;
   \                     ??TIM_OC3Init_0:
   \   0000004C   4FF2FF75           MOVW     R5,#+63487
   \   00000050   2C40               ANDS     R4,R5,R4
    473              /* Set the Output N Polarity */
    474              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
   \   00000052   CD89               LDRH     R5,[R1, #+14]
   \   00000054   54EA0524           ORRS     R4,R4,R5, LSL #+8
    475              /* Reset the Output N State */
    476              tmpccer &= ~TIM_CCER_CC3NE;
   \   00000058   4FF6FF35           MOVW     R5,#+64511
   \   0000005C   2C40               ANDS     R4,R5,R4
    477              
    478              /* Set the Output N State */
    479              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
   \   0000005E   8D88               LDRH     R5,[R1, #+4]
   \   00000060   54EA0524           ORRS     R4,R4,R5, LSL #+8
    480              /* Reset the Ouput Compare and Output Compare N IDLE State */
    481              tmpcr2 &= ~TIM_CR2_OIS3;
   \   00000064   4EF6FF75           MOVW     R5,#+61439
   \   00000068   2A40               ANDS     R2,R5,R2
    482              tmpcr2 &= ~TIM_CR2_OIS3N;
   \   0000006A   4DF6FF75           MOVW     R5,#+57343
   \   0000006E   2A40               ANDS     R2,R5,R2
    483              /* Set the Output Idle state */
    484              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
   \   00000070   0D8A               LDRH     R5,[R1, #+16]
   \   00000072   52EA0512           ORRS     R2,R2,R5, LSL #+4
    485              /* Set the Output N Idle state */
    486              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
   \   00000076   4D8A               LDRH     R5,[R1, #+18]
   \   00000078   52EA0512           ORRS     R2,R2,R5, LSL #+4
    487            }
    488            /* Write to TIMx CR2 */
    489            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC3Init_1:
   \   0000007C   8280               STRH     R2,[R0, #+4]
    490            
    491            /* Write to TIMx CCMR2 */
    492            TIMx->CCMR2 = tmpccmrx;
   \   0000007E   8383               STRH     R3,[R0, #+28]
    493            
    494            /* Set the Capture Compare Register value */
    495            TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
   \   00000080   8968               LDR      R1,[R1, #+8]
   \   00000082   C163               STR      R1,[R0, #+60]
    496            
    497            /* Write to TIMx CCER */
    498            TIMx->CCER = tmpccer;
   \   00000084   0484               STRH     R4,[R0, #+32]
    499          }
   \   00000086   70BC               POP      {R4-R6}
   \   00000088   7047               BX       LR               ;; return
    500          
    501          /**
    502            * @brief  Initializes the TIMx Channel4 according to the specified
    503            *   parameters in the TIM_OCInitStruct.
    504            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
    505            *   peripheral.
    506            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    507            *   that contains the configuration information for the specified TIM peripheral.
    508            * @retval None
    509            */

   \                                 In section .text, align 2, keep-with-next
    510          void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    511          {
   \                     TIM_OC4Init:
   \   00000000   70B4               PUSH     {R4-R6}
    512            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   0024               MOVS     R4,#+0
   \   00000006   0022               MOVS     R2,#+0
    513             
    514            /* Check the parameters */
    515            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
    516            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    517            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    518            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    519            /* Disable the Channel 2: Reset the CC4E Bit */
    520            TIMx->CCER &= ~TIM_CCER_CC4E;
   \   00000008   058C               LDRH     R5,[R0, #+32]
   \   0000000A   4EF6FF76           MOVW     R6,#+61439
   \   0000000E   3540               ANDS     R5,R6,R5
   \   00000010   0584               STRH     R5,[R0, #+32]
    521            
    522            /* Get the TIMx CCER register value */
    523            tmpccer = TIMx->CCER;
   \   00000012   058C               LDRH     R5,[R0, #+32]
   \   00000014   2C00               MOVS     R4,R5
    524            /* Get the TIMx CR2 register value */
    525            tmpcr2 =  TIMx->CR2;
   \   00000016   8588               LDRH     R5,[R0, #+4]
   \   00000018   2A00               MOVS     R2,R5
    526            
    527            /* Get the TIMx CCMR2 register value */
    528            tmpccmrx = TIMx->CCMR2;
   \   0000001A   858B               LDRH     R5,[R0, #+28]
   \   0000001C   2B00               MOVS     R3,R5
    529              
    530            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    531            tmpccmrx &= ~TIM_CCMR2_OC4M;
   \   0000001E   48F6FF75           MOVW     R5,#+36863
   \   00000022   2B40               ANDS     R3,R5,R3
    532            tmpccmrx &= ~TIM_CCMR2_CC4S;
   \   00000024   4FF6FF45           MOVW     R5,#+64767
   \   00000028   2B40               ANDS     R3,R5,R3
    533            
    534            /* Select the Output Compare Mode */
    535            tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
   \   0000002A   0D88               LDRH     R5,[R1, #+0]
   \   0000002C   53EA0523           ORRS     R3,R3,R5, LSL #+8
    536            
    537            /* Reset the Output Polarity level */
    538            tmpccer &= ~TIM_CCER_CC4P;
   \   00000030   4DF6FF75           MOVW     R5,#+57343
   \   00000034   2C40               ANDS     R4,R5,R4
    539            /* Set the Output Compare Polarity */
    540            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
   \   00000036   8D89               LDRH     R5,[R1, #+12]
   \   00000038   54EA0534           ORRS     R4,R4,R5, LSL #+12
    541            
    542            /* Set the Output State */
    543            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
   \   0000003C   4D88               LDRH     R5,[R1, #+2]
   \   0000003E   54EA0534           ORRS     R4,R4,R5, LSL #+12
    544            
    545            if((*(uint32_t*)&TIMx == TIM1_BASE) || (*(uint32_t*)&TIMx == TIM8_BASE))
   \   00000042   ....               LDR.N    R5,??DataTable5  ;; 0x40010000
   \   00000044   A842               CMP      R0,R5
   \   00000046   02D0               BEQ.N    ??TIM_OC4Init_0
   \   00000048   ....               LDR.N    R5,??DataTable5_6  ;; 0x40010400
   \   0000004A   A842               CMP      R0,R5
   \   0000004C   05D1               BNE.N    ??TIM_OC4Init_1
    546            {
    547              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    548              /* Reset the Ouput Compare IDLE State */
    549              tmpcr2 &= ~TIM_CR2_OIS4;
   \                     ??TIM_OC4Init_0:
   \   0000004E   4BF6FF75           MOVW     R5,#+49151
   \   00000052   2A40               ANDS     R2,R5,R2
    550              /* Set the Output Idle state */
    551              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
   \   00000054   0D8A               LDRH     R5,[R1, #+16]
   \   00000056   52EA8512           ORRS     R2,R2,R5, LSL #+6
    552            }
    553            /* Write to TIMx CR2 */
    554            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC4Init_1:
   \   0000005A   8280               STRH     R2,[R0, #+4]
    555            
    556            /* Write to TIMx CCMR2 */  
    557            TIMx->CCMR2 = tmpccmrx;
   \   0000005C   8383               STRH     R3,[R0, #+28]
    558              
    559            /* Set the Capture Compare Register value */
    560            TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
   \   0000005E   8968               LDR      R1,[R1, #+8]
   \   00000060   0164               STR      R1,[R0, #+64]
    561            
    562            /* Write to TIMx CCER */
    563            TIMx->CCER = tmpccer;
   \   00000062   0484               STRH     R4,[R0, #+32]
    564          }
   \   00000064   70BC               POP      {R4-R6}
   \   00000066   7047               BX       LR               ;; return
    565          
    566          /**
    567            * @brief  Initializes the TIM peripheral according to the specified
    568            *   parameters in the TIM_ICInitStruct.
    569            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14  
    570            *   to select the TIM peripheral.
    571            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
    572            *   that contains the configuration information for the specified TIM peripheral.
    573            * @retval None
    574            */

   \                                 In section .text, align 2, keep-with-next
    575          void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
    576          {
   \                     TIM_ICInit:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    577            /* Check the parameters */
    578            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
    579            assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
    580            assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
    581            assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
    582            assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
    583            
    584            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   \   00000006   2888               LDRH     R0,[R5, #+0]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   0AD1               BNE.N    ??TIM_ICInit_0
    585            {
    586              /* TI1 Configuration */
    587              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    588                         TIM_ICInitStruct->TIM_ICSelection,
    589                         TIM_ICInitStruct->TIM_ICFilter);
   \   0000000C   2B89               LDRH     R3,[R5, #+8]
   \   0000000E   AA88               LDRH     R2,[R5, #+4]
   \   00000010   6988               LDRH     R1,[R5, #+2]
   \   00000012   2000               MOVS     R0,R4
   \   00000014   ........           BL       TI1_Config
    590              /* Set the Input Capture Prescaler value */
    591              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000018   E988               LDRH     R1,[R5, #+6]
   \   0000001A   2000               MOVS     R0,R4
   \   0000001C   ........           BL       TIM_SetIC1Prescaler
   \   00000020   25E0               B.N      ??TIM_ICInit_1
    592            }
    593            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
   \                     ??TIM_ICInit_0:
   \   00000022   2888               LDRH     R0,[R5, #+0]
   \   00000024   0428               CMP      R0,#+4
   \   00000026   0AD1               BNE.N    ??TIM_ICInit_2
    594            {
    595              /* TI2 Configuration */
    596              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    597                         TIM_ICInitStruct->TIM_ICSelection,
    598                         TIM_ICInitStruct->TIM_ICFilter);
   \   00000028   2B89               LDRH     R3,[R5, #+8]
   \   0000002A   AA88               LDRH     R2,[R5, #+4]
   \   0000002C   6988               LDRH     R1,[R5, #+2]
   \   0000002E   2000               MOVS     R0,R4
   \   00000030   ........           BL       TI2_Config
    599              /* Set the Input Capture Prescaler value */
    600              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000034   E988               LDRH     R1,[R5, #+6]
   \   00000036   2000               MOVS     R0,R4
   \   00000038   ........           BL       TIM_SetIC2Prescaler
   \   0000003C   17E0               B.N      ??TIM_ICInit_1
    601            }
    602            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
   \                     ??TIM_ICInit_2:
   \   0000003E   2888               LDRH     R0,[R5, #+0]
   \   00000040   0828               CMP      R0,#+8
   \   00000042   0AD1               BNE.N    ??TIM_ICInit_3
    603            {
    604              /* TI3 Configuration */
    605              TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
    606                         TIM_ICInitStruct->TIM_ICSelection,
    607                         TIM_ICInitStruct->TIM_ICFilter);
   \   00000044   2B89               LDRH     R3,[R5, #+8]
   \   00000046   AA88               LDRH     R2,[R5, #+4]
   \   00000048   6988               LDRH     R1,[R5, #+2]
   \   0000004A   2000               MOVS     R0,R4
   \   0000004C   ........           BL       TI3_Config
    608              /* Set the Input Capture Prescaler value */
    609              TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000050   E988               LDRH     R1,[R5, #+6]
   \   00000052   2000               MOVS     R0,R4
   \   00000054   ........           BL       TIM_SetIC3Prescaler
   \   00000058   09E0               B.N      ??TIM_ICInit_1
    610            }
    611            else
    612            {
    613              /* TI4 Configuration */
    614              TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    615                         TIM_ICInitStruct->TIM_ICSelection,
    616                         TIM_ICInitStruct->TIM_ICFilter);
   \                     ??TIM_ICInit_3:
   \   0000005A   2B89               LDRH     R3,[R5, #+8]
   \   0000005C   AA88               LDRH     R2,[R5, #+4]
   \   0000005E   6988               LDRH     R1,[R5, #+2]
   \   00000060   2000               MOVS     R0,R4
   \   00000062   ........           BL       TI4_Config
    617              /* Set the Input Capture Prescaler value */
    618              TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000066   E988               LDRH     R1,[R5, #+6]
   \   00000068   2000               MOVS     R0,R4
   \   0000006A   ........           BL       TIM_SetIC4Prescaler
    619            }
    620          }
   \                     ??TIM_ICInit_1:
   \   0000006E   31BD               POP      {R0,R4,R5,PC}    ;; return
    621          
    622          /**
    623            * @brief  Configures the TIM peripheral according to the specified
    624            *   parameters in the TIM_ICInitStruct to measure an external PWM signal.
    625            * @param  TIMx: where x can be  1, 2, 3, 4, 5,8, 9 or 12 to select the TIM 
    626            *   peripheral.
    627            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
    628            *   that contains the configuration information for the specified TIM peripheral.
    629            * @retval None
    630            */

   \                                 In section .text, align 2, keep-with-next
    631          void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
    632          {
   \                     TIM_PWMIConfig:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    633            uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
   \   00000006   0026               MOVS     R6,#+0
    634            uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
   \   00000008   0127               MOVS     R7,#+1
    635            /* Check the parameters */
    636            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
    637            /* Select the Opposite Input Polarity */
    638            if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
   \   0000000A   6888               LDRH     R0,[R5, #+2]
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   01D1               BNE.N    ??TIM_PWMIConfig_0
    639            {
    640              icoppositepolarity = TIM_ICPolarity_Falling;
   \   00000010   0226               MOVS     R6,#+2
   \   00000012   00E0               B.N      ??TIM_PWMIConfig_1
    641            }
    642            else
    643            {
    644              icoppositepolarity = TIM_ICPolarity_Rising;
   \                     ??TIM_PWMIConfig_0:
   \   00000014   0026               MOVS     R6,#+0
    645            }
    646            /* Select the Opposite Input */
    647            if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
   \                     ??TIM_PWMIConfig_1:
   \   00000016   A888               LDRH     R0,[R5, #+4]
   \   00000018   0128               CMP      R0,#+1
   \   0000001A   01D1               BNE.N    ??TIM_PWMIConfig_2
    648            {
    649              icoppositeselection = TIM_ICSelection_IndirectTI;
   \   0000001C   0227               MOVS     R7,#+2
   \   0000001E   00E0               B.N      ??TIM_PWMIConfig_3
    650            }
    651            else
    652            {
    653              icoppositeselection = TIM_ICSelection_DirectTI;
   \                     ??TIM_PWMIConfig_2:
   \   00000020   0127               MOVS     R7,#+1
    654            }
    655            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   \                     ??TIM_PWMIConfig_3:
   \   00000022   2888               LDRH     R0,[R5, #+0]
   \   00000024   0028               CMP      R0,#+0
   \   00000026   16D1               BNE.N    ??TIM_PWMIConfig_4
    656            {
    657              /* TI1 Configuration */
    658              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
    659                         TIM_ICInitStruct->TIM_ICFilter);
   \   00000028   2B89               LDRH     R3,[R5, #+8]
   \   0000002A   AA88               LDRH     R2,[R5, #+4]
   \   0000002C   6988               LDRH     R1,[R5, #+2]
   \   0000002E   2000               MOVS     R0,R4
   \   00000030   ........           BL       TI1_Config
    660              /* Set the Input Capture Prescaler value */
    661              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000034   E988               LDRH     R1,[R5, #+6]
   \   00000036   2000               MOVS     R0,R4
   \   00000038   ........           BL       TIM_SetIC1Prescaler
    662              /* TI2 Configuration */
    663              TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   \   0000003C   2B89               LDRH     R3,[R5, #+8]
   \   0000003E   3A00               MOVS     R2,R7
   \   00000040   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000042   3100               MOVS     R1,R6
   \   00000044   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000046   2000               MOVS     R0,R4
   \   00000048   ........           BL       TI2_Config
    664              /* Set the Input Capture Prescaler value */
    665              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   0000004C   E988               LDRH     R1,[R5, #+6]
   \   0000004E   2000               MOVS     R0,R4
   \   00000050   ........           BL       TIM_SetIC2Prescaler
   \   00000054   15E0               B.N      ??TIM_PWMIConfig_5
    666            }
    667            else
    668            { 
    669              /* TI2 Configuration */
    670              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
    671                         TIM_ICInitStruct->TIM_ICFilter);
   \                     ??TIM_PWMIConfig_4:
   \   00000056   2B89               LDRH     R3,[R5, #+8]
   \   00000058   AA88               LDRH     R2,[R5, #+4]
   \   0000005A   6988               LDRH     R1,[R5, #+2]
   \   0000005C   2000               MOVS     R0,R4
   \   0000005E   ........           BL       TI2_Config
    672              /* Set the Input Capture Prescaler value */
    673              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000062   E988               LDRH     R1,[R5, #+6]
   \   00000064   2000               MOVS     R0,R4
   \   00000066   ........           BL       TIM_SetIC2Prescaler
    674              /* TI1 Configuration */
    675              TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   \   0000006A   2B89               LDRH     R3,[R5, #+8]
   \   0000006C   3A00               MOVS     R2,R7
   \   0000006E   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000070   3100               MOVS     R1,R6
   \   00000072   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000074   2000               MOVS     R0,R4
   \   00000076   ........           BL       TI1_Config
    676              /* Set the Input Capture Prescaler value */
    677              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   0000007A   E988               LDRH     R1,[R5, #+6]
   \   0000007C   2000               MOVS     R0,R4
   \   0000007E   ........           BL       TIM_SetIC1Prescaler
    678            }
    679          }
   \                     ??TIM_PWMIConfig_5:
   \   00000082   F1BD               POP      {R0,R4-R7,PC}    ;; return
    680          
    681          /**
    682            * @brief  Configures the: Break feature, dead time, Lock level, the OSSI,
    683            *   the OSSR State and the AOE(automatic output enable).
    684            * @param  TIMx: where x can be  1 or 8 to select the TIM 
    685            * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure that
    686            *   contains the BDTR Register configuration  information for the TIM peripheral.
    687            * @retval None
    688            */

   \                                 In section .text, align 2, keep-with-next
    689          void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
    690          {
    691            /* Check the parameters */
    692            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
    693            assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
    694            assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
    695            assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
    696            assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
    697            assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
    698            assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
    699            /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
    700               the OSSI State, the dead time value and the Automatic Output Enable Bit */
    701            TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
    702                       TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
    703                       TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
    704                       TIM_BDTRInitStruct->TIM_AutomaticOutput;
   \                     TIM_BDTRConfig:
   \   00000000   0A88               LDRH     R2,[R1, #+0]
   \   00000002   4B88               LDRH     R3,[R1, #+2]
   \   00000004   1A43               ORRS     R2,R3,R2
   \   00000006   8B88               LDRH     R3,[R1, #+4]
   \   00000008   1A43               ORRS     R2,R3,R2
   \   0000000A   CB88               LDRH     R3,[R1, #+6]
   \   0000000C   1A43               ORRS     R2,R3,R2
   \   0000000E   0B89               LDRH     R3,[R1, #+8]
   \   00000010   1A43               ORRS     R2,R3,R2
   \   00000012   4B89               LDRH     R3,[R1, #+10]
   \   00000014   1A43               ORRS     R2,R3,R2
   \   00000016   8989               LDRH     R1,[R1, #+12]
   \   00000018   1143               ORRS     R1,R1,R2
   \   0000001A   A0F84410           STRH     R1,[R0, #+68]
    705          }
   \   0000001E   7047               BX       LR               ;; return
    706          
    707          /**
    708            * @brief  Fills each TIM_TimeBaseInitStruct member with its default value.
    709            * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
    710            *   structure which will be initialized.
    711            * @retval None
    712            */

   \                                 In section .text, align 2, keep-with-next
    713          void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    714          {
    715            /* Set the default configuration */
    716            TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
   \                     TIM_TimeBaseStructInit:
   \   00000000   5FF0FF31           MOVS     R1,#-1
   \   00000004   4160               STR      R1,[R0, #+4]
    717            TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   0180               STRH     R1,[R0, #+0]
    718            TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   0181               STRH     R1,[R0, #+8]
    719            TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
   \   0000000E   0021               MOVS     R1,#+0
   \   00000010   4180               STRH     R1,[R0, #+2]
    720            TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
   \   00000012   0021               MOVS     R1,#+0
   \   00000014   8172               STRB     R1,[R0, #+10]
    721          }
   \   00000016   7047               BX       LR               ;; return
    722          
    723          /**
    724            * @brief  Fills each TIM_OCInitStruct member with its default value.
    725            * @param  TIM_OCInitStruct : pointer to a TIM_OCInitTypeDef structure which will
    726            *   be initialized.
    727            * @retval None
    728            */

   \                                 In section .text, align 2, keep-with-next
    729          void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
    730          {
    731            /* Set the default configuration */
    732            TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
   \                     TIM_OCStructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0180               STRH     R1,[R0, #+0]
    733            TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   4180               STRH     R1,[R0, #+2]
    734            TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   8180               STRH     R1,[R0, #+4]
    735            TIM_OCInitStruct->TIM_Pulse = 0x00000000;
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   8160               STR      R1,[R0, #+8]
    736            TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   8181               STRH     R1,[R0, #+12]
    737            TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   C181               STRH     R1,[R0, #+14]
    738            TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
   \   00000018   0021               MOVS     R1,#+0
   \   0000001A   0182               STRH     R1,[R0, #+16]
    739            TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
   \   0000001C   0021               MOVS     R1,#+0
   \   0000001E   4182               STRH     R1,[R0, #+18]
    740          }
   \   00000020   7047               BX       LR               ;; return
    741          
    742          /**
    743            * @brief  Fills each TIM_ICInitStruct member with its default value.
    744            * @param  TIM_ICInitStruct : pointer to a TIM_ICInitTypeDef structure which will
    745            *   be initialized.
    746            * @retval None
    747            */

   \                                 In section .text, align 2, keep-with-next
    748          void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
    749          {
    750            /* Set the default configuration */
    751            TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
   \                     TIM_ICStructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0180               STRH     R1,[R0, #+0]
    752            TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   4180               STRH     R1,[R0, #+2]
    753            TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
   \   00000008   0121               MOVS     R1,#+1
   \   0000000A   8180               STRH     R1,[R0, #+4]
    754            TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   C180               STRH     R1,[R0, #+6]
    755            TIM_ICInitStruct->TIM_ICFilter = 0x00;
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   0181               STRH     R1,[R0, #+8]
    756          }
   \   00000014   7047               BX       LR               ;; return
    757          
    758          /**
    759            * @brief  Fills each TIM_BDTRInitStruct member with its default value.
    760            * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure which
    761            *   will be initialized.
    762            * @retval None
    763            */

   \                                 In section .text, align 2, keep-with-next
    764          void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
    765          {
    766            /* Set the default configuration */
    767            TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
   \                     TIM_BDTRStructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0180               STRH     R1,[R0, #+0]
    768            TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   4180               STRH     R1,[R0, #+2]
    769            TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   8180               STRH     R1,[R0, #+4]
    770            TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   C180               STRH     R1,[R0, #+6]
    771            TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   0181               STRH     R1,[R0, #+8]
    772            TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   4181               STRH     R1,[R0, #+10]
    773            TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
   \   00000018   0021               MOVS     R1,#+0
   \   0000001A   8181               STRH     R1,[R0, #+12]
    774          }
   \   0000001C   7047               BX       LR               ;; return
    775          
    776          /**
    777            * @brief  Enables or disables the specified TIM peripheral.
    778            * @param  TIMx: where x can be 1 to 14 to select the TIMx peripheral.
    779            * @param  NewState: new state of the TIMx peripheral.
    780            *   This parameter can be: ENABLE or DISABLE.
    781            * @retval None
    782            */

   \                                 In section .text, align 2, keep-with-next
    783          void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
    784          {
    785            /* Check the parameters */
    786            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    787            assert_param(IS_FUNCTIONAL_STATE(NewState));
    788            
    789            if (NewState != DISABLE)
   \                     TIM_Cmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??TIM_Cmd_0
    790            {
    791              /* Enable the TIM Counter */
    792              TIMx->CR1 |= TIM_CR1_CEN;
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   51F00101           ORRS     R1,R1,#0x1
   \   0000000C   0180               STRH     R1,[R0, #+0]
   \   0000000E   04E0               B.N      ??TIM_Cmd_1
    793            }
    794            else
    795            {
    796              /* Disable the TIM Counter */
    797              TIMx->CR1 &= ~TIM_CR1_CEN;
   \                     ??TIM_Cmd_0:
   \   00000010   0188               LDRH     R1,[R0, #+0]
   \   00000012   4FF6FE72           MOVW     R2,#+65534
   \   00000016   1140               ANDS     R1,R2,R1
   \   00000018   0180               STRH     R1,[R0, #+0]
    798            }
    799          }
   \                     ??TIM_Cmd_1:
   \   0000001A   7047               BX       LR               ;; return
    800          
    801          /**
    802            * @brief  Enables or disables the TIM peripheral Main Outputs.
    803            * @param  TIMx: where x can be 1 or 8 to select the TIMx peripheral.
    804            * @param  NewState: new state of the TIM peripheral Main Outputs.
    805            *   This parameter can be: ENABLE or DISABLE.
    806            * @retval None
    807            */

   \                                 In section .text, align 2, keep-with-next
    808          void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
    809          {
    810            /* Check the parameters */
    811            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
    812            assert_param(IS_FUNCTIONAL_STATE(NewState));
    813            if (NewState != DISABLE)
   \                     TIM_CtrlPWMOutputs:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   06D0               BEQ.N    ??TIM_CtrlPWMOutputs_0
    814            {
    815              /* Enable the TIM Main Output */
    816              TIMx->BDTR |= TIM_BDTR_MOE;
   \   00000006   B0F84410           LDRH     R1,[R0, #+68]
   \   0000000A   51F40041           ORRS     R1,R1,#0x8000
   \   0000000E   A0F84410           STRH     R1,[R0, #+68]
   \   00000012   05E0               B.N      ??TIM_CtrlPWMOutputs_1
    817            }
    818            else
    819            {
    820              /* Disable the TIM Main Output */
    821              TIMx->BDTR &= ~TIM_BDTR_MOE;
   \                     ??TIM_CtrlPWMOutputs_0:
   \   00000014   B0F84410           LDRH     R1,[R0, #+68]
   \   00000018   4904               LSLS     R1,R1,#+17
   \   0000001A   490C               LSRS     R1,R1,#+17
   \   0000001C   A0F84410           STRH     R1,[R0, #+68]
    822            }  
    823          }
   \                     ??TIM_CtrlPWMOutputs_1:
   \   00000020   7047               BX       LR               ;; return
    824          
    825          /**
    826            * @brief  Enables or disables the specified TIM interrupts.
    827            * @param  TIMx: where x can be 1 to 14 to select the TIMx peripheral.
    828            * @param  TIM_IT: specifies the TIM interrupts sources to be enabled or disabled.
    829            *   This parameter can be any combination of the following values:
    830            *     @arg TIM_IT_Update: TIM update Interrupt source
    831            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
    832            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
    833            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
    834            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
    835            *     @arg TIM_IT_COM: TIM Commutation Interrupt source
    836            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
    837            *     @arg TIM_IT_Break: TIM Break Interrupt source
    838            * @note 
    839            *   - TIM6 and TIM7 can only generate an update interrupt. 
    840            *   - TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.  
    841            * @param  NewState: new state of the TIM interrupts.
    842            *   This parameter can be: ENABLE or DISABLE.
    843            * @retval None
    844          
    845            */

   \                                 In section .text, align 2, keep-with-next
    846          void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
    847          {  
    848            /* Check the parameters */
    849            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    850            assert_param(IS_TIM_IT(TIM_IT));
    851            assert_param(IS_FUNCTIONAL_STATE(NewState));
    852            
    853            if (NewState != DISABLE)
   \                     TIM_ITConfig:
   \   00000000   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   002A               CMP      R2,#+0
   \   00000004   03D0               BEQ.N    ??TIM_ITConfig_0
    854            {
    855              /* Enable the Interrupt sources */
    856              TIMx->DIER |= TIM_IT;
   \   00000006   8289               LDRH     R2,[R0, #+12]
   \   00000008   1143               ORRS     R1,R1,R2
   \   0000000A   8181               STRH     R1,[R0, #+12]
   \   0000000C   03E0               B.N      ??TIM_ITConfig_1
    857            }
    858            else
    859            {
    860              /* Disable the Interrupt sources */
    861              TIMx->DIER &= (uint16_t)~TIM_IT;
   \                     ??TIM_ITConfig_0:
   \   0000000E   8289               LDRH     R2,[R0, #+12]
   \   00000010   32EA0101           BICS     R1,R2,R1
   \   00000014   8181               STRH     R1,[R0, #+12]
    862            }
    863          }
   \                     ??TIM_ITConfig_1:
   \   00000016   7047               BX       LR               ;; return
    864          
    865          /**
    866            * @brief  Configures the TIMx event to be generate by software.
    867            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    868            * @param  TIM_EventSource: specifies the event source.
    869            *   This parameter can be one or more of the following values:	   
    870            *     @arg TIM_EventSource_Update: Timer update Event source
    871            *     @arg TIM_EventSource_CC1: Timer Capture Compare 1 Event source
    872            *     @arg TIM_EventSource_CC2: Timer Capture Compare 2 Event source
    873            *     @arg TIM_EventSource_CC3: Timer Capture Compare 3 Event source
    874            *     @arg TIM_EventSource_CC4: Timer Capture Compare 4 Event source
    875            *     @arg TIM_EventSource_COM: Timer COM event source  
    876            *     @arg TIM_EventSource_Trigger: Timer Trigger Event source
    877            *     @arg TIM_EventSource_Break: Timer Break event source
    878            * @note 
    879            *   - TIM6 and TIM7 can only generate an update event. 
    880            *   - TIM_EventSource_COM and TIM_EventSource_Break are used only with TIM1 and TIM8.      
    881            * @retval None
    882            */

   \                                 In section .text, align 2, keep-with-next
    883          void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
    884          { 
    885            /* Check the parameters */
    886            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    887            assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
    888           
    889            /* Set the event sources */
    890            TIMx->EGR = TIM_EventSource;
   \                     TIM_GenerateEvent:
   \   00000000   8182               STRH     R1,[R0, #+20]
    891          }
   \   00000002   7047               BX       LR               ;; return
    892          
    893          /**
    894            * @brief  Configures the TIMxs DMA interface.
    895            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
    896            *   peripheral.
    897            * @param  TIM_DMABase: DMA Base address.
    898            *   This parameter can be one of the following values:
    899            *     @arg TIM_DMABase_CR, TIM_DMABase_CR2, TIM_DMABase_SMCR,
    900            *   TIM_DMABase_DIER, TIM1_DMABase_SR, TIM_DMABase_EGR,
    901            *   TIM_DMABase_CCMR1, TIM_DMABase_CCMR2, TIM_DMABase_CCER,
    902            *   TIM_DMABase_CNT, TIM_DMABase_PSC, TIM_DMABase_ARR,
    903            *   TIM_DMABase_RCR, TIM_DMABase_CCR1, TIM_DMABase_CCR2,
    904            *   TIM_DMABase_CCR3, TIM_DMABase_CCR4, TIM_DMABase_BDTR,
    905            *   TIM_DMABase_DCR.
    906            * @param  TIM_DMABurstLength: DMA Burst length.
    907            *   This parameter can be one value between:
    908            *   TIM_DMABurstLength_1Byte and TIM_DMABurstLength_18Bytes.
    909            * @retval None
    910            */

   \                                 In section .text, align 2, keep-with-next
    911          void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
    912          {
    913            /* Check the parameters */
    914            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    915            assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
    916            assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
    917            /* Set the DMA Base and the DMA Burst Length */
    918            TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
   \                     TIM_DMAConfig:
   \   00000000   1143               ORRS     R1,R2,R1
   \   00000002   A0F84810           STRH     R1,[R0, #+72]
    919          }
   \   00000006   7047               BX       LR               ;; return
    920          
    921          /**
    922            * @brief  Enables or disables the TIMxs DMA Requests.
    923            * @param  TIMx: where x can be 1 to 8 to select the TIM peripheral. 
    924            * @param  TIM_DMASource: specifies the DMA Request sources.
    925            *   This parameter can be any combination of the following values:
    926            *     @arg TIM_DMA_Update: TIM update Interrupt source
    927            *     @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
    928            *     @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
    929            *     @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
    930            *     @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
    931            *     @arg TIM_DMA_COM: TIM Commutation DMA source
    932            *     @arg TIM_DMA_Trigger: TIM Trigger DMA source
    933            * @param  NewState: new state of the DMA Request sources.
    934            *   This parameter can be: ENABLE or DISABLE.
    935            * @retval None
    936            */

   \                                 In section .text, align 2, keep-with-next
    937          void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
    938          { 
    939            /* Check the parameters */
    940            assert_param(IS_TIM_LIST5_PERIPH(TIMx)); 
    941            assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
    942            assert_param(IS_FUNCTIONAL_STATE(NewState));
    943            
    944            if (NewState != DISABLE)
   \                     TIM_DMACmd:
   \   00000000   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   002A               CMP      R2,#+0
   \   00000004   03D0               BEQ.N    ??TIM_DMACmd_0
    945            {
    946              /* Enable the DMA sources */
    947              TIMx->DIER |= TIM_DMASource; 
   \   00000006   8289               LDRH     R2,[R0, #+12]
   \   00000008   1143               ORRS     R1,R1,R2
   \   0000000A   8181               STRH     R1,[R0, #+12]
   \   0000000C   03E0               B.N      ??TIM_DMACmd_1
    948            }
    949            else
    950            {
    951              /* Disable the DMA sources */
    952              TIMx->DIER &= (uint16_t)~TIM_DMASource;
   \                     ??TIM_DMACmd_0:
   \   0000000E   8289               LDRH     R2,[R0, #+12]
   \   00000010   32EA0101           BICS     R1,R2,R1
   \   00000014   8181               STRH     R1,[R0, #+12]
    953            }
    954          }
   \                     ??TIM_DMACmd_1:
   \   00000016   7047               BX       LR               ;; return
    955          
    956          /**
    957            * @brief  Configures the TIMx interrnal Clock
    958            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    959            * @retval : None
    960            */

   \                                 In section .text, align 2, keep-with-next
    961          void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
    962          {
    963            /* Check the parameters */
    964            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
    965            /* Disable slave mode to clock the prescaler directly with the internal clock */
    966            TIMx->SMCR &=  ~TIM_SMCR_SMS;
   \                     TIM_InternalClockConfig:
   \   00000000   0189               LDRH     R1,[R0, #+8]
   \   00000002   4FF6F872           MOVW     R2,#+65528
   \   00000006   1140               ANDS     R1,R2,R1
   \   00000008   0181               STRH     R1,[R0, #+8]
    967          }
   \   0000000A   7047               BX       LR               ;; return
    968          
    969          /**
    970            * @brief  Configures the TIMx Internal Trigger as External Clock
    971            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
    972            *   peripheral.
    973            * @param  TIM_ITRSource: Trigger source.
    974            *   This parameter can be one of the following values:
    975            * @param  TIM_TS_ITR0: Internal Trigger 0
    976            * @param  TIM_TS_ITR1: Internal Trigger 1
    977            * @param  TIM_TS_ITR2: Internal Trigger 2
    978            * @param  TIM_TS_ITR3: Internal Trigger 3
    979            * @retval None
    980            */

   \                                 In section .text, align 2, keep-with-next
    981          void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
    982          {
   \                     TIM_ITRxExternalClockConfig:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    983            /* Check the parameters */
    984            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
    985            assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
    986            /* Select the Internal Trigger */
    987            TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
   \   00000004   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   2000               MOVS     R0,R4
   \   00000008   ........           BL       TIM_SelectInputTrigger
    988            /* Select the External clock mode1 */
    989            TIMx->SMCR |= TIM_SlaveMode_External1;
   \   0000000C   2089               LDRH     R0,[R4, #+8]
   \   0000000E   50F00700           ORRS     R0,R0,#0x7
   \   00000012   2081               STRH     R0,[R4, #+8]
    990          }
   \   00000014   10BD               POP      {R4,PC}          ;; return
    991          
    992          /**
    993            * @brief  Configures the TIMx Trigger as External Clock
    994            * @param TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14  
    995            *   to select the TIM peripheral.
    996            * @param  TIM_TIxExternalCLKSource: Trigger source.
    997            *   This parameter can be one of the following values:
    998            *     @arg TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
    999            *     @arg TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
   1000            *     @arg TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
   1001            * @param  TIM_ICPolarity: specifies the TIx Polarity.
   1002            *   This parameter can be one of the following values:
   1003            *     @arg TIM_ICPolarity_Rising
   1004            *     @arg TIM_ICPolarity_Falling
   1005            * @param  ICFilter : specifies the filter value.
   1006            *   This parameter must be a value between 0x0 and 0xF.
   1007            * @retval None
   1008            */

   \                                 In section .text, align 2, keep-with-next
   1009          void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
   1010                                          uint16_t TIM_ICPolarity, uint16_t ICFilter)
   1011          {
   \                     TIM_TIxExternalClockConfig:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1100               MOVS     R1,R2
   1012            /* Check the parameters */
   1013            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1014            assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
   1015            assert_param(IS_TIM_IC_FILTER(ICFilter));
   1016            /* Configure the Timer Input Clock Source */
   1017            if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
   \   00000008   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000000A   602D               CMP      R5,#+96
   \   0000000C   06D1               BNE.N    ??TIM_TIxExternalClockConfig_0
   1018            {
   1019              TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   \   0000000E   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000010   0122               MOVS     R2,#+1
   \   00000012   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000014   2000               MOVS     R0,R4
   \   00000016   ........           BL       TI2_Config
   \   0000001A   05E0               B.N      ??TIM_TIxExternalClockConfig_1
   1020            }
   1021            else
   1022            {
   1023              TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   \                     ??TIM_TIxExternalClockConfig_0:
   \   0000001C   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001E   0122               MOVS     R2,#+1
   \   00000020   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000022   2000               MOVS     R0,R4
   \   00000024   ........           BL       TI1_Config
   1024            }
   1025            /* Select the Trigger source */
   1026            TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
   \                     ??TIM_TIxExternalClockConfig_1:
   \   00000028   2900               MOVS     R1,R5
   \   0000002A   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000002C   2000               MOVS     R0,R4
   \   0000002E   ........           BL       TIM_SelectInputTrigger
   1027            /* Select the External clock mode1 */
   1028            TIMx->SMCR |= TIM_SlaveMode_External1;
   \   00000032   2089               LDRH     R0,[R4, #+8]
   \   00000034   50F00700           ORRS     R0,R0,#0x7
   \   00000038   2081               STRH     R0,[R4, #+8]
   1029          }
   \   0000003A   31BD               POP      {R0,R4,R5,PC}    ;; return
   1030          
   1031          /**
   1032            * @brief  Configures the External clock Mode1
   1033            * @param TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1034            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1035            *   This parameter can be one of the following values:
   1036            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   1037            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   1038            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   1039            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   1040            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   1041            *   This parameter can be one of the following values:
   1042            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   1043            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   1044            * @param  ExtTRGFilter: External Trigger Filter.
   1045          
   1046            *   This parameter must be a value between 0x00 and 0x0F
   1047            * @retval None
   1048            */

   \                                 In section .text, align 2, keep-with-next
   1049          void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
   1050                                       uint16_t ExtTRGFilter)
   1051          {
   \                     TIM_ETRClockMode1Config:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
   1052            uint16_t tmpsmcr = 0;
   \   00000004   0025               MOVS     R5,#+0
   1053            /* Check the parameters */
   1054            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1055            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1056            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1057            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1058            /* Configure the ETR Clock source */
   1059            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   \   00000006   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000008   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000A   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       TIM_ETRConfig
   1060            
   1061            /* Get the TIMx SMCR register value */
   1062            tmpsmcr = TIMx->SMCR;
   \   00000012   2089               LDRH     R0,[R4, #+8]
   \   00000014   0500               MOVS     R5,R0
   1063            /* Reset the SMS Bits */
   1064            tmpsmcr &= ~TIM_SMCR_SMS;
   \   00000016   4FF6F870           MOVW     R0,#+65528
   \   0000001A   0540               ANDS     R5,R0,R5
   1065            /* Select the External clock mode1 */
   1066            tmpsmcr |= TIM_SlaveMode_External1;
   \   0000001C   55F00705           ORRS     R5,R5,#0x7
   1067            /* Select the Trigger selection : ETRF */
   1068            tmpsmcr &= ~TIM_SMCR_TS;
   \   00000020   4FF68F70           MOVW     R0,#+65423
   \   00000024   0540               ANDS     R5,R0,R5
   1069            tmpsmcr |= TIM_TS_ETRF;
   \   00000026   55F07005           ORRS     R5,R5,#0x70
   1070            /* Write to TIMx SMCR */
   1071            TIMx->SMCR = tmpsmcr;
   \   0000002A   2581               STRH     R5,[R4, #+8]
   1072          }
   \   0000002C   31BD               POP      {R0,R4,R5,PC}    ;; return
   1073          
   1074          /**
   1075            * @brief  Configures the External clock Mode2
   1076            * @param TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1077            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1078            *   This parameter can be one of the following values:
   1079            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   1080            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   1081            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   1082            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   1083            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   1084            *   This parameter can be one of the following values:
   1085            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   1086            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   1087            * @param  ExtTRGFilter: External Trigger Filter.
   1088            *   This parameter must be a value between 0x00 and 0x0F
   1089            * @retval None
   1090            */

   \                                 In section .text, align 2, keep-with-next
   1091          void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
   1092                                       uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
   1093          {
   \                     TIM_ETRClockMode2Config:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   1094            /* Check the parameters */
   1095            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1096            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1097            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1098            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1099            /* Configure the ETR Clock source */
   1100            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   \   00000004   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000006   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000008   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   ........           BL       TIM_ETRConfig
   1101            /* Enable the External clock mode2 */
   1102            TIMx->SMCR |= TIM_SMCR_ECE;
   \   00000010   2089               LDRH     R0,[R4, #+8]
   \   00000012   50F48040           ORRS     R0,R0,#0x4000
   \   00000016   2081               STRH     R0,[R4, #+8]
   1103          }
   \   00000018   10BD               POP      {R4,PC}          ;; return
   1104          
   1105          /**
   1106            * @brief  Configures the TIMx External Trigger (ETR).
   1107            * @param TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1108            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1109            *   This parameter can be one of the following values:
   1110            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   1111            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   1112            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   1113            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   1114            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   1115            *   This parameter can be one of the following values:
   1116            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   1117            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   1118            * @param  ExtTRGFilter: External Trigger Filter.
   1119            *   This parameter must be a value between 0x00 and 0x0F
   1120            * @retval None
   1121            */

   \                                 In section .text, align 2, keep-with-next
   1122          void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
   1123                             uint16_t ExtTRGFilter)
   1124          {
   \                     TIM_ETRConfig:
   \   00000000   30B4               PUSH     {R4,R5}
   1125            uint16_t tmpsmcr = 0;
   \   00000002   0024               MOVS     R4,#+0
   1126            /* Check the parameters */
   1127            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1128            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1129            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1130            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1131            tmpsmcr = TIMx->SMCR;
   \   00000004   0589               LDRH     R5,[R0, #+8]
   \   00000006   2C00               MOVS     R4,R5
   1132            /* Reset the ETR Bits */
   1133            tmpsmcr &= SMCR_ETR_Mask;
   \   00000008   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   1134            /* Set the Prescaler, the Filter value and the Polarity */
   1135            tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
   \   0000000A   52EA0322           ORRS     R2,R2,R3, LSL #+8
   \   0000000E   1143               ORRS     R1,R2,R1
   \   00000010   0C43               ORRS     R4,R1,R4
   1136            /* Write to TIMx SMCR */
   1137            TIMx->SMCR = tmpsmcr;
   \   00000012   0481               STRH     R4,[R0, #+8]
   1138          }
   \   00000014   30BC               POP      {R4,R5}
   \   00000016   7047               BX       LR               ;; return
   1139          
   1140          /**
   1141            * @brief  Configures the TIMx Prescaler.
   1142            * @param TIMx: where x can be  1 to 14 to select the TIM peripheral.
   1143            * @param  Prescaler: specifies the Prescaler Register value
   1144            * @param  TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
   1145            *   This parameter can be one of the following values:
   1146            *     @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
   1147            *     @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediatly.
   1148            * @retval None
   1149            */

   \                                 In section .text, align 2, keep-with-next
   1150          void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
   1151          {
   1152            /* Check the parameters */
   1153            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1154            assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
   1155            /* Set the Prescaler value */
   1156            TIMx->PSC = Prescaler;
   \                     TIM_PrescalerConfig:
   \   00000000   0185               STRH     R1,[R0, #+40]
   1157            /* Set or reset the UG Bit */
   1158            TIMx->EGR = TIM_PSCReloadMode;
   \   00000002   8282               STRH     R2,[R0, #+20]
   1159          }
   \   00000004   7047               BX       LR               ;; return
   1160          
   1161          /**
   1162            * @brief  Specifies the TIMx Counter Mode to be used.
   1163            * @param TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1164            * @param  TIM_CounterMode: specifies the Counter Mode to be used
   1165            *   This parameter can be one of the following values:
   1166            *     @arg TIM_CounterMode_Up: TIM Up Counting Mode
   1167            *     @arg TIM_CounterMode_Down: TIM Down Counting Mode
   1168            *     @arg TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
   1169            *     @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
   1170            *     @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
   1171            * @retval None
   1172            */

   \                                 In section .text, align 2, keep-with-next
   1173          void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
   1174          {
   1175            uint16_t tmpcr1 = 0;
   \                     TIM_CounterModeConfig:
   \   00000000   0022               MOVS     R2,#+0
   1176            /* Check the parameters */
   1177            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1178            assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
   1179            tmpcr1 = TIMx->CR1;
   \   00000002   0388               LDRH     R3,[R0, #+0]
   \   00000004   1A00               MOVS     R2,R3
   1180            /* Reset the CMS and DIR Bits */
   1181            tmpcr1 &= (~(TIM_CR1_DIR | TIM_CR1_CMS));
   \   00000006   4FF68F73           MOVW     R3,#+65423
   \   0000000A   1A40               ANDS     R2,R3,R2
   1182            /* Set the Counter Mode */
   1183            tmpcr1 |= TIM_CounterMode;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1184            /* Write to TIMx CR1 register */
   1185            TIMx->CR1 = tmpcr1;
   \   0000000E   0280               STRH     R2,[R0, #+0]
   1186          }
   \   00000010   7047               BX       LR               ;; return
   1187          
   1188          /**
   1189            * @brief  Selects the Input Trigger source
   1190            * @param TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14  
   1191            *   to select the TIM peripheral.
   1192            * @param  TIM_InputTriggerSource: The Input Trigger source.
   1193            *   This parameter can be one of the following values:
   1194            *     @arg TIM_TS_ITR0: Internal Trigger 0
   1195            *     @arg TIM_TS_ITR1: Internal Trigger 1
   1196            *     @arg TIM_TS_ITR2: Internal Trigger 2
   1197            *     @arg TIM_TS_ITR3: Internal Trigger 3
   1198            *     @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   1199            *     @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   1200            *     @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   1201            *     @arg TIM_TS_ETRF: External Trigger input
   1202            * @retval None
   1203            */

   \                                 In section .text, align 2, keep-with-next
   1204          void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
   1205          {
   1206            uint16_t tmpsmcr = 0;
   \                     TIM_SelectInputTrigger:
   \   00000000   0022               MOVS     R2,#+0
   1207            /* Check the parameters */
   1208            assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
   1209            assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
   1210            /* Get the TIMx SMCR register value */
   1211            tmpsmcr = TIMx->SMCR;
   \   00000002   0389               LDRH     R3,[R0, #+8]
   \   00000004   1A00               MOVS     R2,R3
   1212            /* Reset the TS Bits */
   1213            tmpsmcr &= ~TIM_SMCR_TS;
   \   00000006   4FF68F73           MOVW     R3,#+65423
   \   0000000A   1A40               ANDS     R2,R3,R2
   1214            /* Set the Input Trigger source */
   1215            tmpsmcr |= TIM_InputTriggerSource;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1216            /* Write to TIMx SMCR */
   1217            TIMx->SMCR = tmpsmcr;
   \   0000000E   0281               STRH     R2,[R0, #+8]
   1218          }
   \   00000010   7047               BX       LR               ;; return
   1219          
   1220          /**
   1221            * @brief  Configures the TIMx Encoder Interface.
   1222            * @param TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1223            * @param  TIM_EncoderMode: specifies the TIMx Encoder Mode.
   1224            *   This parameter can be one of the following values:
   1225            *     @arg TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge depending on TI2FP2 level.
   1226            *     @arg TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge depending on TI1FP1 level.
   1227            *     @arg TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and TI2FP2 edges depending
   1228            *                                on the level of the other input.
   1229            * @param  TIM_IC1Polarity: specifies the IC1 Polarity
   1230            *   This parmeter can be one of the following values:
   1231            *     @arg TIM_ICPolarity_Falling: IC Falling edge.
   1232            *     @arg TIM_ICPolarity_Rising: IC Rising edge.
   1233            * @param  TIM_IC2Polarity: specifies the IC2 Polarity
   1234            *   This parmeter can be one of the following values:
   1235            *     @arg TIM_ICPolarity_Falling: IC Falling edge.
   1236            *     @arg TIM_ICPolarity_Rising: IC Rising edge.
   1237            * @retval None
   1238            */

   \                                 In section .text, align 2, keep-with-next
   1239          void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
   1240                                          uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
   1241          {
   \                     TIM_EncoderInterfaceConfig:
   \   00000000   F0B4               PUSH     {R4-R7}
   1242            uint16_t tmpsmcr = 0;
   \   00000002   0024               MOVS     R4,#+0
   1243            uint16_t tmpccmr1 = 0;
   \   00000004   0025               MOVS     R5,#+0
   1244            uint16_t tmpccer = 0;
   \   00000006   0026               MOVS     R6,#+0
   1245              
   1246            /* Check the parameters */
   1247            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1248            assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
   1249            assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
   1250            assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
   1251            /* Get the TIMx SMCR register value */
   1252            tmpsmcr = TIMx->SMCR;
   \   00000008   0789               LDRH     R7,[R0, #+8]
   \   0000000A   3C00               MOVS     R4,R7
   1253            /* Get the TIMx CCMR1 register value */
   1254            tmpccmr1 = TIMx->CCMR1;
   \   0000000C   078B               LDRH     R7,[R0, #+24]
   \   0000000E   3D00               MOVS     R5,R7
   1255            /* Get the TIMx CCER register value */
   1256            tmpccer = TIMx->CCER;
   \   00000010   078C               LDRH     R7,[R0, #+32]
   \   00000012   3E00               MOVS     R6,R7
   1257            /* Set the encoder Mode */
   1258            tmpsmcr &= ~TIM_SMCR_SMS;
   \   00000014   4FF6F877           MOVW     R7,#+65528
   \   00000018   3C40               ANDS     R4,R7,R4
   1259            tmpsmcr |= TIM_EncoderMode;
   \   0000001A   0C43               ORRS     R4,R1,R4
   1260            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   1261            tmpccmr1 &= (~TIM_CCMR1_CC1S) & (~TIM_CCMR1_CC2S);
   \   0000001C   4FF6FC41           MOVW     R1,#+64764
   \   00000020   0D40               ANDS     R5,R1,R5
   1262            tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
   \   00000022   40F20111           MOVW     R1,#+257
   \   00000026   0D43               ORRS     R5,R1,R5
   1263            /* Set the TI1 and the TI2 Polarities */
   1264            tmpccer &= (~TIM_CCER_CC1P) & (~TIM_CCER_CC2P);
   \   00000028   4FF6DD71           MOVW     R1,#+65501
   \   0000002C   0E40               ANDS     R6,R1,R6
   1265            tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
   \   0000002E   52EA0311           ORRS     R1,R2,R3, LSL #+4
   \   00000032   0E43               ORRS     R6,R1,R6
   1266            /* Write to TIMx SMCR */
   1267            TIMx->SMCR = tmpsmcr;
   \   00000034   0481               STRH     R4,[R0, #+8]
   1268            /* Write to TIMx CCMR1 */
   1269            TIMx->CCMR1 = tmpccmr1;
   \   00000036   0583               STRH     R5,[R0, #+24]
   1270            /* Write to TIMx CCER */
   1271            TIMx->CCER = tmpccer;
   \   00000038   0684               STRH     R6,[R0, #+32]
   1272          }
   \   0000003A   F0BC               POP      {R4-R7}
   \   0000003C   7047               BX       LR               ;; return
   1273          
   1274          /**
   1275            * @brief  Forces the TIMx output 1 waveform to active or inactive level.
   1276            * @param TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14 
   1277            *   to select the TIM peripheral.
   1278            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1279            *   This parameter can be one of the following values:
   1280            *     @arg TIM_ForcedAction_Active: Force active level on OC1REF
   1281            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
   1282            * @retval None
   1283            */

   \                                 In section .text, align 2, keep-with-next
   1284          void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1285          {
   1286            uint16_t tmpccmr1 = 0;
   \                     TIM_ForcedOC1Config:
   \   00000000   0022               MOVS     R2,#+0
   1287            /* Check the parameters */
   1288            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1289            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1290            tmpccmr1 = TIMx->CCMR1;
   \   00000002   038B               LDRH     R3,[R0, #+24]
   \   00000004   1A00               MOVS     R2,R3
   1291            /* Reset the OC1M Bits */
   1292            tmpccmr1 &= ~TIM_CCMR1_OC1M;
   \   00000006   4FF68F73           MOVW     R3,#+65423
   \   0000000A   1A40               ANDS     R2,R3,R2
   1293            /* Configure The Forced output Mode */
   1294            tmpccmr1 |= TIM_ForcedAction;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1295            /* Write to TIMx CCMR1 register */
   1296            TIMx->CCMR1 = tmpccmr1;
   \   0000000E   0283               STRH     R2,[R0, #+24]
   1297          }
   \   00000010   7047               BX       LR               ;; return
   1298          
   1299          /**
   1300            * @brief  Forces the TIMx output 2 waveform to active or inactive level.
   1301            * @param TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1302            *   peripheral.
   1303            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1304            *   This parameter can be one of the following values:
   1305            *     @arg TIM_ForcedAction_Active: Force active level on OC2REF
   1306            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
   1307            * @retval None
   1308            */

   \                                 In section .text, align 2, keep-with-next
   1309          void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1310          {
   1311            uint16_t tmpccmr1 = 0;
   \                     TIM_ForcedOC2Config:
   \   00000000   0022               MOVS     R2,#+0
   1312            /* Check the parameters */
   1313            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1314            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1315            tmpccmr1 = TIMx->CCMR1;
   \   00000002   038B               LDRH     R3,[R0, #+24]
   \   00000004   1A00               MOVS     R2,R3
   1316            /* Reset the OC2M Bits */
   1317            tmpccmr1 &= ~TIM_CCMR1_OC2M;
   \   00000006   48F6FF73           MOVW     R3,#+36863
   \   0000000A   1A40               ANDS     R2,R3,R2
   1318            /* Configure The Forced output Mode */
   1319            tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
   \   0000000C   52EA0122           ORRS     R2,R2,R1, LSL #+8
   1320            /* Write to TIMx CCMR1 register */
   1321            TIMx->CCMR1 = tmpccmr1;
   \   00000010   0283               STRH     R2,[R0, #+24]
   1322          }
   \   00000012   7047               BX       LR               ;; return
   1323          
   1324          /**
   1325            * @brief  Forces the TIMx output 3 waveform to active or inactive level.
   1326            * @param TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1327            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1328            *   This parameter can be one of the following values:
   1329            *     @arg TIM_ForcedAction_Active: Force active level on OC3REF
   1330            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
   1331            * @retval None
   1332            */

   \                                 In section .text, align 2, keep-with-next
   1333          void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1334          {
   1335            uint16_t tmpccmr2 = 0;
   \                     TIM_ForcedOC3Config:
   \   00000000   0022               MOVS     R2,#+0
   1336            /* Check the parameters */
   1337            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1338            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1339            tmpccmr2 = TIMx->CCMR2;
   \   00000002   838B               LDRH     R3,[R0, #+28]
   \   00000004   1A00               MOVS     R2,R3
   1340            /* Reset the OC1M Bits */
   1341            tmpccmr2 &= ~TIM_CCMR2_OC3M;
   \   00000006   4FF68F73           MOVW     R3,#+65423
   \   0000000A   1A40               ANDS     R2,R3,R2
   1342            /* Configure The Forced output Mode */
   1343            tmpccmr2 |= TIM_ForcedAction;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1344            /* Write to TIMx CCMR2 register */
   1345            TIMx->CCMR2 = tmpccmr2;
   \   0000000E   8283               STRH     R2,[R0, #+28]
   1346          }
   \   00000010   7047               BX       LR               ;; return
   1347          
   1348          /**
   1349            * @brief  Forces the TIMx output 4 waveform to active or inactive level.
   1350            * @param TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1351            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1352            *   This parameter can be one of the following values:
   1353            *     @arg TIM_ForcedAction_Active: Force active level on OC4REF
   1354            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
   1355            * @retval None
   1356            */

   \                                 In section .text, align 2, keep-with-next
   1357          void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1358          {
   1359            uint16_t tmpccmr2 = 0;
   \                     TIM_ForcedOC4Config:
   \   00000000   0022               MOVS     R2,#+0
   1360            /* Check the parameters */
   1361            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1362            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1363            tmpccmr2 = TIMx->CCMR2;
   \   00000002   838B               LDRH     R3,[R0, #+28]
   \   00000004   1A00               MOVS     R2,R3
   1364            /* Reset the OC2M Bits */
   1365            tmpccmr2 &= ~TIM_CCMR2_OC4M;
   \   00000006   48F6FF73           MOVW     R3,#+36863
   \   0000000A   1A40               ANDS     R2,R3,R2
   1366            /* Configure The Forced output Mode */
   1367            tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
   \   0000000C   52EA0122           ORRS     R2,R2,R1, LSL #+8
   1368            /* Write to TIMx CCMR2 register */
   1369            TIMx->CCMR2 = tmpccmr2;
   \   00000010   8283               STRH     R2,[R0, #+28]
   1370          }
   \   00000012   7047               BX       LR               ;; return
   1371          
   1372          /**
   1373            * @brief  Enables or disables TIMx peripheral Preload register on ARR.
   1374            * @param TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14 
   1375            *   to select the TIM peripheral.
   1376            * @param  NewState: new state of the TIMx peripheral Preload register
   1377            *   This parameter can be: ENABLE or DISABLE.
   1378            * @retval None
   1379            */

   \                                 In section .text, align 2, keep-with-next
   1380          void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
   1381          {
   1382            /* Check the parameters */
   1383            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1384            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1385            if (NewState != DISABLE)
   \                     TIM_ARRPreloadConfig:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??TIM_ARRPreloadConfig_0
   1386            {
   1387              /* Set the ARR Preload Bit */
   1388              TIMx->CR1 |= TIM_CR1_ARPE;
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   51F08001           ORRS     R1,R1,#0x80
   \   0000000C   0180               STRH     R1,[R0, #+0]
   \   0000000E   04E0               B.N      ??TIM_ARRPreloadConfig_1
   1389            }
   1390            else
   1391            {
   1392              /* Reset the ARR Preload Bit */
   1393              TIMx->CR1 &= ~TIM_CR1_ARPE;
   \                     ??TIM_ARRPreloadConfig_0:
   \   00000010   0188               LDRH     R1,[R0, #+0]
   \   00000012   4FF67F72           MOVW     R2,#+65407
   \   00000016   1140               ANDS     R1,R2,R1
   \   00000018   0180               STRH     R1,[R0, #+0]
   1394            }
   1395          }
   \                     ??TIM_ARRPreloadConfig_1:
   \   0000001A   7047               BX       LR               ;; return
   1396          
   1397          /**
   1398            * @brief  Selects the TIM peripheral Commutation event.
   1399            * @param TIMx: where x can be  1 or 8 to select the TIMx peripheral
   1400            * @param  NewState: new state of the Commutation event.
   1401            *   This parameter can be: ENABLE or DISABLE.
   1402            * @retval None
   1403            */

   \                                 In section .text, align 2, keep-with-next
   1404          void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
   1405          {
   1406            /* Check the parameters */
   1407            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1408            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1409            if (NewState != DISABLE)
   \                     TIM_SelectCOM:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??TIM_SelectCOM_0
   1410            {
   1411              /* Set the COM Bit */
   1412              TIMx->CR2 |= TIM_CR2_CCUS;
   \   00000006   8188               LDRH     R1,[R0, #+4]
   \   00000008   51F00401           ORRS     R1,R1,#0x4
   \   0000000C   8180               STRH     R1,[R0, #+4]
   \   0000000E   04E0               B.N      ??TIM_SelectCOM_1
   1413            }
   1414            else
   1415            {
   1416              /* Reset the COM Bit */
   1417              TIMx->CR2 &= ~TIM_CR2_CCUS;
   \                     ??TIM_SelectCOM_0:
   \   00000010   8188               LDRH     R1,[R0, #+4]
   \   00000012   4FF6FB72           MOVW     R2,#+65531
   \   00000016   1140               ANDS     R1,R2,R1
   \   00000018   8180               STRH     R1,[R0, #+4]
   1418            }
   1419          }
   \                     ??TIM_SelectCOM_1:
   \   0000001A   7047               BX       LR               ;; return
   1420          
   1421          /**
   1422            * @brief  Selects the TIMx peripheral Capture Compare DMA source.
   1423            * @param TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1424            * @param  NewState: new state of the Capture Compare DMA source
   1425            *   This parameter can be: ENABLE or DISABLE.
   1426            * @retval None
   1427            */

   \                                 In section .text, align 2, keep-with-next
   1428          void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
   1429          {
   1430            /* Check the parameters */
   1431            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1432            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1433            if (NewState != DISABLE)
   \                     TIM_SelectCCDMA:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??TIM_SelectCCDMA_0
   1434            {
   1435              /* Set the CCDS Bit */
   1436              TIMx->CR2 |= TIM_CR2_CCDS;
   \   00000006   8188               LDRH     R1,[R0, #+4]
   \   00000008   51F00801           ORRS     R1,R1,#0x8
   \   0000000C   8180               STRH     R1,[R0, #+4]
   \   0000000E   04E0               B.N      ??TIM_SelectCCDMA_1
   1437            }
   1438            else
   1439            {
   1440              /* Reset the CCDS Bit */
   1441              TIMx->CR2 &= ~TIM_CR2_CCDS;
   \                     ??TIM_SelectCCDMA_0:
   \   00000010   8188               LDRH     R1,[R0, #+4]
   \   00000012   4FF6F772           MOVW     R2,#+65527
   \   00000016   1140               ANDS     R1,R2,R1
   \   00000018   8180               STRH     R1,[R0, #+4]
   1442            }
   1443          }
   \                     ??TIM_SelectCCDMA_1:
   \   0000001A   7047               BX       LR               ;; return
   1444          
   1445          /**
   1446            * @brief  Sets or Resets the TIM peripheral Capture Compare Preload Control bit.
   1447            * @param  TIMx: where x can be  1 or 8 to select the TIMx peripheral
   1448            * @param  NewState: new state of the Capture Compare Preload Control bit
   1449            *   This parameter can be: ENABLE or DISABLE.
   1450            * @retval None
   1451            */

   \                                 In section .text, align 2, keep-with-next
   1452          void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
   1453          { 
   1454            /* Check the parameters */
   1455            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1456            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1457            if (NewState != DISABLE)
   \                     TIM_CCPreloadControl:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??TIM_CCPreloadControl_0
   1458            {
   1459              /* Set the CCPC Bit */
   1460              TIMx->CR2 |= TIM_CR2_CCPC;
   \   00000006   8188               LDRH     R1,[R0, #+4]
   \   00000008   51F00101           ORRS     R1,R1,#0x1
   \   0000000C   8180               STRH     R1,[R0, #+4]
   \   0000000E   04E0               B.N      ??TIM_CCPreloadControl_1
   1461            }
   1462            else
   1463            {
   1464              /* Reset the CCPC Bit */
   1465              TIMx->CR2 &= ~TIM_CR2_CCPC;
   \                     ??TIM_CCPreloadControl_0:
   \   00000010   8188               LDRH     R1,[R0, #+4]
   \   00000012   4FF6FE72           MOVW     R2,#+65534
   \   00000016   1140               ANDS     R1,R2,R1
   \   00000018   8180               STRH     R1,[R0, #+4]
   1466            }
   1467          }
   \                     ??TIM_CCPreloadControl_1:
   \   0000001A   7047               BX       LR               ;; return
   1468          
   1469          /**
   1470            * @brief  Enables or disables the TIMx peripheral Preload register on CCR1.
   1471            * @param TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14  
   1472            *   to select the TIM peripheral.
   1473            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1474            *   This parameter can be one of the following values:
   1475            *     @arg TIM_OCPreload_Enable
   1476            *     @arg TIM_OCPreload_Disable
   1477            * @retval None
   1478            */

   \                                 In section .text, align 2, keep-with-next
   1479          void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1480          {
   1481            uint16_t tmpccmr1 = 0;
   \                     TIM_OC1PreloadConfig:
   \   00000000   0022               MOVS     R2,#+0
   1482            /* Check the parameters */
   1483            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1484            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1485            tmpccmr1 = TIMx->CCMR1;
   \   00000002   038B               LDRH     R3,[R0, #+24]
   \   00000004   1A00               MOVS     R2,R3
   1486            /* Reset the OC1PE Bit */
   1487            tmpccmr1 &= (~TIM_CCMR1_OC1PE);
   \   00000006   4FF6F773           MOVW     R3,#+65527
   \   0000000A   1A40               ANDS     R2,R3,R2
   1488            /* Enable or Disable the Output Compare Preload feature */
   1489            tmpccmr1 |= TIM_OCPreload;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1490            /* Write to TIMx CCMR1 register */
   1491            TIMx->CCMR1 = tmpccmr1;
   \   0000000E   0283               STRH     R2,[R0, #+24]
   1492          }
   \   00000010   7047               BX       LR               ;; return
   1493          
   1494          /**
   1495            * @brief  Enables or disables the TIMx peripheral Preload register on CCR2.
   1496            * @param TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1497            *   peripheral.
   1498            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1499            *   This parameter can be one of the following values:
   1500            *     @arg TIM_OCPreload_Enable
   1501            *     @arg TIM_OCPreload_Disable
   1502            * @retval None
   1503            */

   \                                 In section .text, align 2, keep-with-next
   1504          void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1505          {
   1506            uint16_t tmpccmr1 = 0;
   \                     TIM_OC2PreloadConfig:
   \   00000000   0022               MOVS     R2,#+0
   1507            /* Check the parameters */
   1508            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1509            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1510            tmpccmr1 = TIMx->CCMR1;
   \   00000002   038B               LDRH     R3,[R0, #+24]
   \   00000004   1A00               MOVS     R2,R3
   1511            /* Reset the OC2PE Bit */
   1512            tmpccmr1 &= (~TIM_CCMR1_OC2PE);
   \   00000006   4FF2FF73           MOVW     R3,#+63487
   \   0000000A   1A40               ANDS     R2,R3,R2
   1513            /* Enable or Disable the Output Compare Preload feature */
   1514            tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
   \   0000000C   52EA0122           ORRS     R2,R2,R1, LSL #+8
   1515            /* Write to TIMx CCMR1 register */
   1516            TIMx->CCMR1 = tmpccmr1;
   \   00000010   0283               STRH     R2,[R0, #+24]
   1517          }
   \   00000012   7047               BX       LR               ;; return
   1518          
   1519          /**
   1520            * @brief  Enables or disables the TIMx peripheral Preload register on CCR3.
   1521            * @param TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1522            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1523            *   This parameter can be one of the following values:
   1524            *     @arg TIM_OCPreload_Enable
   1525            *     @arg TIM_OCPreload_Disable
   1526            * @retval None
   1527            */

   \                                 In section .text, align 2, keep-with-next
   1528          void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1529          {
   1530            uint16_t tmpccmr2 = 0;
   \                     TIM_OC3PreloadConfig:
   \   00000000   0022               MOVS     R2,#+0
   1531            /* Check the parameters */
   1532            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1533            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1534            tmpccmr2 = TIMx->CCMR2;
   \   00000002   838B               LDRH     R3,[R0, #+28]
   \   00000004   1A00               MOVS     R2,R3
   1535            /* Reset the OC3PE Bit */
   1536            tmpccmr2 &= (~TIM_CCMR2_OC3PE);
   \   00000006   4FF6F773           MOVW     R3,#+65527
   \   0000000A   1A40               ANDS     R2,R3,R2
   1537            /* Enable or Disable the Output Compare Preload feature */
   1538            tmpccmr2 |= TIM_OCPreload;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1539            /* Write to TIMx CCMR2 register */
   1540            TIMx->CCMR2 = tmpccmr2;
   \   0000000E   8283               STRH     R2,[R0, #+28]
   1541          }
   \   00000010   7047               BX       LR               ;; return
   1542          
   1543          /**
   1544            * @brief  Enables or disables the TIMx peripheral Preload register on CCR4.
   1545            * @param TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1546            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1547            *   This parameter can be one of the following values:
   1548            *     @arg TIM_OCPreload_Enable
   1549            *     @arg TIM_OCPreload_Disable
   1550            * @retval None
   1551            */

   \                                 In section .text, align 2, keep-with-next
   1552          void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1553          {
   1554            uint16_t tmpccmr2 = 0;
   \                     TIM_OC4PreloadConfig:
   \   00000000   0022               MOVS     R2,#+0
   1555            /* Check the parameters */
   1556            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1557            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1558            tmpccmr2 = TIMx->CCMR2;
   \   00000002   838B               LDRH     R3,[R0, #+28]
   \   00000004   1A00               MOVS     R2,R3
   1559            /* Reset the OC4PE Bit */
   1560            tmpccmr2 &= (~TIM_CCMR2_OC4PE);
   \   00000006   4FF2FF73           MOVW     R3,#+63487
   \   0000000A   1A40               ANDS     R2,R3,R2
   1561            /* Enable or Disable the Output Compare Preload feature */
   1562            tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
   \   0000000C   52EA0122           ORRS     R2,R2,R1, LSL #+8
   1563            /* Write to TIMx CCMR2 register */
   1564            TIMx->CCMR2 = tmpccmr2;
   \   00000010   8283               STRH     R2,[R0, #+28]
   1565          }
   \   00000012   7047               BX       LR               ;; return
   1566          
   1567          /**
   1568            * @brief  Configures the TIMx Output Compare 1 Fast feature.
   1569            * @param TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14  
   1570            *   to select the TIM peripheral.
   1571            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1572            *   This parameter can be one of the following values:
   1573            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1574            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1575            * @retval None
   1576            */

   \                                 In section .text, align 2, keep-with-next
   1577          void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1578          {
   1579            uint16_t tmpccmr1 = 0;
   \                     TIM_OC1FastConfig:
   \   00000000   0022               MOVS     R2,#+0
   1580            /* Check the parameters */
   1581            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1582            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1583            /* Get the TIMx CCMR1 register value */
   1584            tmpccmr1 = TIMx->CCMR1;
   \   00000002   038B               LDRH     R3,[R0, #+24]
   \   00000004   1A00               MOVS     R2,R3
   1585            /* Reset the OC1FE Bit */
   1586            tmpccmr1 &= ~TIM_CCMR1_OC1FE;
   \   00000006   4FF6FB73           MOVW     R3,#+65531
   \   0000000A   1A40               ANDS     R2,R3,R2
   1587            /* Enable or Disable the Output Compare Fast Bit */
   1588            tmpccmr1 |= TIM_OCFast;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1589            /* Write to TIMx CCMR1 */
   1590            TIMx->CCMR1 = tmpccmr1;
   \   0000000E   0283               STRH     R2,[R0, #+24]
   1591          }
   \   00000010   7047               BX       LR               ;; return
   1592          
   1593          /**
   1594            * @brief  Configures the TIMx Output Compare 2 Fast feature.
   1595            * @param TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1596            *   peripheral.
   1597            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1598            *   This parameter can be one of the following values:
   1599            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1600            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1601            * @retval None
   1602            */

   \                                 In section .text, align 2, keep-with-next
   1603          void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1604          {
   1605            uint16_t tmpccmr1 = 0;
   \                     TIM_OC2FastConfig:
   \   00000000   0022               MOVS     R2,#+0
   1606            /* Check the parameters */
   1607            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1608            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1609            /* Get the TIMx CCMR1 register value */
   1610            tmpccmr1 = TIMx->CCMR1;
   \   00000002   038B               LDRH     R3,[R0, #+24]
   \   00000004   1A00               MOVS     R2,R3
   1611            /* Reset the OC2FE Bit */
   1612            tmpccmr1 &= (~TIM_CCMR1_OC2FE);
   \   00000006   4FF6FF33           MOVW     R3,#+64511
   \   0000000A   1A40               ANDS     R2,R3,R2
   1613            /* Enable or Disable the Output Compare Fast Bit */
   1614            tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
   \   0000000C   52EA0122           ORRS     R2,R2,R1, LSL #+8
   1615            /* Write to TIMx CCMR1 */
   1616            TIMx->CCMR1 = tmpccmr1;
   \   00000010   0283               STRH     R2,[R0, #+24]
   1617          }
   \   00000012   7047               BX       LR               ;; return
   1618          
   1619          /**
   1620            * @brief  Configures the TIMx Output Compare 3 Fast feature.
   1621            * @param TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1622            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1623            *   This parameter can be one of the following values:
   1624            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1625            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1626            * @retval None
   1627            */

   \                                 In section .text, align 2, keep-with-next
   1628          void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1629          {
   1630            uint16_t tmpccmr2 = 0;
   \                     TIM_OC3FastConfig:
   \   00000000   0022               MOVS     R2,#+0
   1631            /* Check the parameters */
   1632            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1633            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1634            /* Get the TIMx CCMR2 register value */
   1635            tmpccmr2 = TIMx->CCMR2;
   \   00000002   838B               LDRH     R3,[R0, #+28]
   \   00000004   1A00               MOVS     R2,R3
   1636            /* Reset the OC3FE Bit */
   1637            tmpccmr2 &= ~TIM_CCMR2_OC3FE;
   \   00000006   4FF6FB73           MOVW     R3,#+65531
   \   0000000A   1A40               ANDS     R2,R3,R2
   1638            /* Enable or Disable the Output Compare Fast Bit */
   1639            tmpccmr2 |= TIM_OCFast;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1640            /* Write to TIMx CCMR2 */
   1641            TIMx->CCMR2 = tmpccmr2;
   \   0000000E   8283               STRH     R2,[R0, #+28]
   1642          }
   \   00000010   7047               BX       LR               ;; return
   1643          
   1644          /**
   1645            * @brief  Configures the TIMx Output Compare 4 Fast feature.
   1646            * @param TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1647            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1648            *   This parameter can be one of the following values:
   1649            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1650            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1651            * @retval None
   1652            */

   \                                 In section .text, align 2, keep-with-next
   1653          void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1654          {
   1655            uint16_t tmpccmr2 = 0;
   \                     TIM_OC4FastConfig:
   \   00000000   0022               MOVS     R2,#+0
   1656            /* Check the parameters */
   1657            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1658            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1659            /* Get the TIMx CCMR2 register value */
   1660            tmpccmr2 = TIMx->CCMR2;
   \   00000002   838B               LDRH     R3,[R0, #+28]
   \   00000004   1A00               MOVS     R2,R3
   1661            /* Reset the OC4FE Bit */
   1662            tmpccmr2 &= (~TIM_CCMR2_OC4FE);
   \   00000006   4FF6FF33           MOVW     R3,#+64511
   \   0000000A   1A40               ANDS     R2,R3,R2
   1663            /* Enable or Disable the Output Compare Fast Bit */
   1664            tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
   \   0000000C   52EA0122           ORRS     R2,R2,R1, LSL #+8
   1665            /* Write to TIMx CCMR2 */
   1666            TIMx->CCMR2 = tmpccmr2;
   \   00000010   8283               STRH     R2,[R0, #+28]
   1667          }
   \   00000012   7047               BX       LR               ;; return
   1668          
   1669          /**
   1670            * @brief  Clears or safeguards the OCREF1 signal on an external event
   1671            * @param TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14  
   1672            *   to select the TIM peripheral.
   1673            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1674            *   This parameter can be one of the following values:
   1675            *     @arg TIM_OCClear_Enable: TIM Output clear enable
   1676            *     @arg TIM_OCClear_Disable: TIM Output clear disable
   1677            * @retval None
   1678            */

   \                                 In section .text, align 2, keep-with-next
   1679          void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1680          {
   1681            uint16_t tmpccmr1 = 0;
   \                     TIM_ClearOC1Ref:
   \   00000000   0022               MOVS     R2,#+0
   1682            /* Check the parameters */
   1683            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1684            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1685            tmpccmr1 = TIMx->CCMR1;
   \   00000002   038B               LDRH     R3,[R0, #+24]
   \   00000004   1A00               MOVS     R2,R3
   1686            /* Reset the OC1CE Bit */
   1687            tmpccmr1 &= ~TIM_CCMR1_OC1CE;
   \   00000006   4FF67F73           MOVW     R3,#+65407
   \   0000000A   1A40               ANDS     R2,R3,R2
   1688            /* Enable or Disable the Output Compare Clear Bit */
   1689            tmpccmr1 |= TIM_OCClear;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1690            /* Write to TIMx CCMR1 register */
   1691            TIMx->CCMR1 = tmpccmr1;
   \   0000000E   0283               STRH     R2,[R0, #+24]
   1692          }
   \   00000010   7047               BX       LR               ;; return
   1693          
   1694          /**
   1695            * @brief  Clears or safeguards the OCREF2 signal on an external event
   1696            * @param TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1697            *   peripheral.
   1698            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1699            *   This parameter can be one of the following values:
   1700            *     @arg TIM_OCClear_Enable: TIM Output clear enable
   1701            *     @arg TIM_OCClear_Disable: TIM Output clear disable
   1702            * @retval None
   1703            */

   \                                 In section .text, align 2, keep-with-next
   1704          void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1705          {
   1706            uint16_t tmpccmr1 = 0;
   \                     TIM_ClearOC2Ref:
   \   00000000   0022               MOVS     R2,#+0
   1707            /* Check the parameters */
   1708            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1709            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1710            tmpccmr1 = TIMx->CCMR1;
   \   00000002   038B               LDRH     R3,[R0, #+24]
   \   00000004   1A00               MOVS     R2,R3
   1711            /* Reset the OC2CE Bit */
   1712            tmpccmr1 &= ~TIM_CCMR1_OC2CE;
   \   00000006   5204               LSLS     R2,R2,#+17
   \   00000008   520C               LSRS     R2,R2,#+17
   1713            /* Enable or Disable the Output Compare Clear Bit */
   1714            tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
   \   0000000A   52EA0122           ORRS     R2,R2,R1, LSL #+8
   1715            /* Write to TIMx CCMR1 register */
   1716            TIMx->CCMR1 = tmpccmr1;
   \   0000000E   0283               STRH     R2,[R0, #+24]
   1717          }
   \   00000010   7047               BX       LR               ;; return
   1718          
   1719          /**
   1720            * @brief  Clears or safeguards the OCREF3 signal on an external event
   1721            * @param TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1722            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1723            *   This parameter can be one of the following values:
   1724            *     @arg TIM_OCClear_Enable: TIM Output clear enable
   1725            *     @arg TIM_OCClear_Disable: TIM Output clear disable
   1726            * @retval None
   1727            */

   \                                 In section .text, align 2, keep-with-next
   1728          void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1729          {
   1730            uint16_t tmpccmr2 = 0;
   \                     TIM_ClearOC3Ref:
   \   00000000   0022               MOVS     R2,#+0
   1731            /* Check the parameters */
   1732            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1733            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1734            tmpccmr2 = TIMx->CCMR2;
   \   00000002   838B               LDRH     R3,[R0, #+28]
   \   00000004   1A00               MOVS     R2,R3
   1735            /* Reset the OC3CE Bit */
   1736            tmpccmr2 &= ~TIM_CCMR2_OC3CE;
   \   00000006   4FF67F73           MOVW     R3,#+65407
   \   0000000A   1A40               ANDS     R2,R3,R2
   1737            /* Enable or Disable the Output Compare Clear Bit */
   1738            tmpccmr2 |= TIM_OCClear;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1739            /* Write to TIMx CCMR2 register */
   1740            TIMx->CCMR2 = tmpccmr2;
   \   0000000E   8283               STRH     R2,[R0, #+28]
   1741          }
   \   00000010   7047               BX       LR               ;; return
   1742          
   1743          /**
   1744            * @brief  Clears or safeguards the OCREF4 signal on an external event
   1745            * @param TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1746            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1747            *   This parameter can be one of the following values:
   1748            *     @arg TIM_OCClear_Enable: TIM Output clear enable
   1749            *     @arg TIM_OCClear_Disable: TIM Output clear disable
   1750            * @retval None
   1751            */

   \                                 In section .text, align 2, keep-with-next
   1752          void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1753          {
   1754            uint16_t tmpccmr2 = 0;
   \                     TIM_ClearOC4Ref:
   \   00000000   0022               MOVS     R2,#+0
   1755            /* Check the parameters */
   1756            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1757            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1758            tmpccmr2 = TIMx->CCMR2;
   \   00000002   838B               LDRH     R3,[R0, #+28]
   \   00000004   1A00               MOVS     R2,R3
   1759            /* Reset the OC4CE Bit */
   1760            tmpccmr2 &= ~TIM_CCMR2_OC4CE;
   \   00000006   5204               LSLS     R2,R2,#+17
   \   00000008   520C               LSRS     R2,R2,#+17
   1761            /* Enable or Disable the Output Compare Clear Bit */
   1762            tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
   \   0000000A   52EA0122           ORRS     R2,R2,R1, LSL #+8
   1763            /* Write to TIMx CCMR2 register */
   1764            TIMx->CCMR2 = tmpccmr2;
   \   0000000E   8283               STRH     R2,[R0, #+28]
   1765          }
   \   00000010   7047               BX       LR               ;; return
   1766          
   1767          /**
   1768            * @brief  Configures the TIMx channel 1 polarity.
   1769            * @param TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14  
   1770            *   to select the TIM peripheral.
   1771            * @param  TIM_OCPolarity: specifies the OC1 Polarity
   1772            *   This parmeter can be one of the following values:
   1773            *     @arg TIM_OCPolarity_High: Output Compare active high
   1774            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1775            * @retval None
   1776            */

   \                                 In section .text, align 2, keep-with-next
   1777          void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1778          {
   1779            uint16_t tmpccer = 0;
   \                     TIM_OC1PolarityConfig:
   \   00000000   0022               MOVS     R2,#+0
   1780            /* Check the parameters */
   1781            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1782            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1783            tmpccer = TIMx->CCER;
   \   00000002   038C               LDRH     R3,[R0, #+32]
   \   00000004   1A00               MOVS     R2,R3
   1784            /* Set or Reset the CC1P Bit */
   1785            tmpccer &= (~TIM_CCER_CC1P);
   \   00000006   4FF6FD73           MOVW     R3,#+65533
   \   0000000A   1A40               ANDS     R2,R3,R2
   1786            tmpccer |= TIM_OCPolarity;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1787            /* Write to TIMx CCER register */
   1788            TIMx->CCER = tmpccer;
   \   0000000E   0284               STRH     R2,[R0, #+32]
   1789          }
   \   00000010   7047               BX       LR               ;; return
   1790          
   1791          /**
   1792            * @brief  Configures the TIMx Channel 1N polarity.
   1793            * @param TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1794            * @param  TIM_OCNPolarity: specifies the OC1N Polarity
   1795            *   This parmeter can be one of the following values:
   1796            *     @arg TIM_OCNPolarity_High: Output Compare active high
   1797            *     @arg TIM_OCNPolarity_Low: Output Compare active low
   1798            * @retval None
   1799            */

   \                                 In section .text, align 2, keep-with-next
   1800          void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1801          {
   1802            uint16_t tmpccer = 0;
   \                     TIM_OC1NPolarityConfig:
   \   00000000   0022               MOVS     R2,#+0
   1803            /* Check the parameters */
   1804            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1805            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1806             
   1807            tmpccer = TIMx->CCER;
   \   00000002   038C               LDRH     R3,[R0, #+32]
   \   00000004   1A00               MOVS     R2,R3
   1808            /* Set or Reset the CC1NP Bit */
   1809            tmpccer &= ~TIM_CCER_CC1NP;
   \   00000006   4FF6F773           MOVW     R3,#+65527
   \   0000000A   1A40               ANDS     R2,R3,R2
   1810            tmpccer |= TIM_OCNPolarity;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1811            /* Write to TIMx CCER register */
   1812            TIMx->CCER = tmpccer;
   \   0000000E   0284               STRH     R2,[R0, #+32]
   1813          }
   \   00000010   7047               BX       LR               ;; return
   1814          
   1815          /**
   1816            * @brief  Configures the TIMx channel 2 polarity.
   1817            * @param TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1818            *   peripheral.
   1819            * @param  TIM_OCPolarity: specifies the OC2 Polarity
   1820            *   This parmeter can be one of the following values:
   1821            *     @arg TIM_OCPolarity_High: Output Compare active high
   1822            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1823            * @retval None
   1824            */

   \                                 In section .text, align 2, keep-with-next
   1825          void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1826          {
   1827            uint16_t tmpccer = 0;
   \                     TIM_OC2PolarityConfig:
   \   00000000   0022               MOVS     R2,#+0
   1828            /* Check the parameters */
   1829            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1830            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1831            tmpccer = TIMx->CCER;
   \   00000002   038C               LDRH     R3,[R0, #+32]
   \   00000004   1A00               MOVS     R2,R3
   1832            /* Set or Reset the CC2P Bit */
   1833            tmpccer &= (~TIM_CCER_CC2P);
   \   00000006   4FF6DF73           MOVW     R3,#+65503
   \   0000000A   1A40               ANDS     R2,R3,R2
   1834            tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
   \   0000000C   52EA0112           ORRS     R2,R2,R1, LSL #+4
   1835            /* Write to TIMx CCER register */
   1836            TIMx->CCER = tmpccer;
   \   00000010   0284               STRH     R2,[R0, #+32]
   1837          }
   \   00000012   7047               BX       LR               ;; return
   1838          
   1839          /**
   1840            * @brief  Configures the TIMx Channel 2N polarity.
   1841            * @param TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1842            * @param  TIM_OCNPolarity: specifies the OC2N Polarity
   1843            *   This parmeter can be one of the following values:
   1844            *     @arg TIM_OCNPolarity_High: Output Compare active high
   1845            *     @arg TIM_OCNPolarity_Low: Output Compare active low
   1846            * @retval None
   1847            */

   \                                 In section .text, align 2, keep-with-next
   1848          void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1849          {
   1850            uint16_t tmpccer = 0;
   \                     TIM_OC2NPolarityConfig:
   \   00000000   0022               MOVS     R2,#+0
   1851            /* Check the parameters */
   1852            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1853            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1854            
   1855            tmpccer = TIMx->CCER;
   \   00000002   038C               LDRH     R3,[R0, #+32]
   \   00000004   1A00               MOVS     R2,R3
   1856            /* Set or Reset the CC2NP Bit */
   1857            tmpccer &= ~TIM_CCER_CC2NP;
   \   00000006   4FF67F73           MOVW     R3,#+65407
   \   0000000A   1A40               ANDS     R2,R3,R2
   1858            tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
   \   0000000C   52EA0112           ORRS     R2,R2,R1, LSL #+4
   1859            /* Write to TIMx CCER register */
   1860            TIMx->CCER = tmpccer;
   \   00000010   0284               STRH     R2,[R0, #+32]
   1861          }
   \   00000012   7047               BX       LR               ;; return
   1862          
   1863          /**
   1864            * @brief  Configures the TIMx channel 3 polarity.
   1865            * @param TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1866            * @param  TIM_OCPolarity: specifies the OC3 Polarity
   1867            *   This parmeter can be one of the following values:
   1868            *     @arg TIM_OCPolarity_High: Output Compare active high
   1869            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1870            * @retval None
   1871            */

   \                                 In section .text, align 2, keep-with-next
   1872          void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1873          {
   1874            uint16_t tmpccer = 0;
   \                     TIM_OC3PolarityConfig:
   \   00000000   0022               MOVS     R2,#+0
   1875            /* Check the parameters */
   1876            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1877            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1878            tmpccer = TIMx->CCER;
   \   00000002   038C               LDRH     R3,[R0, #+32]
   \   00000004   1A00               MOVS     R2,R3
   1879            /* Set or Reset the CC3P Bit */
   1880            tmpccer &= ~TIM_CCER_CC3P;
   \   00000006   4FF6FF53           MOVW     R3,#+65023
   \   0000000A   1A40               ANDS     R2,R3,R2
   1881            tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
   \   0000000C   52EA0122           ORRS     R2,R2,R1, LSL #+8
   1882            /* Write to TIMx CCER register */
   1883            TIMx->CCER = tmpccer;
   \   00000010   0284               STRH     R2,[R0, #+32]
   1884          }
   \   00000012   7047               BX       LR               ;; return
   1885          
   1886          /**
   1887            * @brief  Configures the TIMx Channel 3N polarity.
   1888            * @param TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1889            * @param  TIM_OCNPolarity: specifies the OC3N Polarity
   1890            *   This parmeter can be one of the following values:
   1891            *     @arg TIM_OCNPolarity_High: Output Compare active high
   1892            *     @arg TIM_OCNPolarity_Low: Output Compare active low
   1893            * @retval None
   1894            */

   \                                 In section .text, align 2, keep-with-next
   1895          void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1896          {
   1897            uint16_t tmpccer = 0;
   \                     TIM_OC3NPolarityConfig:
   \   00000000   0022               MOVS     R2,#+0
   1898           
   1899            /* Check the parameters */
   1900            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1901            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1902              
   1903            tmpccer = TIMx->CCER;
   \   00000002   038C               LDRH     R3,[R0, #+32]
   \   00000004   1A00               MOVS     R2,R3
   1904            /* Set or Reset the CC3NP Bit */
   1905            tmpccer &= ~TIM_CCER_CC3NP;
   \   00000006   4FF2FF73           MOVW     R3,#+63487
   \   0000000A   1A40               ANDS     R2,R3,R2
   1906            tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
   \   0000000C   52EA0122           ORRS     R2,R2,R1, LSL #+8
   1907            /* Write to TIMx CCER register */
   1908            TIMx->CCER = tmpccer;
   \   00000010   0284               STRH     R2,[R0, #+32]
   1909          }
   \   00000012   7047               BX       LR               ;; return
   1910          
   1911          /**
   1912            * @brief  Configures the TIMx channel 4 polarity.
   1913            * @param TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1914            * @param  TIM_OCPolarity: specifies the OC4 Polarity
   1915            *   This parmeter can be one of the following values:
   1916            *     @arg TIM_OCPolarity_High: Output Compare active high
   1917            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1918            * @retval None
   1919            */

   \                                 In section .text, align 2, keep-with-next
   1920          void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1921          {
   1922            uint16_t tmpccer = 0;
   \                     TIM_OC4PolarityConfig:
   \   00000000   0022               MOVS     R2,#+0
   1923            /* Check the parameters */
   1924            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1925            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1926            tmpccer = TIMx->CCER;
   \   00000002   038C               LDRH     R3,[R0, #+32]
   \   00000004   1A00               MOVS     R2,R3
   1927            /* Set or Reset the CC4P Bit */
   1928            tmpccer &= ~TIM_CCER_CC4P;
   \   00000006   4DF6FF73           MOVW     R3,#+57343
   \   0000000A   1A40               ANDS     R2,R3,R2
   1929            tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
   \   0000000C   52EA0132           ORRS     R2,R2,R1, LSL #+12
   1930            /* Write to TIMx CCER register */
   1931            TIMx->CCER = tmpccer;
   \   00000010   0284               STRH     R2,[R0, #+32]
   1932          }
   \   00000012   7047               BX       LR               ;; return
   1933          
   1934          /**
   1935            * @brief  Enables or disables the TIM Capture Compare Channel x.
   1936            * @param TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14 
   1937            *   to select the TIM peripheral.
   1938            * @param  TIM_Channel: specifies the TIM Channel
   1939            *   This parmeter can be one of the following values:
   1940            *     @arg TIM_Channel_1: TIM Channel 1
   1941            *     @arg TIM_Channel_2: TIM Channel 2
   1942            *     @arg TIM_Channel_3: TIM Channel 3
   1943            *     @arg TIM_Channel_4: TIM Channel 4
   1944            * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
   1945            *   This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
   1946            * @retval None
   1947            */

   \                                 In section .text, align 2, keep-with-next
   1948          void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
   1949          {
   \                     TIM_CCxCmd:
   \   00000000   10B4               PUSH     {R4}
   1950            uint16_t tmp = 0;
   \   00000002   0023               MOVS     R3,#+0
   1951            /* Check the parameters */
   1952            assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
   1953            assert_param(IS_TIM_CHANNEL(TIM_Channel));
   1954            assert_param(IS_TIM_CCX(TIM_CCx));
   1955          
   1956            tmp = CCER_CCE_Set << TIM_Channel;
   \   00000004   0124               MOVS     R4,#+1
   \   00000006   8C40               LSLS     R4,R4,R1
   \   00000008   2300               MOVS     R3,R4
   1957          
   1958            /* Reset the CCxE Bit */
   1959            TIMx->CCER &= (uint16_t)~ tmp;
   \   0000000A   048C               LDRH     R4,[R0, #+32]
   \   0000000C   34EA0303           BICS     R3,R4,R3
   \   00000010   0384               STRH     R3,[R0, #+32]
   1960          
   1961            /* Set or reset the CCxE Bit */ 
   1962            TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
   \   00000012   038C               LDRH     R3,[R0, #+32]
   \   00000014   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000016   12FA01F1           LSLS     R1,R2,R1
   \   0000001A   1943               ORRS     R1,R1,R3
   \   0000001C   0184               STRH     R1,[R0, #+32]
   1963          }
   \   0000001E   10BC               POP      {R4}
   \   00000020   7047               BX       LR               ;; return
   1964          
   1965          /**
   1966            * @brief  Enables or disables the TIM Capture Compare Channel xN.
   1967            * @param TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1968            * @param  TIM_Channel: specifies the TIM Channel
   1969            *   This parmeter can be one of the following values:
   1970            *     @arg TIM_Channel_1: TIM Channel 1
   1971            *     @arg TIM_Channel_2: TIM Channel 2
   1972            *     @arg TIM_Channel_3: TIM Channel 3
   1973            * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
   1974            *   This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
   1975            * @retval None
   1976            */

   \                                 In section .text, align 2, keep-with-next
   1977          void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
   1978          {
   \                     TIM_CCxNCmd:
   \   00000000   10B4               PUSH     {R4}
   1979            uint16_t tmp = 0;
   \   00000002   0023               MOVS     R3,#+0
   1980            /* Check the parameters */
   1981            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1982            assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
   1983            assert_param(IS_TIM_CCXN(TIM_CCxN));
   1984          
   1985            tmp = CCER_CCNE_Set << TIM_Channel;
   \   00000004   0424               MOVS     R4,#+4
   \   00000006   8C40               LSLS     R4,R4,R1
   \   00000008   2300               MOVS     R3,R4
   1986          
   1987            /* Reset the CCxNE Bit */
   1988            TIMx->CCER &= (uint16_t) ~tmp;
   \   0000000A   048C               LDRH     R4,[R0, #+32]
   \   0000000C   34EA0303           BICS     R3,R4,R3
   \   00000010   0384               STRH     R3,[R0, #+32]
   1989          
   1990            /* Set or reset the CCxNE Bit */ 
   1991            TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
   \   00000012   038C               LDRH     R3,[R0, #+32]
   \   00000014   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000016   12FA01F1           LSLS     R1,R2,R1
   \   0000001A   1943               ORRS     R1,R1,R3
   \   0000001C   0184               STRH     R1,[R0, #+32]
   1992          }
   \   0000001E   10BC               POP      {R4}
   \   00000020   7047               BX       LR               ;; return
   1993          
   1994          /**
   1995            * @brief  Selects the TIM Ouput Compare Mode.
   1996            * @note   This function disables the selected channel before changing the Ouput
   1997            *         Compare Mode.
   1998            *         User has to enable this channel using TIM_CCxCmd and TIM_CCxNCmd functions.
   1999            * @param TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14 
   2000            *   to select the TIM peripheral.
   2001            * @param  TIM_Channel: specifies the TIM Channel
   2002            *   This parmeter can be one of the following values:
   2003            *     @arg TIM_Channel_1: TIM Channel 1
   2004            *     @arg TIM_Channel_2: TIM Channel 2
   2005            *     @arg TIM_Channel_3: TIM Channel 3
   2006            *     @arg TIM_Channel_4: TIM Channel 4
   2007            * @param  TIM_OCMode: specifies the TIM Output Compare Mode.
   2008            *   This paramter can be one of the following values:
   2009            *     @arg TIM_OCMode_Timing
   2010            *     @arg TIM_OCMode_Active
   2011            *     @arg TIM_OCMode_Toggle
   2012            *     @arg TIM_OCMode_PWM1
   2013            *     @arg TIM_OCMode_PWM2
   2014            *     @arg TIM_ForcedAction_Active
   2015            *     @arg TIM_ForcedAction_InActive
   2016            * @retval None
   2017            */

   \                                 In section .text, align 2, keep-with-next
   2018          void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
   2019          {
   \                     TIM_SelectOCxM:
   \   00000000   30B4               PUSH     {R4,R5}
   2020            uint32_t tmp = 0;
   \   00000002   0023               MOVS     R3,#+0
   2021            uint16_t tmp1 = 0;
   \   00000004   0024               MOVS     R4,#+0
   2022          
   2023            /* Check the parameters */
   2024            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   2025            assert_param(IS_TIM_CHANNEL(TIM_Channel));
   2026            assert_param(IS_TIM_OCM(TIM_OCMode));
   2027          
   2028            tmp = (uint32_t) TIMx;
   \   00000006   0300               MOVS     R3,R0
   2029            tmp += CCMR_Offset;
   \   00000008   1833               ADDS     R3,R3,#+24
   2030          
   2031            tmp1 = CCER_CCE_Set << (uint16_t)TIM_Channel;
   \   0000000A   0125               MOVS     R5,#+1
   \   0000000C   8D40               LSLS     R5,R5,R1
   \   0000000E   2C00               MOVS     R4,R5
   2032          
   2033            /* Disable the Channel: Reset the CCxE Bit */
   2034            TIMx->CCER &= (uint16_t) ~tmp1;
   \   00000010   058C               LDRH     R5,[R0, #+32]
   \   00000012   35EA0404           BICS     R4,R5,R4
   \   00000016   0484               STRH     R4,[R0, #+32]
   2035          
   2036            if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
   \   00000018   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001A   0029               CMP      R1,#+0
   \   0000001C   02D0               BEQ.N    ??TIM_SelectOCxM_0
   \   0000001E   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000020   0829               CMP      R1,#+8
   \   00000022   0DD1               BNE.N    ??TIM_SelectOCxM_1
   2037            {
   2038              tmp += (TIM_Channel>>1);
   \                     ??TIM_SelectOCxM_0:
   \   00000024   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000026   4808               LSRS     R0,R1,#+1
   \   00000028   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002A   C318               ADDS     R3,R0,R3
   2039          
   2040              /* Reset the OCxM bits in the CCMRx register */
   2041              *(__IO uint32_t *) tmp &= CCMR_OC13M_Mask;
   \   0000002C   1868               LDR      R0,[R3, #+0]
   \   0000002E   4FF68F71           MOVW     R1,#+65423
   \   00000032   0840               ANDS     R0,R1,R0
   \   00000034   1860               STR      R0,[R3, #+0]
   2042             
   2043              /* Configure the OCxM bits in the CCMRx register */
   2044              *(__IO uint32_t *) tmp |= TIM_OCMode;
   \   00000036   1868               LDR      R0,[R3, #+0]
   \   00000038   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000003A   1043               ORRS     R0,R2,R0
   \   0000003C   1860               STR      R0,[R3, #+0]
   \   0000003E   0EE0               B.N      ??TIM_SelectOCxM_2
   2045            }
   2046            else
   2047            {
   2048              tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
   \                     ??TIM_SelectOCxM_1:
   \   00000040   081F               SUBS     R0,R1,#+4
   \   00000042   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000044   4008               LSRS     R0,R0,#+1
   \   00000046   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000048   C318               ADDS     R3,R0,R3
   2049          
   2050              /* Reset the OCxM bits in the CCMRx register */
   2051              *(__IO uint32_t *) tmp &= CCMR_OC24M_Mask;
   \   0000004A   1868               LDR      R0,[R3, #+0]
   \   0000004C   48F6FF71           MOVW     R1,#+36863
   \   00000050   0840               ANDS     R0,R1,R0
   \   00000052   1860               STR      R0,[R3, #+0]
   2052              
   2053              /* Configure the OCxM bits in the CCMRx register */
   2054              *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
   \   00000054   1868               LDR      R0,[R3, #+0]
   \   00000056   1102               LSLS     R1,R2,#+8
   \   00000058   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000005A   0843               ORRS     R0,R1,R0
   \   0000005C   1860               STR      R0,[R3, #+0]
   2055            }
   2056          }
   \                     ??TIM_SelectOCxM_2:
   \   0000005E   30BC               POP      {R4,R5}
   \   00000060   7047               BX       LR               ;; return
   2057          
   2058          /**
   2059            * @brief  Enables or Disables the TIMx Update event.
   2060            * @param TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2061            * @param  NewState: new state of the TIMx UDIS bit
   2062            *   This parameter can be: ENABLE or DISABLE.
   2063            * @retval None
   2064            */

   \                                 In section .text, align 2, keep-with-next
   2065          void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
   2066          {
   2067            /* Check the parameters */
   2068            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2069            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2070            if (NewState != DISABLE)
   \                     TIM_UpdateDisableConfig:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??TIM_UpdateDisableConfig_0
   2071            {
   2072              /* Set the Update Disable Bit */
   2073              TIMx->CR1 |= TIM_CR1_UDIS;
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   51F00201           ORRS     R1,R1,#0x2
   \   0000000C   0180               STRH     R1,[R0, #+0]
   \   0000000E   04E0               B.N      ??TIM_UpdateDisableConfig_1
   2074            }
   2075            else
   2076            {
   2077              /* Reset the Update Disable Bit */
   2078              TIMx->CR1 &= ~TIM_CR1_UDIS;
   \                     ??TIM_UpdateDisableConfig_0:
   \   00000010   0188               LDRH     R1,[R0, #+0]
   \   00000012   4FF6FD72           MOVW     R2,#+65533
   \   00000016   1140               ANDS     R1,R2,R1
   \   00000018   0180               STRH     R1,[R0, #+0]
   2079            }
   2080          }
   \                     ??TIM_UpdateDisableConfig_1:
   \   0000001A   7047               BX       LR               ;; return
   2081          
   2082          /**
   2083            * @brief  Configures the TIMx Update Request Interrupt source.
   2084            * @param TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2085            * @param  TIM_UpdateSource: specifies the Update source.
   2086            *   This parameter can be one of the following values:
   2087            *     @arg TIM_UpdateSource_Regular: Source of update is the counter overflow/underflow
   2088                                                 or the setting of UG bit, or an update generation
   2089                                                 through the slave mode controller.
   2090            *     @arg TIM_UpdateSource_Global: Source of update is counter overflow/underflow.
   2091            * @retval None
   2092            */

   \                                 In section .text, align 2, keep-with-next
   2093          void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
   2094          {
   2095            /* Check the parameters */
   2096            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2097            assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
   2098            if (TIM_UpdateSource != TIM_UpdateSource_Global)
   \                     TIM_UpdateRequestConfig:
   \   00000000   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??TIM_UpdateRequestConfig_0
   2099            {
   2100              /* Set the URS Bit */
   2101              TIMx->CR1 |= TIM_CR1_URS;
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   51F00401           ORRS     R1,R1,#0x4
   \   0000000C   0180               STRH     R1,[R0, #+0]
   \   0000000E   04E0               B.N      ??TIM_UpdateRequestConfig_1
   2102            }
   2103            else
   2104            {
   2105              /* Reset the URS Bit */
   2106              TIMx->CR1 &= ~TIM_CR1_URS;
   \                     ??TIM_UpdateRequestConfig_0:
   \   00000010   0188               LDRH     R1,[R0, #+0]
   \   00000012   4FF6FB72           MOVW     R2,#+65531
   \   00000016   1140               ANDS     R1,R2,R1
   \   00000018   0180               STRH     R1,[R0, #+0]
   2107            }
   2108          }
   \                     ??TIM_UpdateRequestConfig_1:
   \   0000001A   7047               BX       LR               ;; return
   2109          
   2110          /**
   2111            * @brief  Enables or disables the TIMxs Hall sensor interface.
   2112            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2113            * @param  NewState: new state of the TIMx Hall sensor interface.
   2114            *   This parameter can be: ENABLE or DISABLE.
   2115            * @retval None
   2116            */

   \                                 In section .text, align 2, keep-with-next
   2117          void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
   2118          {
   2119            /* Check the parameters */
   2120            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2121            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2122            if (NewState != DISABLE)
   \                     TIM_SelectHallSensor:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??TIM_SelectHallSensor_0
   2123            {
   2124              /* Set the TI1S Bit */
   2125              TIMx->CR2 |= TIM_CR2_TI1S;
   \   00000006   8188               LDRH     R1,[R0, #+4]
   \   00000008   51F08001           ORRS     R1,R1,#0x80
   \   0000000C   8180               STRH     R1,[R0, #+4]
   \   0000000E   04E0               B.N      ??TIM_SelectHallSensor_1
   2126            }
   2127            else
   2128            {
   2129              /* Reset the TI1S Bit */
   2130              TIMx->CR2 &= ~TIM_CR2_TI1S;
   \                     ??TIM_SelectHallSensor_0:
   \   00000010   8188               LDRH     R1,[R0, #+4]
   \   00000012   4FF67F72           MOVW     R2,#+65407
   \   00000016   1140               ANDS     R1,R2,R1
   \   00000018   8180               STRH     R1,[R0, #+4]
   2131            }
   2132          }
   \                     ??TIM_SelectHallSensor_1:
   \   0000001A   7047               BX       LR               ;; return
   2133          
   2134          /**
   2135            * @brief  Selects the TIMxs One Pulse Mode.
   2136            * @param TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2137            * @param  TIM_OPMode: specifies the OPM Mode to be used.
   2138            *   This parameter can be one of the following values:
   2139            *     @arg TIM_OPMode_Single
   2140            *     @arg TIM_OPMode_Repetitive
   2141            * @retval None
   2142            */

   \                                 In section .text, align 2, keep-with-next
   2143          void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
   2144          {
   2145            /* Check the parameters */
   2146            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2147            assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
   2148            /* Reset the OPM Bit */
   2149            TIMx->CR1 &= ~TIM_CR1_OPM;
   \                     TIM_SelectOnePulseMode:
   \   00000000   0288               LDRH     R2,[R0, #+0]
   \   00000002   4FF6F773           MOVW     R3,#+65527
   \   00000006   1A40               ANDS     R2,R3,R2
   \   00000008   0280               STRH     R2,[R0, #+0]
   2150            /* Configure the OPM Mode */
   2151            TIMx->CR1 |= TIM_OPMode;
   \   0000000A   0288               LDRH     R2,[R0, #+0]
   \   0000000C   1143               ORRS     R1,R1,R2
   \   0000000E   0180               STRH     R1,[R0, #+0]
   2152          }
   \   00000010   7047               BX       LR               ;; return
   2153          
   2154          /**
   2155            * @brief  Selects the TIMx Trigger Output Mode.
   2156            * @param TIMx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the TIM peripheral.
   2157            * @param  TIM_TRGOSource: specifies the Trigger Output source.
   2158            *   This paramter can be one of the following values:
   2159            *
   2160            *  - For all TIMx
   2161            *     @arg TIM_TRGOSource_Reset:  The UG bit in the TIM_EGR register is used as the trigger output (TRGO).
   2162            *     @arg TIM_TRGOSource_Enable: The Counter Enable CEN is used as the trigger output (TRGO).
   2163            *     @arg TIM_TRGOSource_Update: The update event is selected as the trigger output (TRGO).
   2164            *
   2165            *  - For all TIMx except TIM6 and TIM7
   2166            *     @arg TIM_TRGOSource_OC1: The trigger output sends a positive pulse when the CC1IF flag
   2167            *                              is to be set, as soon as a capture or compare match occurs (TRGO).
   2168            *     @arg TIM_TRGOSource_OC1Ref: OC1REF signal is used as the trigger output (TRGO).
   2169            *     @arg TIM_TRGOSource_OC2Ref: OC2REF signal is used as the trigger output (TRGO).
   2170            *     @arg TIM_TRGOSource_OC3Ref: OC3REF signal is used as the trigger output (TRGO).
   2171            *     @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output (TRGO).
   2172            *
   2173            * @retval None
   2174            */

   \                                 In section .text, align 2, keep-with-next
   2175          void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
   2176          {
   2177            /* Check the parameters */
   2178            assert_param(IS_TIM_LIST5_PERIPH(TIMx));
   2179            assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
   2180          
   2181            /* Reset the MMS Bits */
   2182            TIMx->CR2 &= ~TIM_CR2_MMS;
   \                     TIM_SelectOutputTrigger:
   \   00000000   8288               LDRH     R2,[R0, #+4]
   \   00000002   4FF68F73           MOVW     R3,#+65423
   \   00000006   1A40               ANDS     R2,R3,R2
   \   00000008   8280               STRH     R2,[R0, #+4]
   2183            /* Select the TRGO source */
   2184            TIMx->CR2 |=  TIM_TRGOSource;
   \   0000000A   8288               LDRH     R2,[R0, #+4]
   \   0000000C   1143               ORRS     R1,R1,R2
   \   0000000E   8180               STRH     R1,[R0, #+4]
   2185          }
   \   00000010   7047               BX       LR               ;; return
   2186          
   2187          /**
   2188            * @brief  Selects the TIMx Slave Mode.
   2189            * @param TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM peripheral.
   2190            * @param  TIM_SlaveMode: specifies the Timer Slave Mode.
   2191            *   This paramter can be one of the following values:
   2192            *     @arg TIM_SlaveMode_Reset: Rising edge of the selected trigger signal (TRGI) re-initializes
   2193            *                               the counter and triggers an update of the registers.
   2194            *     @arg TIM_SlaveMode_Gated:     The counter clock is enabled when the trigger signal (TRGI) is high.
   2195            *     @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI.
   2196            *     @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter.
   2197            * @retval None
   2198            */

   \                                 In section .text, align 2, keep-with-next
   2199          void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
   2200          {
   2201            /* Check the parameters */
   2202            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2203            assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
   2204            /* Reset the SMS Bits */
   2205            TIMx->SMCR &= ~TIM_SMCR_SMS;
   \                     TIM_SelectSlaveMode:
   \   00000000   0289               LDRH     R2,[R0, #+8]
   \   00000002   4FF6F873           MOVW     R3,#+65528
   \   00000006   1A40               ANDS     R2,R3,R2
   \   00000008   0281               STRH     R2,[R0, #+8]
   2206            /* Select the Slave Mode */
   2207            TIMx->SMCR |= TIM_SlaveMode;
   \   0000000A   0289               LDRH     R2,[R0, #+8]
   \   0000000C   1143               ORRS     R1,R1,R2
   \   0000000E   0181               STRH     R1,[R0, #+8]
   2208          }
   \   00000010   7047               BX       LR               ;; return
   2209          
   2210          /**
   2211            * @brief  Sets or Resets the TIMx Master/Slave Mode.
   2212            * @param TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM peripheral.
   2213            * @param  TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
   2214            *   This paramter can be one of the following values:
   2215            *     @arg TIM_MasterSlaveMode_Enable: synchronization between the current timer
   2216            *                                      and its slaves (through TRGO).
   2217            *     @arg TIM_MasterSlaveMode_Disable: No action
   2218            * @retval None
   2219            */

   \                                 In section .text, align 2, keep-with-next
   2220          void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
   2221          {
   2222            /* Check the parameters */
   2223            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2224            assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
   2225            /* Reset the MSM Bit */
   2226            TIMx->SMCR &= ~TIM_SMCR_MSM;
   \                     TIM_SelectMasterSlaveMode:
   \   00000000   0289               LDRH     R2,[R0, #+8]
   \   00000002   4FF67F73           MOVW     R3,#+65407
   \   00000006   1A40               ANDS     R2,R3,R2
   \   00000008   0281               STRH     R2,[R0, #+8]
   2227            
   2228            /* Set or Reset the MSM Bit */
   2229            TIMx->SMCR |= TIM_MasterSlaveMode;
   \   0000000A   0289               LDRH     R2,[R0, #+8]
   \   0000000C   1143               ORRS     R1,R1,R2
   \   0000000E   0181               STRH     R1,[R0, #+8]
   2230          }
   \   00000010   7047               BX       LR               ;; return
   2231          
   2232          /**
   2233            * @brief  Sets the TIMx Counter Register value
   2234            * @param TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2235            * @param  TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2236            * @param  Counter: specifies the Counter register new value.
   2237            * @retval None
   2238            */

   \                                 In section .text, align 2, keep-with-next
   2239          void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
   2240          {
   2241            /* Check the parameters */
   2242             assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2243            /* Set the Counter Register value */
   2244            TIMx->CNT = Counter;
   \                     TIM_SetCounter:
   \   00000000   4162               STR      R1,[R0, #+36]
   2245          }
   \   00000002   7047               BX       LR               ;; return
   2246          
   2247          /**
   2248            * @brief  Sets the TIMx Autoreload Register value
   2249            * @param TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2250            * @param  Autoreload: specifies the Autoreload register new value.
   2251            * @retval None
   2252            */

   \                                 In section .text, align 2, keep-with-next
   2253          void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
   2254          {
   2255            /* Check the parameters */
   2256            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2257            /* Set the Autoreload Register value */
   2258            TIMx->ARR = Autoreload;
   \                     TIM_SetAutoreload:
   \   00000000   C162               STR      R1,[R0, #+44]
   2259          }
   \   00000002   7047               BX       LR               ;; return
   2260          
   2261          /**
   2262            * @brief  Sets the TIMx Capture Compare1 Register value
   2263            * @param TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14 
   2264            *   to select the TIM peripheral.
   2265            * @param  Compare1: specifies the Capture Compare1 register new value.
   2266            * @retval None
   2267            */

   \                                 In section .text, align 2, keep-with-next
   2268          void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
   2269          {
   2270            /* Check the parameters */
   2271            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   2272            /* Set the Capture Compare1 Register value */
   2273            TIMx->CCR1 = Compare1;
   \                     TIM_SetCompare1:
   \   00000000   4163               STR      R1,[R0, #+52]
   2274          }
   \   00000002   7047               BX       LR               ;; return
   2275          
   2276          /**
   2277            * @brief  Sets the TIMx Capture Compare2 Register value
   2278            * @param TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2279            *   peripheral.
   2280            * @param  Compare2: specifies the Capture Compare2 register new value.
   2281            * @retval None
   2282            */

   \                                 In section .text, align 2, keep-with-next
   2283          void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
   2284          {
   2285            /* Check the parameters */
   2286            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2287            /* Set the Capture Compare2 Register value */
   2288            TIMx->CCR2 = Compare2;
   \                     TIM_SetCompare2:
   \   00000000   8163               STR      R1,[R0, #+56]
   2289          }
   \   00000002   7047               BX       LR               ;; return
   2290          
   2291          /**
   2292            * @brief  Sets the TIMx Capture Compare3 Register value
   2293            * @param TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2294            * @param  Compare3: specifies the Capture Compare3 register new value.
   2295            * @retval None
   2296            */

   \                                 In section .text, align 2, keep-with-next
   2297          void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
   2298          {
   2299            /* Check the parameters */
   2300            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2301            /* Set the Capture Compare3 Register value */
   2302            TIMx->CCR3 = Compare3;
   \                     TIM_SetCompare3:
   \   00000000   C163               STR      R1,[R0, #+60]
   2303          }
   \   00000002   7047               BX       LR               ;; return
   2304          
   2305          /**
   2306            * @brief  Sets the TIMx Capture Compare4 Register value
   2307            * @param TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2308            * @param  Compare4: specifies the Capture Compare4 register new value.
   2309            * @retval None
   2310            */

   \                                 In section .text, align 2, keep-with-next
   2311          void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
   2312          {
   2313            /* Check the parameters */
   2314            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2315            /* Set the Capture Compare4 Register value */
   2316            TIMx->CCR4 = Compare4;
   \                     TIM_SetCompare4:
   \   00000000   0164               STR      R1,[R0, #+64]
   2317          }
   \   00000002   7047               BX       LR               ;; return
   2318          
   2319          /**
   2320            * @brief  Sets the TIMx Input Capture 1 prescaler.
   2321            * @param TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14 
   2322            *   to select the TIM peripheral.
   2323            * @param  TIM_ICPSC: specifies the Input Capture1 prescaler new value.
   2324            *   This parameter can be one of the following values:
   2325            *     @arg TIM_ICPSC_DIV1: no prescaler
   2326            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2327            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2328            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2329            * @retval None
   2330            */

   \                                 In section .text, align 2, keep-with-next
   2331          void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2332          {
   2333            /* Check the parameters */
   2334            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   2335            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2336            /* Reset the IC1PSC Bits */
   2337            TIMx->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \                     TIM_SetIC1Prescaler:
   \   00000000   028B               LDRH     R2,[R0, #+24]
   \   00000002   4FF6F373           MOVW     R3,#+65523
   \   00000006   1A40               ANDS     R2,R3,R2
   \   00000008   0283               STRH     R2,[R0, #+24]
   2338            /* Set the IC1PSC value */
   2339            TIMx->CCMR1 |= TIM_ICPSC;
   \   0000000A   028B               LDRH     R2,[R0, #+24]
   \   0000000C   1143               ORRS     R1,R1,R2
   \   0000000E   0183               STRH     R1,[R0, #+24]
   2340          }
   \   00000010   7047               BX       LR               ;; return
   2341          
   2342          /**
   2343            * @brief  Sets the TIMx Input Capture 2 prescaler.
   2344            * @param TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2345            *   peripheral.
   2346            * @param  TIM_ICPSC: specifies the Input Capture2 prescaler new value.
   2347            *   This parameter can be one of the following values:
   2348            *     @arg TIM_ICPSC_DIV1: no prescaler
   2349            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2350            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2351            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2352            * @retval None
   2353            */

   \                                 In section .text, align 2, keep-with-next
   2354          void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2355          {
   2356            /* Check the parameters */
   2357            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2358            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2359            /* Reset the IC2PSC Bits */
   2360            TIMx->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \                     TIM_SetIC2Prescaler:
   \   00000000   028B               LDRH     R2,[R0, #+24]
   \   00000002   4FF2FF33           MOVW     R3,#+62463
   \   00000006   1A40               ANDS     R2,R3,R2
   \   00000008   0283               STRH     R2,[R0, #+24]
   2361            /* Set the IC2PSC value */
   2362            TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
   \   0000000A   028B               LDRH     R2,[R0, #+24]
   \   0000000C   52EA0121           ORRS     R1,R2,R1, LSL #+8
   \   00000010   0183               STRH     R1,[R0, #+24]
   2363          }
   \   00000012   7047               BX       LR               ;; return
   2364          
   2365          /**
   2366            * @brief  Sets the TIMx Input Capture 3 prescaler.
   2367            * @param TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2368            * @param  TIM_ICPSC: specifies the Input Capture3 prescaler new value.
   2369            *   This parameter can be one of the following values:
   2370            *     @arg TIM_ICPSC_DIV1: no prescaler
   2371            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2372            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2373            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2374            * @retval None
   2375            */

   \                                 In section .text, align 2, keep-with-next
   2376          void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2377          {
   2378            /* Check the parameters */
   2379            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2380            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2381            /* Reset the IC3PSC Bits */
   2382            TIMx->CCMR2 &= ~TIM_CCMR2_IC3PSC;
   \                     TIM_SetIC3Prescaler:
   \   00000000   828B               LDRH     R2,[R0, #+28]
   \   00000002   4FF6F373           MOVW     R3,#+65523
   \   00000006   1A40               ANDS     R2,R3,R2
   \   00000008   8283               STRH     R2,[R0, #+28]
   2383            /* Set the IC3PSC value */
   2384            TIMx->CCMR2 |= TIM_ICPSC;
   \   0000000A   828B               LDRH     R2,[R0, #+28]
   \   0000000C   1143               ORRS     R1,R1,R2
   \   0000000E   8183               STRH     R1,[R0, #+28]
   2385          }
   \   00000010   7047               BX       LR               ;; return
   2386          
   2387          /**
   2388            * @brief  Sets the TIMx Input Capture 4 prescaler.
   2389            * @param TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2390            * @param  TIM_ICPSC: specifies the Input Capture4 prescaler new value.
   2391            *   This parameter can be one of the following values:
   2392            *     @arg TIM_ICPSC_DIV1: no prescaler
   2393            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2394            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2395            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2396            * @retval None
   2397            */

   \                                 In section .text, align 2, keep-with-next
   2398          void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2399          {  
   2400            /* Check the parameters */
   2401            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2402            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2403            /* Reset the IC4PSC Bits */
   2404            TIMx->CCMR2 &= ~TIM_CCMR2_IC4PSC;
   \                     TIM_SetIC4Prescaler:
   \   00000000   828B               LDRH     R2,[R0, #+28]
   \   00000002   4FF2FF33           MOVW     R3,#+62463
   \   00000006   1A40               ANDS     R2,R3,R2
   \   00000008   8283               STRH     R2,[R0, #+28]
   2405            /* Set the IC4PSC value */
   2406            TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
   \   0000000A   828B               LDRH     R2,[R0, #+28]
   \   0000000C   52EA0121           ORRS     R1,R2,R1, LSL #+8
   \   00000010   8183               STRH     R1,[R0, #+28]
   2407          }
   \   00000012   7047               BX       LR               ;; return
   2408          
   2409          /**
   2410            * @brief  Sets the TIMx Clock Division value.
   2411            * @param TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2412            * @param  TIM_CKD: specifies the clock division value.
   2413            *   This parameter can be one of the following value:
   2414            *     @arg TIM_CKD_DIV1: TDTS = Tck_tim
   2415            *     @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim
   2416            *     @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim
   2417            * @retval None
   2418            */

   \                                 In section .text, align 2, keep-with-next
   2419          void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
   2420          {
   2421            /* Check the parameters */
   2422            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   2423            assert_param(IS_TIM_CKD_DIV(TIM_CKD));
   2424            /* Reset the CKD Bits */
   2425            TIMx->CR1 &= (~TIM_CR1_CKD);
   \                     TIM_SetClockDivision:
   \   00000000   0288               LDRH     R2,[R0, #+0]
   \   00000002   4FF6FF43           MOVW     R3,#+64767
   \   00000006   1A40               ANDS     R2,R3,R2
   \   00000008   0280               STRH     R2,[R0, #+0]
   2426            /* Set the CKD value */
   2427            TIMx->CR1 |= TIM_CKD;
   \   0000000A   0288               LDRH     R2,[R0, #+0]
   \   0000000C   1143               ORRS     R1,R1,R2
   \   0000000E   0180               STRH     R1,[R0, #+0]
   2428          }
   \   00000010   7047               BX       LR               ;; return
   2429          
   2430          /**
   2431            * @brief  Gets the TIMx Input Capture 1 value.
   2432            * @param TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14 
   2433            *   to select the TIM peripheral.
   2434            * @retval Capture Compare 1 Register value.
   2435            */

   \                                 In section .text, align 2, keep-with-next
   2436          uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
   2437          {
   2438            /* Check the parameters */
   2439            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   2440            /* Get the Capture 1 Register value */
   2441            return TIMx->CCR1;
   \                     TIM_GetCapture1:
   \   00000000   406B               LDR      R0,[R0, #+52]
   \   00000002   7047               BX       LR               ;; return
   2442          }
   2443          
   2444          /**
   2445            * @brief  Gets the TIMx Input Capture 2 value.
   2446            * @param TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2447            *   peripheral.
   2448            * @retval Capture Compare 2 Register value.
   2449            */

   \                                 In section .text, align 2, keep-with-next
   2450          uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
   2451          {
   2452            /* Check the parameters */
   2453            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2454            /* Get the Capture 2 Register value */
   2455            return TIMx->CCR2;
   \                     TIM_GetCapture2:
   \   00000000   806B               LDR      R0,[R0, #+56]
   \   00000002   7047               BX       LR               ;; return
   2456          }
   2457          
   2458          /**
   2459            * @brief  Gets the TIMx Input Capture 3 value.
   2460            * @param TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2461            * @retval Capture Compare 3 Register value.
   2462            */

   \                                 In section .text, align 2, keep-with-next
   2463          uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
   2464          {
   2465            /* Check the parameters */
   2466            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
   2467            /* Get the Capture 3 Register value */
   2468            return TIMx->CCR3;
   \                     TIM_GetCapture3:
   \   00000000   C06B               LDR      R0,[R0, #+60]
   \   00000002   7047               BX       LR               ;; return
   2469          }
   2470          
   2471          /**
   2472            * @brief  Gets the TIMx Input Capture 4 value.
   2473            * @param TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2474            * @retval Capture Compare 4 Register value.
   2475            */

   \                                 In section .text, align 2, keep-with-next
   2476          uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
   2477          {
   2478            /* Check the parameters */
   2479            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2480            /* Get the Capture 4 Register value */
   2481            return TIMx->CCR4;
   \                     TIM_GetCapture4:
   \   00000000   006C               LDR      R0,[R0, #+64]
   \   00000002   7047               BX       LR               ;; return
   2482          }
   2483          
   2484          /**
   2485            * @brief  Gets the TIMx Counter value.
   2486            * @param TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2487            * @retval Counter Register value
   2488            */

   \                                 In section .text, align 2, keep-with-next
   2489          uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
   2490          {
   2491            /* Check the parameters */
   2492            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2493            /* Get the Counter Register value */
   2494            return TIMx->CNT;
   \                     TIM_GetCounter:
   \   00000000   406A               LDR      R0,[R0, #+36]
   \   00000002   7047               BX       LR               ;; return
   2495          }
   2496          
   2497          /**
   2498            * @brief  Gets the TIMx Prescaler value.
   2499            * @param TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2500            * @retval Prescaler Register value.
   2501            */

   \                                 In section .text, align 2, keep-with-next
   2502          uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
   2503          {
   2504            /* Check the parameters */
   2505            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2506            /* Get the Prescaler Register value */
   2507            return TIMx->PSC;
   \                     TIM_GetPrescaler:
   \   00000000   008D               LDRH     R0,[R0, #+40]
   \   00000002   7047               BX       LR               ;; return
   2508          }
   2509          
   2510          /**
   2511            * @brief  Configures the TIM2 and TIM5 Remapping input Capabilities.
   2512            * @param TIMx: where x can be 2, 5 or 11 to select the TIM peripheral.
   2513            * @param TIM_Remap: specifies the TIM input reampping source.
   2514            *   This parameter can be one of the following values:
   2515            * @arg TIM2_TIM8_TRGO: TIM2 ITR1 is connected to TIM8 Trigger output(default)
   2516            * @arg TIM2_ETH_PTP: TIM2 ITR1 is connected to ETH PTP trogger output.
   2517            * @arg TIM2_USBFS_SOF: TIM2 ITR1 is connected to USB FS SOF. 
   2518            * @arg TIM2_USBHS_SOF: TIM2 ITR1 is connected to USB HS SOF. 
   2519            * @arg TIM5_GPIO: TIM5 Channel 4 is connected to dedicated Timer pin(default)
   2520            * @arg TIM5_LSI: TIM5 Channel 4 is connected to LSI clock.
   2521            * @arg TIM5_LSE: TIM5 Channel 4 is connected to LSE clock.
   2522            * @arg TIM5_RTC: TIM5 Channel 4 is connected to RTC Output event.
   2523            * @arg TIM11_GPIO: TIM11 Channel 1 is connected to dedicated Timer pin(default) 
   2524            * @arg TIM11_HSE: TIM11 Channel 1 is connected to HSE clock.   
   2525            * @retval : None
   2526            */

   \                                 In section .text, align 2, keep-with-next
   2527          void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
   2528          {
   2529           /* Check the parameters */
   2530            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   2531            assert_param(IS_TIM_REMAP(TIM_Remap));
   2532          
   2533            /* Set the Timer remapping configuration */
   2534            TIMx->OR =  TIM_Remap;
   \                     TIM_RemapConfig:
   \   00000000   A0F85010           STRH     R1,[R0, #+80]
   2535          }
   \   00000004   7047               BX       LR               ;; return
   2536          
   2537          /**
   2538            * @brief  Checks whether the specified TIM flag is set or not.
   2539            * @param TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2540            * @param  TIM_FLAG: specifies the flag to check.
   2541            *   This parameter can be one of the following values:
   2542            *     @arg TIM_FLAG_Update: TIM update Flag
   2543            *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2544            *     @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2545            *     @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2546            *     @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2547            *     @arg TIM_FLAG_COM: TIM Commutation Flag
   2548            *     @arg TIM_FLAG_Trigger: TIM Trigger Flag
   2549            *     @arg TIM_FLAG_Break: TIM Break Flag
   2550            *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
   2551            *     @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
   2552            *     @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
   2553            *     @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
   2554            * @note
   2555            *   - TIM6 and TIM7 can have only one update flag. 
   2556            *   - TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.    
   2557            * @retval The new state of TIM_FLAG (SET or RESET).
   2558            */

   \                                 In section .text, align 2, keep-with-next
   2559          FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
   2560          { 
   2561            ITStatus bitstatus = RESET;  
   \                     TIM_GetFlagStatus:
   \   00000000   0022               MOVS     R2,#+0
   2562            /* Check the parameters */
   2563            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2564            assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
   2565          
   2566            
   2567            if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
   \   00000002   008A               LDRH     R0,[R0, #+16]
   \   00000004   0842               TST      R0,R1
   \   00000006   01D0               BEQ.N    ??TIM_GetFlagStatus_0
   2568            {
   2569              bitstatus = SET;
   \   00000008   0122               MOVS     R2,#+1
   \   0000000A   00E0               B.N      ??TIM_GetFlagStatus_1
   2570            }
   2571            else
   2572            {
   2573              bitstatus = RESET;
   \                     ??TIM_GetFlagStatus_0:
   \   0000000C   0022               MOVS     R2,#+0
   2574            }
   2575            return bitstatus;
   \                     ??TIM_GetFlagStatus_1:
   \   0000000E   1000               MOVS     R0,R2
   \   00000010   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   7047               BX       LR               ;; return
   2576          }
   2577          
   2578          /**
   2579            * @brief  Clears the TIMx's pending flags.
   2580            * @param TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2581            * @param  TIM_FLAG: specifies the flag bit to clear.
   2582            *   This parameter can be any combination of the following values:
   2583            *     @arg TIM_FLAG_Update: TIM update Flag
   2584            *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2585            *     @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2586            *     @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2587            *     @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2588            *     @arg TIM_FLAG_COM: TIM Commutation Flag
   2589            *     @arg TIM_FLAG_Trigger: TIM Trigger Flag
   2590            *     @arg TIM_FLAG_Break: TIM Break Flag
   2591            *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
   2592            *     @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
   2593            *     @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
   2594            *     @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
   2595            * @note
   2596            *   - TIM6 and TIM7 can have only one update flag. 
   2597            *   - TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.  
   2598            * @retval None
   2599            */

   \                                 In section .text, align 2, keep-with-next
   2600          void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
   2601          {  
   2602            /* Check the parameters */
   2603            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2604             
   2605            /* Clear the flags */
   2606            TIMx->SR = (uint16_t)~TIM_FLAG;
   \                     TIM_ClearFlag:
   \   00000000   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   C943               MVNS     R1,R1
   \   00000004   0182               STRH     R1,[R0, #+16]
   2607          }
   \   00000006   7047               BX       LR               ;; return
   2608          
   2609          /**
   2610            * @brief  Checks whether the TIM interrupt has occurred or not.
   2611            * @param TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2612            * @param  TIM_IT: specifies the TIM interrupt source to check.
   2613            *   This parameter can be one of the following values:
   2614            *     @arg TIM_IT_Update: TIM update Interrupt source
   2615            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2616            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2617            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2618            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2619            *     @arg TIM_IT_COM: TIM Commutation Interrupt source
   2620            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2621            *     @arg TIM_IT_Break: TIM Break Interrupt source
   2622            * @note
   2623            *   - TIM6 and TIM7 can generate only an update interrupt.
   2624            *   - TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.  
   2625            * @retval The new state of the TIM_IT(SET or RESET).
   2626            */

   \                                 In section .text, align 2, keep-with-next
   2627          ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
   2628          {
   \                     TIM_GetITStatus:
   \   00000000   30B4               PUSH     {R4,R5}
   2629            ITStatus bitstatus = RESET;  
   \   00000002   0022               MOVS     R2,#+0
   2630            uint16_t itstatus = 0x0, itenable = 0x0;
   \   00000004   0023               MOVS     R3,#+0
   \   00000006   0024               MOVS     R4,#+0
   2631            /* Check the parameters */
   2632            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2633            assert_param(IS_TIM_GET_IT(TIM_IT));
   2634             
   2635            itstatus = TIMx->SR & TIM_IT;
   \   00000008   058A               LDRH     R5,[R0, #+16]
   \   0000000A   0D40               ANDS     R5,R1,R5
   \   0000000C   2B00               MOVS     R3,R5
   2636            
   2637            itenable = TIMx->DIER & TIM_IT;
   \   0000000E   8089               LDRH     R0,[R0, #+12]
   \   00000010   0840               ANDS     R0,R1,R0
   \   00000012   0400               MOVS     R4,R0
   2638            if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
   \   00000014   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000016   002B               CMP      R3,#+0
   \   00000018   04D0               BEQ.N    ??TIM_GetITStatus_0
   \   0000001A   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001C   002C               CMP      R4,#+0
   \   0000001E   01D0               BEQ.N    ??TIM_GetITStatus_0
   2639            {
   2640              bitstatus = SET;
   \   00000020   0122               MOVS     R2,#+1
   \   00000022   00E0               B.N      ??TIM_GetITStatus_1
   2641            }
   2642            else
   2643            {
   2644              bitstatus = RESET;
   \                     ??TIM_GetITStatus_0:
   \   00000024   0022               MOVS     R2,#+0
   2645            }
   2646            return bitstatus;
   \                     ??TIM_GetITStatus_1:
   \   00000026   1000               MOVS     R0,R2
   \   00000028   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   30BC               POP      {R4,R5}
   \   0000002C   7047               BX       LR               ;; return
   2647          }
   2648          
   2649          /**
   2650            * @brief  Clears the TIMx's interrupt pending bits.
   2651            * @param TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2652            * @param  TIM_IT: specifies the pending bit to clear.
   2653            *   This parameter can be any combination of the following values:
   2654            *     @arg TIM_IT_Update: TIM1 update Interrupt source
   2655            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2656            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2657            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2658            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2659            *     @arg TIM_IT_COM: TIM Commutation Interrupt source
   2660            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2661            *     @arg TIM_IT_Break: TIM Break Interrupt source
   2662            * @note
   2663            *   - TIM6 and TIM7 can generate only an update interrupt.
   2664            *   - TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.    
   2665            * @retval None
   2666            */

   \                                 In section .text, align 2, keep-with-next
   2667          void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
   2668          {
   2669            /* Check the parameters */
   2670            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2671          
   2672            /* Clear the IT pending Bit */
   2673            TIMx->SR = (uint16_t)~TIM_IT;
   \                     TIM_ClearITPendingBit:
   \   00000000   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   C943               MVNS     R1,R1
   \   00000004   0182               STRH     R1,[R0, #+16]
   2674          }
   \   00000006   7047               BX       LR               ;; return
   2675          
   2676          /**
   2677            * @brief  Configure the TI1 as Input.
   2678            * @param TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14 
   2679            *   to select the TIM peripheral.
   2680            * @param  TIM_ICPolarity : The Input Polarity.
   2681            *   This parameter can be one of the following values:
   2682            *     @arg TIM_ICPolarity_Rising
   2683            *     @arg TIM_ICPolarity_Falling
   2684            *     @arg TIM_ICPolarity_BothEdge  
   2685            * @param  TIM_ICSelection: specifies the input to be used.
   2686            *   This parameter can be one of the following values:
   2687            *     @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
   2688            *     @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
   2689            *     @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
   2690            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2691            *   This parameter must be a value between 0x00 and 0x0F.
   2692            * @retval None
   2693            */

   \                                 In section .text, align 2, keep-with-next
   2694          static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2695                                 uint16_t TIM_ICFilter)
   2696          {
   \                     TI1_Config:
   \   00000000   F0B4               PUSH     {R4-R7}
   2697            uint16_t tmpccmr1 = 0, tmpccer = 0;
   \   00000002   0024               MOVS     R4,#+0
   \   00000004   0025               MOVS     R5,#+0
   2698            /* Disable the Channel 1: Reset the CC1E Bit */
   2699            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000006   068C               LDRH     R6,[R0, #+32]
   \   00000008   4FF6FE77           MOVW     R7,#+65534
   \   0000000C   3E40               ANDS     R6,R7,R6
   \   0000000E   0684               STRH     R6,[R0, #+32]
   2700            tmpccmr1 = TIMx->CCMR1;
   \   00000010   068B               LDRH     R6,[R0, #+24]
   \   00000012   3400               MOVS     R4,R6
   2701            tmpccer = TIMx->CCER;
   \   00000014   068C               LDRH     R6,[R0, #+32]
   \   00000016   3500               MOVS     R5,R6
   2702            /* Select the Input and set the filter */
   2703            tmpccmr1 &= (~TIM_CCMR1_CC1S) & (~TIM_CCMR1_IC1F);
   \   00000018   4FF60C76           MOVW     R6,#+65292
   \   0000001C   3440               ANDS     R4,R6,R4
   2704             tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   \   0000001E   52EA0312           ORRS     R2,R2,R3, LSL #+4
   \   00000022   1443               ORRS     R4,R2,R4
   2705            /* Select the Polarity and set the CC1E Bit */
   2706            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   \   00000024   4FF6F572           MOVW     R2,#+65525
   \   00000028   1540               ANDS     R5,R2,R5
   2707            tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
   \   0000002A   51F00101           ORRS     R1,R1,#0x1
   \   0000002E   0D43               ORRS     R5,R1,R5
   2708            /* Write to TIMx CCMR1 and CCER registers */
   2709            TIMx->CCMR1 = tmpccmr1;
   \   00000030   0483               STRH     R4,[R0, #+24]
   2710            TIMx->CCER = tmpccer;
   \   00000032   0584               STRH     R5,[R0, #+32]
   2711          }
   \   00000034   F0BC               POP      {R4-R7}
   \   00000036   7047               BX       LR               ;; return
   2712          
   2713          /**
   2714            * @brief  Configure the TI2 as Input.
   2715            * @param TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2716            *   peripheral.
   2717            * @param  TIM_ICPolarity : The Input Polarity.
   2718            *   This parameter can be one of the following values:
   2719            *     @arg TIM_ICPolarity_Rising
   2720            *     @arg TIM_ICPolarity_Falling
   2721            *     @arg TIM_ICPolarity_BothEdge   
   2722            * @param  TIM_ICSelection: specifies the input to be used.
   2723            *   This parameter can be one of the following values:
   2724            *     @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
   2725            *     @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
   2726            *     @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
   2727            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2728            *   This parameter must be a value between 0x00 and 0x0F.
   2729            * @retval None
   2730            */

   \                                 In section .text, align 2, keep-with-next
   2731          static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2732                                 uint16_t TIM_ICFilter)
   2733          {
   \                     TI2_Config:
   \   00000000   F0B4               PUSH     {R4-R7}
   2734            uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
   \   00000002   0025               MOVS     R5,#+0
   \   00000004   0026               MOVS     R6,#+0
   \   00000006   0024               MOVS     R4,#+0
   2735            /* Disable the Channel 2: Reset the CC2E Bit */
   2736            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000008   078C               LDRH     R7,[R0, #+32]
   \   0000000A   4FF6EF7C           MOVW     R12,#+65519
   \   0000000E   1CEA0707           ANDS     R7,R12,R7
   \   00000012   0784               STRH     R7,[R0, #+32]
   2737            tmpccmr1 = TIMx->CCMR1;
   \   00000014   078B               LDRH     R7,[R0, #+24]
   \   00000016   3D00               MOVS     R5,R7
   2738            tmpccer = TIMx->CCER;
   \   00000018   078C               LDRH     R7,[R0, #+32]
   \   0000001A   3E00               MOVS     R6,R7
   2739            tmp = (uint16_t)(TIM_ICPolarity << 4);
   \   0000001C   0901               LSLS     R1,R1,#+4
   \   0000001E   0C00               MOVS     R4,R1
   2740            /* Select the Input and set the filter */
   2741            tmpccmr1 &= (~TIM_CCMR1_CC2S) & (~TIM_CCMR1_IC2F);
   \   00000020   40F6FF41           MOVW     R1,#+3327
   \   00000024   0D40               ANDS     R5,R1,R5
   2742            tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
   \   00000026   55EA0335           ORRS     R5,R5,R3, LSL #+12
   2743            tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
   \   0000002A   55EA0225           ORRS     R5,R5,R2, LSL #+8
   2744            /* Select the Polarity and set the CC2E Bit */
   2745            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   \   0000002E   4FF65F71           MOVW     R1,#+65375
   \   00000032   0E40               ANDS     R6,R1,R6
   2746            tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
   \   00000034   54F01001           ORRS     R1,R4,#0x10
   \   00000038   0E43               ORRS     R6,R1,R6
   2747            /* Write to TIMx CCMR1 and CCER registers */
   2748            TIMx->CCMR1 = tmpccmr1 ;
   \   0000003A   0583               STRH     R5,[R0, #+24]
   2749            TIMx->CCER = tmpccer;
   \   0000003C   0684               STRH     R6,[R0, #+32]
   2750          }
   \   0000003E   F0BC               POP      {R4-R7}
   \   00000040   7047               BX       LR               ;; return
   2751          
   2752          /**
   2753            * @brief  Configure the TI3 as Input.
   2754            * @param TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2755            * @param  TIM_ICPolarity : The Input Polarity.
   2756            *   This parameter can be one of the following values:
   2757            *     @arg TIM_ICPolarity_Rising
   2758            *     @arg TIM_ICPolarity_Falling
   2759            *     @arg TIM_ICPolarity_BothEdge         
   2760            * @param  TIM_ICSelection: specifies the input to be used.
   2761            *   This parameter can be one of the following values:
   2762            *     @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
   2763            *     @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
   2764            *     @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
   2765            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2766            *   This parameter must be a value between 0x00 and 0x0F.
   2767            * @retval None
   2768            */

   \                                 In section .text, align 2, keep-with-next
   2769          static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2770                                 uint16_t TIM_ICFilter)
   2771          {
   \                     TI3_Config:
   \   00000000   F0B4               PUSH     {R4-R7}
   2772            uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   \   00000002   0026               MOVS     R6,#+0
   \   00000004   0024               MOVS     R4,#+0
   \   00000006   0025               MOVS     R5,#+0
   2773            /* Disable the Channel 3: Reset the CC3E Bit */
   2774            TIMx->CCER &= ~TIM_CCER_CC3E;
   \   00000008   078C               LDRH     R7,[R0, #+32]
   \   0000000A   4FF6FF6C           MOVW     R12,#+65279
   \   0000000E   1CEA0707           ANDS     R7,R12,R7
   \   00000012   0784               STRH     R7,[R0, #+32]
   2775            tmpccmr2 = TIMx->CCMR2;
   \   00000014   878B               LDRH     R7,[R0, #+28]
   \   00000016   3E00               MOVS     R6,R7
   2776            tmpccer = TIMx->CCER;
   \   00000018   078C               LDRH     R7,[R0, #+32]
   \   0000001A   3C00               MOVS     R4,R7
   2777            tmp = (uint16_t)(TIM_ICPolarity << 8);
   \   0000001C   0902               LSLS     R1,R1,#+8
   \   0000001E   0D00               MOVS     R5,R1
   2778            /* Select the Input and set the filter */
   2779            tmpccmr2 &= (~TIM_CCMR1_CC1S) & (~TIM_CCMR2_IC3F);
   \   00000020   4FF60C71           MOVW     R1,#+65292
   \   00000024   0E40               ANDS     R6,R1,R6
   2780            tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   \   00000026   52EA0311           ORRS     R1,R2,R3, LSL #+4
   \   0000002A   0E43               ORRS     R6,R1,R6
   2781            /* Select the Polarity and set the CC3E Bit */
   2782            tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   \   0000002C   4FF2FF51           MOVW     R1,#+62975
   \   00000030   0C40               ANDS     R4,R1,R4
   2783            tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
   \   00000032   4FF48071           MOV      R1,#+256
   \   00000036   2943               ORRS     R1,R1,R5
   \   00000038   0C43               ORRS     R4,R1,R4
   2784            /* Write to TIMx CCMR2 and CCER registers */
   2785            TIMx->CCMR2 = tmpccmr2;
   \   0000003A   8683               STRH     R6,[R0, #+28]
   2786            TIMx->CCER = tmpccer;
   \   0000003C   0484               STRH     R4,[R0, #+32]
   2787          }
   \   0000003E   F0BC               POP      {R4-R7}
   \   00000040   7047               BX       LR               ;; return
   2788          
   2789          /**
   2790            * @brief  Configure the TI4 as Input.
   2791            * @param TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2792            * @param  TIM_ICPolarity : The Input Polarity.
   2793            *   This parameter can be one of the following values:
   2794            *     @arg TIM_ICPolarity_Rising
   2795            *     @arg TIM_ICPolarity_Falling
   2796            *     @arg TIM_ICPolarity_BothEdge     
   2797            * @param  TIM_ICSelection: specifies the input to be used.
   2798            *   This parameter can be one of the following values:
   2799            *     @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
   2800            *     @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
   2801            *     @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
   2802            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2803            *   This parameter must be a value between 0x00 and 0x0F.
   2804            * @retval None
   2805            */

   \                                 In section .text, align 2, keep-with-next
   2806          static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2807                                 uint16_t TIM_ICFilter)
   2808          {
   \                     TI4_Config:
   \   00000000   F0B4               PUSH     {R4-R7}
   2809            uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   \   00000002   0025               MOVS     R5,#+0
   \   00000004   0026               MOVS     R6,#+0
   \   00000006   0024               MOVS     R4,#+0
   2810            /* Disable the Channel 4: Reset the CC4E Bit */
   2811            TIMx->CCER &= ~TIM_CCER_CC4E;
   \   00000008   078C               LDRH     R7,[R0, #+32]
   \   0000000A   4EF6FF7C           MOVW     R12,#+61439
   \   0000000E   1CEA0707           ANDS     R7,R12,R7
   \   00000012   0784               STRH     R7,[R0, #+32]
   2812            tmpccmr2 = TIMx->CCMR2;
   \   00000014   878B               LDRH     R7,[R0, #+28]
   \   00000016   3D00               MOVS     R5,R7
   2813            tmpccer = TIMx->CCER;
   \   00000018   078C               LDRH     R7,[R0, #+32]
   \   0000001A   3E00               MOVS     R6,R7
   2814            tmp = (uint16_t)(TIM_ICPolarity << 12);
   \   0000001C   0903               LSLS     R1,R1,#+12
   \   0000001E   0C00               MOVS     R4,R1
   2815            /* Select the Input and set the filter */
   2816            tmpccmr2 &= (~TIM_CCMR1_CC2S) & (~TIM_CCMR1_IC2F);
   \   00000020   40F6FF41           MOVW     R1,#+3327
   \   00000024   0D40               ANDS     R5,R1,R5
   2817            tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
   \   00000026   55EA0225           ORRS     R5,R5,R2, LSL #+8
   2818            tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
   \   0000002A   55EA0335           ORRS     R5,R5,R3, LSL #+12
   2819          
   2820            /* Select the Polarity and set the CC4E Bit */
   2821            tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   \   0000002E   45F6FF71           MOVW     R1,#+24575
   \   00000032   0E40               ANDS     R6,R1,R6
   2822            tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
   \   00000034   54F48051           ORRS     R1,R4,#0x1000
   \   00000038   0E43               ORRS     R6,R1,R6
   2823            /* Write to TIMx CCMR2 and CCER registers */
   2824            TIMx->CCMR2 = tmpccmr2;
   \   0000003A   8583               STRH     R5,[R0, #+28]
   2825            TIMx->CCER = tmpccer ;
   \   0000003C   0684               STRH     R6,[R0, #+32]
   2826          }
   \   0000003E   F0BC               POP      {R4-R7}
   \   00000040   7047               BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   00000140           DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   00040040           DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   00080040           DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   000C0040           DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   00100040           DC32     0x40001000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   00140040           DC32     0x40001400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   00040140           DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   00400140           DC32     0x40014000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   00440140           DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   00480140           DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   00180040           DC32     0x40001800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   001C0040           DC32     0x40001c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   00200040           DC32     0x40002000
   2827          
   2828          /**
   2829            * @}
   2830            */
   2831          
   2832          /**
   2833            * @}
   2834            */
   2835          
   2836          /**
   2837            * @}
   2838            */
   2839          
   2840          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                    .cstack
     --------                    -------
     TI1_Config                      16
     TI2_Config                      16
     TI3_Config                      16
     TI4_Config                      16
     TIM_ARRPreloadConfig             0
     TIM_BDTRConfig                   0
     TIM_BDTRStructInit               0
     TIM_CCPreloadControl             0
     TIM_CCxCmd                       4
     TIM_CCxNCmd                      4
     TIM_ClearFlag                    0
     TIM_ClearITPendingBit            0
     TIM_ClearOC1Ref                  0
     TIM_ClearOC2Ref                  0
     TIM_ClearOC3Ref                  0
     TIM_ClearOC4Ref                  0
     TIM_Cmd                          0
     TIM_CounterModeConfig            0
     TIM_CtrlPWMOutputs               0
     TIM_DMACmd                       0
     TIM_DMAConfig                    0
     TIM_DeInit                       8
     TIM_ETRClockMode1Config         16
     TIM_ETRClockMode2Config          8
     TIM_ETRConfig                    8
     TIM_EncoderInterfaceConfig      16
     TIM_ForcedOC1Config              0
     TIM_ForcedOC2Config              0
     TIM_ForcedOC3Config              0
     TIM_ForcedOC4Config              0
     TIM_GenerateEvent                0
     TIM_GetCapture1                  0
     TIM_GetCapture2                  0
     TIM_GetCapture3                  0
     TIM_GetCapture4                  0
     TIM_GetCounter                   0
     TIM_GetFlagStatus                0
     TIM_GetITStatus                  8
     TIM_GetPrescaler                 0
     TIM_ICInit                      16
     TIM_ICStructInit                 0
     TIM_ITConfig                     0
     TIM_ITRxExternalClockConfig      8
     TIM_InternalClockConfig          0
     TIM_OC1FastConfig                0
     TIM_OC1Init                     12
     TIM_OC1NPolarityConfig           0
     TIM_OC1PolarityConfig            0
     TIM_OC1PreloadConfig             0
     TIM_OC2FastConfig                0
     TIM_OC2Init                     12
     TIM_OC2NPolarityConfig           0
     TIM_OC2PolarityConfig            0
     TIM_OC2PreloadConfig             0
     TIM_OC3FastConfig                0
     TIM_OC3Init                     12
     TIM_OC3NPolarityConfig           0
     TIM_OC3PolarityConfig            0
     TIM_OC3PreloadConfig             0
     TIM_OC4FastConfig                0
     TIM_OC4Init                     12
     TIM_OC4PolarityConfig            0
     TIM_OC4PreloadConfig             0
     TIM_OCStructInit                 0
     TIM_PWMIConfig                  24
     TIM_PrescalerConfig              0
     TIM_RemapConfig                  0
     TIM_SelectCCDMA                  0
     TIM_SelectCOM                    0
     TIM_SelectHallSensor             0
     TIM_SelectInputTrigger           0
     TIM_SelectMasterSlaveMode        0
     TIM_SelectOCxM                   8
     TIM_SelectOnePulseMode           0
     TIM_SelectOutputTrigger          0
     TIM_SelectSlaveMode              0
     TIM_SetAutoreload                0
     TIM_SetClockDivision             0
     TIM_SetCompare1                  0
     TIM_SetCompare2                  0
     TIM_SetCompare3                  0
     TIM_SetCompare4                  0
     TIM_SetCounter                   0
     TIM_SetIC1Prescaler              0
     TIM_SetIC2Prescaler              0
     TIM_SetIC3Prescaler              0
     TIM_SetIC4Prescaler              0
     TIM_TIxExternalClockConfig      16
     TIM_TimeBaseInit                 0
     TIM_TimeBaseStructInit           0
     TIM_UpdateDisableConfig          0
     TIM_UpdateRequestConfig          0


   Section sizes:

     Function/Label              Bytes
     --------------              -----
     TIM_DeInit                   362
     TIM_TimeBaseInit             106
     TIM_OC1Init                  126
     TIM_OC2Init                  140
     TIM_OC3Init                  138
     TIM_OC4Init                  104
     TIM_ICInit                   112
     TIM_PWMIConfig               132
     TIM_BDTRConfig                32
     TIM_TimeBaseStructInit        24
     TIM_OCStructInit              34
     TIM_ICStructInit              22
     TIM_BDTRStructInit            30
     TIM_Cmd                       28
     TIM_CtrlPWMOutputs            34
     TIM_ITConfig                  24
     TIM_GenerateEvent              4
     TIM_DMAConfig                  8
     TIM_DMACmd                    24
     TIM_InternalClockConfig       12
     TIM_ITRxExternalClockConfig   22
     TIM_TIxExternalClockConfig    60
     TIM_ETRClockMode1Config       46
     TIM_ETRClockMode2Config       26
     TIM_ETRConfig                 24
     TIM_PrescalerConfig            6
     TIM_CounterModeConfig         18
     TIM_SelectInputTrigger        18
     TIM_EncoderInterfaceConfig    62
     TIM_ForcedOC1Config           18
     TIM_ForcedOC2Config           20
     TIM_ForcedOC3Config           18
     TIM_ForcedOC4Config           20
     TIM_ARRPreloadConfig          28
     TIM_SelectCOM                 28
     TIM_SelectCCDMA               28
     TIM_CCPreloadControl          28
     TIM_OC1PreloadConfig          18
     TIM_OC2PreloadConfig          20
     TIM_OC3PreloadConfig          18
     TIM_OC4PreloadConfig          20
     TIM_OC1FastConfig             18
     TIM_OC2FastConfig             20
     TIM_OC3FastConfig             18
     TIM_OC4FastConfig             20
     TIM_ClearOC1Ref               18
     TIM_ClearOC2Ref               18
     TIM_ClearOC3Ref               18
     TIM_ClearOC4Ref               18
     TIM_OC1PolarityConfig         18
     TIM_OC1NPolarityConfig        18
     TIM_OC2PolarityConfig         20
     TIM_OC2NPolarityConfig        20
     TIM_OC3PolarityConfig         20
     TIM_OC3NPolarityConfig        20
     TIM_OC4PolarityConfig         20
     TIM_CCxCmd                    34
     TIM_CCxNCmd                   34
     TIM_SelectOCxM                98
     TIM_UpdateDisableConfig       28
     TIM_UpdateRequestConfig       28
     TIM_SelectHallSensor          28
     TIM_SelectOnePulseMode        18
     TIM_SelectOutputTrigger       18
     TIM_SelectSlaveMode           18
     TIM_SelectMasterSlaveMode     18
     TIM_SetCounter                 4
     TIM_SetAutoreload              4
     TIM_SetCompare1                4
     TIM_SetCompare2                4
     TIM_SetCompare3                4
     TIM_SetCompare4                4
     TIM_SetIC1Prescaler           18
     TIM_SetIC2Prescaler           20
     TIM_SetIC3Prescaler           18
     TIM_SetIC4Prescaler           20
     TIM_SetClockDivision          18
     TIM_GetCapture1                4
     TIM_GetCapture2                4
     TIM_GetCapture3                4
     TIM_GetCapture4                4
     TIM_GetCounter                 4
     TIM_GetPrescaler               4
     TIM_RemapConfig                6
     TIM_GetFlagStatus             20
     TIM_ClearFlag                  8
     TIM_GetITStatus               46
     TIM_ClearITPendingBit          8
     TI1_Config                    56
     TI2_Config                    66
     TI3_Config                    66
     TI4_Config                    66
     ??DataTable5                   4
     ??DataTable5_1                 4
     ??DataTable5_2                 4
     ??DataTable5_3                 4
     ??DataTable5_4                 4
     ??DataTable5_5                 4
     ??DataTable5_6                 4
     ??DataTable5_7                 4
     ??DataTable5_8                 4
     ??DataTable5_9                 4
     ??DataTable5_10                4
     ??DataTable5_11                4
     ??DataTable5_12                4

 
 3 184 bytes in section .text
 
 3 184 bytes of CODE memory

Errors: none
Warnings: none
