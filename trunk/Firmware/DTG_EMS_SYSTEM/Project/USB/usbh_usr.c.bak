/**
******************************************************************************
* @file    usbh_usr.c
* @author  MCD Application Team
* @version V2.0.0RC1
* @date    18-March-2011
* @brief   This file includes the usb host library user callbacks
******************************************************************************
* @attention
*
* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
* TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
* DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
* FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
* CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
*
* <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
******************************************************************************
*/

/* Includes ------------------------------------------------------------------*/
#include <string.h>

#include "main.h"
#include "usbh_usr.h"
#include "ff.h"       /* FATFS */
#include "usbh_msc_core.h"
#include "usbh_msc_scsi.h"
#include "usbh_msc_bot.h"
#include "Key_Process.h"
#include "Log.h"
#include "RTC.h"
#include "Memory.h"
#include "Voice.h"


/** @addtogroup USBH_USER
* @{
*/

/** @addtogroup USBH_MSC_DEMO_USER_CALLBACKS
* @{
*/

/** @defgroup USBH_USR 
* @brief    This file includes the usb host stack user callbacks
* @{
*/ 

/** @defgroup USBH_USR_Private_TypesDefinitions
* @{
*/ 
/**
* @}
*/ 


/** @defgroup USBH_USR_Private_Defines
* @{
*/ 
/**
* @}
*/ 


/** @defgroup USBH_USR_Private_Macros
* @{
*/ 
extern USB_OTG_CORE_HANDLE          USB_OTG_Core;
/**
* @}
*/ 


/** @defgroup USBH_USR_Private_Variables
* @{
*/ 
uint8_t USBH_USR_ApplicationState = USH_USR_FS_INIT;
uint8_t USBH_USR_ActionFlag = USH_USR_FS_IDLE;
uint8_t USBH_USR_Log_Buffer[100] ;
uint8_t USBH_USR_DTG_Buffer[200] ;
uint8_t USB_File_Buffer[MAX_USB_FILE_SIZE];

FATFS fatfs;
FIL file;
FILINFO finfo;
/*  Points to the DEVICE_PROP structure of current device */
/*  The purpose of this register is to speed up the execution */

USBH_Usr_cb_TypeDef USR_cb =
{
     USBH_USR_Init,
     USBH_USR_DeInit,
     USBH_USR_DeviceAttached,
     USBH_USR_ResetDevice,
     USBH_USR_DeviceDisconnected,
     USBH_USR_OverCurrentDetected,
     USBH_USR_DeviceSpeedDetected,
     USBH_USR_Device_DescAvailable,
     USBH_USR_DeviceAddressAssigned,
     USBH_USR_Configuration_DescAvailable,
     USBH_USR_Manufacturer_String,
     USBH_USR_Product_String,
     USBH_USR_SerialNum_String,
     USBH_USR_EnumerationDone,
     USBH_USR_UserInput,
     USBH_USR_MSC_Application,
     USBH_USR_DeviceNotSupported,
     USBH_USR_UnrecoveredError
          
};

/**
* @}
*/

/** @defgroup USBH_USR_Private_Constants
* @{
*/ 
/*--------------- LCD Messages ---------------*/
const uint8_t MSG_HOST_INIT[]        = "> Host Library Initialized\r\n";
const uint8_t MSG_DEV_ATTACHED[]     = "> Device Attached \r\n";
const uint8_t MSG_DEV_DISCONNECTED[] = "> Device Disconnected\r\n";
const uint8_t MSG_DEV_ENUMERATED[]   = "> Enumeration completed \r\n";
const uint8_t MSG_DEV_HIGHSPEED[]    = "> High speed device detected\r\n";
const uint8_t MSG_DEV_FULLSPEED[]    = "> Full speed device detected\r\n";
const uint8_t MSG_DEV_LOWSPEED[]     = "> Low speed device detected\\rn";
const uint8_t MSG_DEV_ERROR[]        = "> Device fault \r\n";

const uint8_t MSG_MSC_CLASS[]      = "> Mass storage device connected\r\n";
const uint8_t MSG_HID_CLASS[]      = "> HID device connected\r\n";
const uint8_t MSG_DISK_SIZE[]      = "> Size of the disk in MBytes: \r\n";
const uint8_t MSG_LUN[]            = "> LUN Available in the device:\r\n";
const uint8_t MSG_ROOT_CONT[]      = "> Exploring disk flash ...\r\n";
const uint8_t MSG_WR_PROTECT[]      = "> The disk is write protected\r\n";
const uint8_t MSG_UNREC_ERROR[]     = "> UNRECOVERED ERROR STATE\r\n";

/**
* @}
*/



/** @defgroup USBH_USR_Private_FunctionPrototypes
* @{
*/
static uint8_t Explore_Disk (char* path , uint8_t recu_level);
static uint8_t Image_Browser (char* path);
static void     Show_Image(void);

/**
* @}
*/ 


/** @defgroup USBH_USR_Private_Functions
* @{
*/ 


/**
* @brief  USBH_USR_Init 
*         Displays the message on LCD for host lib initialization
* @param  None
* @retval None
*/
void USBH_USR_Init(void)
{
     // LOG -------------------------------------------------------------------------
     if(LOGWRITE & LOG_USB_SYSTEM)                       
     {
          sprintf((char *)Buffer,"USB Initailze \r\n "); 
          Write_Log(Buffer, NORMAL_LOG);
     }            
     // -----------------------------------------------------------------------------
}

/**
* @brief  USBH_USR_DeviceAttached 
*         Displays the message on LCD on device attached
* @param  None
* @retval None
*/
void USBH_USR_DeviceAttached(void)
{
     // LOG -------------------------------------------------------------------------
     if(LOGWRITE & LOG_USB_SYSTEM)                       
     {
          sprintf((char *)Buffer, (void *)MSG_DEV_ATTACHED); 
          Write_Log(Buffer, NORMAL_LOG);
     }            
     // -----------------------------------------------------------------------------     
}


/**
* @brief  USBH_USR_UnrecoveredError
* @param  None
* @retval None
*/
void USBH_USR_UnrecoveredError (void)
{
     
     /* Set default screen color*/ 
     if(LOGWRITE & LOG_USB_SYSTEM)                       
     {
          sprintf((char *)Buffer, (void *)MSG_UNREC_ERROR); 
          Write_Log(Buffer, ERROR_LOG);
     }            
}


/**
* @brief  USBH_DisconnectEvent
*         Device disconnect event
* @param  None
* @retval Staus
*/
void USBH_USR_DeviceDisconnected (void)
{
     /* Set default screen color*/
     if(LOGWRITE & LOG_USB_SYSTEM)                       
     {
          sprintf((char *)Buffer, (void *)MSG_DEV_DISCONNECTED); 
          Write_Log(Buffer, ERROR_LOG);
     }     
}
/**
* @brief  USBH_USR_ResetUSBDevice 
* @param  None
* @retval None
*/
void USBH_USR_ResetDevice(void)
{
     /* callback for USB-Reset */
     if(LOGWRITE & LOG_USB_SYSTEM)                       
     {
          sprintf((char *)Buffer, "USB_Reset \r\n"); 
          Write_Log(Buffer, NORMAL_LOG);
     }          
}


/**
* @brief  USBH_USR_DeviceSpeedDetected 
*         Displays the message on LCD for device speed
* @param  Device speed
* @retval None
*/
void USBH_USR_DeviceSpeedDetected(uint8_t DeviceSpeed)
{
     if(LOGWRITE & LOG_USB_SYSTEM)                       
     {     
          if(DeviceSpeed == HPRT0_PRTSPD_HIGH_SPEED)
          {
               sprintf((char *)Buffer,(void *)MSG_DEV_HIGHSPEED);
          }  
          else if(DeviceSpeed == HPRT0_PRTSPD_FULL_SPEED)
          {
               sprintf((char *)Buffer,(void *)MSG_DEV_FULLSPEED);
          }
          else if(DeviceSpeed == HPRT0_PRTSPD_LOW_SPEED)
          {
               sprintf((char *)Buffer,(void *)MSG_DEV_LOWSPEED);
          }
          else
          {
               sprintf((char *)Buffer,(void *)MSG_DEV_ERROR);
          }
          Write_Log(Buffer, NORMAL_LOG);
     }
}

/**
* @brief  USBH_USR_Device_DescAvailable 
*         Displays the message on LCD for device descriptor
* @param  device descriptor
* @retval None
*/
void USBH_USR_Device_DescAvailable(void *DeviceDesc)
{ 
     USBH_DevDesc_TypeDef *hs;
     hs = DeviceDesc;  
     if(LOGWRITE & LOG_USB_SYSTEM)                       
     {       
          sprintf((char *)Buffer,"> VID : %04Xh\r\n" , (uint32_t)(*hs).idVendor); 
          Write_Log(Buffer, NORMAL_LOG);
          sprintf((char *)Buffer,"> PID : %04Xh\r\n" , (uint32_t)(*hs).idProduct);
          Write_Log(Buffer, NORMAL_LOG);
     }
}

/**
* @brief  USBH_USR_DeviceAddressAssigned 
*         USB device is successfully assigned the Address 
* @param  None
* @retval None
*/
void USBH_USR_DeviceAddressAssigned(void)
{  
}


/**
* @brief  USBH_USR_Conf_Desc 
*         Displays the message on LCD for configuration descriptor
* @param  Configuration descriptor
* @retval None
*/
void USBH_USR_Configuration_DescAvailable(USBH_CfgDesc_TypeDef * cfgDesc,
                                          USBH_InterfaceDesc_TypeDef *itfDesc,
                                          USBH_EpDesc_TypeDef *epDesc)
{
     if(LOGWRITE & LOG_USB_SYSTEM)                       
     {      
          USBH_InterfaceDesc_TypeDef *id;  
          
          id = itfDesc;  
          
          if((*id).bInterfaceClass  == 0x08)
          {
               sprintf((char *)Buffer,(void *)MSG_MSC_CLASS);
               
          }
          else if((*id).bInterfaceClass  == 0x03)
          {
               sprintf((char *)Buffer,(void *)MSG_HID_CLASS);
          }    
          Write_Log(Buffer, NORMAL_LOG);
     }
}

/**
* @brief  USBH_USR_Manufacturer_String 
*         Displays the message on LCD for Manufacturer String 
* @param  Manufacturer String 
* @retval None
*/
void USBH_USR_Manufacturer_String(void *ManufacturerString)
{
     if(LOGWRITE & LOG_USB_SYSTEM)                       
     {               
          sprintf((char *)Buffer, "> Manufacturer : %s \r\n", (char *)ManufacturerString);
          Write_Log(Buffer, NORMAL_LOG);
     }
}

/**
* @brief  USBH_USR_Product_String 
*         Displays the message on LCD for Product String
* @param  Product String
* @retval None
*/
void USBH_USR_Product_String(void *ProductString)
{          
     if(LOGWRITE & LOG_USB_SYSTEM)                       
     {   
          sprintf((char *)Buffer, "> Product : %s \r\n", (char *)ProductString);  
          Write_Log(Buffer, NORMAL_LOG);
     }
}

/**
* @brief  USBH_USR_SerialNum_String 
*         Displays the message on LCD for SerialNum_String 
* @param  SerialNum_String 
* @retval None
*/
void USBH_USR_SerialNum_String(void *SerialNumString)
{
     if(LOGWRITE & LOG_USB_SYSTEM)                       
     {
          sprintf((char *)Buffer, "> Serial Number : %s \r\n", (char *)SerialNumString);    
          Write_Log(Buffer, NORMAL_LOG);
     }    
} 



/**
* @brief  EnumerationDone 
*         User response request is displayed to ask application jump to class
* @param  None
* @retval None
*/
void USBH_USR_EnumerationDone(void)
{
     if(LOGWRITE & LOG_USB_SYSTEM)                       
     {
          /* Enumeration complete */
          sprintf((char *)Buffer, (void *)MSG_DEV_ENUMERATED); 
          Write_Log(Buffer, NORMAL_LOG);
          //  LCD_SetTextColor(Green);
          //  LCD_DisplayStringLine( LCD_PIXEL_HEIGHT - 42, "To see the root content of the disk : " );
          //  LCD_DisplayStringLine( LCD_PIXEL_HEIGHT - 30, "Press Key...                       ");
          //  LCD_SetTextColor(LCD_LOG_DEFAULT_COLOR); 
     }
} 


/**
* @brief  USBH_USR_DeviceNotSupported
*         Device is not supported
* @param  None
* @retval None
*/
void USBH_USR_DeviceNotSupported(void)
{
     if(LOGWRITE & LOG_USB_SYSTEM)                       
     {     
          sprintf((char *)Buffer, "> Device not supported.\r\n" ); 
          Write_Log(Buffer, ERROR_LOG);
     }
}  


/**
* @brief  USBH_USR_UserInput
*         User Action for application state entry
* @param  None
* @retval USBH_USR_Status : User response for key button
*/
USBH_USR_Status USBH_USR_UserInput(void)
{
     USBH_USR_Status usbh_usr_status;
//     usbh_usr_status = USBH_USR_NO_RESP;     
     /*Key B3 is in polling mode to detect user action */
//     if(IsKey_ECO()==RESET)  
//     {          
     
     usbh_usr_status = USBH_USR_RESP_OK;          
//     } 
     return usbh_usr_status;
}  

/**
* @brief  USBH_USR_OverCurrentDetected
*         Over Current Detected on VBUS
* @param  None
* @retval Staus
*/
void USBH_USR_OverCurrentDetected (void)
{
     if(LOGWRITE & LOG_USB_SYSTEM)                       
     {     
          sprintf((char *)Buffer, "> Overcurrent detected.\r\n" ); 
          Write_Log(Buffer, ERROR_LOG);
     }     
}


/**
* @brief  USBH_USR_MSC_Application 
*         Demo application for mass storage
* @param  None
* @retval Staus
*/
int USBH_USR_MSC_Application(void)
{
     FRESULT res;
     uint8_t ret = 1;
     FILINFO fno;
     DIR dir;
     char *fn;
     uint8_t writeTextBuff[100];
     uint16_t bytesWritten, bytesToWrite;
     uint16_t numOfReadBytes;
     uint8_t FileName[20];
     u16 i,i2,i3;
     u32 Address = 0;
     u8 TempBuffer[256];
     u8 Rdata;
     
     switch(USBH_USR_ApplicationState)
     {
          case USH_USR_FS_INIT: 
          
          /* Initialises the File System*/
          if ( f_mount( 0, &fatfs ) != FR_OK ) 
          {
               /* efs initialisation fails*/
               if(LOGWRITE & LOG_USB_SYSTEM)                       
               {     
                    sprintf((char *)Buffer, "> Cannot initialize File System.\r\n" ); 
                    Write_Log(Buffer, ERROR_LOG);
               }                    
               return(-1);
          }
          if(LOGWRITE & LOG_USB_SYSTEM)                       
          {     
               sprintf((char *)Buffer, "> File System initialized.\r\n" ); 
               Write_Log(Buffer, NORMAL_LOG);
               sprintf((char *)Buffer, "> Disk capacity : %u Bytes\r\n",(long)( USBH_MSC_Param.MSCapacity * USBH_MSC_Param.MSPageLength));
               Write_Log(Buffer, NORMAL_LOG);
          }           
          
          if(USBH_MSC_Param.MSWriteProtect == DISK_WRITE_PROTECTED)
          {
               if(LOGWRITE & LOG_USB_SYSTEM)                       
               {     
                    sprintf((char *)Buffer, (void *)MSG_WR_PROTECT); 
                    Write_Log(Buffer, ERROR_LOG);
               }                 
          }
          f_mount(0, &fatfs);
          f_mkdir("0:\\Log_File");
          f_mkdir("0:\\DTG_File");
          f_mount(0, NULL);
          USBH_USR_ApplicationState = USH_USR_FS_MACHINE_INIT;       // 동작실행
          break;
          case USH_USR_FS_MACHINE_INIT:         // 장비 온시 처음 초기화
          {
               if( USBH_USR_ActionFlag == USH_USR_FS_SOUND )      // 백업데이터 기록            
               {
                    USBH_USR_ApplicationState = USH_USR_FS_SOUND;
                    USBH_USR_ActionFlag = USH_USR_FS_IDLE;                    
               }                              
          }break;
          
          case USH_USR_FS_IDLE:
          {
               // 대기상태 
               if( USBH_USR_ActionFlag == USH_USR_FS_WRITELOG )       // 로그 기록
               {
                    USBH_USR_ApplicationState = USH_USR_FS_WRITELOG;
                    USBH_USR_ActionFlag = USH_USR_FS_IDLE;
               }
               if( USBH_USR_ActionFlag == USH_USR_FS_WRITEFILE )      // 1초데이터 기록
               {
                    USBH_USR_ApplicationState = USH_USR_FS_WRITEFILE;
                    USBH_USR_ActionFlag = USH_USR_FS_IDLE;
               }               
               if( USBH_USR_ActionFlag == USH_USR_FS_WRITEBACKUP )      // 백업데이터 기록            
               {
                    USBH_USR_ApplicationState = USH_USR_FS_WRITEBACKUP;
                    USBH_USR_ActionFlag = USH_USR_FS_IDLE;                    
               }
               
          }break;
          case USH_USR_FS_WRITELOG:
          {
               sprintf((char *) FileName, "0:\\Log_File\\%d%d%d.txt", SYSTEM_TIME.tm_year,SYSTEM_TIME.tm_mon,SYSTEM_TIME.tm_mday);
               if(! HCD_IsDeviceConnected(&USB_OTG_Core) )
               {
                    USBH_USR_ApplicationState = USH_USR_FS_IDLE;
                    break;
               }
               f_mount(0, &fatfs);               
               if(f_open(&file, (char*)FileName,FA_OPEN_ALWAYS | FA_WRITE) == FR_OK) 
               {
                    bytesToWrite = strlen(USBH_USR_Log_Buffer); 
//                    f_stat(FileName,&finfo);
                    f_lseek(&file,file.fsize);
                    res= f_write (&file, USBH_USR_Log_Buffer, bytesToWrite, (void *)&bytesWritten);                      
                    
                    f_close(&file);
                    f_mount(0, NULL);                     
               }
               USBH_USR_ApplicationState = USH_USR_FS_IDLE;
               
          }break;
          case USH_USR_FS_WRITEFILE:              // 1초데이터 기록
          {
               sprintf((char *) FileName, "0:\\DTG_File\\%d%d%d.txt", SYSTEM_TIME.tm_year,SYSTEM_TIME.tm_mon,SYSTEM_TIME.tm_mday);
               if(! HCD_IsDeviceConnected(&USB_OTG_Core) )
               {
                    USBH_USR_ApplicationState = USH_USR_FS_IDLE;
                    break;
               }
               f_mount(0, &fatfs);               
               if(f_open(&file,  (char*)FileName,FA_OPEN_ALWAYS | FA_WRITE) == FR_OK) 
               {
                    bytesToWrite = strlen(USBH_USR_DTG_Buffer); 
//                    USBH_USR_DTG_Buffer[20]=0;
//                    printf("%s\r\n",USBH_USR_DTG_Buffer);
//                    f_stat(FileName,&finfo);
                    f_lseek(&file,file.fsize);
                    res= f_write (&file, USBH_USR_DTG_Buffer, bytesToWrite, (void *)&bytesWritten);                      
                    
                    f_close(&file);
                    f_mount(0, NULL);                     
               }
               USBH_USR_ApplicationState = USH_USR_FS_IDLE;
               
          }break;          
          case USH_USR_FS_WRITEBACKUP:
          {
               for( i = VIEW_Header.Start_Index ; i <= VIEW_Header.End_Index ; i++)
               {
                    VIEW_Header.Header = Read_Header_Information( i ) ;
                    sprintf((char *) FileName, "0:\\DTG_File\\%02d%02d%02d.txt",
                            VIEW_Header.Header.Date[0],
                            VIEW_Header.Header.Date[1],
                            VIEW_Header.Header.Date[2]);
                    
                    if(! HCD_IsDeviceConnected(&USB_OTG_Core) )
                    {
                         USBH_USR_ApplicationState = USH_USR_FS_IDLE;
                         break;
                    }
                    f_mount(0, &fatfs);               
                    if(f_open(&file,  (char*)FileName,FA_OPEN_ALWAYS | FA_WRITE) == FR_OK) 
                    {
                         f_lseek(&file,file.fsize);
                         for( i2 = VIEW_Header.Header.Start_Page ; i2 < VIEW_Header.Header.End_Page ;i2++)
                         {
                              DTG_EMS_DataLoad(i2);
                              for(i3 = 0 ; i3 < 30 ; i3++)
                              {
                                   Convert_DTG_Data(i3);
                                   bytesToWrite = strlen(USBH_USR_DTG_Buffer); 
                                   
                                   res= f_write (&file, USBH_USR_DTG_Buffer, bytesToWrite, (void *)&bytesWritten);                      
                              }                         
                         }
                         f_close(&file);
                         f_mount(0, NULL); 
                         Input_Mode = 3;          // 화면저장 완료 표시                    
                    }
               }
               USBH_USR_ApplicationState = USH_USR_FS_IDLE;
               
          }break;
          case USH_USR_FS_SOUND:
          {
               f_mount(0, &fatfs);
               res = f_opendir(&dir, "0:\\Config");
               if (res == FR_OK) {
                    
                    for (;;) {
                         res = f_readdir(&dir, &fno);
                         if (res != FR_OK || fno.fname[0] == 0) break;
                         if (fno.fname[0] == '.') continue;
//#if _USE_LFN
//                         fn = *fno.lfname ? fno.lfname : fno.fname;
//#else
                         fn = fno.fname;
//#endif
                         if (fno.fattrib & AM_DIR) 
                         {
                              continue;
                         } 
                         else 
                         {
                              if((strstr(fn, "bin")) || (strstr(fn, "BIN")))
                              {
                                   res = f_open(&file, "0:\\Config\\Sound.bin", FA_OPEN_EXISTING | FA_READ);    
                                    if (res != FR_OK)
                                         break;
                                   SerialFlash_ProgramWirte_Start();       // 음성 IC 라이트 초기화

                                   Address = 0;                               
                                   //for (Address=0;Address<MaxAddress;Address+=256){
                                   while (HCD_IsDeviceConnected(&USB_OTG_Core))                                        
                                   {
                                        res = f_read(&file, USB_File_Buffer, MAX_USB_FILE_SIZE, (void *)&numOfReadBytes);
                                        if((numOfReadBytes == 0) || (res != FR_OK)) /*EOF or Error*/
                                        {
                                             break; 
                                        }
                                        SerialFlash_busy_check();
                                        SerialFlash_Program(Address);
                                        for(i = 0 ; i < numOfReadBytes; i+= 1)
                                        {
                                             SerialFlash_Write_8bit( USB_File_Buffer[i] );
                                        }
                                                                         	
                                        VOICE_CSB_HIGH();                                        
                                     	// 잘 읽히는지 테스트 읽기
//                                        SerialFlash_busy_check();
//                                        SerialFlash_Read_Program(Address);
//                                        for(i = 0 ; i < numOfReadBytes; i+= 1)
//                                        {
//                                             TempBuffer[i] = SerialFlash_Read_8bit();
//                                        }   
//                                        VOICE_CSB_HIGH(); 
//                                        Address += numOfReadBytes;  
                                   }
                                   SerialFlash_ProgramWirte_End();
                                   Register_Write(0x15, 0x01);
                                   do {
                                        Rdata = Register_Read(0x15);
                                   } while (Rdata&0x01);
                                   Rdata = Register_Read(0x16);     
                                   if (Rdata == 0x00) 
                                   {
                                        printf("Sound File Write Success\r\n");
                                   }
                              }
                         }
                    }
               } 
               f_close(&file);
               f_mount(0, NULL); 
          }// end of case
          USBH_USR_ApplicationState = USH_USR_FS_IDLE;         
          break;
          
/*          
          case USH_USR_FS_READLIST:
          
          LCD_UsrLog((void *)MSG_ROOT_CONT);
          Explore_Disk("0:/", 1);
          line_idx = 0;   
          USBH_USR_ApplicationState = USH_USR_FS_WRITEFILE;
          
          break;
          
          case USH_USR_FS_WRITEFILE:
          
          USB_OTG_BSP_mDelay(500);           // 라이트 하기전에 딜레이?
          

//          while((HCD_IsDeviceConnected(&USB_OTG_Core)) && (IsKey_ECO() == SET));          
  
          f_mount(0, &fatfs);
          
          if(f_open(&file, "0:Host_Write_Demo.TXT",FA_CREATE_ALWAYS | FA_WRITE) == FR_OK)
          { 
               bytesToWrite = sizeof(writeTextBuff); 
               res= f_write (&file, writeTextBuff, bytesToWrite, (void *)&bytesWritten);   
               
               if((bytesWritten == 0) || (res != FR_OK))
               {
                    LCD_ErrLog("> Host_Write_Demo.TXT CANNOT be writen.\n");
               }
               else
               {
                    LCD_UsrLog("> 'Host_Write_Demo.TXT' file created\n");
               }
                              f_close(&file);
               f_mount(0, NULL); 
          }
          
          else
          {
               LCD_UsrLog ("> Host_Write_Demo.TXT created in the disk\n");
          }
          
          USBH_USR_ApplicationState = USH_USR_FS_DRAW; //ToDo : wait here (continueous PB pressed issue)
          
          LCD_SetTextColor(Green);
          LCD_DisplayStringLine( LCD_PIXEL_HEIGHT - 42, "                                              ");
          LCD_DisplayStringLine( LCD_PIXEL_HEIGHT - 30, "To start Image slide show Press Key.");
          LCD_SetTextColor(LCD_LOG_DEFAULT_COLOR); 
          break;
          
          case USH_USR_FS_DRAW:
          
          while((HCD_IsDeviceConnected(&USB_OTG_Core)) && \
               (IsKey_ECO() == SET))
          {
               Toggle_Leds();
          }
          
          
          while(HCD_IsDeviceConnected(&USB_OTG_Core))
          {
               if ( f_mount( 0, &fatfs ) != FR_OK ) 
               {
                    return(-1);
               }
               return Image_Browser("0:/");
          }
          break;
          default: break;
          */
     }
     return(0);
}

/**
* @brief  Explore_Disk 
*         Displays disk content
* @param  path: pointer to root path
* @retval None
*/
static uint8_t Explore_Disk (char* path , uint8_t recu_level)
{
     ;
//     FRESULT res;
//     FILINFO fno;
//     DIR dir;
//     char *fn;
//     
//#if _USE_LFN
//     static char lfn[_MAX_LFN * (_DF1S ? 2 : 1) + 1];
//     fno.lfname = lfn;
//     fno.lfsize = sizeof(lfn);
//#endif
//     
//     
//     res = f_opendir(&dir, path);
//     if (res == FR_OK) {
//          while(HCD_IsDeviceConnected(&USB_OTG_Core)) 
//          {
//               res = f_readdir(&dir, &fno);
//               if (res != FR_OK || fno.fname[0] == 0) 
//               {
//                    break;
//               }
//               if (fno.fname[0] == '.')
//               {
//                    continue;
//               }
//#if _USE_LFN
//               fn = *fno.lfname ? fno.lfname : fno.fname;
//#else
//               fn = fno.fname;
//#endif
//               
//               
//               line_idx++;
//               if(line_idx > 9)
//               {
//                    line_idx = 0;
//                    LCD_SetTextColor(Green);
//                    LCD_DisplayStringLine( LCD_PIXEL_HEIGHT - 42, "                                              ");
//                    LCD_DisplayStringLine( LCD_PIXEL_HEIGHT - 30, "Press Key to continue...");
//                    LCD_SetTextColor(LCD_LOG_DEFAULT_COLOR); 
//                    
//                    /*Key B3 in polling*/
//                    while((HCD_IsDeviceConnected(&USB_OTG_Core)) && \
//                         (IsKey_ECO() == SET))
//                    {
//                         Toggle_Leds();
//                         
//                    }
//               } 
//               
//               if(recu_level == 1)
//               {
//                    LCD_DbgLog("   |__");
//               }
//               else if(recu_level == 2)
//               {
//                    LCD_DbgLog("   |   |__");
//               }
//               if((fno.fattrib & AM_MASK) == AM_DIR)
//               {
//                    LCD_UsrLog((void *)fn);
//               }
//               else
//               {
//                    LCD_DbgLog((void *)fn);
//               }
//               LCD_DbgLog("\n");
//               if(((fno.fattrib & AM_MASK) == AM_DIR)&&(recu_level == 1))
//               {
//                    Explore_Disk(fn, 2);
//               }
//          }
//     }
//     return res;
}

static uint8_t Image_Browser (char* path)
{
//     FRESULT res;
//     uint8_t ret = 1;
//     FILINFO fno;
//     DIR dir;
//     char *fn;
//#if _USE_LFN
//     static char lfn[_MAX_LFN * (_DF1S ? 2 : 1) + 1];
//     fno.lfname = lfn;
//     fno.lfsize = sizeof(lfn);
//#endif
//     
//     res = f_opendir(&dir, path);
//     if (res == FR_OK) {
//          
//          for (;;) {
//               res = f_readdir(&dir, &fno);
//               if (res != FR_OK || fno.fname[0] == 0) break;
//               if (fno.fname[0] == '.') continue;
//#if _USE_LFN
//               fn = *fno.lfname ? fno.lfname : fno.fname;
//#else
//               fn = fno.fname;
//#endif
//               if (fno.fattrib & AM_DIR) 
//               {
//                    continue;
//               } 
//               else 
//               {
//                    if((strstr(fn, "bmp")) || (strstr(fn, "BMP")))
//                    {
//                         res = f_open(&file, fn, FA_OPEN_EXISTING | FA_READ);
//                         Show_Image();
//                         ret = 0;
//                         while((HCD_IsDeviceConnected(&USB_OTG_Core)) && \
//                              (IsKey_ECO() == SET))
//                         {
//                              Toggle_Leds();
//                         }
//                         f_close(&file);
//                         
//                    }
//               }
//          }  
//     }
//     
//#ifdef USE_USB_OTG_HS 
//     LCD_LOG_SetHeader(" USB OTG HS MSC Host");
//#else
//     LCD_LOG_SetHeader(" USB OTG FS MSC Host");
//#endif
//     LCD_LOG_SetFooter ("     USB Host Library v2.0.0rc1" );
//     LCD_UsrLog("> Disk capacity : %d Bytes\n", USBH_MSC_Param.MSCapacity * \
//          USBH_MSC_Param.MSPageLength); 
//     USBH_USR_ApplicationState = USH_USR_FS_READLIST;
//     return ret;
}

/**
* @brief  Show_Image 
*         Displays BMP image
* @param  None
* @retval None
*/
static void Show_Image(void)
{
//     
//     uint16_t i = 0;
//     uint16_t numOfReadBytes = 0;
//     FRESULT res; 
//     
//     LCD_SetDisplayWindow(239, 319, 240, 320);
//     LCD_WriteReg(R3, 0x1008);
//     LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
//     
//     /* Bypass Bitmap header */ 
//     f_lseek (&file, 54);
//     
//     while (HCD_IsDeviceConnected(&USB_OTG_Core))
//     {
//          res = f_read(&file, Image_Buf, IMAGE_BUFFER_SIZE, (void *)&numOfReadBytes);
//          if((numOfReadBytes == 0) || (res != FR_OK)) /*EOF or Error*/
//          {
//               break; 
//          }
//          for(i = 0 ; i < IMAGE_BUFFER_SIZE; i+= 2)
//          {
//               LCD_WriteRAM(Image_Buf[i+1] << 8 | Image_Buf[i]); 
//          } 
//     }
//     
}


/**
* @brief  USBH_USR_DeInit
*         Deint User state and associated variables
* @param  None
* @retval None
*/
void USBH_USR_DeInit(void)
{
     USBH_USR_ApplicationState = USH_USR_FS_INIT;
}


/**
* @}
*/ 

/**
* @}
*/ 

/**
* @}
*/

/**
* @}
*/

/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/






























