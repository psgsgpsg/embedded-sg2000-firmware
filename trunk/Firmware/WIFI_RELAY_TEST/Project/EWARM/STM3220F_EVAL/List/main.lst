###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     20/Dec/2011  16:28:24 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\Work\Firmware\DTG\WIFI_RELAY_TEST\Project\main.c      #
#    Command line =  E:\Work\Firmware\DTG\WIFI_RELAY_TEST\Project\main.c -D   #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D RTC_CLOCK_SOURCE_LSE -lC            #
#                    E:\Work\Firmware\DTG\WIFI_RELAY_TEST\Project\EWARM\STM32 #
#                    20F_EVAL\List\ -lA E:\Work\Firmware\DTG\WIFI_RELAY_TEST\ #
#                    Project\EWARM\STM3220F_EVAL\List\ -o                     #
#                    E:\Work\Firmware\DTG\WIFI_RELAY_TEST\Project\EWARM\STM32 #
#                    20F_EVAL\Obj\ --no_cse --no_unroll --no_inline           #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I E:\Work\Firmware\DTG\WIFI_RELAY_TEST\Project\EWA #
#                    RM\..\ -I E:\Work\Firmware\DTG\WIFI_RELAY_TEST\Project\E #
#                    WARM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I           #
#                    E:\Work\Firmware\DTG\WIFI_RELAY_TEST\Project\EWARM\..\.. #
#                    \Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I      #
#                    E:\Work\Firmware\DTG\WIFI_RELAY_TEST\Project\EWARM\..\.. #
#                    \Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I            #
#                    E:\Work\Firmware\DTG\WIFI_RELAY_TEST\Project\EWARM\..\.. #
#                    \Utilities\STM32_EVAL\ -I E:\Work\Firmware\DTG\WIFI_RELA #
#                    Y_TEST\Project\EWARM\..\..\Utilities\STM32_EVAL\Common\  #
#                    -I E:\Work\Firmware\DTG\WIFI_RELAY_TEST\Project\EWARM\.. #
#                    \..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I               #
#                    E:\Work\Firmware\DTG\WIFI_RELAY_TEST\Project\EWARM\..\.. #
#                    \Libraries\STM32_USB_OTG_Driver\inc\ -I                  #
#                    E:\Work\Firmware\DTG\WIFI_RELAY_TEST\Project\EWARM\..\.. #
#                    \Libraries\STM32_USB_Device_Library\Core\inc\ -I         #
#                    E:\Work\Firmware\DTG\WIFI_RELAY_TEST\Project\EWARM\..\.. #
#                    \Libraries\STM32_USB_Device_Library\Class\msc\inc\ -I    #
#                    E:\Work\Firmware\DTG\WIFI_RELAY_TEST\Project\EWARM\..\Us #
#                    b\ -I E:\Work\Firmware\DTG\WIFI_RELAY_TEST\Project\EWARM #
#                    \..\Usb\Inc\ -I E:\Work\Firmware\DTG\WIFI_RELAY_TEST\Pro #
#                    ject\EWARM\..\Usb\src\ -I E:\Work\Firmware\DTG\WIFI_RELA #
#                    Y_TEST\Project\EWARM\..\..\Libraries\STM32_USB_HOST_Libr #
#                    ary\Core\inc\ -I E:\Work\Firmware\DTG\WIFI_RELAY_TEST\Pr #
#                    oject\EWARM\..\..\Libraries\STM32_USB_HOST_Library\Class #
#                    \MSC\inc\ -Ol --use_c++_inline                           #
#    List file    =  E:\Work\Firmware\DTG\WIFI_RELAY_TEST\Project\EWARM\STM32 #
#                    20F_EVAL\List\main.lst                                   #
#    Object file  =  E:\Work\Firmware\DTG\WIFI_RELAY_TEST\Project\EWARM\STM32 #
#                    20F_EVAL\Obj\main.o                                      #
#                                                                             #
#                                                                             #
###############################################################################

E:\Work\Firmware\DTG\WIFI_RELAY_TEST\Project\main.c
      1          /**
      2          ******************************************************************************
      3          * @file    Project/STM32F2xx_StdPeriph_Template/main.c 
      4          * @author  MCD Application Team
      5          * @version V0.0.4
      6          * @date    13-January-2011
      7          * @brief   Main program body
      8          ******************************************************************************
      9          * @attention
     10          *
     11          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13          * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14          * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15          * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16          * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17          *
     18          * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19          ******************************************************************************
     20          */ 
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "main.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SetPriority(IRQn_Type, uint32_t)
   \                     NVIC_SetPriority:
   \   00000000   40B2               SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000002   0028               CMP      R0,#+0
   \   00000004   09D5               BPL.N    ??NVIC_SetPriority_0
   \   00000006   40B2               SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000008   10F00F00           ANDS     R0,R0,#0xF
   \   0000000C   ........           LDR.W    R2,??DataTable28  ;; 0xe000ed18
   \   00000010   8018               ADDS     R0,R0,R2
   \   00000012   0901               LSLS     R1,R1,#+4
   \   00000014   00F8041C           STRB     R1,[R0, #-4]
   \   00000018   04E0               B.N      ??NVIC_SetPriority_1
   \                     ??NVIC_SetPriority_0:
   \   0000001A   40B2               SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000001C   ........           LDR.W    R2,??DataTable30  ;; 0xe000e400
   \   00000020   0901               LSLS     R1,R1,#+4
   \   00000022   8154               STRB     R1,[R0, R2]
   \                     ??NVIC_SetPriority_1:
   \   00000024   7047               BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t SysTick_Config(uint32_t)
   \                     SysTick_Config:
   \   00000000   80B5               PUSH     {R7,LR}
   \   00000002   B0F1807F           CMP      R0,#+16777216
   \   00000006   01D3               BCC.N    ??SysTick_Config_0
   \   00000008   0120               MOVS     R0,#+1
   \   0000000A   13E0               B.N      ??SysTick_Config_1
   \                     ??SysTick_Config_0:
   \   0000000C   0002               LSLS     R0,R0,#+8
   \   0000000E   000A               LSRS     R0,R0,#+8
   \   00000010   401E               SUBS     R0,R0,#+1
   \   00000012   ........           LDR.W    R1,??DataTable28_1  ;; 0xe000e014
   \   00000016   0860               STR      R0,[R1, #+0]
   \   00000018   0F21               MOVS     R1,#+15
   \   0000001A   5FF0FF30           MOVS     R0,#-1
   \   0000001E   ........           BL       NVIC_SetPriority
   \   00000022   ........           LDR.W    R0,??DataTable28_2  ;; 0xe000e018
   \   00000026   0021               MOVS     R1,#+0
   \   00000028   0160               STR      R1,[R0, #+0]
   \   0000002A   ........           LDR.W    R0,??DataTable31  ;; 0xe000e010
   \   0000002E   0721               MOVS     R1,#+7
   \   00000030   0160               STR      R1,[R0, #+0]
   \   00000032   0020               MOVS     R0,#+0
   \                     ??SysTick_Config_1:
   \   00000034   02BD               POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __intrinsic __interwork __softfp void *memcpy(void *, void const *, size_t)
   \                     memcpy:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           BL       __aeabi_memcpy
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   10BD               POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __intrinsic __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   1000               MOVS     R0,R2
   \   00000006   0A00               MOVS     R2,R1
   \   00000008   0100               MOVS     R1,R0
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   ........           BL       __aeabi_memset
   \   00000010   2000               MOVS     R0,R4
   \   00000012   10BD               POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LED1_OFF(void)
   \                     LED1_OFF:
   \   00000000   80B5               PUSH     {R7,LR}
   \   00000002   4FF40051           MOV      R1,#+8192
   \   00000006   ........           LDR.W    R0,??DataTable30_1  ;; 0x40021800
   \   0000000A   ........           BL       GPIO_SetBits
   \   0000000E   4FF48041           MOV      R1,#+16384
   \   00000012   ........           LDR.W    R0,??DataTable30_1  ;; 0x40021800
   \   00000016   ........           BL       GPIO_SetBits
   \   0000001A   01BD               POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LED2_OFF(void)
   \                     LED2_OFF:
   \   00000000   80B5               PUSH     {R7,LR}
   \   00000002   4FF40061           MOV      R1,#+2048
   \   00000006   ........           LDR.W    R0,??DataTable30_1  ;; 0x40021800
   \   0000000A   ........           BL       GPIO_SetBits
   \   0000000E   4FF48051           MOV      R1,#+4096
   \   00000012   ........           LDR.W    R0,??DataTable30_1  ;; 0x40021800
   \   00000016   ........           BL       GPIO_SetBits
   \   0000001A   01BD               POP      {R0,PC}          ;; return
     24          #include "stm32f2xx_gpio.h"
     25          
     26          #include "spi_flash.h"
     27          #include "fsmc_nand.h"
     28          #include "Tilt.h"
     29          #include "Key_Switch.h"
     30          #include "RTC.h"
     31          #include "GraphicLcd.h"
     32          #include "Voice.h"
     33          #include "Key_Process.h"
     34          #include "DAC_Control.h"
     35          
     36          #include "Memory.h"
     37          #include "Display.h"
     38          
     39          #include "Serial.h"
     40          
     41          #include "Log.h"
     42          #include "Ems_System.h"
     43          #include "GPSLIB.h"
     44          
     45          #include "Adc_Process.h"
     46          
     47          #include "usbh_core.h"
     48          #include "usbh_usr.h"
     49          #include "usbh_msc_core.h"
     50          
     51          #include "Wifi.h"
     52          #include "PC_COM.h"
     53          
     54          #include "i2c_ee.h"
     55          
     56          #include "nand_if.h"
     57          
     58          #include "Drive_Process.h"
     59          #include "Eeprom.h"
     60          
     61          /** @addtogroup Template_Project
     62          * @{
     63          */
     64          
     65          /* Private typedef -----------------------------------------------------------*/
     66          /* Private define ------------------------------------------------------------*/
     67          
     68          
     69          /* Private macro -------------------------------------------------------------*/
     70          /* Private variables ---------------------------------------------------------*/
     71          

   \                                 In section .bss, align 4
     72          EMS_DRIVE_VALUE EMS_Drive_Value;
   \                     EMS_Drive_Value:
   \   00000000                      DS8 36
     73          
     74          //typedef enum {FAILED = 0, PASSED = !FAILED} TestStatus;
     75          

   \                                 In section .bss, align 4
     76          static __IO uint32_t TimingDelay;
   \                     TimingDelay:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     77          RCC_ClocksTypeDef RCC_Clocks;
   \                     RCC_Clocks:
   \   00000000                      DS8 16
     78          
     79          /* Private macro -------------------------------------------------------------*/
     80          
     81          
     82          //volatile TestStatus TransferStatus1 = FAILED, TransferStatus2 = FAILED;

   \                                 In section .bss, align 1
     83          ErrorStatus HSEStartUpStatus;
   \                     HSEStartUpStatus:
   \   00000000                      DS8 1
     84          
     85          /* Private function prototypes -----------------------------------------------*/
     86          #ifdef __GNUC__
     87          /* With GCC/RAISONANCE, small printf (option LD Linker->Libraries->Small printf
     88          set to 'Yes') calls __io_putchar() */
     89          #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
     90          #else
     91          #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
     92          #endif /* __GNUC__ */
     93          
     94          /* Private functions ---------------------------------------------------------*/
     95          /**
     96          * @brief  Main program.
     97          * @param  None
     98          * @retval None
     99          */
    100          
    101          //__IO uint32_t FLASH_ID = 0;

   \                                 In section .bss, align 2
    102          u16 Timer_1Sec;			// 1초 타이머 만들기
   \                     Timer_1Sec:
   \   00000000                      DS8 2
    103          

   \                                 In section .bss, align 4
    104          struct __flag Flag;
   \                     Flag:
   \   00000000                      DS8 20
    105          

   \                                 In section .bss, align 1
    106          u8 ERROR_Status;			// 에러 상태를 보여준다.
   \                     ERROR_Status:
   \   00000000                      DS8 1
    107          

   \                                 In section .bss, align 4
    108          u8 Buffer [512];
   \                     Buffer:
   \   00000000                      DS8 512
    109          

   \                                 In section .bss, align 2
    110          u16 BuffCnt = 0 ;
   \                     BuffCnt:
   \   00000000                      DS8 2
    111          

   \                                 In section .bss, align 2
    112          u16 SYSTEM_STEP;
   \                     SYSTEM_STEP:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
    113          u32 SPEED_PULS_Count;				// 스피드에 들어오는 펄스 카운트 수 - 거리 개산용으로 사용
   \                     SPEED_PULS_Count:
   \   00000000                      DS8 4
    114          

   \                                 In section .bss, align 2
    115          u16 m_sec;
   \                     m_sec:
   \   00000000                      DS8 2
    116          

   \                                 In section .bss, align 4
    117          struct _SERIALFLASH_CarInfo SFLASH_CarInfo;
   \                     SFLASH_CarInfo:
   \   00000000                      DS8 96
    118          

   \                                 In section .bss, align 4
    119          struct _SERIALFLASH_Data SFLASH_Memory;      //  SFLASH에 저장되고 불러올 데이터
   \                     SFLASH_Memory:
   \   00000000                      DS8 180
    120          

   \                                 In section .bss, align 4
    121          struct _GPS_Check GPS_RouteCheck; 
   \                     GPS_RouteCheck:
   \   00000000                      DS8 68
    122          

   \                                 In section .bss, align 4
    123          struct _SERIALFLASH_Wifi SFLASH_Wifi; 
   \                     SFLASH_Wifi:
   \   00000000                      DS8 76
    124          

   \                                 In section .bss, align 4
    125          struct _Setting_Information Set_Info;	// 기본적으로 세팅되어져있는 값
   \                     Set_Info:
   \   00000000                      DS8 16
    126          

   \                                 In section .bss, align 4
    127          struct _Info Info;                      // 현재 메모리에 가지고 있는 총체적인 데이터
   \                     Info:
   \   00000000                      DS8 104
    128          

   \                                 In section .bss, align 4
    129          struct _ACCIDENT Accident_Buffer[1000];
   \                     Accident_Buffer:
   \   00000000                      DS8 8000

   \                                 In section .bss, align 4
    130          struct _ACCIDENT2 Accident2_Buffer[10]; 
   \                     Accident2_Buffer:
   \   00000000                      DS8 172
    131          

   \                                 In section .bss, align 4
    132          struct _ACCIDENT Accident_SaveBuffer[1000];
   \                     Accident_SaveBuffer:
   \   00000000                      DS8 8000

   \                                 In section .bss, align 4
    133          struct _ACCIDENT2 Accident2_SaveBuffer[10]; 
   \                     Accident2_SaveBuffer:
   \   00000000                      DS8 172
    134          

   \                                 In section .bss, align 4
    135          u8 Accident_Time[13];
   \                     Accident_Time:
   \   00000000                      DS8 16
    136          

   \                                 In section .bss, align 2
    137          u16 AccidentPoint;
   \                     AccidentPoint:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
    138          u16 AccidentPoint2;
   \                     AccidentPoint2:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
    139          struct _ECO_Driving ECO_Driving;
   \                     ECO_Driving:
   \   00000000                      DS8 12
    140          
    141          /* Private function prototypes -----------------------------------------------*/
    142          void TIM6_Config(void);    // 타이머 => DAC 에 클럭 공급한다.
    143          
    144          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLEDFlash_size
    145          #pragma data_alignment = 4 
    146          #endif

   \                                 In section .bss, align 4
    147          USB_OTG_CORE_HANDLE           USB_OTG_Core;
   \                     USB_OTG_Core:
   \   00000000                      DS8 1200

   \                                 In section .bss, align 4
    148          USBH_HOST                     USB_Host;
   \                     USB_Host:
   \   00000000                      DS8 132
    149          
    150          
    151          /*************************************************************************************
    152          와치독을 초기화한다.
    153          *************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    154          void InitIWDG(void)
    155          {
   \                     InitIWDG:
   \   00000000   80B5               PUSH     {R7,LR}
    156          /* IWDG timeout equal to 280 ms (the timeout may varies due to LSI frequency
    157                dispersion) -------------------------------------------------------------*/
    158          	/* Enable write access to IWDG_PR and IWDG_RLR registers */
    159               
    160              if (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) != RESET)
   \   00000002   7D20               MOVS     R0,#+125
   \   00000004   ........           BL       RCC_GetFlagStatus
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   0AD0               BEQ.N    ??InitIWDG_0
    161              {
    162                   printf("IWDGRST flag set ...\n");
   \   0000000C   ........           LDR.W    R0,??DataTable28_3
   \   00000010   ........           BL       printf
    163                  /* IWDGRST flag set */
    164                  /* Clear reset flags */
    165                  Flag.WatchDog = 1;
   \   00000014   ........           LDR.W    R0,??DataTable31_1
   \   00000018   0121               MOVS     R1,#+1
   \   0000001A   0172               STRB     R1,[R0, #+8]
    166          
    167                  RCC_ClearFlag();
   \   0000001C   ........           BL       RCC_ClearFlag
   \   00000020   07E0               B.N      ??InitIWDG_1
    168              }
    169              else
    170              {
    171                  printf("IWDGRST flag is not set ...\n");
   \                     ??InitIWDG_0:
   \   00000022   ........           LDR.W    R0,??DataTable28_4
   \   00000026   ........           BL       printf
    172                  Flag.WatchDog = 0;
   \   0000002A   ........           LDR.W    R0,??DataTable31_1
   \   0000002E   0021               MOVS     R1,#+0
   \   00000030   0172               STRB     R1,[R0, #+8]
    173              }
    174          	IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
   \                     ??InitIWDG_1:
   \   00000032   45F25550           MOVW     R0,#+21845
   \   00000036   ........           BL       IWDG_WriteAccessCmd
    175          	
    176          	/* IWDG counter clock: 40KHz(LSI) / 32 = 1.25 KHz */
    177          	IWDG_SetPrescaler(IWDG_Prescaler_256);
   \   0000003A   0620               MOVS     R0,#+6
   \   0000003C   ........           BL       IWDG_SetPrescaler
    178          
    179          	/* Set counter reload value to 349 */
    180          	IWDG_SetReload(349);
   \   00000040   40F25D10           MOVW     R0,#+349
   \   00000044   ........           BL       IWDG_SetReload
    181          	
    182          	/* Reload IWDG counter */
    183          	IWDG_ReloadCounter();
   \   00000048   ........           BL       IWDG_ReloadCounter
    184          	
    185          	/* Enable IWDG (the LSI oscillator will be enabled by hardware) */
    186          	IWDG_Enable();
   \   0000004C   ........           BL       IWDG_Enable
    187          }
   \   00000050   01BD               POP      {R0,PC}          ;; return
    188          

   \                                 In section .text, align 2, keep-with-next
    189          void InitWWDG(void)
    190          {
   \                     InitWWDG:
   \   00000000   80B5               PUSH     {R7,LR}
    191               NVIC_InitTypeDef NVIC_InitStructure;
    192               if (RCC_GetFlagStatus(RCC_FLAG_WWDGRST) != RESET)
   \   00000002   7E20               MOVS     R0,#+126
   \   00000004   ........           BL       RCC_GetFlagStatus
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   06D0               BEQ.N    ??InitWWDG_0
    193               {
    194                    printf(" WatchDog Reset !!!!!!!!!!!!!!!!! \r\n");
   \   0000000C   ........           LDR.W    R0,??DataTable28_5
   \   00000010   ........           BL       printf
    195                    RCC_ClearFlag();
   \   00000014   ........           BL       RCC_ClearFlag
   \   00000018   03E0               B.N      ??InitWWDG_1
    196               }else
    197               {
    198                    printf(" Normal BootOn WatchDog Start \r\n");
   \                     ??InitWWDG_0:
   \   0000001A   ........           LDR.W    R0,??DataTable31_2
   \   0000001E   ........           BL       printf
    199               }
    200              /* Enable the WWDG Interrupt */
    201               NVIC_InitStructure.NVIC_IRQChannel = WWDG_IRQn;
   \                     ??InitWWDG_1:
   \   00000022   0020               MOVS     R0,#+0
   \   00000024   8DF80000           STRB     R0,[SP, #+0]
    202               NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
   \   00000028   0120               MOVS     R0,#+1
   \   0000002A   8DF80100           STRB     R0,[SP, #+1]
    203               NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
   \   0000002E   0120               MOVS     R0,#+1
   \   00000030   8DF80200           STRB     R0,[SP, #+2]
    204               NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000034   0120               MOVS     R0,#+1
   \   00000036   8DF80300           STRB     R0,[SP, #+3]
    205               NVIC_Init(&NVIC_InitStructure);
   \   0000003A   00A8               ADD      R0,SP,#+0
   \   0000003C   ........           BL       NVIC_Init
    206               
    207               RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE); 
   \   00000040   0121               MOVS     R1,#+1
   \   00000042   4FF40060           MOV      R0,#+2048
   \   00000046   ........           BL       RCC_APB1PeriphClockCmd
    208               
    209               WWDG_SetPrescaler(WWDG_Prescaler_8);     
   \   0000004A   4FF4C070           MOV      R0,#+384
   \   0000004E   ........           BL       WWDG_SetPrescaler
    210               WWDG_SetWindowValue(65);
   \   00000052   4120               MOVS     R0,#+65
   \   00000054   ........           BL       WWDG_SetWindowValue
    211               
    212               WWDG_Enable(127);
   \   00000058   7F20               MOVS     R0,#+127
   \   0000005A   ........           BL       WWDG_Enable
    213              /* Clear EWI flag */
    214               WWDG_ClearFlag();     
   \   0000005E   ........           BL       WWDG_ClearFlag
    215               WWDG_EnableIT();     
   \   00000062   ........           BL       WWDG_EnableIT
    216              // while(1);
    217               
    218          }
   \   00000066   01BD               POP      {R0,PC}          ;; return
    219          
    220          /**********************************************************************/
    221          

   \                                 In section .text, align 2, keep-with-next
    222          void GPIO_Configuration()
    223          {    
   \                     GPIO_Configuration:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   83B0               SUB      SP,SP,#+12
    224          	RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOG , ENABLE);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   4020               MOVS     R0,#+64
   \   00000008   ........           BL       RCC_AHB1PeriphClockCmd
    225          	GPIO_InitTypeDef GPIO_InitStructure;
    226          	// LED 초기화 3색 
    227          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 ;
   \   0000000C   4FF4F040           MOV      R0,#+30720
   \   00000010   0090               STR      R0,[SP, #+0]
    228          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   \   00000012   0120               MOVS     R0,#+1
   \   00000014   8DF80400           STRB     R0,[SP, #+4]
    229          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   8DF80600           STRB     R0,[SP, #+6]
    230          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;     
   \   0000001E   0020               MOVS     R0,#+0
   \   00000020   8DF80700           STRB     R0,[SP, #+7]
    231          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000024   0220               MOVS     R0,#+2
   \   00000026   8DF80500           STRB     R0,[SP, #+5]
    232          	GPIO_Init(GPIOG, &GPIO_InitStructure);
   \   0000002A   00A9               ADD      R1,SP,#+0
   \   0000002C   ........           LDR.W    R0,??DataTable30_1  ;; 0x40021800
   \   00000030   ........           BL       GPIO_Init
    233          }
   \   00000034   07BD               POP      {R0-R2,PC}       ;; return
    234          /**********************************************************************/
    235          

   \                                 In section .text, align 2, keep-with-next
    236          void GPIO_Configuration2()
    237          {
   \                     GPIO_Configuration2:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   83B0               SUB      SP,SP,#+12
    238          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);     
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   0220               MOVS     R0,#+2
   \   00000008   ........           BL       RCC_AHB1PeriphClockCmd
    239          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   0420               MOVS     R0,#+4
   \   00000010   ........           BL       RCC_AHB1PeriphClockCmd
    240          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);  
   \   00000014   0121               MOVS     R1,#+1
   \   00000016   0820               MOVS     R0,#+8
   \   00000018   ........           BL       RCC_AHB1PeriphClockCmd
    241          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);
   \   0000001C   0121               MOVS     R1,#+1
   \   0000001E   1020               MOVS     R0,#+16
   \   00000020   ........           BL       RCC_AHB1PeriphClockCmd
    242          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG, ENABLE);  
   \   00000024   0121               MOVS     R1,#+1
   \   00000026   4020               MOVS     R0,#+64
   \   00000028   ........           BL       RCC_AHB1PeriphClockCmd
    243          	GPIO_InitTypeDef GPIO_InitStructure;
    244          	
    245          	/* Configure the GPIO_LED pin */
    246          	GPIO_InitStructure.GPIO_Pin = IN_CPU_GEAR_STATUS_FLAG|IN_CPU_BREAK_LAMP_STATUS_FLAG|IN_CPU_PARKING_BREAK_STATUS_FLAG;
   \   0000002C   4FF46070           MOV      R0,#+896
   \   00000030   0090               STR      R0,[SP, #+0]
    247          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   00000032   0020               MOVS     R0,#+0
   \   00000034   8DF80400           STRB     R0,[SP, #+4]
    248          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000038   0020               MOVS     R0,#+0
   \   0000003A   8DF80600           STRB     R0,[SP, #+6]
    249          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   0000003E   0120               MOVS     R0,#+1
   \   00000040   8DF80700           STRB     R0,[SP, #+7]
    250          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   \   00000044   0320               MOVS     R0,#+3
   \   00000046   8DF80500           STRB     R0,[SP, #+5]
    251          	GPIO_Init(IN_CPU_EMS_PORT, &GPIO_InitStructure);        // 기어 상태 초기화
   \   0000004A   00A9               ADD      R1,SP,#+0
   \   0000004C   ........           LDR.W    R0,??DataTable30_2  ;; 0x40020800
   \   00000050   ........           BL       GPIO_Init
    252          	
    253          	
    254          	GPIO_InitStructure.GPIO_Pin = IN_CPU_F_DOOR_STATUS_FLAG;
   \   00000054   4FF40070           MOV      R0,#+512
   \   00000058   0090               STR      R0,[SP, #+0]
    255          	GPIO_Init(IN_CPU_F_DOOR_PORT, &GPIO_InitStructure);        // 도어 프론트
   \   0000005A   00A9               ADD      R1,SP,#+0
   \   0000005C   ........           LDR.W    R0,??DataTable30_1  ;; 0x40021800
   \   00000060   ........           BL       GPIO_Init
    256          	
    257          	GPIO_InitStructure.GPIO_Pin = IN_CPU_R_DOOR_STATUS_FLAG;
   \   00000064   4FF48070           MOV      R0,#+256
   \   00000068   0090               STR      R0,[SP, #+0]
    258          	GPIO_Init(IN_CPU_R_DOOR_PORT, &GPIO_InitStructure);        // 도어 옆문
   \   0000006A   00A9               ADD      R1,SP,#+0
   \   0000006C   ........           LDR.W    R0,??DataTable30_1  ;; 0x40021800
   \   00000070   ........           BL       GPIO_Init
    259          	
    260          	
    261          	GPIO_InitStructure.GPIO_Pin = IN_CPU_KEY_STATUS_FLAG | IN_CPU_R_DISTANCE_STATUS_FLAG;
   \   00000074   4FF44070           MOV      R0,#+768
   \   00000078   0090               STR      R0,[SP, #+0]
    262          	GPIO_Init(IN_CPU_DISTANCE_PORT, &GPIO_InitStructure);       
   \   0000007A   00A9               ADD      R1,SP,#+0
   \   0000007C   ........           LDR.W    R0,??DataTable31_3  ;; 0x40020c00
   \   00000080   ........           BL       GPIO_Init
    263          	
    264          	
    265          	GPIO_InitStructure.GPIO_Pin = IN_CPU_R_LIGHT_STATUS_FLAG;			// 깜박이 R신호
   \   00000084   4FF48050           MOV      R0,#+4096
   \   00000088   0090               STR      R0,[SP, #+0]
    266          	GPIO_Init(IN_CPU_RLIGHT_PORT, &GPIO_InitStructure);        
   \   0000008A   00A9               ADD      R1,SP,#+0
   \   0000008C   ........           LDR.W    R0,??DataTable30_2  ;; 0x40020800
   \   00000090   ........           BL       GPIO_Init
    267               
    268          	GPIO_InitStructure.GPIO_Pin = IN_CPU_L_LIGHT_STATUS_FLAG ;			// 깜박이 L 신호
   \   00000094   4FF48070           MOV      R0,#+256
   \   00000098   0090               STR      R0,[SP, #+0]
    269          	GPIO_Init(IN_CPU_LLIGHT_PORT, &GPIO_InitStructure);      	
   \   0000009A   00A9               ADD      R1,SP,#+0
   \   0000009C   ........           LDR.W    R0,??DataTable30_3  ;; 0x40020000
   \   000000A0   ........           BL       GPIO_Init
    270          	
    271          	
    272          	
    273          	GPIO_InitStructure.GPIO_Pin = OUT_CPU_ENGINE_ON |OUT_CPU_ENGINE_OFF;
   \   000000A4   4FF4C050           MOV      R0,#+6144
   \   000000A8   0090               STR      R0,[SP, #+0]
    274          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   \   000000AA   0120               MOVS     R0,#+1
   \   000000AC   8DF80400           STRB     R0,[SP, #+4]
    275          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   000000B0   0020               MOVS     R0,#+0
   \   000000B2   8DF80600           STRB     R0,[SP, #+6]
    276          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   000000B6   0120               MOVS     R0,#+1
   \   000000B8   8DF80700           STRB     R0,[SP, #+7]
    277          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   000000BC   0220               MOVS     R0,#+2
   \   000000BE   8DF80500           STRB     R0,[SP, #+5]
    278          	GPIO_Init(OUT_CPU_ENGINE_PORT, &GPIO_InitStructure);  
   \   000000C2   00A9               ADD      R1,SP,#+0
   \   000000C4   ........           LDR.W    R0,??DataTable31_4  ;; 0x40021000
   \   000000C8   ........           BL       GPIO_Init
    279          	
    280          	GPIO_InitStructure.GPIO_Pin = OUT_CPU_LIGHT_ON;
   \   000000CC   4FF40050           MOV      R0,#+8192
   \   000000D0   0090               STR      R0,[SP, #+0]
    281          	GPIO_Init(OUT_CPU_LIGHT_PORT, &GPIO_InitStructure);        // 전조등 세팅
   \   000000D2   00A9               ADD      R1,SP,#+0
   \   000000D4   ........           LDR.W    R0,??DataTable31_4  ;; 0x40021000
   \   000000D8   ........           BL       GPIO_Init
    282          	
    283          	GPIO_InitStructure.GPIO_Pin = OUT_CPU_AIRCON_ON;
   \   000000DC   2020               MOVS     R0,#+32
   \   000000DE   0090               STR      R0,[SP, #+0]
    284          	GPIO_Init(OUT_CPU_AIRCON_PORT, &GPIO_InitStructure);        // 도어 옆문
   \   000000E0   00A9               ADD      R1,SP,#+0
   \   000000E2   ........           LDR.W    R0,??DataTable30_1  ;; 0x40021800
   \   000000E6   ........           BL       GPIO_Init
    285          	
    286          	GPIO_InitStructure.GPIO_Pin = OUT_CPU_L_TURN_POWER | OUT_CPU_R_TURN_POWER;
   \   000000EA   1820               MOVS     R0,#+24
   \   000000EC   0090               STR      R0,[SP, #+0]
    287          	GPIO_Init(OUT_CPU_TURNPOWER_PORT, &GPIO_InitStructure);        // 도어 옆문
   \   000000EE   00A9               ADD      R1,SP,#+0
   \   000000F0   ........           LDR.W    R0,??DataTable30_1  ;; 0x40021800
   \   000000F4   ........           BL       GPIO_Init
    288          	
    289          	
    290          	GPIO_InitStructure.GPIO_Pin = OUT_CPU_HITER;
   \   000000F8   0420               MOVS     R0,#+4
   \   000000FA   0090               STR      R0,[SP, #+0]
    291          	GPIO_Init(OUT_CPU_HITER_PORT, &GPIO_InitStructure);        // 도어 옆문
   \   000000FC   00A9               ADD      R1,SP,#+0
   \   000000FE   ........           LDR.W    R0,??DataTable30_1  ;; 0x40021800
   \   00000102   ........           BL       GPIO_Init
    292          	
    293          	GPIO_InitStructure.GPIO_Pin = OUT_CPU_RESERVE2;
   \   00000106   4FF40050           MOV      R0,#+8192
   \   0000010A   0090               STR      R0,[SP, #+0]
    294          	GPIO_Init(OUT_CPU_RESERVE2_PORT, &GPIO_InitStructure);        // 도어 옆문  
   \   0000010C   00A9               ADD      R1,SP,#+0
   \   0000010E   ........           LDR.W    R0,??DataTable31_3  ;; 0x40020c00
   \   00000112   ........           BL       GPIO_Init
    295          }
   \   00000116   07BD               POP      {R0-R2,PC}       ;; return
    296          /**********************************************************************/
    297          
    298          
    299          /**
    300          * @brief  DAC  Channel2 SineWave Configuration
    301          * @param  None
    302          * @retval None
    303          */
    304          

   \                                 In section .text, align 2, keep-with-next
    305          void EXTILine1_Config(void)
    306          {
   \                     EXTILine1_Config:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   85B0               SUB      SP,SP,#+20
    307          	EXTI_InitTypeDef   EXTI_InitStructure;
    308          	GPIO_InitTypeDef   GPIO_InitStructure;
    309          	NVIC_InitTypeDef   NVIC_InitStructure;
    310          	
    311          	/* Enable GPIOA clock */
    312          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   0820               MOVS     R0,#+8
   \   00000008   ........           BL       RCC_AHB1PeriphClockCmd
    313          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);  
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   0220               MOVS     R0,#+2
   \   00000010   ........           BL       RCC_AHB1PeriphClockCmd
    314          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG, ENABLE);    
   \   00000014   0121               MOVS     R1,#+1
   \   00000016   4020               MOVS     R0,#+64
   \   00000018   ........           BL       RCC_AHB1PeriphClockCmd
    315          	/* Enable SYSCFG clock */
    316          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
   \   0000001C   0121               MOVS     R1,#+1
   \   0000001E   4FF48040           MOV      R0,#+16384
   \   00000022   ........           BL       RCC_APB2PeriphClockCmd
    317          	
    318          	/* Configure PA0 pin as input floating */
    319          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   \   00000026   0320               MOVS     R0,#+3
   \   00000028   8DF81100           STRB     R0,[SP, #+17]
    320          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   0000002C   0020               MOVS     R0,#+0
   \   0000002E   8DF81000           STRB     R0,[SP, #+16]
    321          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;     
   \   00000032   0020               MOVS     R0,#+0
   \   00000034   8DF81200           STRB     R0,[SP, #+18]
    322          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
   \   00000038   0020               MOVS     R0,#+0
   \   0000003A   8DF81300           STRB     R0,[SP, #+19]
    323          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   0000003E   4FF48060           MOV      R0,#+1024
   \   00000042   0390               STR      R0,[SP, #+12]
    324          	GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   00000044   03A9               ADD      R1,SP,#+12
   \   00000046   ........           LDR.W    R0,??DataTable31_3  ;; 0x40020c00
   \   0000004A   ........           BL       GPIO_Init
    325          	
    326          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
   \   0000004E   4020               MOVS     R0,#+64
   \   00000050   0390               STR      R0,[SP, #+12]
    327          	GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   00000052   03A9               ADD      R1,SP,#+12
   \   00000054   ........           LDR.W    R0,??DataTable31_5  ;; 0x40020400
   \   00000058   ........           BL       GPIO_Init
    328          	
    329          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
   \   0000005C   4FF40040           MOV      R0,#+32768
   \   00000060   0390               STR      R0,[SP, #+12]
    330          	GPIO_Init(GPIOG, &GPIO_InitStructure);
   \   00000062   03A9               ADD      R1,SP,#+12
   \   00000064   ........           LDR.W    R0,??DataTable30_1  ;; 0x40021800
   \   00000068   ........           BL       GPIO_Init
    331          	/* Connect EXTI Line0 to PA0 pin */
    332          	
    333          	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource10);     // LPG PWM 	
   \   0000006C   0A21               MOVS     R1,#+10
   \   0000006E   0320               MOVS     R0,#+3
   \   00000070   ........           BL       SYSCFG_EXTILineConfig
    334          	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource6);     // SPEED PIN
   \   00000074   0621               MOVS     R1,#+6
   \   00000076   0120               MOVS     R0,#+1
   \   00000078   ........           BL       SYSCFG_EXTILineConfig
    335          	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOG, EXTI_PinSource15);    // RPM PIN
   \   0000007C   0F21               MOVS     R1,#+15
   \   0000007E   0620               MOVS     R0,#+6
   \   00000080   ........           BL       SYSCFG_EXTILineConfig
    336          	
    337          	// Configure EXTI Line0 
    338          	EXTI_InitStructure.EXTI_Line = EXTI_Line10;
   \   00000084   4FF48060           MOV      R0,#+1024
   \   00000088   0190               STR      R0,[SP, #+4]
    339          	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   0000008A   0020               MOVS     R0,#+0
   \   0000008C   8DF80800           STRB     R0,[SP, #+8]
    340          	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;   // PWM 측정을 위해 라이징 폴링 엣지
   \   00000090   1020               MOVS     R0,#+16
   \   00000092   8DF80900           STRB     R0,[SP, #+9]
    341          	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   00000096   0120               MOVS     R0,#+1
   \   00000098   8DF80A00           STRB     R0,[SP, #+10]
    342          	EXTI_Init(&EXTI_InitStructure);
   \   0000009C   01A8               ADD      R0,SP,#+4
   \   0000009E   ........           BL       EXTI_Init
    343          	
    344          	// Configure EXTI Line6 
    345          	// 외부 스피드 입력 설정
    346          	EXTI_InitStructure.EXTI_Line = EXTI_Line6;                  //  Speed 입력핀
   \   000000A2   4020               MOVS     R0,#+64
   \   000000A4   0190               STR      R0,[SP, #+4]
    347          	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;         // 외부 인터럽트
   \   000000A6   0020               MOVS     R0,#+0
   \   000000A8   8DF80800           STRB     R0,[SP, #+8]
    348          	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;  // 
   \   000000AC   0820               MOVS     R0,#+8
   \   000000AE   8DF80900           STRB     R0,[SP, #+9]
    349          	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   000000B2   0120               MOVS     R0,#+1
   \   000000B4   8DF80A00           STRB     R0,[SP, #+10]
    350          	EXTI_Init(&EXTI_InitStructure);
   \   000000B8   01A8               ADD      R0,SP,#+4
   \   000000BA   ........           BL       EXTI_Init
    351          	
    352          	// Configure EXTI Line6 
    353          	// 외부 RPM 입력 설정
    354          	EXTI_InitStructure.EXTI_Line = EXTI_Line15;                 //  RPM 입력핀  /
   \   000000BE   4FF40040           MOV      R0,#+32768
   \   000000C2   0190               STR      R0,[SP, #+4]
    355          	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;         // 외부 인터럽트
   \   000000C4   0020               MOVS     R0,#+0
   \   000000C6   8DF80800           STRB     R0,[SP, #+8]
    356          	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;  // 
   \   000000CA   0820               MOVS     R0,#+8
   \   000000CC   8DF80900           STRB     R0,[SP, #+9]
    357          	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   000000D0   0120               MOVS     R0,#+1
   \   000000D2   8DF80A00           STRB     R0,[SP, #+10]
    358          	EXTI_Init(&EXTI_InitStructure);
   \   000000D6   01A8               ADD      R0,SP,#+4
   \   000000D8   ........           BL       EXTI_Init
    359          	
    360          
    361          	NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQn;
   \   000000DC   1720               MOVS     R0,#+23
   \   000000DE   8DF80000           STRB     R0,[SP, #+0]
    362          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0F;
   \   000000E2   0F20               MOVS     R0,#+15
   \   000000E4   8DF80100           STRB     R0,[SP, #+1]
    363          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F;
   \   000000E8   0F20               MOVS     R0,#+15
   \   000000EA   8DF80200           STRB     R0,[SP, #+2]
    364          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   000000EE   0120               MOVS     R0,#+1
   \   000000F0   8DF80300           STRB     R0,[SP, #+3]
    365          	NVIC_Init(&NVIC_InitStructure);
   \   000000F4   00A8               ADD      R0,SP,#+0
   \   000000F6   ........           BL       NVIC_Init
    366          	
    367          	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
   \   000000FA   2820               MOVS     R0,#+40
   \   000000FC   8DF80000           STRB     R0,[SP, #+0]
    368          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x01;
   \   00000100   0120               MOVS     R0,#+1
   \   00000102   8DF80100           STRB     R0,[SP, #+1]
    369          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F;
   \   00000106   0F20               MOVS     R0,#+15
   \   00000108   8DF80200           STRB     R0,[SP, #+2]
    370          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000010C   0120               MOVS     R0,#+1
   \   0000010E   8DF80300           STRB     R0,[SP, #+3]
    371          	NVIC_Init(&NVIC_InitStructure);  
   \   00000112   00A8               ADD      R0,SP,#+0
   \   00000114   ........           BL       NVIC_Init
    372          	
    373          	EXTI_GenerateSWInterrupt(EXTI_Line10);       // LPG_PWM
   \   00000118   4FF48060           MOV      R0,#+1024
   \   0000011C   ........           BL       EXTI_GenerateSWInterrupt
    374          	EXTI_GenerateSWInterrupt(EXTI_Line6);    
   \   00000120   4020               MOVS     R0,#+64
   \   00000122   ........           BL       EXTI_GenerateSWInterrupt
    375          	EXTI_GenerateSWInterrupt(EXTI_Line15);          
   \   00000126   4FF40040           MOV      R0,#+32768
   \   0000012A   ........           BL       EXTI_GenerateSWInterrupt
    376          }
   \   0000012E   05B0               ADD      SP,SP,#+20
   \   00000130   00BD               POP      {PC}             ;; return
    377          
    378          

   \                                 In section .text, align 2, keep-with-next
    379          void TIM3_Config(void)
    380          {
   \                     TIM3_Config:
   \   00000000   E0B5               PUSH     {R5-R7,LR}
    381               TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
    382               RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   0220               MOVS     R0,#+2
   \   00000006   ........           BL       RCC_APB1PeriphClockCmd
    383               
    384               // 72Mhz use scale : 72Mhz / 7200 = 10Khz > 100us 
    385               // scale      
    386               
    387               TIM_TimeBaseStructure.TIM_Period = 0xffff ; // 오버플로워 한계값 1000;    // 1000us 1ms
   \   0000000A   4FF6FF70           MOVW     R0,#+65535
   \   0000000E   0190               STR      R0,[SP, #+4]
    388               // Prescaler 의 변수크기가 16 Bit 이므로 72000은 값이 들어가지 안음
    389               // 프로그램 오차로 인해 90은 99.5khz 고 89는 100.0 khz이므로 측정시 89로 세팅해야
    390               // 10us가 나옴
    391               // 450 = 25us / 900 = 50us / 1800 = 100us
    392               // 
    393               
    394               TIM_TimeBaseStructure.TIM_Prescaler = 1800 - 1;   // 72hz / 7200 / 1000 
   \   00000010   40F20770           MOVW     R0,#+1799
   \   00000014   ADF80000           STRH     R0,[SP, #+0]
    395               TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   ADF80800           STRH     R0,[SP, #+8]
    396               TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
   \   0000001E   0020               MOVS     R0,#+0
   \   00000020   ADF80200           STRH     R0,[SP, #+2]
    397               //  TIM_PrescalerConfig(TIM3, 4, TIM_PSCReloadMode_Update);
    398               TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
   \   00000024   00A9               ADD      R1,SP,#+0
   \   00000026   ........           LDR.W    R0,??DataTable31_6  ;; 0x40000400
   \   0000002A   ........           BL       TIM_TimeBaseInit
    399               TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);  
   \   0000002E   0122               MOVS     R2,#+1
   \   00000030   0121               MOVS     R1,#+1
   \   00000032   ........           LDR.W    R0,??DataTable31_6  ;; 0x40000400
   \   00000036   ........           BL       TIM_ITConfig
    400               TIM_ClearFlag(TIM3,TIM_FLAG_Update);
   \   0000003A   0121               MOVS     R1,#+1
   \   0000003C   ........           LDR.W    R0,??DataTable31_6  ;; 0x40000400
   \   00000040   ........           BL       TIM_ClearFlag
    401               TIM_Cmd(TIM3, ENABLE);
   \   00000044   0121               MOVS     R1,#+1
   \   00000046   ........           LDR.W    R0,??DataTable31_6  ;; 0x40000400
   \   0000004A   ........           BL       TIM_Cmd
    402               
    403               /*
    404               NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
    405               NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    406               NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    407               NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    408               NVIC_Init(&NVIC_InitStructure);
    409               */
    410          }
   \   0000004E   07BD               POP      {R0-R2,PC}       ;; return
    411          
    412          

   \                                 In section .text, align 2, keep-with-next
    413          void TIM4_Config(void)			// 대우 구형 타이머 // 사용하지 않음
    414          {
   \                     TIM4_Config:
   \   00000000   E0B5               PUSH     {R5-R7,LR}
    415               
    416               TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
    417               RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   0420               MOVS     R0,#+4
   \   00000006   ........           BL       RCC_APB1PeriphClockCmd
    418               
    419               TIM_TimeBaseStructure.TIM_Period = 99 ; // 오버플로워 한계값 1000;    // 1000us 1ms
   \   0000000A   6320               MOVS     R0,#+99
   \   0000000C   0190               STR      R0,[SP, #+4]
    420               TIM_TimeBaseStructure.TIM_Prescaler = 36000-1;   // 72hz / 72000 / 1000 
   \   0000000E   48F69F40           MOVW     R0,#+35999
   \   00000012   ADF80000           STRH     R0,[SP, #+0]
    421               TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV2;
   \   00000016   4FF48070           MOV      R0,#+256
   \   0000001A   ADF80800           STRH     R0,[SP, #+8]
    422               TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
   \   0000001E   0020               MOVS     R0,#+0
   \   00000020   ADF80200           STRH     R0,[SP, #+2]
    423               //  TIM_PrescalerConfig(TIM3, 4, TIM_PSCReloadMode_Update);
    424               TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
   \   00000024   00A9               ADD      R1,SP,#+0
   \   00000026   ........           LDR.W    R0,??DataTable31_7  ;; 0x40000800
   \   0000002A   ........           BL       TIM_TimeBaseInit
    425               //  TIM_ITConfig(TIM4, TIM_IT_Update, ENABLE);  
    426               TIM_ClearFlag(TIM4,TIM_FLAG_Update);  
   \   0000002E   0121               MOVS     R1,#+1
   \   00000030   ........           LDR.W    R0,??DataTable31_7  ;; 0x40000800
   \   00000034   ........           BL       TIM_ClearFlag
    427               
    428          }
   \   00000038   07BD               POP      {R0-R2,PC}       ;; return
    429          
    430          

   \                                 In section .text, align 2, keep-with-next
    431          void TIM5_Config(void)
    432          {     
   \                     TIM5_Config:
   \   00000000   E0B5               PUSH     {R5-R7,LR}
    433               TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
    434               RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE);
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   0820               MOVS     R0,#+8
   \   00000006   ........           BL       RCC_APB1PeriphClockCmd
    435               
    436               TIM_TimeBaseStructure.TIM_Period = 0xffff ; // 오버플로워 한계값 1000;    // 1000us 1ms
   \   0000000A   4FF6FF70           MOVW     R0,#+65535
   \   0000000E   0190               STR      R0,[SP, #+4]
    437          //     TIM_TimeBaseStructure.TIM_Period = 1 ; // 오버플로워 한계값 1000;    // 1000us 1ms     
    438               TIM_TimeBaseStructure.TIM_Prescaler = 36000-1;   // 72hz / 72000 / 1000 
   \   00000010   48F69F40           MOVW     R0,#+35999
   \   00000014   ADF80000           STRH     R0,[SP, #+0]
    439               TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV2;
   \   00000018   4FF48070           MOV      R0,#+256
   \   0000001C   ADF80800           STRH     R0,[SP, #+8]
    440               TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
   \   00000020   0020               MOVS     R0,#+0
   \   00000022   ADF80200           STRH     R0,[SP, #+2]
    441               //  TIM_PrescalerConfig(TIM3, 4, TIM_PSCReloadMode_Update);
    442               TIM_TimeBaseInit(TIM5, &TIM_TimeBaseStructure);
   \   00000026   00A9               ADD      R1,SP,#+0
   \   00000028   ........           LDR.W    R0,??DataTable33  ;; 0x40000c00
   \   0000002C   ........           BL       TIM_TimeBaseInit
    443               //  TIM_ITConfig(TIM5, TIM_IT_Update, ENABLE);  
    444               TIM_ClearFlag(TIM5,TIM_FLAG_Update);  
   \   00000030   0121               MOVS     R1,#+1
   \   00000032   ........           LDR.W    R0,??DataTable33  ;; 0x40000c00
   \   00000036   ........           BL       TIM_ClearFlag
    445               
    446               TIM_Cmd(TIM5, ENABLE);        
   \   0000003A   0121               MOVS     R1,#+1
   \   0000003C   ........           LDR.W    R0,??DataTable33  ;; 0x40000c00
   \   00000040   ........           BL       TIM_Cmd
    447          }
   \   00000044   07BD               POP      {R0-R2,PC}       ;; return
    448          

   \                                 In section .text, align 2, keep-with-next
    449          void TIM6_Config(void)    // 타이머 => DAC 에 클럭 공급한다.
    450          {
   \                     TIM6_Config:
   \   00000000   E0B5               PUSH     {R5-R7,LR}
    451          	TIM_TimeBaseInitTypeDef    TIM_TimeBaseStructure;
    452          	/* TIM6 Periph clock enable */
    453          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6, ENABLE);
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   1020               MOVS     R0,#+16
   \   00000006   ........           BL       RCC_APB1PeriphClockCmd
    454          	
    455          	/* Time base configuration */
    456          	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure); 
   \   0000000A   00A8               ADD      R0,SP,#+0
   \   0000000C   ........           BL       TIM_TimeBaseStructInit
    457          	TIM_TimeBaseStructure.TIM_Period = 0xFF;          
   \   00000010   FF20               MOVS     R0,#+255
   \   00000012   0190               STR      R0,[SP, #+4]
    458          	TIM_TimeBaseStructure.TIM_Prescaler = 0;       
   \   00000014   0020               MOVS     R0,#+0
   \   00000016   ADF80000           STRH     R0,[SP, #+0]
    459          	TIM_TimeBaseStructure.TIM_ClockDivision = 0;    
   \   0000001A   0020               MOVS     R0,#+0
   \   0000001C   ADF80800           STRH     R0,[SP, #+8]
    460          	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  
   \   00000020   0020               MOVS     R0,#+0
   \   00000022   ADF80200           STRH     R0,[SP, #+2]
    461          	TIM_TimeBaseInit(TIM6, &TIM_TimeBaseStructure);
   \   00000026   00A9               ADD      R1,SP,#+0
   \   00000028   ........           LDR.W    R0,??DataTable34  ;; 0x40001000
   \   0000002C   ........           BL       TIM_TimeBaseInit
    462          	
    463          	/* TIM6 TRGO selection */
    464          	TIM_SelectOutputTrigger(TIM6, TIM_TRGOSource_Update);
   \   00000030   2021               MOVS     R1,#+32
   \   00000032   ........           LDR.W    R0,??DataTable34  ;; 0x40001000
   \   00000036   ........           BL       TIM_SelectOutputTrigger
    465          	
    466          	/* TIM6 enable counter */
    467          	TIM_Cmd(TIM6, ENABLE);
   \   0000003A   0121               MOVS     R1,#+1
   \   0000003C   ........           LDR.W    R0,??DataTable34  ;; 0x40001000
   \   00000040   ........           BL       TIM_Cmd
    468          }
   \   00000044   07BD               POP      {R0-R2,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
    469          void TIM7_Config(void)		// 2us
    470          {     
   \                     TIM7_Config:
   \   00000000   E0B5               PUSH     {R5-R7,LR}
    471               TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
    472               RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM7, ENABLE);
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   2020               MOVS     R0,#+32
   \   00000006   ........           BL       RCC_APB1PeriphClockCmd
    473               
    474               TIM_TimeBaseStructure.TIM_Period = 0xffff ;                      // 오버플로워 한계값 1000;    // 1000us 1ms
   \   0000000A   4FF6FF70           MOVW     R0,#+65535
   \   0000000E   0190               STR      R0,[SP, #+4]
    475               TIM_TimeBaseStructure.TIM_Prescaler = 18-1;                      // 72hz / 72000 / 1000 // 2us
   \   00000010   1120               MOVS     R0,#+17
   \   00000012   ADF80000           STRH     R0,[SP, #+0]
    476               TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   ADF80800           STRH     R0,[SP, #+8]
    477               TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
   \   0000001C   0020               MOVS     R0,#+0
   \   0000001E   ADF80200           STRH     R0,[SP, #+2]
    478               TIM_TimeBaseInit(TIM7, &TIM_TimeBaseStructure);
   \   00000022   00A9               ADD      R1,SP,#+0
   \   00000024   ........           LDR.W    R0,??DataTable34_1  ;; 0x40001400
   \   00000028   ........           BL       TIM_TimeBaseInit
    479               
    480               TIM_ClearFlag(TIM7,TIM_FLAG_Update);  
   \   0000002C   0121               MOVS     R1,#+1
   \   0000002E   ........           LDR.W    R0,??DataTable34_1  ;; 0x40001400
   \   00000032   ........           BL       TIM_ClearFlag
    481               
    482               TIM_Cmd(TIM7, ENABLE);     
   \   00000036   0121               MOVS     R1,#+1
   \   00000038   ........           LDR.W    R0,??DataTable34_1  ;; 0x40001400
   \   0000003C   ........           BL       TIM_Cmd
    483          }
   \   00000040   07BD               POP      {R0-R2,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
    484          void TIM8_Config(void)
    485          {
   \                     TIM8_Config:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   8BB0               SUB      SP,SP,#+44
    486               GPIO_InitTypeDef GPIO_InitStructure;
    487               TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
    488               TIM_OCInitTypeDef  TIM_OCInitStructure;     
    489               /* TIM3 clock enable */
    490               RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8, ENABLE);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   0220               MOVS     R0,#+2
   \   00000008   ........           BL       RCC_APB2PeriphClockCmd
    491               /* GPIOC clock enable */
    492               RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   0420               MOVS     R0,#+4
   \   00000010   ........           BL       RCC_AHB1PeriphClockCmd
    493               
    494               /* GPIOC Configuration: TIM3 CH1 (PC6), TIM3 CH2 (PC7), TIM3 CH3 (PC8) and TIM3 CH4 (PC9) */
    495               GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 ;
   \   00000014   4020               MOVS     R0,#+64
   \   00000016   0090               STR      R0,[SP, #+0]
    496               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   00000018   0220               MOVS     R0,#+2
   \   0000001A   8DF80400           STRB     R0,[SP, #+4]
    497               GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   \   0000001E   0320               MOVS     R0,#+3
   \   00000020   8DF80500           STRB     R0,[SP, #+5]
    498               GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000024   0020               MOVS     R0,#+0
   \   00000026   8DF80600           STRB     R0,[SP, #+6]
    499               GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
   \   0000002A   0120               MOVS     R0,#+1
   \   0000002C   8DF80700           STRB     R0,[SP, #+7]
    500               GPIO_Init(GPIOC, &GPIO_InitStructure); 
   \   00000030   00A9               ADD      R1,SP,#+0
   \   00000032   ........           LDR.W    R0,??DataTable30_2  ;; 0x40020800
   \   00000036   ........           BL       GPIO_Init
    501               
    502               /* Connect TIM3 pins to AF2 */  
    503               GPIO_PinAFConfig(GPIOC, GPIO_PinSource6, GPIO_AF_TIM8);
   \   0000003A   0322               MOVS     R2,#+3
   \   0000003C   0621               MOVS     R1,#+6
   \   0000003E   ........           LDR.W    R0,??DataTable30_2  ;; 0x40020800
   \   00000042   ........           BL       GPIO_PinAFConfig
    504               /* -----------------------------------------------------------------------
    505               TIM3 Configuration: generate 4 PWM signals with 4 different duty cycles:
    506               The TIM3CLK frequency is set to SystemCoreClock / 2  (Hz), to get TIM3 counter
    507               clock at 20 MHz the Prescaler is computed as following:
    508               - Prescaler = (TIM3CLK / TIM3 counter clock) - 1
    509               SystemCoreClock is set to 120 MHz for STM32F2xx devices
    510               
    511               The TIM3 is running at 30 KHz: TIM3 Frequency = TIM3 counter clock/(ARR + 1)
    512               = 20 MHz / 666 = 30 KHz
    513               TIM3 Channel1 duty cycle = (TIM3_CCR1/ TIM3_ARR)* 100 = 50%
    514               
    515               ----------------------------------------------------------------------- */     
    516               
    517               /* Compute the prescaler value */
    518               //PrescalerValue = (uint16_t) (SystemCoreClock / 20000000) - 1;
    519               
    520               /* Time base configuration */
    521               TIM_TimeBaseStructure.TIM_Period = 65535;
   \   00000046   4FF6FF70           MOVW     R0,#+65535
   \   0000004A   0890               STR      R0,[SP, #+32]
    522               TIM_TimeBaseStructure.TIM_Prescaler = 7200 -1;
   \   0000004C   41F61F40           MOVW     R0,#+7199
   \   00000050   ADF81C00           STRH     R0,[SP, #+28]
    523               TIM_TimeBaseStructure.TIM_ClockDivision = 0;
   \   00000054   0020               MOVS     R0,#+0
   \   00000056   ADF82400           STRH     R0,[SP, #+36]
    524               TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
   \   0000005A   0020               MOVS     R0,#+0
   \   0000005C   ADF81E00           STRH     R0,[SP, #+30]
    525               
    526               TIM_TimeBaseInit(TIM8, &TIM_TimeBaseStructure);
   \   00000060   07A9               ADD      R1,SP,#+28
   \   00000062   ........           LDR.W    R0,??DataTable35  ;; 0x40010400
   \   00000066   ........           BL       TIM_TimeBaseInit
    527               
    528               /* PWM1 Mode configuration: Channel1 */
    529               TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Toggle;
   \   0000006A   3020               MOVS     R0,#+48
   \   0000006C   ADF80800           STRH     R0,[SP, #+8]
    530               TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
   \   00000070   0120               MOVS     R0,#+1
   \   00000072   ADF80A00           STRH     R0,[SP, #+10]
    531               TIM_OCInitStructure.TIM_Pulse = 0;
   \   00000076   0020               MOVS     R0,#+0
   \   00000078   0490               STR      R0,[SP, #+16]
    532               TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
   \   0000007A   0020               MOVS     R0,#+0
   \   0000007C   ADF81400           STRH     R0,[SP, #+20]
    533          
    534               TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
   \   00000080   0420               MOVS     R0,#+4
   \   00000082   ADF80C00           STRH     R0,[SP, #+12]
    535               TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;
   \   00000086   0020               MOVS     R0,#+0
   \   00000088   ADF81600           STRH     R0,[SP, #+22]
    536               TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;
   \   0000008C   4FF48070           MOV      R0,#+256
   \   00000090   ADF81800           STRH     R0,[SP, #+24]
    537               TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCIdleState_Reset;
   \   00000094   0020               MOVS     R0,#+0
   \   00000096   ADF81A00           STRH     R0,[SP, #+26]
    538               
    539               TIM_OC1Init(TIM8, &TIM_OCInitStructure);
   \   0000009A   02A9               ADD      R1,SP,#+8
   \   0000009C   ........           LDR.W    R0,??DataTable35  ;; 0x40010400
   \   000000A0   ........           BL       TIM_OC1Init
    540               
    541               TIM_OC1PreloadConfig(TIM8, TIM_OCPreload_Enable);
   \   000000A4   0821               MOVS     R1,#+8
   \   000000A6   ........           LDR.W    R0,??DataTable35  ;; 0x40010400
   \   000000AA   ........           BL       TIM_OC1PreloadConfig
    542               
    543               TIM_ARRPreloadConfig(TIM8, ENABLE);
   \   000000AE   0121               MOVS     R1,#+1
   \   000000B0   ........           LDR.W    R0,??DataTable35  ;; 0x40010400
   \   000000B4   ........           BL       TIM_ARRPreloadConfig
    544               
    545               /* TIM8 enable counter */
    546               TIM_Cmd(TIM8, ENABLE);
   \   000000B8   0121               MOVS     R1,#+1
   \   000000BA   ........           LDR.W    R0,??DataTable35  ;; 0x40010400
   \   000000BE   ........           BL       TIM_Cmd
    547               TIM_CtrlPWMOutputs(TIM8, ENABLE);
   \   000000C2   0121               MOVS     R1,#+1
   \   000000C4   ........           LDR.W    R0,??DataTable35  ;; 0x40010400
   \   000000C8   ........           BL       TIM_CtrlPWMOutputs
    548          
    549               
    550          }
   \   000000CC   0BB0               ADD      SP,SP,#+44
   \   000000CE   00BD               POP      {PC}             ;; return
    551          
    552          //***************************************************************************************************************
    553          //  주어진 시간이 경과되었는지 확인한다. 1ms 단위 
    554          //***************************************************************************************************************
    555          

   \                                 In section .text, align 2, keep-with-next
    556          unsigned char CheckTimeOver(u16 ms, u16 OldTime)
    557          {
   \                     CheckTimeOver:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    558               volatile u32 timer;
    559               
    560               timer = MS_TIMER;               
   \   00000006   ........           LDR.W    R0,??DataTable35_1  ;; 0x40000c00
   \   0000000A   ........           BL       TIM_GetCounter
   \   0000000E   0090               STR      R0,[SP, #+0]
    561               
    562               if (OldTime > timer) {
   \   00000010   0098               LDR      R0,[SP, #+0]
   \   00000012   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000014   A842               CMP      R0,R5
   \   00000016   0CD2               BCS.N    ??CheckTimeOver_0
    563                    return (((u32) timer + 0x10000) >= ((u32) OldTime + ms)) ? 1:0;
   \   00000018   0098               LDR      R0,[SP, #+0]
   \   0000001A   10F58030           ADDS     R0,R0,#+65536
   \   0000001E   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000020   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000022   6119               ADDS     R1,R4,R5
   \   00000024   8842               CMP      R0,R1
   \   00000026   01D3               BCC.N    ??CheckTimeOver_1
   \   00000028   0120               MOVS     R0,#+1
   \   0000002A   00E0               B.N      ??CheckTimeOver_2
   \                     ??CheckTimeOver_1:
   \   0000002C   0020               MOVS     R0,#+0
   \                     ??CheckTimeOver_2:
   \   0000002E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   09E0               B.N      ??CheckTimeOver_3
    564               }
    565               else
    566               {
    567                    return ((u32) timer >= ((u32) OldTime + ms)) ? 1:0;
   \                     ??CheckTimeOver_0:
   \   00000032   0098               LDR      R0,[SP, #+0]
   \   00000034   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000036   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000038   6119               ADDS     R1,R4,R5
   \   0000003A   8842               CMP      R0,R1
   \   0000003C   01D3               BCC.N    ??CheckTimeOver_4
   \   0000003E   0120               MOVS     R0,#+1
   \   00000040   00E0               B.N      ??CheckTimeOver_5
   \                     ??CheckTimeOver_4:
   \   00000042   0020               MOVS     R0,#+0
   \                     ??CheckTimeOver_5:
   \   00000044   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??CheckTimeOver_3:
   \   00000046   32BD               POP      {R1,R4,R5,PC}    ;; return
    568               }
    569          }
    570          

   \                                 In section .text, align 2, keep-with-next
    571          unsigned char CheckTimeOver1Sec(u16 ms, u16 OldTime)
    572          {
   \                     CheckTimeOver1Sec:
   \   00000000   81B0               SUB      SP,SP,#+4
    573               volatile u32 timer;
    574               
    575               timer = MS_TIMER_1sec;               
   \   00000002   ........           LDR.W    R2,??DataTable35_2
   \   00000006   1288               LDRH     R2,[R2, #+0]
   \   00000008   0092               STR      R2,[SP, #+0]
    576               
    577               if (OldTime > timer) {
   \   0000000A   009A               LDR      R2,[SP, #+0]
   \   0000000C   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   8A42               CMP      R2,R1
   \   00000010   0CD2               BCS.N    ??CheckTimeOver1Sec_0
    578                    return (((u32) timer + 0x10000) >= ((u32) OldTime + ms)) ? 1:0;
   \   00000012   009A               LDR      R2,[SP, #+0]
   \   00000014   12F58032           ADDS     R2,R2,#+65536
   \   00000018   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001A   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001C   4018               ADDS     R0,R0,R1
   \   0000001E   8242               CMP      R2,R0
   \   00000020   01D3               BCC.N    ??CheckTimeOver1Sec_1
   \   00000022   0120               MOVS     R0,#+1
   \   00000024   00E0               B.N      ??CheckTimeOver1Sec_2
   \                     ??CheckTimeOver1Sec_1:
   \   00000026   0020               MOVS     R0,#+0
   \                     ??CheckTimeOver1Sec_2:
   \   00000028   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   09E0               B.N      ??CheckTimeOver1Sec_3
    579               }
    580               else
    581               {
    582                    return ((u32) timer >= ((u32) OldTime + ms)) ? 1:0;
   \                     ??CheckTimeOver1Sec_0:
   \   0000002C   009A               LDR      R2,[SP, #+0]
   \   0000002E   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000030   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000032   4018               ADDS     R0,R0,R1
   \   00000034   8242               CMP      R2,R0
   \   00000036   01D3               BCC.N    ??CheckTimeOver1Sec_4
   \   00000038   0120               MOVS     R0,#+1
   \   0000003A   00E0               B.N      ??CheckTimeOver1Sec_5
   \                     ??CheckTimeOver1Sec_4:
   \   0000003C   0020               MOVS     R0,#+0
   \                     ??CheckTimeOver1Sec_5:
   \   0000003E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??CheckTimeOver1Sec_3:
   \   00000040   01B0               ADD      SP,SP,#+4
   \   00000042   7047               BX       LR               ;; return
    583               }
    584          }
    585          
    586          //***************************************************************************************************************
    587          //  경과된 시간을 리턴한다. 100us 단위 
    588          //***************************************************************************************************************

   \                                 In section .text, align 2, keep-with-next
    589          u32 CheckTimeInterval_100us(u16 OldTime)
    590          {
   \                     CheckTimeInterval_100us:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   \   00000004   0400               MOVS     R4,R0
    591               volatile u32 timer;
    592               
    593               timer = MS_TIMER_100us;               
   \   00000006   ........           LDR.W    R0,??DataTable31_6  ;; 0x40000400
   \   0000000A   ........           BL       TIM_GetCounter
   \   0000000E   0090               STR      R0,[SP, #+0]
    594               
    595               if (OldTime > timer) {
   \   00000010   0098               LDR      R0,[SP, #+0]
   \   00000012   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000014   A042               CMP      R0,R4
   \   00000016   05D2               BCS.N    ??CheckTimeInterval_100us_0
    596                    return (((u32) timer + 0x10000) - (u32)OldTime );
   \   00000018   0098               LDR      R0,[SP, #+0]
   \   0000001A   10F58030           ADDS     R0,R0,#+65536
   \   0000001E   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000020   001B               SUBS     R0,R0,R4
   \   00000022   02E0               B.N      ??CheckTimeInterval_100us_1
    597               }
    598               else
    599               {
    600                    return ((u32)timer - (u32)OldTime);
   \                     ??CheckTimeInterval_100us_0:
   \   00000024   0098               LDR      R0,[SP, #+0]
   \   00000026   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000028   001B               SUBS     R0,R0,R4
   \                     ??CheckTimeInterval_100us_1:
   \   0000002A   16BD               POP      {R1,R2,R4,PC}    ;; return
    601               }
    602          }
    603          

   \                                 In section .text, align 2, keep-with-next
    604          u32 CheckTimeInterval_1us(u16 OldTime)
    605          {
   \                     CheckTimeInterval_1us:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   \   00000004   0400               MOVS     R4,R0
    606               volatile u32 timer;
    607               
    608               timer = MS_TIMER_2us;               
   \   00000006   ........           LDR.W    R0,??DataTable34_1  ;; 0x40001400
   \   0000000A   ........           BL       TIM_GetCounter
   \   0000000E   0090               STR      R0,[SP, #+0]
    609               
    610               if (OldTime > timer) {
   \   00000010   0098               LDR      R0,[SP, #+0]
   \   00000012   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000014   A042               CMP      R0,R4
   \   00000016   05D2               BCS.N    ??CheckTimeInterval_1us_0
    611                    return (((u32) timer + 0x10000) - (u32)OldTime );
   \   00000018   0098               LDR      R0,[SP, #+0]
   \   0000001A   10F58030           ADDS     R0,R0,#+65536
   \   0000001E   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000020   001B               SUBS     R0,R0,R4
   \   00000022   02E0               B.N      ??CheckTimeInterval_1us_1
    612               }
    613               else
    614               {
    615                    return ((u32)timer - (u32)OldTime);
   \                     ??CheckTimeInterval_1us_0:
   \   00000024   0098               LDR      R0,[SP, #+0]
   \   00000026   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000028   001B               SUBS     R0,R0,R4
   \                     ??CheckTimeInterval_1us_1:
   \   0000002A   16BD               POP      {R1,R2,R4,PC}    ;; return
    616               }
    617          }
    618          
    619          //***************************************************************************************************************
    620          //  문자열을 찾아서 지작점을 받환한다.
    621          //***************************************************************************************************************

   \                                 In section .text, align 2, keep-with-next
    622          u16 FindString( char *string, int StartPoint, char Search )
    623          {
   \                     FindString:
   \   00000000   10B4               PUSH     {R4}
    624          	u16 Point = 0;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   01E0               B.N      ??FindString_0
    625          //     string += StartPoint;
    626          	while(*string)
    627          	{
    628          		if ( Point >= StartPoint ) 
    629          		{
    630          			if( *string == Search )
    631          			{
    632          				return Point;
    633          			}
    634          		}
    635          		Point ++;	
   \                     ??FindString_1:
   \   00000006   5B1C               ADDS     R3,R3,#+1
    636          		string ++;
   \   00000008   401C               ADDS     R0,R0,#+1
   \                     ??FindString_0:
   \   0000000A   0478               LDRB     R4,[R0, #+0]
   \   0000000C   002C               CMP      R4,#+0
   \   0000000E   09D0               BEQ.N    ??FindString_2
   \   00000010   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000012   8B42               CMP      R3,R1
   \   00000014   F7DB               BLT.N    ??FindString_1
   \   00000016   0478               LDRB     R4,[R0, #+0]
   \   00000018   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001A   9442               CMP      R4,R2
   \   0000001C   F3D1               BNE.N    ??FindString_1
   \   0000001E   1800               MOVS     R0,R3
   \   00000020   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000022   01E0               B.N      ??FindString_3
    637          	}
    638          	return -1;
   \                     ??FindString_2:
   \   00000024   4FF6FF70           MOVW     R0,#+65535
   \                     ??FindString_3:
   \   00000028   10BC               POP      {R4}
   \   0000002A   7047               BX       LR               ;; return
    639          }
    640          /*=============================================================================
    641          
    642          속도는 50hz 일때 27km / 100hz 일때 54km
    643          
    644          =============================================================================*/
    645          

   \                                 In section .text, align 2, keep-with-next
    646          void SpeedCheck(void)
    647          {
   \                     SpeedCheck:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
    648               static u16 SPEED_Timer = 0;
    649               
    650               static u16 RPM_Timer = 0;
    651               static u8 Low_Count = 0;
    652          
    653               u8 i;
    654               u32 Speed_Avr;
    655               u32 Speed_Hz;
    656               u16 Speed_Change;
    657          
    658          
    659               u8 error_flg ;
    660               float compare_value ;
    661          //     static u8 Speed_Check_Count = 0;
    662               //-------------------------------------------------------------------------
    663               // 500ms 마다 검사 하는데 낮은 주파수를 정확히 측정하기 위해서는
    664               // 일정 이상의 값을 넣어줘야 한다.
    665               
    666               if(!CheckTimeOver(100,SPEED_Timer))
   \   00000002   ........           LDR.W    R0,??DataTable35_3
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   6420               MOVS     R0,#+100
   \   0000000A   ........           BL       CheckTimeOver
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   00F0D480           BEQ.W    ??SpeedCheck_0
    667                    return;      
    668               
    669               SPEED_Timer = MS_TIMER;  
   \                     ??SpeedCheck_1:
   \   00000014   ........           LDR.W    R0,??DataTable33  ;; 0x40000c00
   \   00000018   ........           BL       TIM_GetCounter
   \   0000001C   ........           LDR.W    R1,??DataTable35_3
   \   00000020   0880               STRH     R0,[R1, #+0]
    670               // 실제 Speed 처리루틴
    671               
    672               Speed_Avr = 0;
   \   00000022   0024               MOVS     R4,#+0
    673          //     Count = SPEED_Count;
    674               
    675               error_flg = 1 ;
   \   00000024   0125               MOVS     R5,#+1
    676               for( i = 0 ; i < MAX_RPMSPEED_BUFFERCOUNT  ; i++)
   \   00000026   0026               MOVS     R6,#+0
   \   00000028   00E0               B.N      ??SpeedCheck_2
   \                     ??SpeedCheck_3:
   \   0000002A   761C               ADDS     R6,R6,#+1
   \                     ??SpeedCheck_2:
   \   0000002C   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002E   142E               CMP      R6,#+20
   \   00000030   21D2               BCS.N    ??SpeedCheck_4
    677               {          
    678                    Speed_Avr += SPEED_Buffer[i];
   \   00000032   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000034   ........           LDR.W    R0,??DataTable35_4
   \   00000038   50F82600           LDR      R0,[R0, R6, LSL #+2]
   \   0000003C   0419               ADDS     R4,R0,R4
    679                    compare_value = (float)((float)SPEED_Buffer[0] / (float)SPEED_Buffer[i]);
   \   0000003E   ........           LDR.W    R0,??DataTable35_4
   \   00000042   0068               LDR      R0,[R0, #+0]
   \   00000044   ........           BL       __aeabi_ui2f
   \   00000048   0700               MOVS     R7,R0
   \   0000004A   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004C   ........           LDR.W    R0,??DataTable35_4
   \   00000050   50F82600           LDR      R0,[R0, R6, LSL #+2]
   \   00000054   ........           BL       __aeabi_ui2f
   \   00000058   0100               MOVS     R1,R0
   \   0000005A   3800               MOVS     R0,R7
   \   0000005C   ........           BL       __aeabi_fdiv
    680                    
    681                    if((compare_value > 1.75) || (compare_value < 0.75))
   \   00000060   ........           LDR.W    R1,??DataTable35_5  ;; 0x3fe00001
   \   00000064   ........           BL       __aeabi_cfrcmple
   \   00000068   04D9               BLS.N    ??SpeedCheck_5
   \   0000006A   5FF07D51           MOVS     R1,#+1061158912
   \   0000006E   ........           BL       __aeabi_cfcmple
   \   00000072   DAD2               BCS.N    ??SpeedCheck_3
    682                    {   
    683                         error_flg =  0 ;
   \                     ??SpeedCheck_5:
   \   00000074   0025               MOVS     R5,#+0
    684                         break ;
    685                    }
    686               }
    687          //     if( SPEED_Count > 0 )          // 들어온 카운트가 1hz 보다 낮으면 클리어
    688          //     {
    689          //          for( i = 0 ; i < MAX_RPMSPEED_BUFFERCOUNT ; i++)
    690          //          {
    691          //               SPEED_Buffer[i] = 0;
    692          //          }
    693          //          SPEED_Count = 0;
    694          //          Speed_Avr = 0;
    695          //     }
    696               if(SPEED_Check == 0)         // 들어온 펄스가 한개도 없다면
   \                     ??SpeedCheck_4:
   \   00000076   ........           LDR.W    R0,??DataTable35_6
   \   0000007A   0078               LDRB     R0,[R0, #+0]
   \   0000007C   0028               CMP      R0,#+0
   \   0000007E   17D1               BNE.N    ??SpeedCheck_6
    697               {
    698                    if(Low_Count++ > 10)          // 1초동안 검사
   \   00000080   ........           LDR.W    R0,??DataTable35_7
   \   00000084   0078               LDRB     R0,[R0, #+0]
   \   00000086   411C               ADDS     R1,R0,#+1
   \   00000088   ........           LDR.W    R2,??DataTable35_7
   \   0000008C   1170               STRB     R1,[R2, #+0]
   \   0000008E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000090   0B28               CMP      R0,#+11
   \   00000092   11D3               BCC.N    ??SpeedCheck_7
    699                    {
    700                         for( i = 0 ; i < MAX_RPMSPEED_BUFFERCOUNT ; i++)
   \   00000094   0026               MOVS     R6,#+0
   \   00000096   06E0               B.N      ??SpeedCheck_8
    701                         {
    702                              SPEED_Buffer[i] = 0;
   \                     ??SpeedCheck_9:
   \   00000098   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009A   ........           LDR.W    R0,??DataTable35_4
   \   0000009E   0021               MOVS     R1,#+0
   \   000000A0   40F82610           STR      R1,[R0, R6, LSL #+2]
    703                         }
   \   000000A4   761C               ADDS     R6,R6,#+1
   \                     ??SpeedCheck_8:
   \   000000A6   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A8   142E               CMP      R6,#+20
   \   000000AA   F5D3               BCC.N    ??SpeedCheck_9
    704                         Speed_Avr = 0;
   \   000000AC   0024               MOVS     R4,#+0
   \   000000AE   03E0               B.N      ??SpeedCheck_7
    705                    }
    706               }else
    707               {
    708                    Low_Count = 0;          
   \                     ??SpeedCheck_6:
   \   000000B0   ........           LDR.W    R0,??DataTable35_7
   \   000000B4   0021               MOVS     R1,#+0
   \   000000B6   0170               STRB     R1,[R0, #+0]
    709               }
    710                    
    711               if( Info.RPM_Value == 0 )
   \                     ??SpeedCheck_7:
   \   000000B8   ........           LDR.W    R0,??DataTable35_8
   \   000000BC   B0F83500           LDRH     R0,[R0, #+53]
   \   000000C0   0028               CMP      R0,#+0
   \   000000C2   0BD1               BNE.N    ??SpeedCheck_10
    712               {
    713                    RPM_Timer = MS_TIMER;
   \   000000C4   ........           LDR.W    R0,??DataTable33  ;; 0x40000c00
   \   000000C8   ........           BL       TIM_GetCounter
   \   000000CC   ........           LDR.W    R1,??DataTable35_9
   \   000000D0   0880               STRH     R0,[R1, #+0]
    714                    Flag.RPM1Min = 1;
   \   000000D2   ........           LDR.W    R0,??DataTable31_1
   \   000000D6   0121               MOVS     R1,#+1
   \   000000D8   8171               STRB     R1,[R0, #+6]
   \   000000DA   0CE0               B.N      ??SpeedCheck_11
    715               }
    716               else
    717               {
    718                    if(CheckTimeOver(1000,RPM_Timer))
   \                     ??SpeedCheck_10:
   \   000000DC   ........           LDR.W    R0,??DataTable35_9
   \   000000E0   0188               LDRH     R1,[R0, #+0]
   \   000000E2   4FF47A70           MOV      R0,#+1000
   \   000000E6   ........           BL       CheckTimeOver
   \   000000EA   0028               CMP      R0,#+0
   \   000000EC   03D0               BEQ.N    ??SpeedCheck_11
    719                    {
    720                         Flag.RPM1Min = 0;
   \   000000EE   ........           LDR.W    R0,??DataTable31_1
   \   000000F2   0021               MOVS     R1,#+0
   \   000000F4   8171               STRB     R1,[R0, #+6]
    721                    }
    722               }
    723               
    724               if( ( Set_Info.Speed_OUT == 1 ) && ( error_flg == 1 ) )                        // SPEED출력일경우 1.4는 상수
   \                     ??SpeedCheck_11:
   \   000000F6   ........           LDR.W    R0,??DataTable35_10
   \   000000FA   407B               LDRB     R0,[R0, #+13]
   \   000000FC   0128               CMP      R0,#+1
   \   000000FE   20D1               BNE.N    ??SpeedCheck_12
   \   00000100   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000102   012D               CMP      R5,#+1
   \   00000104   1DD1               BNE.N    ??SpeedCheck_12
    725               {    
    726                    Speed_Hz = 200000 / Speed_Avr * 2;
   \   00000106   ........           LDR.W    R0,??DataTable35_11  ;; 0x30d40
   \   0000010A   B0FBF4F0           UDIV     R0,R0,R4
   \   0000010E   4000               LSLS     R0,R0,#+1
    727                    Speed_Hz /= 1.481;
   \   00000110   ........           BL       __aeabi_ui2d
   \   00000114   ........           LDR.W    R2,??DataTable35_12  ;; 0xe560419
   \   00000118   ........           LDR.W    R3,??DataTable35_13  ;; 0x3ff7b22d
   \   0000011C   ........           BL       __aeabi_ddiv
   \   00000120   ........           BL       __aeabi_d2uiz
    728                    Speed_Change = 5000 / Speed_Hz;
   \   00000124   41F28831           MOVW     R1,#+5000
   \   00000128   B1FBF0F1           UDIV     R1,R1,R0
    729            
    730                    if(Speed_Change < 65535 && Speed_Change > 1)
   \   0000012C   881E               SUBS     R0,R1,#+2
   \   0000012E   4FF6FD72           MOVW     R2,#+65533
   \   00000132   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000134   9042               CMP      R0,R2
   \   00000136   04D2               BCS.N    ??SpeedCheck_12
    731                    {           
    732                         TIM_SetAutoreload(TIM8,Speed_Change);         
   \   00000138   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000013A   ........           LDR.W    R0,??DataTable35  ;; 0x40010400
   \   0000013E   ........           BL       TIM_SetAutoreload
    733                    }
    734               }
    735               if( error_flg == 1 )
   \                     ??SpeedCheck_12:
   \   00000142   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000144   012D               CMP      R5,#+1
   \   00000146   14D1               BNE.N    ??SpeedCheck_13
    736               {
    737                    u32 SpeedTmp ;
    738                    
    739                    SpeedTmp = (unsigned int)( Set_Info.SPEED_Adjust * 2000) / Speed_Avr;   
   \   00000148   ........           LDR.W    R0,??DataTable35_10
   \   0000014C   D0F80500           LDR      R0,[R0, #+5]
   \   00000150   4FF4FA61           MOV      R1,#+2000
   \   00000154   4843               MULS     R0,R1,R0
   \   00000156   B0FBF4F0           UDIV     R0,R0,R4
    740                    if(SpeedTmp > 255)
   \   0000015A   FF28               CMP      R0,#+255
   \   0000015C   05D9               BLS.N    ??SpeedCheck_14
    741                         Info.SPEED_Value = 255;
   \   0000015E   ........           LDR.W    R0,??DataTable35_8
   \   00000162   FF21               MOVS     R1,#+255
   \   00000164   80F83410           STRB     R1,[R0, #+52]
   \   00000168   03E0               B.N      ??SpeedCheck_13
    742                    else
    743                         Info.SPEED_Value = SpeedTmp;
   \                     ??SpeedCheck_14:
   \   0000016A   ........           LDR.W    R1,??DataTable35_8
   \   0000016E   81F83400           STRB     R0,[R1, #+52]
    744               }
    745          
    746               if(Speed_Check_Count > 9)
   \                     ??SpeedCheck_13:
   \   00000172   ........           LDR.W    R0,??DataTable35_14
   \   00000176   0078               LDRB     R0,[R0, #+0]
   \   00000178   0A28               CMP      R0,#+10
   \   0000017A   0AD3               BCC.N    ??SpeedCheck_15
    747               {          
    748                    Speed_Check_Count = 0;
   \   0000017C   ........           LDR.W    R0,??DataTable35_14
   \   00000180   0021               MOVS     R1,#+0
   \   00000182   0170               STRB     R1,[R0, #+0]
    749                    memcpy(&Speed_Buffer2,&Speed_Buffer1,sizeof(Speed_Buffer1));          
   \   00000184   0A22               MOVS     R2,#+10
   \   00000186   ........           LDR.W    R1,??DataTable35_15
   \   0000018A   ........           LDR.W    R0,??DataTable35_16
   \   0000018E   ........           BL       memcpy
    750               }
    751               Speed_Buffer1[Speed_Check_Count++] = Info.SPEED_Value;
   \                     ??SpeedCheck_15:
   \   00000192   ........           LDR.W    R0,??DataTable35_14
   \   00000196   0078               LDRB     R0,[R0, #+0]
   \   00000198   ........           LDR.W    R1,??DataTable35_15
   \   0000019C   ........           LDR.W    R2,??DataTable35_8
   \   000001A0   92F83420           LDRB     R2,[R2, #+52]
   \   000001A4   4254               STRB     R2,[R0, R1]
   \   000001A6   ........           LDR.W    R0,??DataTable35_14
   \   000001AA   0078               LDRB     R0,[R0, #+0]
   \   000001AC   401C               ADDS     R0,R0,#+1
   \   000001AE   ........           LDR.W    R1,??DataTable35_14
   \   000001B2   0870               STRB     R0,[R1, #+0]
    752               SPEED_Check = 0;
   \   000001B4   ........           LDR.W    R0,??DataTable35_6
   \   000001B8   0021               MOVS     R1,#+0
   \   000001BA   0170               STRB     R1,[R0, #+0]
    753               // LOG -------------------------------------------------------------------------
    754               // 로그 기록단위 500ms 
    755               // 1.입력받은 갯수
    756               // 2. 평균 입력값
    757               // 3. SPPED 값          
    758          //     if(LOGWRITE & LOG_SPEED)                       
    759          //     {
    760          //          sprintf((char *)Buffer,"SPEED %03d/%5d/%04d/%d\r\n ",Count,Speed_Avr,Info.SPEED_Value,Set_Info.SPEED_Adjust); 
    761          //          Write_Log(Buffer, NORMAL_LOG);
    762          //     }            
    763               // -----------------------------------------------------------------------------
    764          
    765          }
   \                     ??SpeedCheck_0:
   \   000001BC   F1BD               POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .bss, align 2
   \                     ??SPEED_Timer:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     ??RPM_Timer:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
   \                     ??Low_Count:
   \   00000000                      DS8 1
    766          
    767          /*=============================================================================
    768          
    769          RPM는 50hz 일때 1000rpm / 100hz 일때 2000rpm
    770          
    771          =============================================================================*/
    772          

   \                                 In section .text, align 2, keep-with-next
    773          void RPMCheck(void)
    774          {
   \                     RPMCheck:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
    775               //  RPM은 현대 50hz 일때 1000rpm        // 상수 4000000
    776              //        대우 200hz 일때 1000rpm        // 상수 1000000
    777               static u16 RPM_Timer;
    778               u8 Count;
    779               u8 i;
    780               u32 RPM_Avr;  
    781               static u8 Low_Count = 0;
    782          
    783               u8 error_flg ;
    784               float compare_value ;
    785               
    786               if(!CheckTimeOver( 100,RPM_Timer))      // 100ms 이하로 떨어지면 늦은 알피엠이 측정이 안된다. 10일경우 잘안된다.
   \   00000004   ........           LDR.W    R0,??DataTable35_17
   \   00000008   0188               LDRH     R1,[R0, #+0]
   \   0000000A   6420               MOVS     R0,#+100
   \   0000000C   ........           BL       CheckTimeOver
   \   00000010   0028               CMP      R0,#+0
   \   00000012   7DD0               BEQ.N    ??RPMCheck_0
    787                    return;      
    788               RPM_Timer = MS_TIMER; 
   \                     ??RPMCheck_1:
   \   00000014   ........           LDR.W    R0,??DataTable33  ;; 0x40000c00
   \   00000018   ........           BL       TIM_GetCounter
   \   0000001C   ........           LDR.W    R1,??DataTable35_17
   \   00000020   0880               STRH     R0,[R1, #+0]
    789               // 실제 RPM 처리루틴
    790               RPM_Avr = 0;
   \   00000022   0024               MOVS     R4,#+0
    791               Count = RPM_Count;
   \   00000024   ........           LDR.W    R0,??DataTable35_18
   \   00000028   0568               LDR      R5,[R0, #+0]
    792               
    793               error_flg = 1 ;
   \   0000002A   0126               MOVS     R6,#+1
    794               for( i = 0 ; i < MAX_RPMSPEED_BUFFERCOUNT ; i++ )
   \   0000002C   0027               MOVS     R7,#+0
   \   0000002E   00E0               B.N      ??RPMCheck_2
   \                     ??RPMCheck_3:
   \   00000030   7F1C               ADDS     R7,R7,#+1
   \                     ??RPMCheck_2:
   \   00000032   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000034   142F               CMP      R7,#+20
   \   00000036   2AD2               BCS.N    ??RPMCheck_4
    795               {
    796                    if(Count == 0 )
   \   00000038   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   002D               CMP      R5,#+0
   \   0000003C   05D1               BNE.N    ??RPMCheck_5
    797                         RPM_Buffer[i] = 0 ;
   \   0000003E   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000040   ........           LDR.W    R0,??DataTable35_19
   \   00000044   0021               MOVS     R1,#+0
   \   00000046   40F82710           STR      R1,[R0, R7, LSL #+2]
    798                    RPM_Avr += RPM_Buffer[i];
   \                     ??RPMCheck_5:
   \   0000004A   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004C   ........           LDR.W    R0,??DataTable35_19
   \   00000050   50F82700           LDR      R0,[R0, R7, LSL #+2]
   \   00000054   0419               ADDS     R4,R0,R4
    799          
    800                    compare_value = (float)((float)RPM_Buffer[0] / (float)RPM_Buffer[i]) ;                         
   \   00000056   ........           LDR.W    R0,??DataTable35_19
   \   0000005A   0068               LDR      R0,[R0, #+0]
   \   0000005C   ........           BL       __aeabi_ui2f
   \   00000060   8046               MOV      R8,R0
   \   00000062   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000064   ........           LDR.W    R0,??DataTable35_19
   \   00000068   50F82700           LDR      R0,[R0, R7, LSL #+2]
   \   0000006C   ........           BL       __aeabi_ui2f
   \   00000070   0100               MOVS     R1,R0
   \   00000072   4046               MOV      R0,R8
   \   00000074   ........           BL       __aeabi_fdiv
    801                    if((compare_value > 1.5) || (compare_value < 0.5))
   \   00000078   ........           LDR.W    R1,??DataTable35_20  ;; 0x3fc00001
   \   0000007C   ........           BL       __aeabi_cfrcmple
   \   00000080   04D9               BLS.N    ??RPMCheck_6
   \   00000082   5FF07C51           MOVS     R1,#+1056964608
   \   00000086   ........           BL       __aeabi_cfcmple
   \   0000008A   D1D2               BCS.N    ??RPMCheck_3
    802                    {   
    803                      error_flg =  0 ;
   \                     ??RPMCheck_6:
   \   0000008C   0026               MOVS     R6,#+0
    804                      break ;
    805                    }
    806               }
    807          
    808               if(Count == 0)      // 입력이 없을때 반드시 0으로 클리어 시켜줘야한다.
   \                     ??RPMCheck_4:
   \   0000008E   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000090   002D               CMP      R5,#+0
   \   00000092   11D1               BNE.N    ??RPMCheck_7
    809               {          
    810                    Low_Count++;
   \   00000094   ........           LDR.W    R0,??DataTable35_21
   \   00000098   0078               LDRB     R0,[R0, #+0]
   \   0000009A   401C               ADDS     R0,R0,#+1
   \   0000009C   ........           LDR.W    R1,??DataTable35_21
   \   000000A0   0870               STRB     R0,[R1, #+0]
    811                    if( Low_Count > 30 )
   \   000000A2   ........           LDR.W    R0,??DataTable35_21
   \   000000A6   0078               LDRB     R0,[R0, #+0]
   \   000000A8   1F28               CMP      R0,#+31
   \   000000AA   09D3               BCC.N    ??RPMCheck_8
    812                    {
    813                         Low_Count = 30;
   \   000000AC   ........           LDR.W    R0,??DataTable35_21
   \   000000B0   1E21               MOVS     R1,#+30
   \   000000B2   0170               STRB     R1,[R0, #+0]
    814                         RPM_Avr = 0;
   \   000000B4   0024               MOVS     R4,#+0
   \   000000B6   03E0               B.N      ??RPMCheck_8
    815                    }
    816               }else 
    817               {
    818                    Low_Count = 0;
   \                     ??RPMCheck_7:
   \   000000B8   ........           LDR.W    R0,??DataTable35_21
   \   000000BC   0021               MOVS     R1,#+0
   \   000000BE   0170               STRB     R1,[R0, #+0]
    819               }
    820               
    821               if((error_flg == 1 ) || ( Low_Count >= 30 ))
   \                     ??RPMCheck_8:
   \   000000C0   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000C2   012E               CMP      R6,#+1
   \   000000C4   04D0               BEQ.N    ??RPMCheck_9
   \   000000C6   ........           LDR.W    R0,??DataTable35_21
   \   000000CA   0078               LDRB     R0,[R0, #+0]
   \   000000CC   1E28               CMP      R0,#+30
   \   000000CE   1BD3               BCC.N    ??RPMCheck_10
    822               {
    823                    if( Set_Info.RPM_Adjust != 0)
   \                     ??RPMCheck_9:
   \   000000D0   ........           LDR.W    R0,??DataTable35_10
   \   000000D4   D0F80100           LDR      R0,[R0, #+1]
   \   000000D8   0028               CMP      R0,#+0
   \   000000DA   0DD0               BEQ.N    ??RPMCheck_11
    824                         Info.RPM_Value =  (unsigned int)(Set_Info.RPM_Adjust * 2000) / RPM_Avr;
   \   000000DC   ........           LDR.W    R0,??DataTable35_10
   \   000000E0   D0F80100           LDR      R0,[R0, #+1]
   \   000000E4   4FF4FA61           MOV      R1,#+2000
   \   000000E8   4843               MULS     R0,R1,R0
   \   000000EA   B0FBF4F0           UDIV     R0,R0,R4
   \   000000EE   ........           LDR.W    R1,??DataTable35_8
   \   000000F2   A1F83500           STRH     R0,[R1, #+53]
   \   000000F6   07E0               B.N      ??RPMCheck_10
    825                    else
    826                         Info.RPM_Value =  (unsigned int)(1000 * 2000) / RPM_Avr;               
   \                     ??RPMCheck_11:
   \   000000F8   ........           LDR.W    R0,??DataTable35_22  ;; 0x1e8480
   \   000000FC   B0FBF4F0           UDIV     R0,R0,R4
   \   00000100   ........           LDR.W    R1,??DataTable35_8
   \   00000104   A1F83500           STRH     R0,[R1, #+53]
    827               }
    828          
    829               RPM_Count = 0;
   \                     ??RPMCheck_10:
   \   00000108   ........           LDR.W    R0,??DataTable35_18
   \   0000010C   0021               MOVS     R1,#+0
   \   0000010E   0160               STR      R1,[R0, #+0]
    830               
    831               // LOG -------------------------------------------------------------------------
    832               // 로그 기록단위 500ms 
    833               // 1.입력받은 갯수
    834               // 2. 평균 입력값
    835               // 3. RPM 값
    836          //     if(LOGWRITE & LOG_RPM)
    837          //     {
    838          //          sprintf((char*)Buffer,"RPM %03d/%5d/%04d/%d\r\n ",Count, RPM_Avr, Info.RPM_Value,Set_Info.RPM_Adjust); 
    839          //          Write_Log(Buffer, NORMAL_LOG);
    840          //     }
    841               // -----------------------------------------------------------------------------
    842               
    843          }
   \                     ??RPMCheck_0:
   \   00000110   BDE8F081           POP      {R4-R8,PC}       ;; return

   \                                 In section .bss, align 2
   \                     ??RPM_Timer_1:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
   \                     ??Low_Count_1:
   \   00000000                      DS8 1

   \                                 In section .text, align 2, keep-with-next
    844          void LPGPWM_Check(void)
    845          {
   \                     LPGPWM_Check:
   \   00000000   80B5               PUSH     {R7,LR}
    846               static u16 LPGPWM_Timer =0;
    847               u8 i;
    848               u32 Avr_Value;
    849               
    850               if(!CheckTimeOver( 1000 , LPGPWM_Timer))
   \   00000002   ........           LDR.W    R0,??DataTable35_23
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   4FF47A70           MOV      R0,#+1000
   \   0000000C   ........           BL       CheckTimeOver
   \   00000010   0028               CMP      R0,#+0
   \   00000012   24D0               BEQ.N    ??LPGPWM_Check_0
    851                    return;      
    852               LPGPWM_Timer = MS_TIMER;      
   \                     ??LPGPWM_Check_1:
   \   00000014   ........           LDR.W    R0,??DataTable33  ;; 0x40000c00
   \   00000018   ........           BL       TIM_GetCounter
   \   0000001C   ........           LDR.W    R1,??DataTable35_23
   \   00000020   0880               STRH     R0,[R1, #+0]
    853          
    854               Avr_Value = 0;
   \   00000022   0021               MOVS     R1,#+0
    855               for ( i = 0 ; i < 10 ; i++)
   \   00000024   0020               MOVS     R0,#+0
   \   00000026   06E0               B.N      ??LPGPWM_Check_2
    856               {
    857                    Avr_Value += LPGBuffer[i];
   \                     ??LPGPWM_Check_3:
   \   00000028   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   ........           LDR.W    R2,??DataTable35_24
   \   0000002E   52F82020           LDR      R2,[R2, R0, LSL #+2]
   \   00000032   5118               ADDS     R1,R2,R1
    858               }
   \   00000034   401C               ADDS     R0,R0,#+1
   \                     ??LPGPWM_Check_2:
   \   00000036   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0A28               CMP      R0,#+10
   \   0000003A   F5D3               BCC.N    ??LPGPWM_Check_3
    859               if(LPG_Count == 0)
   \   0000003C   ........           LDR.W    R0,??DataTable35_25
   \   00000040   0078               LDRB     R0,[R0, #+0]
   \   00000042   0028               CMP      R0,#+0
   \   00000044   00D1               BNE.N    ??LPGPWM_Check_4
    860                    Avr_Value = 0;
   \   00000046   0021               MOVS     R1,#+0
    861               
    862               Info.EMS_Data.LPG_PWM_Value = Avr_Value / 10;	
   \                     ??LPGPWM_Check_4:
   \   00000048   0A20               MOVS     R0,#+10
   \   0000004A   B1FBF0F0           UDIV     R0,R1,R0
   \   0000004E   ........           LDR.W    R1,??DataTable35_8
   \   00000052   A1F85100           STRH     R0,[R1, #+81]
    863               LPG_Count = 0;
   \   00000056   ........           LDR.W    R0,??DataTable35_25
   \   0000005A   0021               MOVS     R1,#+0
   \   0000005C   0170               STRB     R1,[R0, #+0]
    864          }     
   \                     ??LPGPWM_Check_0:
   \   0000005E   01BD               POP      {R0,PC}          ;; return

   \                                 In section .bss, align 2
   \                     ??LPGPWM_Timer:
   \   00000000                      DS8 2
    865          

   \                                 In section .text, align 2, keep-with-next
    866          void Infomation_Process(void)
    867          {
   \                     Infomation_Process:
   \   00000000   38B5               PUSH     {R3-R5,LR}
    868               static u16 IO_Check_Timer = 0;
    869               static u16 IO_Check_Timer2 = 0;
    870          
    871          //     static u8 Count = 0;
    872          //     
    873          //     static u16 InCre = 0;
    874          //     static u16 Accident_Cnt2 = 0;
    875               
    876               if(!CheckTimeOver(10,IO_Check_Timer))
   \   00000002   ........           LDR.W    R0,??DataTable35_26
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   0A20               MOVS     R0,#+10
   \   0000000A   ........           BL       CheckTimeOver
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   00F0B781           BEQ.W    ??Infomation_Process_0
    877                    return;      
    878               IO_Check_Timer = MS_TIMER;
   \                     ??Infomation_Process_1:
   \   00000014   ........           LDR.W    R0,??DataTable33  ;; 0x40000c00
   \   00000018   ........           BL       TIM_GetCounter
   \   0000001C   ........           LDR.W    R1,??DataTable35_26
   \   00000020   0880               STRH     R0,[R1, #+0]
    879               // -- 실시간으로 수신해야 하는 목록들
    880               
    881               // 인포 시간 데이터 저장 시간에서 데이터는 u32로 변환한다.
    882               Info.Datetime = SYSTEM_TIME_BINARY;     
   \   00000022   ........           LDR.W    R0,??DataTable35_8
   \   00000026   ........           LDR.W    R1,??DataTable35_27
   \   0000002A   0968               LDR      R1,[R1, #+0]
   \   0000002C   0163               STR      R1,[R0, #+48]
    883               if ( (Info.Input_Status& INPUT_BREAK_FLAG)  )
   \   0000002E   ........           LDR.W    R0,??DataTable35_8
   \   00000032   90F85D00           LDRB     R0,[R0, #+93]
   \   00000036   C007               LSLS     R0,R0,#+31
   \   00000038   04D5               BPL.N    ??Infomation_Process_2
    884               {          
    885                    Info.Sign_Break = 1;	
   \   0000003A   ........           LDR.W    R0,??DataTable35_8
   \   0000003E   0121               MOVS     R1,#+1
   \   00000040   80F83710           STRB     R1,[R0, #+55]
    886               }     
    887               Info.EMS_Data.Tilt_X = TiltInfo.DegX;
   \                     ??Infomation_Process_2:
   \   00000044   ........           LDR.W    R0,??DataTable35_8
   \   00000048   ........           LDR.W    R1,??DataTable35_28
   \   0000004C   098A               LDRH     R1,[R1, #+16]
   \   0000004E   80F85310           STRB     R1,[R0, #+83]
    888               Info.EMS_Data.Tilt_Y = TiltInfo.DegY;
   \   00000052   ........           LDR.W    R0,??DataTable35_8
   \   00000056   ........           LDR.W    R1,??DataTable35_28
   \   0000005A   498A               LDRH     R1,[R1, #+18]
   \   0000005C   80F85410           STRB     R1,[R0, #+84]
    889               
    890               Info.AccelX = TiltInfo.AccelX;
   \   00000060   ........           LDR.W    R0,??DataTable35_8
   \   00000064   ........           LDR.W    R1,??DataTable35_28
   \   00000068   898A               LDRH     R1,[R1, #+20]
   \   0000006A   A0F84210           STRH     R1,[R0, #+66]
    891               Info.AccelY = TiltInfo.AccelY;
   \   0000006E   ........           LDR.W    R0,??DataTable35_8
   \   00000072   ........           LDR.W    R1,??DataTable35_28
   \   00000076   C98A               LDRH     R1,[R1, #+22]
   \   00000078   A0F84410           STRH     R1,[R0, #+68]
    892               
    893               //Info.Input_Status = INPUT_DATA;
    894               Info.Output_Status = OUTPUT_DATA;   
   \   0000007C   ........           LDR.W    R0,??DataTable35_8
   \   00000080   ........           LDR.W    R1,??DataTable35_29
   \   00000084   0978               LDRB     R1,[R1, #+0]
   \   00000086   80F85F10           STRB     R1,[R0, #+95]
    895               
    896               
    897               Accident_Buffer[AccidentPoint].Speed = Info.SPEED_Value;
   \   0000008A   ........           LDR.W    R0,??DataTable35_30
   \   0000008E   0088               LDRH     R0,[R0, #+0]
   \   00000090   ........           LDR.W    R1,??DataTable35_31
   \   00000094   ........           LDR.W    R2,??DataTable35_8
   \   00000098   92F83420           LDRB     R2,[R2, #+52]
   \   0000009C   01F83020           STRB     R2,[R1, R0, LSL #+3]
    898               Accident_Buffer[AccidentPoint].RPM = Info.RPM_Value;
   \   000000A0   ........           LDR.W    R0,??DataTable35_30
   \   000000A4   0088               LDRH     R0,[R0, #+0]
   \   000000A6   ........           LDR.W    R1,??DataTable35_31
   \   000000AA   11EBC000           ADDS     R0,R1,R0, LSL #+3
   \   000000AE   ........           LDR.W    R1,??DataTable35_8
   \   000000B2   B1F83510           LDRH     R1,[R1, #+53]
   \   000000B6   A0F80110           STRH     R1,[R0, #+1]
    899               Accident_Buffer[AccidentPoint].Sign_Break = Info.Sign_Break;
   \   000000BA   ........           LDR.W    R0,??DataTable35_30
   \   000000BE   0088               LDRH     R0,[R0, #+0]
   \   000000C0   ........           LDR.W    R1,??DataTable35_31
   \   000000C4   11EBC000           ADDS     R0,R1,R0, LSL #+3
   \   000000C8   ........           LDR.W    R1,??DataTable35_8
   \   000000CC   91F83710           LDRB     R1,[R1, #+55]
   \   000000D0   C170               STRB     R1,[R0, #+3]
    900               Accident_Buffer[AccidentPoint].AccelX = Info.AccelX;
   \   000000D2   ........           LDR.W    R0,??DataTable35_30
   \   000000D6   0088               LDRH     R0,[R0, #+0]
   \   000000D8   ........           LDR.W    R1,??DataTable35_31
   \   000000DC   11EBC000           ADDS     R0,R1,R0, LSL #+3
   \   000000E0   ........           LDR.W    R1,??DataTable35_8
   \   000000E4   B1F84210           LDRH     R1,[R1, #+66]
   \   000000E8   8180               STRH     R1,[R0, #+4]
    901               Accident_Buffer[AccidentPoint].AccelY = Info.AccelY;
   \   000000EA   ........           LDR.W    R0,??DataTable35_30
   \   000000EE   0088               LDRH     R0,[R0, #+0]
   \   000000F0   ........           LDR.W    R1,??DataTable35_31
   \   000000F4   11EBC000           ADDS     R0,R1,R0, LSL #+3
   \   000000F8   ........           LDR.W    R1,??DataTable35_8
   \   000000FC   B1F84410           LDRH     R1,[R1, #+68]
   \   00000100   C180               STRH     R1,[R0, #+6]
    902               AccidentPoint ++ ;     
   \   00000102   ........           LDR.W    R0,??DataTable35_30
   \   00000106   0088               LDRH     R0,[R0, #+0]
   \   00000108   401C               ADDS     R0,R0,#+1
   \   0000010A   ........           LDR.W    R1,??DataTable35_30
   \   0000010E   0880               STRH     R0,[R1, #+0]
    903               
    904          
    905               if( Flag.Accident_Step == 0 ||  Flag.Accident_Step == 1 )        // 0 은 10초가 모이기전 // 1은 10d 모인후
   \   00000110   ....               LDR.N    R0,??DataTable31_1
   \   00000112   4079               LDRB     R0,[R0, #+5]
   \   00000114   0028               CMP      R0,#+0
   \   00000116   03D0               BEQ.N    ??Infomation_Process_3
   \   00000118   ....               LDR.N    R0,??DataTable31_1
   \   0000011A   4079               LDRB     R0,[R0, #+5]
   \   0000011C   0128               CMP      R0,#+1
   \   0000011E   12D1               BNE.N    ??Infomation_Process_4
    906               {
    907                    if(AccidentPoint % 1000 == 0)
   \                     ??Infomation_Process_3:
   \   00000120   ........           LDR.W    R0,??DataTable35_30
   \   00000124   0088               LDRH     R0,[R0, #+0]
   \   00000126   4FF47A71           MOV      R1,#+1000
   \   0000012A   90FBF1F2           SDIV     R2,R0,R1
   \   0000012E   01FB1200           MLS      R0,R1,R2,R0
   \   00000132   0028               CMP      R0,#+0
   \   00000134   24D1               BNE.N    ??Infomation_Process_5
    908                    {
    909                         AccidentPoint = 0;
   \   00000136   ........           LDR.W    R0,??DataTable35_30
   \   0000013A   0021               MOVS     R1,#+0
   \   0000013C   0180               STRH     R1,[R0, #+0]
    910                         Flag.Accident_Step = 1;               
   \   0000013E   ....               LDR.N    R0,??DataTable31_1
   \   00000140   0121               MOVS     R1,#+1
   \   00000142   4171               STRB     R1,[R0, #+5]
   \   00000144   1CE0               B.N      ??Infomation_Process_5
    911                    }
    912               }
    913               else if(Flag.Accident_Step == 3)  //    이벤트가 발생했다면
   \                     ??Infomation_Process_4:
   \   00000146   ....               LDR.N    R0,??DataTable31_1
   \   00000148   4079               LDRB     R0,[R0, #+5]
   \   0000014A   0328               CMP      R0,#+3
   \   0000014C   18D1               BNE.N    ??Infomation_Process_5
    914               {
    915                    AccidentPoint ++ ;
   \   0000014E   ........           LDR.W    R0,??DataTable35_30
   \   00000152   0088               LDRH     R0,[R0, #+0]
   \   00000154   401C               ADDS     R0,R0,#+1
   \   00000156   ........           LDR.W    R1,??DataTable35_30
   \   0000015A   0880               STRH     R0,[R1, #+0]
    916                    if(AccidentPoint % 1000 == 0)
   \   0000015C   ........           LDR.W    R0,??DataTable35_30
   \   00000160   0088               LDRH     R0,[R0, #+0]
   \   00000162   4FF47A71           MOV      R1,#+1000
   \   00000166   90FBF1F2           SDIV     R2,R0,R1
   \   0000016A   01FB1200           MLS      R0,R1,R2,R0
   \   0000016E   0028               CMP      R0,#+0
   \   00000170   06D1               BNE.N    ??Infomation_Process_5
    917                    {
    918                         AccidentPoint = 0;
   \   00000172   ........           LDR.W    R0,??DataTable35_30
   \   00000176   0021               MOVS     R1,#+0
   \   00000178   0180               STRH     R1,[R0, #+0]
    919                         Flag.Accident_Step = 4;               
   \   0000017A   ....               LDR.N    R0,??DataTable31_1
   \   0000017C   0421               MOVS     R1,#+4
   \   0000017E   4171               STRB     R1,[R0, #+5]
    920                    }
    921               }
    922               // ---- 1초에 한번씩 수집하는 데이터 ----------------------------------
    923               if(!CheckTimeOver(1000,IO_Check_Timer2))
   \                     ??Infomation_Process_5:
   \   00000180   ........           LDR.W    R0,??DataTable35_32
   \   00000184   0188               LDRH     R1,[R0, #+0]
   \   00000186   4FF47A70           MOV      R0,#+1000
   \   0000018A   ........           BL       CheckTimeOver
   \   0000018E   0028               CMP      R0,#+0
   \   00000190   00F0F780           BEQ.W    ??Infomation_Process_0
    924                    return;
    925               IO_Check_Timer2 = MS_TIMER;
   \                     ??Infomation_Process_6:
   \   00000194   ........           LDR.W    R0,??DataTable33  ;; 0x40000c00
   \   00000198   ........           BL       TIM_GetCounter
   \   0000019C   ........           LDR.W    R1,??DataTable35_32
   \   000001A0   0880               STRH     R0,[R1, #+0]
    926               
    927               Info.GPSX = GPSInfo.Conv.nLongitude;
   \   000001A2   ........           LDR.W    R0,??DataTable35_8
   \   000001A6   ........           LDR.W    R1,??DataTable35_33
   \   000001AA   D1F8E810           LDR      R1,[R1, #+232]
   \   000001AE   8163               STR      R1,[R0, #+56]
    928               Info.GPSY = GPSInfo.Conv.nLatitude;
   \   000001B0   ........           LDR.W    R0,??DataTable35_8
   \   000001B4   ........           LDR.W    R1,??DataTable35_33
   \   000001B8   D1F8EC10           LDR      R1,[R1, #+236]
   \   000001BC   C163               STR      R1,[R0, #+60]
    929               Info.Azimuth = GPSInfo.Conv.azimuth;	
   \   000001BE   ........           LDR.W    R0,??DataTable35_8
   \   000001C2   ........           LDR.W    R1,??DataTable35_33
   \   000001C6   B1F8F010           LDRH     R1,[R1, #+240]
   \   000001CA   A0F84010           STRH     R1,[R0, #+64]
    930               
    931               Info.EMS_Data.Gps_HDOP = GPSInfo.Conv.HDOP;
   \   000001CE   ........           LDR.W    R0,??DataTable35_8
   \   000001D2   ........           LDR.W    R1,??DataTable35_33
   \   000001D6   B1F8F210           LDRH     R1,[R1, #+242]
   \   000001DA   A0F85710           STRH     R1,[R0, #+87]
    932               Info.EMS_Data.GPS_Speed = GPSInfo.Conv.GPS_Speed;
   \   000001DE   ........           LDR.W    R0,??DataTable35_8
   \   000001E2   ........           LDR.W    R1,??DataTable35_33
   \   000001E6   B1F8F410           LDRH     R1,[R1, #+244]
   \   000001EA   A0F85510           STRH     R1,[R0, #+85]
    933               
    934               Info.DayDriveLength = (u32)( EMS_Drive_Value.Today_Speed_PulsCount * Set_Info.Distance_Adjust ) / 1000;
   \   000001EE   ........           LDR.W    R0,??DataTable35_10
   \   000001F2   D0F80940           LDR      R4,[R0, #+9]
   \   000001F6   ........           LDR.W    R0,??DataTable35_34
   \   000001FA   8068               LDR      R0,[R0, #+8]
   \   000001FC   ........           BL       __aeabi_ui2f
   \   00000200   0100               MOVS     R1,R0
   \   00000202   2000               MOVS     R0,R4
   \   00000204   ........           BL       __aeabi_fmul
   \   00000208   ........           BL       __aeabi_f2uiz
   \   0000020C   4FF47A71           MOV      R1,#+1000
   \   00000210   B0FBF1F0           UDIV     R0,R0,R1
   \   00000214   ........           LDR.W    R1,??DataTable35_8
   \   00000218   4883               STRH     R0,[R1, #+26]
    935               
    936               if(Info.EMS3Sec_Count != 0)
   \   0000021A   ........           LDR.W    R0,??DataTable35_8
   \   0000021E   90F86500           LDRB     R0,[R0, #+101]
   \   00000222   0028               CMP      R0,#+0
   \   00000224   08D0               BEQ.N    ??Infomation_Process_7
    937                    Info.EMS3Sec_Count --;
   \   00000226   ........           LDR.W    R0,??DataTable35_8
   \   0000022A   90F86500           LDRB     R0,[R0, #+101]
   \   0000022E   401E               SUBS     R0,R0,#+1
   \   00000230   ........           LDR.W    R1,??DataTable35_8
   \   00000234   81F86500           STRB     R0,[R1, #+101]
    938               if(Info.EMS3Min_Count != 0)
   \                     ??Infomation_Process_7:
   \   00000238   ........           LDR.W    R0,??DataTable35_8
   \   0000023C   90F86600           LDRB     R0,[R0, #+102]
   \   00000240   0028               CMP      R0,#+0
   \   00000242   08D0               BEQ.N    ??Infomation_Process_8
    939                    Info.EMS3Min_Count --;
   \   00000244   ........           LDR.W    R0,??DataTable35_8
   \   00000248   90F86600           LDRB     R0,[R0, #+102]
   \   0000024C   401E               SUBS     R0,R0,#+1
   \   0000024E   ........           LDR.W    R1,??DataTable35_8
   \   00000252   81F86600           STRB     R0,[R1, #+102]
    940               
    941               if( Info.Total_Drive_PulsCount1 > PLUS_DIVIDE)
   \                     ??Infomation_Process_8:
   \   00000256   ........           LDR.W    R0,??DataTable35_8
   \   0000025A   D0F82A00           LDR      R0,[R0, #+42]
   \   0000025E   B0F1805F           CMP      R0,#+268435456
   \   00000262   10D9               BLS.N    ??Infomation_Process_9
    942               {
    943                   Info.Total_Drive_PulsCount1 -= PLUS_DIVIDE;
   \   00000264   ........           LDR.W    R0,??DataTable35_8
   \   00000268   D0F82A00           LDR      R0,[R0, #+42]
   \   0000026C   B0F18050           SUBS     R0,R0,#+268435456
   \   00000270   ........           LDR.W    R1,??DataTable35_8
   \   00000274   C1F82A00           STR      R0,[R1, #+42]
    944                   Info.Total_Drive_PulsCount2++;
   \   00000278   ........           LDR.W    R0,??DataTable35_8
   \   0000027C   C08D               LDRH     R0,[R0, #+46]
   \   0000027E   401C               ADDS     R0,R0,#+1
   \   00000280   ........           LDR.W    R1,??DataTable35_8
   \   00000284   C885               STRH     R0,[R1, #+46]
    945               }     
    946               Info.TotalDriveLength = ((Info.Total_Drive_PulsCount1 * Set_Info.Distance_Adjust) + 
                                            ^
Warning[Pa093]: implicit conversion from floating point to integer
    947                                        (Info.Total_Drive_PulsCount2 * PLUS_DIVIDE) * Set_Info.Distance_Adjust ) / 1000 ;      
   \                     ??Infomation_Process_9:
   \   00000286   ........           LDR.W    R0,??DataTable35_10
   \   0000028A   D0F80940           LDR      R4,[R0, #+9]
   \   0000028E   ........           LDR.W    R0,??DataTable35_10
   \   00000292   D0F80950           LDR      R5,[R0, #+9]
   \   00000296   ........           LDR.W    R0,??DataTable35_8
   \   0000029A   D0F82A00           LDR      R0,[R0, #+42]
   \   0000029E   ........           BL       __aeabi_ui2f
   \   000002A2   0100               MOVS     R1,R0
   \   000002A4   2000               MOVS     R0,R4
   \   000002A6   ........           BL       __aeabi_fmul
   \   000002AA   0400               MOVS     R4,R0
   \   000002AC   ........           LDR.W    R0,??DataTable35_8
   \   000002B0   C08D               LDRH     R0,[R0, #+46]
   \   000002B2   5FF08051           MOVS     R1,#+268435456
   \   000002B6   4843               MULS     R0,R1,R0
   \   000002B8   ........           BL       __aeabi_i2f
   \   000002BC   0100               MOVS     R1,R0
   \   000002BE   2800               MOVS     R0,R5
   \   000002C0   ........           BL       __aeabi_fmul
   \   000002C4   0100               MOVS     R1,R0
   \   000002C6   2000               MOVS     R0,R4
   \   000002C8   ........           BL       __aeabi_fadd
   \   000002CC   ........           LDR.W    R1,??DataTable35_35  ;; 0x447a0000
   \   000002D0   ........           BL       __aeabi_fdiv
   \   000002D4   ........           BL       __aeabi_f2uiz
   \   000002D8   ........           LDR.W    R1,??DataTable35_8
   \   000002DC   C861               STR      R0,[R1, #+28]
    948          
    949               
    950               Accident2_Buffer[AccidentPoint2].DayDriveLength = Info.DayDriveLength;
   \   000002DE   ........           LDR.W    R0,??DataTable35_36
   \   000002E2   0088               LDRH     R0,[R0, #+0]
   \   000002E4   1121               MOVS     R1,#+17
   \   000002E6   ........           LDR.W    R2,??DataTable35_37
   \   000002EA   01FB0020           MLA      R0,R1,R0,R2
   \   000002EE   ........           LDR.W    R1,??DataTable35_8
   \   000002F2   498B               LDRH     R1,[R1, #+26]
   \   000002F4   0180               STRH     R1,[R0, #+0]
    951               Accident2_Buffer[AccidentPoint2].TotalDriveLength = Info.TotalDriveLength;
   \   000002F6   ........           LDR.W    R0,??DataTable35_36
   \   000002FA   0088               LDRH     R0,[R0, #+0]
   \   000002FC   1121               MOVS     R1,#+17
   \   000002FE   ........           LDR.W    R2,??DataTable35_37
   \   00000302   01FB0020           MLA      R0,R1,R0,R2
   \   00000306   ........           LDR.W    R1,??DataTable35_8
   \   0000030A   C969               LDR      R1,[R1, #+28]
   \   0000030C   C0F80210           STR      R1,[R0, #+2]
    952               Accident2_Buffer[AccidentPoint2].GPSX = Info.GPSX;
   \   00000310   ........           LDR.W    R0,??DataTable35_36
   \   00000314   0088               LDRH     R0,[R0, #+0]
   \   00000316   1121               MOVS     R1,#+17
   \   00000318   ........           LDR.W    R2,??DataTable35_37
   \   0000031C   01FB0020           MLA      R0,R1,R0,R2
   \   00000320   ........           LDR.W    R1,??DataTable35_8
   \   00000324   896B               LDR      R1,[R1, #+56]
   \   00000326   C0F80610           STR      R1,[R0, #+6]
    953               Accident2_Buffer[AccidentPoint2].GPSY = Info.GPSY;
   \   0000032A   ........           LDR.W    R0,??DataTable35_36
   \   0000032E   0088               LDRH     R0,[R0, #+0]
   \   00000330   1121               MOVS     R1,#+17
   \   00000332   ........           LDR.W    R2,??DataTable35_37
   \   00000336   01FB0020           MLA      R0,R1,R0,R2
   \   0000033A   ........           LDR.W    R1,??DataTable35_8
   \   0000033E   C96B               LDR      R1,[R1, #+60]
   \   00000340   C0F80A10           STR      R1,[R0, #+10]
    954               Accident2_Buffer[AccidentPoint2].MachineStatus = Info.MachineStatus;       
   \   00000344   ........           LDR.W    R0,??DataTable35_36
   \   00000348   0088               LDRH     R0,[R0, #+0]
   \   0000034A   1121               MOVS     R1,#+17
   \   0000034C   ........           LDR.W    R2,??DataTable35_37
   \   00000350   01FB0020           MLA      R0,R1,R0,R2
   \   00000354   ........           LDR.W    R1,??DataTable35_8
   \   00000358   91F84610           LDRB     R1,[R1, #+70]
   \   0000035C   0174               STRB     R1,[R0, #+16]
    955               AccidentPoint2++;     
   \   0000035E   ........           LDR.W    R0,??DataTable35_36
   \   00000362   0088               LDRH     R0,[R0, #+0]
   \   00000364   401C               ADDS     R0,R0,#+1
   \   00000366   ........           LDR.W    R1,??DataTable35_36
   \   0000036A   0880               STRH     R0,[R1, #+0]
    956               AccidentPoint2 %= 10; 
   \   0000036C   ........           LDR.W    R0,??DataTable35_36
   \   00000370   0088               LDRH     R0,[R0, #+0]
   \   00000372   0A21               MOVS     R1,#+10
   \   00000374   90FBF1F2           SDIV     R2,R0,R1
   \   00000378   01FB1200           MLS      R0,R1,R2,R0
   \   0000037C   ........           LDR.W    R1,??DataTable35_36
   \   00000380   0880               STRH     R0,[R1, #+0]
    957               
    958          }
   \                     ??Infomation_Process_0:
   \   00000382   31BD               POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .bss, align 2
   \                     ??IO_Check_Timer:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     ??IO_Check_Timer2:
   \   00000000                      DS8 2
    959          
    960          
    961          

   \                                 In section .text, align 2, keep-with-next
    962          void Battery_Check(void) 			// 자동차 운행 종료
    963          {
    964               static u8 Save_Flag = 0;
    965               if( Flag.Active )return;		// 기기 활성화 플래그
   \                     Battery_Check:
   \   00000000   ....               LDR.N    R0,??DataTable31_1
   \   00000002   C079               LDRB     R0,[R0, #+7]
   \   00000004   0028               CMP      R0,#+0
   \   00000006   08D1               BNE.N    ??Battery_Check_0
    966               if(Save_Flag == 0 )
   \                     ??Battery_Check_1:
   \   00000008   ........           LDR.W    R0,??DataTable35_38
   \   0000000C   0078               LDRB     R0,[R0, #+0]
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   03D1               BNE.N    ??Battery_Check_2
    967               {          
    968          //          Driver_End();
    969                    Save_Flag = 1;
   \   00000012   ........           LDR.W    R0,??DataTable35_38
   \   00000016   0121               MOVS     R1,#+1
   \   00000018   0170               STRB     R1,[R0, #+0]
    970               }
    971               // 현배터리 상태를 확인하여 배터리가 일정 이상 떨어지면 장치 오프로
    972               // 인식하여 데이터 저장하기 루틴
    973               // SFLASH 데이터 저장
    974               // 1초데이터 남은 부분 저장
    975          }
   \                     ??Battery_Check_2:
   \                     ??Battery_Check_0:
   \   0000001A   7047               BX       LR               ;; return

   \                                 In section .bss, align 1
   \                     ??Save_Flag:
   \   00000000                      DS8 1
    976          
    977          

   \                                 In section .text, align 2, keep-with-next
    978          void Initialize(void)
    979          {	
   \                     Initialize:
   \   00000000   80B5               PUSH     {R7,LR}
    980          	// ----딜레이 변수 -------------------------------------------
    981          	
    982          	Timer_1ms = 0;  
   \   00000002   ........           LDR.W    R0,??DataTable35_39
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   0180               STRH     R1,[R0, #+0]
    983          	Timer_1Sec = 0;		// 1초타이머 타이머 5 
   \   0000000A   ........           LDR.W    R0,??DataTable35_2
   \   0000000E   0021               MOVS     R1,#+0
   \   00000010   0180               STRH     R1,[R0, #+0]
    984               
    985               SYSTEM_STEP = 0;
   \   00000012   ........           LDR.W    R0,??DataTable35_40
   \   00000016   0021               MOVS     R1,#+0
   \   00000018   0180               STRH     R1,[R0, #+0]
    986               // ---- LED 포트 ----------------------------------------------
    987          	
    988          	LED1_OFF();
   \   0000001A   ........           BL       LED1_OFF
    989          	LED2_OFF();
   \   0000001E   ........           BL       LED2_OFF
    990          	
    991          	// ------ 디스플레이 ------------------------------------------
    992          		
    993          	memset(&DisplayInfo,0,sizeof(DisplayInfo));	
   \   00000022   0822               MOVS     R2,#+8
   \   00000024   0021               MOVS     R1,#+0
   \   00000026   ........           LDR.W    R0,??DataTable35_41
   \   0000002A   ........           BL       memset
    994          	
    995               DisplayInfo.Now_View = DISP_INTRO;     
   \   0000002E   ........           LDR.W    R0,??DataTable35_41
   \   00000032   0221               MOVS     R1,#+2
   \   00000034   4171               STRB     R1,[R0, #+5]
    996               Voice_Set_Volume(SFLASH_Memory.Voice_Volume);          // SFLASH에 저장된 값으로 세팅
   \   00000036   ........           LDR.W    R0,??DataTable35_42
   \   0000003A   90F8A300           LDRB     R0,[R0, #+163]
   \   0000003E   ........           BL       Voice_Set_Volume
    997               
    998          	// ---- 시간및 거리 초기화 -----------------------------------
    999          
   1000               Info.Today_Speed_PulsCount = 0;     
   \   00000042   ........           LDR.W    R0,??DataTable35_8
   \   00000046   0021               MOVS     R1,#+0
   \   00000048   0162               STR      R1,[R0, #+32]
   1001               
   1002               // ---------------------------------------------------------------
   1003               
   1004               Flag.Driver_Change = 0;       // 운전자 변경 플래그               
   \   0000004A   ....               LDR.N    R0,??DataTable31_1
   \   0000004C   0021               MOVS     R1,#+0
   \   0000004E   4172               STRB     R1,[R0, #+9]
   1005               Flag.WatchDog = 0;         // 와치독 플래그            
   \   00000050   ....               LDR.N    R0,??DataTable31_1
   \   00000052   0021               MOVS     R1,#+0
   \   00000054   0172               STRB     R1,[R0, #+8]
   1006               
   1007               memset(Info.Driver_Num,0x30,sizeof(Info.Driver_Num) - 1);            // 처음 운전자 아이디 0으로 클리어 
   \   00000056   1222               MOVS     R2,#+18
   \   00000058   3021               MOVS     R1,#+48
   \   0000005A   ........           LDR.W    R0,??DataTable35_43
   \   0000005E   ........           BL       memset
   1008                  
   1009               Info.Driver_Index = NO_DRIVER;          
   \   00000062   ........           LDR.W    R0,??DataTable35_8
   \   00000066   FF21               MOVS     R1,#+255
   \   00000068   0170               STRB     R1,[R0, #+0]
   1010          }
   \   0000006A   01BD               POP      {R0,PC}          ;; return
   1011          
   1012          

   \                                 In section .text, align 2, keep-with-next
   1013          int main(void) 
   1014          {
   \                     main:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   1015               
   1016               static u16 Main_Timer;
   1017               
   1018               u8 First_Setting ; 
   1019               u16 FLASH_ID;
   1020          #ifdef DEBUG   
   1021          	debug();
   1022          #endif
   1023          	/* 기본적인 새팅하기 */
   1024          	
   1025          	SystemInit();
   \   00000004   ........           BL       SystemInit
   1026               
   1027               NVIC_SetVectorTable(NVIC_VectTab_FLASH,0x10000);   	          // 업데이트 백터 설정
   \   00000008   5FF48031           MOVS     R1,#+65536
   \   0000000C   5FF00060           MOVS     R0,#+134217728
   \   00000010   ........           BL       NVIC_SetVectorTable
   1028               
   1029          	RCC_GetClocksFreq(&RCC_Clocks);
   \   00000014   ........           LDR.W    R0,??DataTable35_44
   \   00000018   ........           BL       RCC_GetClocksFreq
   1030               
   1031          	SysTick_Config(RCC_Clocks.HCLK_Frequency / 10000);			//  [10000 = 1일은 100us ]   [1000 = 1 일은 1ms] [ 100 = 1 일은 10ms ]
   \   0000001C   ........           LDR.W    R0,??DataTable35_44
   \   00000020   4068               LDR      R0,[R0, #+4]
   \   00000022   42F21071           MOVW     R1,#+10000
   \   00000026   B0FBF1F0           UDIV     R0,R0,R1
   \   0000002A   ........           BL       SysTick_Config
   1032          	
   1033                  /*       
   1034                  
   1035                  */
   1036                  
   1037          	////////////////////// GPIO 핀 초기화 //////////////////////////////////////
   1038          	
   1039          	GPIO_Configuration();     // LED와 스위치 초기화
   \   0000002E   ........           BL       GPIO_Configuration
   1040          	
   1041          	GPIO_Configuration2();    // IO 세팅
   \   00000032   ........           BL       GPIO_Configuration2
   1042               
   1043               
   1044               EMS_Config();     	     // EMS 변수 초기화	
   \   00000036   ........           BL       EMS_Config
   1045               
   1046               I2C_EE_Init();      // I2c를 사용해서 NAND헤더를 작업해야 한다.
   \   0000003A   ........           BL       I2C_EE_Init
   1047               
   1048               FSMC_NAND_Init();
   \   0000003E   ........           BL       FSMC_NAND_Init
   1049               
   1050               GLcd_Config();
   \   00000042   ........           BL       GLcd_Config
   1051               
   1052               // -----------------------------------------------------------------------------
   1053          	
   1054          	Key_Config();            // 키초기화
   \   00000046   ........           BL       Key_Config
   1055          	
   1056          	//////////////////////// Serial 세팅 ///////////////////////////////////////
   1057          	
   1058          	Serial_Config();    
   \   0000004A   ........           BL       Serial_Config
   1059          	
   1060          	////////////////////////  ADC 세팅 //////////////////////////////////////////
   1061          	
   1062          	ADC_Config();      
   \   0000004E   ........           BL       ADC_Config
   1063          	
   1064          	////////////////////////  [SPI] 통신 설정 초기화 /////////////////////////////
   1065          	
   1066          	sFLASH_Init();    
   \   00000052   ........           BL       sFLASH_Init
   1067          	
   1068          	///////////////////////  [SPI] MEMS 초기화 ////////////////////////////////
   1069          	
   1070          	MEMS_Config();          
   \   00000056   ........           BL       MEMS_Config
   1071          	
   1072          	////////////////////// [SPI] 음성 IC 초기화 ///////////////////////////////
   1073          	
   1074          	Voice_Config();
   \   0000005A   ........           BL       Voice_Config
   1075          	
   1076               Voice_Init();       // 설정
   \   0000005E   ........           BL       Voice_Init
   1077          	
   1078          	//////////////////////   인터럽트 초기화 ////////////////////////////////
   1079          	
   1080          	EXTILine1_Config();
   \   00000062   ........           BL       EXTILine1_Config
   1081          	
   1082          	/////////////////////// DAC Config      
   1083          	
   1084          	DAC_GPIO_Config();
   \   00000066   ........           BL       DAC_GPIO_Config
   1085               
   1086          	TIM6_Config();           // 타이머 6 DAC
   \   0000006A   ........           BL       TIM6_Config
   1087               
   1088          	DAC_DeInit();
   \   0000006E   ........           BL       DAC_DeInit
   1089          	
   1090          	///////////////////////////////////////////////////////////////////////
   1091          	// Timer Settings
   1092          	//      TIM1_Config();
   1093          	//     TIM2_Config();
   1094          	////////////////////////////////
   1095               
   1096               TIM3_Config();
   \   00000072   ........           BL       TIM3_Config
   1097          	
   1098               TIM4_Config();      // 입력 RPM,SPEED 계산 타이머
   \   00000076   ........           BL       TIM4_Config
   1099          	
   1100               TIM5_Config();      // 1ms 내부 타이머 설정Timer	
   \   0000007A   ........           BL       TIM5_Config
   1101               
   1102          	TIM7_Config();
   \   0000007E   ........           BL       TIM7_Config
   1103          	
   1104          	TIM8_Config();
   \   00000082   ........           BL       TIM8_Config
   1105               
   1106               // Init Host Library 
   1107               
   1108                  USBH_Init(&USB_OTG_Core, 
   1109          #ifdef USE_USB_OTG_FS  
   1110               USB_OTG_FS_CORE_ID,
   1111          #else 
   1112               USB_OTG_HS_CORE_ID,
   1113          #endif 
   1114               &USB_Host,
   1115               &USBH_MSC_cb, 		
   1116               &USR_cb);			
   \   00000086   ........           LDR.W    R0,??DataTable35_45
   \   0000008A   0090               STR      R0,[SP, #+0]
   \   0000008C   ........           LDR.W    R3,??DataTable35_46
   \   00000090   ........           LDR.W    R2,??DataTable35_47
   \   00000094   0121               MOVS     R1,#+1
   \   00000096   ........           LDR.W    R0,??DataTable35_48
   \   0000009A   ........           BL       USBH_Init
   1117               
   1118               printf(" Start \r\n");
   \   0000009E   ........           ADR.W    R0,`?<Constant " Start \\r\\n">`
   \   000000A2   ........           BL       printf
   1119             	FLASH_ID = sFLASH_ReadID();    
   \   000000A6   ........           BL       sFLASH_ReadID
   1120          	if (FLASH_ID == M25P64_FLASH_ID)
   \   000000AA   42F21501           MOVW     R1,#+8213
   \   000000AE   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B0   8842               CMP      R0,R1
   \   000000B2   03D1               BNE.N    ??main_0
   1121               {
   1122          //          Flag.SerialFlash = 1;
   1123                    printf(" SFLASH OK \r\n"); 
   \   000000B4   ........           ADR.W    R0,`?<Constant " SFLASH OK \\r\\n">`
   \   000000B8   ........           BL       printf
   1124               }
   1125               Log_Config();     	// 로그 초기화     	
   \                     ??main_0:
   \   000000BC   ........           BL       Log_Config
   1126          
   1127               Read_SFLASH();
   \   000000C0   ........           BL       Read_SFLASH
   1128               
   1129               // ------------ DAC 설정한다.
   1130               
   1131          	DAC_Config();	     
   \   000000C4   ........           BL       DAC_Config
   1132               
   1133          	DAC_Ch2_Config();
   \   000000C8   ........           BL       DAC_Ch2_Config
   1134          
   1135               DAC_Ch1_Config();     
   \   000000CC   ........           BL       DAC_Ch1_Config
   1136               
   1137               ///////////////////////////////////////////////////////////////////////////
   1138               
   1139                Main_Timer = MS_TIMER;
   \   000000D0   ....               LDR.N    R0,??DataTable33  ;; 0x40000c00
   \   000000D2   ........           BL       TIM_GetCounter
   \   000000D6   ........           LDR.W    R1,??DataTable35_49
   \   000000DA   0880               STRH     R0,[R1, #+0]
   1140                
   1141                GLcd_Init();
   \   000000DC   ........           BL       GLcd_Init
   1142          //      InitIWDG();              // 와치독 초기화
   1143          
   1144                //   NAND_BuildLUT(0);
   1145                //   NAND_If_Init();
   1146                
   1147                FSMC_NAND_Reset();
   \   000000E0   ........           BL       FSMC_NAND_Reset
   1148                
   1149                RTC_Setting(); 		// RTC 초기화
   \   000000E4   ........           BL       RTC_Setting
   1150                
   1151                //RTC_TimeRegulate();         // 시간 초기화
   1152                
   1153                //     EMS_Config();     	     // EMS 변수 초기화	
   1154                
   1155                Memory_Config();		// NAND 해더를 읽어오기
   \   000000E8   ........           BL       Memory_Config
   1156                
   1157                MEMS_Init();   
   \   000000EC   ........           BL       MEMS_Init
   1158                
   1159                RTC_TimeShow(); 		// RTC 시간을 읽어서 변수에 저장 
   \   000000F0   ........           BL       RTC_TimeShow
   1160                
   1161                Initialize();		     // 각종 변수들 초기화		
   \   000000F4   ........           BL       Initialize
   1162                
   1163                Driver_Start();		// 전원이 온이 된다면 온전 시작을 세팅한다.
   \   000000F8   ........           BL       Driver_Start
   1164                
   1165                Wifi_Config();           // 와아파이 초기화     
   \   000000FC   ........           BL       Wifi_Config
   1166                
   1167                Kmap_init();
   \   00000100   ........           BL       Kmap_init
   1168               First_Setting = 0;
   \   00000104   0024               MOVS     R4,#+0
   \   00000106   FFE7               B.N      ??main_1
   1169               
   1170               while(1)
   1171               {    
   1172                    IWDG_ReloadCounter();                   // Clear IWDG
   1173                    SYSTEM_STEP = 0;
   1174                    
   1175                    GraphicOUT_Process();                   // LCD화면 디스플레이 실제처리          
   1176                    SYSTEM_STEP++;          
   1177                    
   1178                    RF_Communcation();                      // RF 모듈 데이터 처리 실시간 처리
   1179                    SYSTEM_STEP++;          
   1180                    
   1181                    SendMessage();			               // 시리얼 데이터를 처리한다.
   1182                    SYSTEM_STEP++;          
   1183                    
   1184                    Ems_realtime_Check();                   // I/O 체크
   1185                    SYSTEM_STEP++;
   1186                    
   1187                    //---------- GPS_Recieve -------------------------------------------
   1188                    
   1189                    GPS_Process();
   1190                    SYSTEM_STEP++;       
   1191                    
   1192                    //--------------------------------------------------------------------
   1193          
   1194                    Wifi_Send();
   1195                    SYSTEM_STEP++;         
   1196                    
   1197          //          WWDG_SetCounter(127);
   1198                    
   1199                    // ---------- USB Process -------------------------------------------         
   1200                    // Host Task handler 
   1201          
   1202                    USBH_Process(&USB_OTG_Core, &USB_Host);
   1203                    SYSTEM_STEP++;
   1204                    
   1205                    if(!CheckTimeOver(10,Main_Timer))       // 없을 경우 
   1206                         continue;
   \                     ??main_2:
   \                     ??main_1:
   \   00000108   ........           BL       IWDG_ReloadCounter
   \   0000010C   ....               LDR.N    R0,??DataTable35_40
   \   0000010E   0021               MOVS     R1,#+0
   \   00000110   0180               STRH     R1,[R0, #+0]
   \   00000112   ........           BL       GraphicOUT_Process
   \   00000116   ....               LDR.N    R0,??DataTable35_40
   \   00000118   0088               LDRH     R0,[R0, #+0]
   \   0000011A   401C               ADDS     R0,R0,#+1
   \   0000011C   ....               LDR.N    R1,??DataTable35_40
   \   0000011E   0880               STRH     R0,[R1, #+0]
   \   00000120   ........           BL       RF_Communcation
   \   00000124   ....               LDR.N    R0,??DataTable35_40
   \   00000126   0088               LDRH     R0,[R0, #+0]
   \   00000128   401C               ADDS     R0,R0,#+1
   \   0000012A   ....               LDR.N    R1,??DataTable35_40
   \   0000012C   0880               STRH     R0,[R1, #+0]
   \   0000012E   ........           BL       SendMessage
   \   00000132   ....               LDR.N    R0,??DataTable35_40
   \   00000134   0088               LDRH     R0,[R0, #+0]
   \   00000136   401C               ADDS     R0,R0,#+1
   \   00000138   ....               LDR.N    R1,??DataTable35_40
   \   0000013A   0880               STRH     R0,[R1, #+0]
   \   0000013C   ........           BL       Ems_realtime_Check
   \   00000140   ....               LDR.N    R0,??DataTable35_40
   \   00000142   0088               LDRH     R0,[R0, #+0]
   \   00000144   401C               ADDS     R0,R0,#+1
   \   00000146   ....               LDR.N    R1,??DataTable35_40
   \   00000148   0880               STRH     R0,[R1, #+0]
   \   0000014A   ........           BL       GPS_Process
   \   0000014E   ....               LDR.N    R0,??DataTable35_40
   \   00000150   0088               LDRH     R0,[R0, #+0]
   \   00000152   401C               ADDS     R0,R0,#+1
   \   00000154   ....               LDR.N    R1,??DataTable35_40
   \   00000156   0880               STRH     R0,[R1, #+0]
   \   00000158   ........           BL       Wifi_Send
   \   0000015C   ....               LDR.N    R0,??DataTable35_40
   \   0000015E   0088               LDRH     R0,[R0, #+0]
   \   00000160   401C               ADDS     R0,R0,#+1
   \   00000162   ....               LDR.N    R1,??DataTable35_40
   \   00000164   0880               STRH     R0,[R1, #+0]
   \   00000166   ....               LDR.N    R1,??DataTable35_47
   \   00000168   ....               LDR.N    R0,??DataTable35_48
   \   0000016A   ........           BL       USBH_Process
   \   0000016E   ....               LDR.N    R0,??DataTable35_40
   \   00000170   0088               LDRH     R0,[R0, #+0]
   \   00000172   401C               ADDS     R0,R0,#+1
   \   00000174   ....               LDR.N    R1,??DataTable35_40
   \   00000176   0880               STRH     R0,[R1, #+0]
   \   00000178   ....               LDR.N    R0,??DataTable35_49
   \   0000017A   0188               LDRH     R1,[R0, #+0]
   \   0000017C   0A20               MOVS     R0,#+10
   \   0000017E   ........           BL       CheckTimeOver
   \   00000182   0028               CMP      R0,#+0
   \   00000184   C0D0               BEQ.N    ??main_2
   1207          
   1208                    Main_Timer = MS_TIMER;  	// 타이머 5
   \   00000186   ....               LDR.N    R0,??DataTable33  ;; 0x40000c00
   \   00000188   ........           BL       TIM_GetCounter
   \   0000018C   ....               LDR.N    R1,??DataTable35_49
   \   0000018E   0880               STRH     R0,[R1, #+0]
   1209          
   1210                    if( First_Setting == 0 )      // 전원 온시 와이파이 세팅 한번하기
   \   00000190   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000192   002C               CMP      R4,#+0
   \   00000194   04D1               BNE.N    ??main_3
   1211                    {
   1212                         SettingWIFI("118.107.161.70,9513,TAEHO,taeho9901");
   \   00000196   ........           ADR.W    R0,`?<Constant "118.107.161.70,9513,T...">`
   \   0000019A   ........           BL       SettingWIFI
   1213                         First_Setting = 1;
   \   0000019E   0124               MOVS     R4,#+1
   1214                    }
   1215                    
   1216                    //---------- ADC 읽기 -------------------------------------------
   1217                    
   1218                    Get_ADC_Data();	   // ADC에서 데이를 읽어온다.
   \                     ??main_3:
   \   000001A0   ........           BL       Get_ADC_Data
   1219                    SYSTEM_STEP++;
   \   000001A4   ....               LDR.N    R0,??DataTable35_40
   \   000001A6   0088               LDRH     R0,[R0, #+0]
   \   000001A8   401C               ADDS     R0,R0,#+1
   \   000001AA   ....               LDR.N    R1,??DataTable35_40
   \   000001AC   0880               STRH     R0,[R1, #+0]
   1220                    //---------- 차량운행종료  -------------------------------------------
   1221                    
   1222                    Battery_Check(); 			// 자동차 운행 종료시 처리 할일을 처리한다.
   \   000001AE   ........           BL       Battery_Check
   1223                    SYSTEM_STEP++;
   \   000001B2   ....               LDR.N    R0,??DataTable35_40
   \   000001B4   0088               LDRH     R0,[R0, #+0]
   \   000001B6   401C               ADDS     R0,R0,#+1
   \   000001B8   ....               LDR.N    R1,??DataTable35_40
   \   000001BA   0880               STRH     R0,[R1, #+0]
   1224                    // --------- 기본 기능 ----------------------------------------------
   1225          
   1226                    KeyProcess();			// 키입력을 처리한다.
   \   000001BC   ........           BL       KeyProcess
   1227                    SYSTEM_STEP++;
   \   000001C0   ....               LDR.N    R0,??DataTable35_40
   \   000001C2   0088               LDRH     R0,[R0, #+0]
   \   000001C4   401C               ADDS     R0,R0,#+1
   \   000001C6   ....               LDR.N    R1,??DataTable35_40
   \   000001C8   0880               STRH     R0,[R1, #+0]
   1228                    
   1229                    Display();			// LCD화면에 디스플레이 한다.
   \   000001CA   ........           BL       Display
   1230                    SYSTEM_STEP++;           //10
   \   000001CE   ....               LDR.N    R0,??DataTable35_40
   \   000001D0   0088               LDRH     R0,[R0, #+0]
   \   000001D2   401C               ADDS     R0,R0,#+1
   \   000001D4   ....               LDR.N    R1,??DataTable35_40
   \   000001D6   0880               STRH     R0,[R1, #+0]
   1231                    
   1232                    //---------- 타이머 --------------------------------------------------
   1233                          
   1234                    RTC_TimeShow(); 		// RTC 시간을 읽어서 변수에 저장 
   \   000001D8   ........           BL       RTC_TimeShow
   1235                    SYSTEM_STEP++;      //10
   \   000001DC   ....               LDR.N    R0,??DataTable35_40
   \   000001DE   0088               LDRH     R0,[R0, #+0]
   \   000001E0   401C               ADDS     R0,R0,#+1
   \   000001E2   ....               LDR.N    R1,??DataTable35_40
   \   000001E4   0880               STRH     R0,[R1, #+0]
   1236          
   1237                    // --------- TILT Check ----------------------------------------------		
   1238                            
   1239                    Tilt_Check();
   \   000001E6   ........           BL       Tilt_Check
   1240                    SYSTEM_STEP++;
   \   000001EA   ....               LDR.N    R0,??DataTable35_40
   \   000001EC   0088               LDRH     R0,[R0, #+0]
   \   000001EE   401C               ADDS     R0,R0,#+1
   \   000001F0   ....               LDR.N    R1,??DataTable35_40
   \   000001F2   0880               STRH     R0,[R1, #+0]
   1241                    
   1242                    //--------- [인터럽트 ] SPEED & RPM & LPG_PWM 검사 -------------------
   1243                    
   1244                    SpeedCheck();			// 속도를 읽어온다.
   \   000001F4   ........           BL       SpeedCheck
   1245                    SYSTEM_STEP++;
   \   000001F8   ....               LDR.N    R0,??DataTable35_40
   \   000001FA   0088               LDRH     R0,[R0, #+0]
   \   000001FC   401C               ADDS     R0,R0,#+1
   \   000001FE   ....               LDR.N    R1,??DataTable35_40
   \   00000200   0880               STRH     R0,[R1, #+0]
   1246                    
   1247                    RPMCheck();			// RPM을 읽어온다.	   
   \   00000202   ........           BL       RPMCheck
   1248                    SYSTEM_STEP++;
   \   00000206   ....               LDR.N    R0,??DataTable35_40
   \   00000208   0088               LDRH     R0,[R0, #+0]
   \   0000020A   401C               ADDS     R0,R0,#+1
   \   0000020C   ....               LDR.N    R1,??DataTable35_40
   \   0000020E   0880               STRH     R0,[R1, #+0]
   1249                    
   1250                    LPGPWM_Check();
   \   00000210   ........           BL       LPGPWM_Check
   1251                    SYSTEM_STEP++;
   \   00000214   ....               LDR.N    R0,??DataTable35_40
   \   00000216   0088               LDRH     R0,[R0, #+0]
   \   00000218   401C               ADDS     R0,R0,#+1
   \   0000021A   ....               LDR.N    R1,??DataTable35_40
   \   0000021C   0880               STRH     R0,[R1, #+0]
   1252                    
   1253                    //---------- 보이스 출력 ----- -------------------------------------
   1254                    
   1255                    Voice_Process();
   \   0000021E   ........           BL       Voice_Process
   1256                    SYSTEM_STEP++;
   \   00000222   ....               LDR.N    R0,??DataTable35_40
   \   00000224   0088               LDRH     R0,[R0, #+0]
   \   00000226   401C               ADDS     R0,R0,#+1
   \   00000228   ....               LDR.N    R1,??DataTable35_40
   \   0000022A   0880               STRH     R0,[R1, #+0]
   1257                    
   1258                    //---------- 와이파이 데이터 처리 ------------------------------------
   1259                    
   1260                    Wifi_Process();
   \   0000022C   ........           BL       Wifi_Process
   1261                    SYSTEM_STEP++;
   \   00000230   ....               LDR.N    R0,??DataTable35_40
   \   00000232   0088               LDRH     R0,[R0, #+0]
   \   00000234   401C               ADDS     R0,R0,#+1
   \   00000236   ....               LDR.N    R1,??DataTable35_40
   \   00000238   0880               STRH     R0,[R1, #+0]
   1262                    
   1263                    //---------- Serial 데이터 처리 ------------------------------------
   1264                            
   1265                    PC_Communication();
   \   0000023A   ........           BL       PC_Communication
   1266                    SYSTEM_STEP++;
   \   0000023E   ....               LDR.N    R0,??DataTable35_40
   \   00000240   0088               LDRH     R0,[R0, #+0]
   \   00000242   401C               ADDS     R0,R0,#+1
   \   00000244   ....               LDR.N    R1,??DataTable35_40
   \   00000246   0880               STRH     R0,[R1, #+0]
   1267          
   1268                    // ----------  운행 관려하여 데이터 처리 ----------------------------
   1269                    
   1270                    Drive_Process();
   \   00000248   ........           BL       Drive_Process
   1271                    SYSTEM_STEP++;
   \   0000024C   ....               LDR.N    R0,??DataTable35_40
   \   0000024E   0088               LDRH     R0,[R0, #+0]
   \   00000250   401C               ADDS     R0,R0,#+1
   \   00000252   ....               LDR.N    R1,??DataTable35_40
   \   00000254   0880               STRH     R0,[R1, #+0]
   1272                    
   1273                    //---------- Memroy [NAND] -------------------------------------------
   1274                    
   1275                    Infomation_Process();
   \   00000256   ........           BL       Infomation_Process
   1276                    SYSTEM_STEP++;           // 메모리 저장 20
   \   0000025A   ....               LDR.N    R0,??DataTable35_40
   \   0000025C   0088               LDRH     R0,[R0, #+0]
   \   0000025E   401C               ADDS     R0,R0,#+1
   \   00000260   ....               LDR.N    R1,??DataTable35_40
   \   00000262   0880               STRH     R0,[R1, #+0]
   1277                    
   1278                    Drive_Acceident_Check();
                           ^
Warning[Pe223]: function "Drive_Acceident_Check" declared implicitly
   \   00000264   ........           BL       Drive_Acceident_Check
   1279                    SYSTEM_STEP++;           // 메모리 저장 20
   \   00000268   ....               LDR.N    R0,??DataTable35_40
   \   0000026A   0088               LDRH     R0,[R0, #+0]
   \   0000026C   401C               ADDS     R0,R0,#+1
   \   0000026E   ....               LDR.N    R1,??DataTable35_40
   \   00000270   0880               STRH     R0,[R1, #+0]
   1280                    
   1281                    Memory_Process();	     // NAND에 저장 한다.
                           ^
Warning[Pe223]: function "Memory_Process" declared implicitly
   \   00000272   ........           BL       Memory_Process
   1282                    SYSTEM_STEP++;
   \   00000276   ....               LDR.N    R0,??DataTable35_40
   \   00000278   0088               LDRH     R0,[R0, #+0]
   \   0000027A   401C               ADDS     R0,R0,#+1
   \   0000027C   ....               LDR.N    R1,??DataTable35_40
   \   0000027E   0880               STRH     R0,[R1, #+0]
   1283                    
   1284                    // -------- ECO 드라이빙 ---------------------------------------------
   1285                    
   1286                    ECO_Driving_Check();          // 
   \   00000280   ........           BL       ECO_Driving_Check
   1287                    SYSTEM_STEP++;
   \   00000284   ....               LDR.N    R0,??DataTable35_40
   \   00000286   0088               LDRH     R0,[R0, #+0]
   \   00000288   401C               ADDS     R0,R0,#+1
   \   0000028A   ....               LDR.N    R1,??DataTable35_40
   \   0000028C   0880               STRH     R0,[R1, #+0]
   1288                    
   1289                    Emergency();                       // 스타트 출력이 3초이상 계속 나가고 있을경우 강제 클리어
   \   0000028E   ........           BL       Emergency
   1290                    SYSTEM_STEP++;
   \   00000292   ....               LDR.N    R0,??DataTable35_40
   \   00000294   0088               LDRH     R0,[R0, #+0]
   \   00000296   401C               ADDS     R0,R0,#+1
   \   00000298   ....               LDR.N    R1,??DataTable35_40
   \   0000029A   0880               STRH     R0,[R1, #+0]
   1291                    
   1292                    // --------- EMS ----------------------------------------------------
   1293                    if(SFLASH_Memory.EMS.USE_Enable)         // EMS를 사용할지 확인한다. 
   \   0000029C   ....               LDR.N    R0,??DataTable35_42
   \   0000029E   90F88A00           LDRB     R0,[R0, #+138]
   \   000002A2   0028               CMP      R0,#+0
   \   000002A4   3FF430AF           BEQ.W    ??main_1
   1294                    {
   1295                         Ems_Port_Check();			     // 입력 포트를 검사한다.
   \   000002A8   ........           BL       Ems_Port_Check
   1296                         SYSTEM_STEP++;
   \   000002AC   ....               LDR.N    R0,??DataTable35_40
   \   000002AE   0088               LDRH     R0,[R0, #+0]
   \   000002B0   401C               ADDS     R0,R0,#+1
   \   000002B2   ....               LDR.N    R1,??DataTable35_40
   \   000002B4   0880               STRH     R0,[R1, #+0]
   1297                         EngineOn_EMSCheck(); 			// 현재 시동온동작인지 체크 한다.
   \   000002B6   ........           BL       EngineOn_EMSCheck
   1298                         SYSTEM_STEP++;
   \   000002BA   ....               LDR.N    R0,??DataTable35_40
   \   000002BC   0088               LDRH     R0,[R0, #+0]
   \   000002BE   401C               ADDS     R0,R0,#+1
   \   000002C0   ....               LDR.N    R1,??DataTable35_40
   \   000002C2   0880               STRH     R0,[R1, #+0]
   1299                         EngineOn_Action();				// 시동온 동작을 시항한다.
   \   000002C4   ........           BL       EngineOn_Action
   1300                         SYSTEM_STEP++;
   \   000002C8   ....               LDR.N    R0,??DataTable35_40
   \   000002CA   0088               LDRH     R0,[R0, #+0]
   \   000002CC   401C               ADDS     R0,R0,#+1
   \   000002CE   ....               LDR.N    R1,??DataTable35_40
   \   000002D0   0880               STRH     R0,[R1, #+0]
   1301                         Relay_Off_Clear();                 // 동작 온시                
   \   000002D2   ........           BL       Relay_Off_Clear
   1302                         SYSTEM_STEP++;
   \   000002D6   ....               LDR.N    R0,??DataTable35_40
   \   000002D8   0088               LDRH     R0,[R0, #+0]
   \   000002DA   401C               ADDS     R0,R0,#+1
   \   000002DC   ....               LDR.N    R1,??DataTable35_40
   \   000002DE   0880               STRH     R0,[R1, #+0]
   1303                         EngineOff_EMSCheck();			// 시동오프 동작체크한다.
   \   000002E0   ........           BL       EngineOff_EMSCheck
   1304                         SYSTEM_STEP++;
   \   000002E4   ....               LDR.N    R0,??DataTable35_40
   \   000002E6   0088               LDRH     R0,[R0, #+0]
   \   000002E8   401C               ADDS     R0,R0,#+1
   \   000002EA   ....               LDR.N    R1,??DataTable35_40
   \   000002EC   0880               STRH     R0,[R1, #+0]
   1305                         EngineOff_Action();				// 시동오프 동작을 실행한다.               
   \   000002EE   ........           BL       EngineOff_Action
   1306                         SYSTEM_STEP++;
   \   000002F2   ....               LDR.N    R0,??DataTable35_40
   \   000002F4   0088               LDRH     R0,[R0, #+0]
   \   000002F6   401C               ADDS     R0,R0,#+1
   \   000002F8   ....               LDR.N    R1,??DataTable35_40
   \   000002FA   0880               STRH     R0,[R1, #+0]
   1307                         EMS_Watching();				// EMS 기능을 이외의 변수(키를 검사)해서 처리
   \   000002FC   ........           BL       EMS_Watching
   1308                         SYSTEM_STEP++;
   \   00000300   ....               LDR.N    R0,??DataTable35_40
   \   00000302   0088               LDRH     R0,[R0, #+0]
   \   00000304   401C               ADDS     R0,R0,#+1
   \   00000306   ....               LDR.N    R1,??DataTable35_40
   \   00000308   0880               STRH     R0,[R1, #+0]
   1309                         EMS_Driving_Check();
   \   0000030A   ........           BL       EMS_Driving_Check
   1310                         SYSTEM_STEP++;
   \   0000030E   ....               LDR.N    R0,??DataTable35_40
   \   00000310   0088               LDRH     R0,[R0, #+0]
   \   00000312   401C               ADDS     R0,R0,#+1
   \   00000314   ....               LDR.N    R1,??DataTable35_40
   \   00000316   0880               STRH     R0,[R1, #+0]
   \   00000318   F6E6               B.N      ??main_1
   1311                    }
   1312                     //-------------------------------------------------------------------
   1313               }
   1314          }      

   \                                 In section .bss, align 2
   \                     ??Main_Timer:
   \   00000000                      DS8 2
   1315          
   1316          ///////////////////////////////////////////////////////////////////////////////////////// 
   1317          /////////////////////////////////////////////////////////////////////////////////////////
   1318          
   1319          /**
   1320          * @brief  Retargets the C library printf function to the USART.
   1321          * @param  None
   1322          * @retval None
   1323          */

   \                                 In section .text, align 2, keep-with-next
   1324          PUTCHAR_PROTOTYPE
   1325          {
   \                     fputc:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   1326          	/* Place your implementation of fputc here */
   1327          	/* e.g. write a character to the USART */
   1328          	//  USART_SendData(EVAL_COM1, (uint8_t) ch);
   1329          	USART_SendData(USART1, (uint8_t) ch); 
   \   00000004   2100               MOVS     R1,R4
   \   00000006   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000A   ....               LDR.N    R0,??DataTable35_50  ;; 0x40011000
   \   0000000C   ........           BL       USART_SendData
   1330          	
   1331          	/* Loop until the end of transmission */
   1332          	//  while (USART_GetFlagStatus(EVAL_COM1, USART_FLAG_TC) == RESET)
   1333          	while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)  
   \                     ??fputc_0:
   \   00000010   4021               MOVS     R1,#+64
   \   00000012   ....               LDR.N    R0,??DataTable35_50  ;; 0x40011000
   \   00000014   ........           BL       USART_GetFlagStatus
   \   00000018   0028               CMP      R0,#+0
   \   0000001A   F9D0               BEQ.N    ??fputc_0
   1334          	{}
   1335          	
   1336          	return ch;
   \   0000001C   2000               MOVS     R0,R4
   \   0000001E   10BD               POP      {R4,PC}          ;; return
   1337          }
   1338          
   1339          /**
   1340          * @brief  Inserts a delay time.
   1341          * @param  nTime: specifies the delay time length, in 10 ms.
   1342          * @retval None
   1343          */

   \                                 In section .text, align 2, keep-with-next
   1344          void Delay(__IO uint32_t nTime)
   1345          {
   \                     Delay:
   \   00000000   01B4               PUSH     {R0}
   1346          	//uint32_t i;
   1347          	//for(i=0; nTime > i; i++);   
   1348          	Timer_1ms = 0;
   \   00000002   ....               LDR.N    R0,??DataTable35_39
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   0180               STRH     R1,[R0, #+0]
   1349          	TimingDelay = nTime;
   \   00000008   ....               LDR.N    R0,??DataTable35_51
   \   0000000A   0099               LDR      R1,[SP, #+0]
   \   0000000C   0160               STR      R1,[R0, #+0]
   1350          	
   1351          	while(TimingDelay > Timer_1ms);
   \                     ??Delay_0:
   \   0000000E   ....               LDR.N    R0,??DataTable35_39
   \   00000010   0088               LDRH     R0,[R0, #+0]
   \   00000012   ....               LDR.N    R1,??DataTable35_51
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   8842               CMP      R0,R1
   \   00000018   F9D3               BCC.N    ??Delay_0
   1352          }
   \   0000001A   01B0               ADD      SP,SP,#+4
   \   0000001C   7047               BX       LR               ;; return
   1353          
   1354          /**
   1355          * @brief  Decrements the TimingDelay variable.
   1356          * @param  None
   1357          * @retval None
   1358          */

   \                                 In section .text, align 2, keep-with-next
   1359          void TimingDelay_Decrement(void)
   1360          {
   1361          	if (TimingDelay != 0x00)
   \                     TimingDelay_Decrement:
   \   00000000   ....               LDR.N    R0,??DataTable35_51
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   0028               CMP      R0,#+0
   \   00000006   04D0               BEQ.N    ??TimingDelay_Decrement_0
   1362          	{ 
   1363          		TimingDelay--;
   \   00000008   ....               LDR.N    R0,??DataTable35_51
   \   0000000A   0068               LDR      R0,[R0, #+0]
   \   0000000C   401E               SUBS     R0,R0,#+1
   \   0000000E   ....               LDR.N    R1,??DataTable35_51
   \   00000010   0860               STR      R0,[R1, #+0]
   1364          	}
   1365          }
   \                     ??TimingDelay_Decrement_0:
   \   00000012   7047               BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   18ED00E0           DC32     0xe000ed18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \   00000000   14E000E0           DC32     0xe000e014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \   00000000   18E000E0           DC32     0xe000e018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \   00000000   ........           DC32     `?<Constant "IWDGRST flag set ...\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_4:
   \   00000000   ........           DC32     `?<Constant "IWDGRST flag is not s...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_5:
   \   00000000   ........           DC32     `?<Constant " WatchDog Reset !!!!!...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   00E400E0           DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_1:
   \   00000000   00180240           DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_2:
   \   00000000   00080240           DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_3:
   \   00000000   00000240           DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \   00000000   10E000E0           DC32     0xe000e010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_1:
   \   00000000   ........           DC32     Flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_2:
   \   00000000   ........           DC32     `?<Constant " Normal BootOn WatchD...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_3:
   \   00000000   000C0240           DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_4:
   \   00000000   00100240           DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_5:
   \   00000000   00040240           DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_6:
   \   00000000   00040040           DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_7:
   \   00000000   00080040           DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "IWDGRST flag set ...\\n">`:
   \   00000000                      ; Initializer data, 24 bytes
   \   00000000   495744475253       DC8 73, 87, 68, 71, 82, 83, 84, 32, 102, 108
   \              5420666C    
   \   0000000A   616720736574       DC8 97, 103, 32, 115, 101, 116, 32, 46, 46, 46
   \              202E2E2E    
   \   00000014   0A000000           DC8 10, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "IWDGRST flag is not s...">`:
   \   00000000                      ; Initializer data, 32 bytes
   \   00000000   495744475253       DC8 73, 87, 68, 71, 82, 83, 84, 32, 102, 108
   \              5420666C    
   \   0000000A   616720697320       DC8 97, 103, 32, 105, 115, 32, 110, 111, 116, 32
   \              6E6F7420    
   \   00000014   736574202E2E       DC8 115, 101, 116, 32, 46, 46, 46, 10, 0, 0
   \              2E0A0000    
   \   0000001E   0000               DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " WatchDog Reset !!!!!...">`:
   \   00000000                      ; Initializer data, 40 bytes
   \   00000000   205761746368       DC8 32, 87, 97, 116, 99, 104, 68, 111, 103, 32
   \              446F6720    
   \   0000000A   526573657420       DC8 82, 101, 115, 101, 116, 32, 33, 33, 33, 33
   \              21212121    
   \   00000014   212121212121       DC8 33, 33, 33, 33, 33, 33, 33, 33, 33, 33
   \              21212121    
   \   0000001E   212121200D0A       DC8 33, 33, 33, 32, 13, 10, 0, 0, 0, 0
   \              00000000    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Normal BootOn WatchD...">`:
   \   00000000                      ; Initializer data, 36 bytes
   \   00000000   204E6F726D61       DC8 32, 78, 111, 114, 109, 97, 108, 32, 66, 111
   \              6C20426F    
   \   0000000A   6F744F6E2057       DC8 111, 116, 79, 110, 32, 87, 97, 116, 99, 104
   \              61746368    
   \   00000014   446F67205374       DC8 68, 111, 103, 32, 83, 116, 97, 114, 116, 32
   \              61727420    
   \   0000001E   0D0A00000000       DC8 13, 10, 0, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33:
   \   00000000   000C0040           DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   00100040           DC32     0x40001000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_1:
   \   00000000   00140040           DC32     0x40001400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \   00000000   00040140           DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_1:
   \   00000000   000C0040           DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_2:
   \   00000000   ........           DC32     Timer_1Sec

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_3:
   \   00000000   ........           DC32     ??SPEED_Timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_4:
   \   00000000   ........           DC32     SPEED_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_5:
   \   00000000   0100E03F           DC32     0x3fe00001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_6:
   \   00000000   ........           DC32     SPEED_Check

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_7:
   \   00000000   ........           DC32     ??Low_Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_8:
   \   00000000   ........           DC32     Info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_9:
   \   00000000   ........           DC32     ??RPM_Timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_10:
   \   00000000   ........           DC32     Set_Info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_11:
   \   00000000   400D0300           DC32     0x30d40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_12:
   \   00000000   1904560E           DC32     0xe560419

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_13:
   \   00000000   2DB2F73F           DC32     0x3ff7b22d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_14:
   \   00000000   ........           DC32     Speed_Check_Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_15:
   \   00000000   ........           DC32     Speed_Buffer1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_16:
   \   00000000   ........           DC32     Speed_Buffer2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_17:
   \   00000000   ........           DC32     ??RPM_Timer_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_18:
   \   00000000   ........           DC32     RPM_Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_19:
   \   00000000   ........           DC32     RPM_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_20:
   \   00000000   0100C03F           DC32     0x3fc00001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_21:
   \   00000000   ........           DC32     ??Low_Count_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_22:
   \   00000000   80841E00           DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_23:
   \   00000000   ........           DC32     ??LPGPWM_Timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_24:
   \   00000000   ........           DC32     LPGBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_25:
   \   00000000   ........           DC32     LPG_Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_26:
   \   00000000   ........           DC32     ??IO_Check_Timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_27:
   \   00000000   ........           DC32     SYSTEM_TIME_BINARY

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_28:
   \   00000000   ........           DC32     TiltInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_29:
   \   00000000   ........           DC32     OUTPUT_DATA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_30:
   \   00000000   ........           DC32     AccidentPoint

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_31:
   \   00000000   ........           DC32     Accident_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_32:
   \   00000000   ........           DC32     ??IO_Check_Timer2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_33:
   \   00000000   ........           DC32     GPSInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_34:
   \   00000000   ........           DC32     EMS_Drive_Value

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_35:
   \   00000000   00007A44           DC32     0x447a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_36:
   \   00000000   ........           DC32     AccidentPoint2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_37:
   \   00000000   ........           DC32     Accident2_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_38:
   \   00000000   ........           DC32     ??Save_Flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_39:
   \   00000000   ........           DC32     Timer_1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_40:
   \   00000000   ........           DC32     SYSTEM_STEP

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_41:
   \   00000000   ........           DC32     DisplayInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_42:
   \   00000000   ........           DC32     SFLASH_Memory

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_43:
   \   00000000   ........           DC32     Info+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_44:
   \   00000000   ........           DC32     RCC_Clocks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_45:
   \   00000000   ........           DC32     USR_cb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_46:
   \   00000000   ........           DC32     USBH_MSC_cb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_47:
   \   00000000   ........           DC32     USB_Host

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_48:
   \   00000000   ........           DC32     USB_OTG_Core

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_49:
   \   00000000   ........           DC32     ??Main_Timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_50:
   \   00000000   00100140           DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_51:
   \   00000000   ........           DC32     TimingDelay

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Start \\r\\n">`:
   \   00000000                      ; Initializer data, 12 bytes
   \   00000000   205374617274       DC8 32, 83, 116, 97, 114, 116, 32, 13, 10, 0
   \              200D0A00    
   \   0000000A   0000               DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " SFLASH OK \\r\\n">`:
   \   00000000                      ; Initializer data, 16 bytes
   \   00000000   2053464C4153       DC8 32, 83, 70, 76, 65, 83, 72, 32, 79, 75
   \              48204F4B    
   \   0000000A   200D0A000000       DC8 32, 13, 10, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "118.107.161.70,9513,T...">`:
   \   00000000                      ; Initializer data, 36 bytes
   \   00000000   3131382E3130       DC8 49, 49, 56, 46, 49, 48, 55, 46, 49, 54
   \              372E3136    
   \   0000000A   312E37302C39       DC8 49, 46, 55, 48, 44, 57, 53, 49, 51, 44
   \              3531332C    
   \   00000014   544145484F2C       DC8 84, 65, 69, 72, 79, 44, 116, 97, 101, 104
   \              74616568    
   \   0000001E   6F3939303100       DC8 111, 57, 57, 48, 49, 0
   1366          
   1367          #ifdef  USE_FULL_ASSERT
   1368          
   1369          /**
   1370          * @brief  Reports the name of the source file and the source line number
   1371          *   where the assert_param error has occurred.
   1372          * @param  file: pointer to the source file name
   1373          * @param  line: assert_param error line source number
   1374          * @retval None
   1375          */
   1376          void assert_failed(uint8_t* file, uint32_t line)
   1377          { 
   1378               /* User can add his own implementation to report the file name and line number,
   1379               ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
   1380          	
   1381          	/* Infinite loop */
   1382          	while (1)
   1383          	{
   1384          	}
   1385          }
   1386          #endif
   1387          
   1388          /**
   1389          * @}
   1390          */
   1391          
   1392          
   1393          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                .cstack
     --------                -------
     Battery_Check                0
     CheckTimeInterval_100us     16
     CheckTimeInterval_1us       16
     CheckTimeOver               16
     CheckTimeOver1Sec            4
     Delay                        4
     EXTILine1_Config            24
     FindString                   4
     GPIO_Configuration          16
     GPIO_Configuration2         16
     Infomation_Process          16
     InitIWDG                     8
     InitWWDG                     8
     Initialize                   8
     LED1_OFF                     8
     LED2_OFF                     8
     LPGPWM_Check                 8
     NVIC_SetPriority             0
     RPMCheck                    24
     SpeedCheck                  24
     SysTick_Config               8
     TIM3_Config                 16
     TIM4_Config                 16
     TIM5_Config                 16
     TIM6_Config                 16
     TIM7_Config                 16
     TIM8_Config                 48
     TimingDelay_Decrement        0
     fputc                        8
     main                        16
     memcpy                       8
     memset                       8


   Section sizes:

     Function/Label                         Bytes
     --------------                         -----
     NVIC_SetPriority                         38
     SysTick_Config                           54
     memcpy                                   14
     memset                                   20
     LED1_OFF                                 28
     LED2_OFF                                 28
     EMS_Drive_Value                          36
     TimingDelay                               4
     RCC_Clocks                               16
     HSEStartUpStatus                          1
     Timer_1Sec                                2
     Flag                                     20
     ERROR_Status                              1
     Buffer                                  512
     BuffCnt                                   2
     SYSTEM_STEP                               2
     SPEED_PULS_Count                          4
     m_sec                                     2
     SFLASH_CarInfo                           96
     SFLASH_Memory                           180
     GPS_RouteCheck                           68
     SFLASH_Wifi                              76
     Set_Info                                 16
     Info                                    104
     Accident_Buffer                        8000
     Accident2_Buffer                        172
     Accident_SaveBuffer                    8000
     Accident2_SaveBuffer                    172
     Accident_Time                            16
     AccidentPoint                             2
     AccidentPoint2                            2
     ECO_Driving                              12
     USB_OTG_Core                           1200
     USB_Host                                132
     InitIWDG                                 82
     InitWWDG                                104
     GPIO_Configuration                       54
     GPIO_Configuration2                     280
     EXTILine1_Config                        306
     TIM3_Config                              80
     TIM4_Config                              58
     TIM5_Config                              70
     TIM6_Config                              70
     TIM7_Config                              66
     TIM8_Config                             208
     CheckTimeOver                            72
     CheckTimeOver1Sec                        68
     CheckTimeInterval_100us                  44
     CheckTimeInterval_1us                    44
     FindString                               44
     SpeedCheck                              446
     SPEED_Timer                               2
     RPM_Timer                                 2
     Low_Count                                 1
     RPMCheck                                276
     RPM_Timer                                 2
     Low_Count                                 1
     LPGPWM_Check                             96
     LPGPWM_Timer                              2
     Infomation_Process                      900
     IO_Check_Timer                            2
     IO_Check_Timer2                           2
     Battery_Check                            28
     Save_Flag                                 1
     Initialize                              108
     main                                    794
     Main_Timer                                2
     fputc                                    32
     Delay                                    30
     TimingDelay_Decrement                    20
     ??DataTable28                             4
     ??DataTable28_1                           4
     ??DataTable28_2                           4
     ??DataTable28_3                           4
     ??DataTable28_4                           4
     ??DataTable28_5                           4
     ??DataTable30                             4
     ??DataTable30_1                           4
     ??DataTable30_2                           4
     ??DataTable30_3                           4
     ??DataTable31                             4
     ??DataTable31_1                           4
     ??DataTable31_2                           4
     ??DataTable31_3                           4
     ??DataTable31_4                           4
     ??DataTable31_5                           4
     ??DataTable31_6                           4
     ??DataTable31_7                           4
     ?<Constant "IWDGRST flag set ...\n">     24
     ?<Constant "IWDGRST flag is not s...">   32
     ?<Constant " WatchDog Reset !!!!!...">   40
     ?<Constant " Normal BootOn WatchD...">   36
     ??DataTable33                             4
     ??DataTable34                             4
     ??DataTable34_1                           4
     ??DataTable35                             4
     ??DataTable35_1                           4
     ??DataTable35_2                           4
     ??DataTable35_3                           4
     ??DataTable35_4                           4
     ??DataTable35_5                           4
     ??DataTable35_6                           4
     ??DataTable35_7                           4
     ??DataTable35_8                           4
     ??DataTable35_9                           4
     ??DataTable35_10                          4
     ??DataTable35_11                          4
     ??DataTable35_12                          4
     ??DataTable35_13                          4
     ??DataTable35_14                          4
     ??DataTable35_15                          4
     ??DataTable35_16                          4
     ??DataTable35_17                          4
     ??DataTable35_18                          4
     ??DataTable35_19                          4
     ??DataTable35_20                          4
     ??DataTable35_21                          4
     ??DataTable35_22                          4
     ??DataTable35_23                          4
     ??DataTable35_24                          4
     ??DataTable35_25                          4
     ??DataTable35_26                          4
     ??DataTable35_27                          4
     ??DataTable35_28                          4
     ??DataTable35_29                          4
     ??DataTable35_30                          4
     ??DataTable35_31                          4
     ??DataTable35_32                          4
     ??DataTable35_33                          4
     ??DataTable35_34                          4
     ??DataTable35_35                          4
     ??DataTable35_36                          4
     ??DataTable35_37                          4
     ??DataTable35_38                          4
     ??DataTable35_39                          4
     ??DataTable35_40                          4
     ??DataTable35_41                          4
     ??DataTable35_42                          4
     ??DataTable35_43                          4
     ??DataTable35_44                          4
     ??DataTable35_45                          4
     ??DataTable35_46                          4
     ??DataTable35_47                          4
     ??DataTable35_48                          4
     ??DataTable35_49                          4
     ??DataTable35_50                          4
     ??DataTable35_51                          4
     ?<Constant " Start \r\n">                12
     ?<Constant " SFLASH OK \r\n">            16
     ?<Constant "118.107.161.70,9513,T...">   36

 
 18 867 bytes in section .bss
  5 050 bytes in section .text
 
  5 016 bytes of CODE memory (+ 34 bytes shared)
 18 867 bytes of DATA memory

Errors: none
Warnings: 3
