###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     12/Nov/2011  19:31:43 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Libraries\STM32 #
#                    _USB_HOST_Library\Class\MSC\src\usbh_msc_scsi.c          #
#    Command line =  "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Libraries\STM3 #
#                    2_USB_HOST_Library\Class\MSC\src\usbh_msc_scsi.c" -D     #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D RTC_CLOCK_SOURCE_LSE -lC            #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    STM3220F_EVAL\List\" -lA "F:\¹¬ÀÛ¾÷\[ NewDTG             #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\STM3220F_EVAL\List\" #
#                     -o "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EW #
#                    ARM\STM3220F_EVAL\Obj\" --no_cse --no_unroll             #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                              #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\" -I              #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\CMSIS\CM3\CoreSupport\" -I "F:\¹¬ÀÛ¾÷\[  #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Librari #
#                    es\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\" -I             #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I      #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Utilities\STM32_EVAL\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG      #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\Common\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\STM3220F_EVAL\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_OTG_Driver\inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Core\inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Class\msc\inc\" -I "F:\¹¬ÀÛ¾÷\[     #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\" -I   #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\Usb\Inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                      #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\src\" -I      #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Core\inc\" -I     #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\"   #
#                    -Ol --use_c++_inline                                     #
#    List file    =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\List\usbh_msc_scsi.lst                      #
#    Object file  =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\Obj\usbh_msc_scsi.o                         #
#                                                                             #
#                                                                             #
###############################################################################

F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Libraries\STM32_USB_HOST_Library\Class\MSC\src\usbh_msc_scsi.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbh_msc_scsi.c 
      4            * @author  MCD Application Team
      5            * @version V2.0.0RC1
      6            * @date    18-March-2011
      7            * @brief   This file implements the SCSI commands
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */ 
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "usbh_msc_core.h"
     24          #include "usbh_msc_scsi.h"
     25          #include "usbh_msc_bot.h"
     26          #include "usbh_ioreq.h"
     27          #include "usbh_def.h"
     28          
     29          
     30          /** @addtogroup USBH_LIB
     31            * @{
     32            */
     33          
     34          /** @addtogroup USBH_CLASS
     35            * @{
     36            */
     37          
     38          /** @addtogroup USBH_MSC_CLASS
     39            * @{
     40            */
     41            
     42          /** @defgroup USBH_MSC_SCSI 
     43            * @brief    This file includes the mass storage related functions
     44            * @{
     45            */ 
     46          
     47          
     48          /** @defgroup USBH_MSC_SCSI_Private_TypesDefinitions
     49            * @{
     50            */ 
     51          

   \                                 In section .bss, align 4
     52          MassStorageParameter_TypeDef USBH_MSC_Param; 
   \                     USBH_MSC_Param:
   \   00000000                      DS8 16
     53          /**
     54            * @}
     55            */ 
     56          
     57          /** @defgroup USBH_MSC_SCSI_Private_Defines
     58            * @{
     59            */ 
     60          /**
     61            * @}
     62            */ 
     63          
     64          /** @defgroup USBH_MSC_SCSI_Private_Macros
     65            * @{
     66            */ 
     67          /**
     68            * @}
     69            */ 
     70          
     71          
     72          /** @defgroup USBH_MSC_SCSI_Private_Variables
     73            * @{
     74            */ 

   \                                 In section .bss, align 4
     75          uint8_t USBH_DataInBuffer[512];
   \                     USBH_DataInBuffer:
   \   00000000                      DS8 512

   \                                 In section .bss, align 4
     76          uint8_t USBH_DataOutBuffer[512];
   \                     USBH_DataOutBuffer:
   \   00000000                      DS8 512
     77          /**
     78            * @}
     79            */ 
     80          
     81          
     82          /** @defgroup USBH_MSC_SCSI_Private_FunctionPrototypes
     83            * @{
     84            */ 
     85          /**
     86            * @}
     87            */ 
     88          
     89          
     90          /** @defgroup USBH_MSC_SCSI_Exported_Variables
     91            * @{
     92            */ 
     93          
     94          /**
     95            * @}
     96            */ 
     97          
     98          
     99          /** @defgroup USBH_MSC_SCSI_Private_Functions
    100            * @{
    101            */ 
    102          
    103          
    104          
    105          
    106          /**
    107            * @brief  USBH_MSC_TestUnitReady 
    108            *         Issues 'Test unit ready' command to the device. Once the response  
    109            *         received, it updates the status to upper layer.
    110            * @param  None
    111            * @retval Status
    112            */

   \                                 In section .text, align 2, keep-with-next
    113          uint8_t USBH_MSC_TestUnitReady (USB_OTG_CORE_HANDLE *pdev)
    114          {
   \                     USBH_MSC_TestUnitReady:
   \   00000000   10B5               PUSH     {R4,LR}
    115            uint8_t index;
    116            USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
   \   00000002   0324               MOVS     R4,#+3
    117            
    118            if(HCD_IsDeviceConnected(pdev))
   \   00000004   ........           BL       HCD_IsDeviceConnected
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   63D0               BEQ.N    ??USBH_MSC_TestUnitReady_0
    119            {  
    120              switch(USBH_MSC_BOTXferParam.CmdStateMachine)
   \   0000000C   ........           LDR.W    R0,??DataTable5
   \   00000010   C078               LDRB     R0,[R0, #+3]
   \   00000012   0128               CMP      R0,#+1
   \   00000014   02D0               BEQ.N    ??USBH_MSC_TestUnitReady_1
   \   00000016   0228               CMP      R0,#+2
   \   00000018   3BD0               BEQ.N    ??USBH_MSC_TestUnitReady_2
   \   0000001A   5BE0               B.N      ??USBH_MSC_TestUnitReady_3
    121              {
    122              case CMD_SEND_STATE:  
    123                /*Prepare the CBW and relevent field*/
    124                USBH_MSC_CBWData.field.CBWTransferLength = 0;       /* No Data Transfer */
   \                     ??USBH_MSC_TestUnitReady_1:
   \   0000001C   ........           LDR.W    R0,??DataTable5_1
   \   00000020   0021               MOVS     R1,#+0
   \   00000022   8160               STR      R1,[R0, #+8]
    125                USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_OUT;
   \   00000024   ........           LDR.W    R0,??DataTable5_1
   \   00000028   0021               MOVS     R1,#+0
   \   0000002A   0173               STRB     R1,[R0, #+12]
    126                USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH_TEST_UNIT_READY;
   \   0000002C   ........           LDR.W    R0,??DataTable5_1
   \   00000030   0621               MOVS     R1,#+6
   \   00000032   8173               STRB     R1,[R0, #+14]
    127                USBH_MSC_BOTXferParam.pRxTxBuff = USBH_MSC_CSWData.CSWArray;
   \   00000034   ........           LDR.W    R0,??DataTable5
   \   00000038   ........           LDR.W    R1,??DataTable5_2
   \   0000003C   8160               STR      R1,[R0, #+8]
    128                USBH_MSC_BOTXferParam.DataLength = USBH_MSC_CSW_MAX_LENGTH;
   \   0000003E   ........           LDR.W    R0,??DataTable5
   \   00000042   3F21               MOVS     R1,#+63
   \   00000044   8181               STRH     R1,[R0, #+12]
    129                USBH_MSC_BOTXferParam.MSCStateCurrent = USBH_MSC_TEST_UNIT_READY;
   \   00000046   ........           LDR.W    R0,??DataTable5
   \   0000004A   0321               MOVS     R1,#+3
   \   0000004C   8170               STRB     R1,[R0, #+2]
    130                
    131                for(index = CBW_CB_LENGTH; index != 0; index--)
   \   0000004E   1020               MOVS     R0,#+16
   \   00000050   06E0               B.N      ??USBH_MSC_TestUnitReady_4
    132                {
    133                  USBH_MSC_CBWData.field.CBWCB[index] = 0x00;
   \                     ??USBH_MSC_TestUnitReady_5:
   \   00000052   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   ........           LDR.W    R1,??DataTable5_1
   \   00000058   4118               ADDS     R1,R0,R1
   \   0000005A   0022               MOVS     R2,#+0
   \   0000005C   CA73               STRB     R2,[R1, #+15]
    134                }
   \   0000005E   401E               SUBS     R0,R0,#+1
   \                     ??USBH_MSC_TestUnitReady_4:
   \   00000060   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0028               CMP      R0,#+0
   \   00000064   F5D1               BNE.N    ??USBH_MSC_TestUnitReady_5
    135                
    136                USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_TEST_UNIT_READY; 
   \   00000066   ........           LDR.W    R0,??DataTable5_1
   \   0000006A   0021               MOVS     R1,#+0
   \   0000006C   C173               STRB     R1,[R0, #+15]
    137                USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SEND_CBW;
   \   0000006E   ........           LDR.W    R0,??DataTable5
   \   00000072   0121               MOVS     R1,#+1
   \   00000074   0171               STRB     R1,[R0, #+4]
    138                /* Start the transfer, then let the state 
    139                machine magage the other transactions */
    140                USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
   \   00000076   ........           LDR.W    R0,??DataTable5
   \   0000007A   0721               MOVS     R1,#+7
   \   0000007C   0170               STRB     R1,[R0, #+0]
    141                USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
   \   0000007E   ........           LDR.W    R0,??DataTable5
   \   00000082   0321               MOVS     R1,#+3
   \   00000084   C173               STRB     R1,[R0, #+15]
    142                USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
   \   00000086   ........           LDR.W    R0,??DataTable5
   \   0000008A   0221               MOVS     R1,#+2
   \   0000008C   C170               STRB     R1,[R0, #+3]
    143                
    144                status = USBH_MSC_BUSY; 
   \   0000008E   0324               MOVS     R4,#+3
    145                break;
   \   00000090   20E0               B.N      ??USBH_MSC_TestUnitReady_0
    146                
    147              case CMD_WAIT_STATUS: 
    148                if(USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_OK)
   \                     ??USBH_MSC_TestUnitReady_2:
   \   00000092   ........           LDR.W    R0,??DataTable5
   \   00000096   C07B               LDRB     R0,[R0, #+15]
   \   00000098   0028               CMP      R0,#+0
   \   0000009A   05D1               BNE.N    ??USBH_MSC_TestUnitReady_6
    149                { 
    150                  /* Commands successfully sent and Response Received  */       
    151                  USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
   \   0000009C   ........           LDR.W    R0,??DataTable5
   \   000000A0   0121               MOVS     R1,#+1
   \   000000A2   C170               STRB     R1,[R0, #+3]
    152                 
    153                  status = USBH_MSC_OK;      
   \   000000A4   0024               MOVS     R4,#+0
   \   000000A6   14E0               B.N      ??USBH_MSC_TestUnitReady_7
    154                }
    155                else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_FAIL )
   \                     ??USBH_MSC_TestUnitReady_6:
   \   000000A8   ........           LDR.W    R0,??DataTable5
   \   000000AC   C07B               LDRB     R0,[R0, #+15]
   \   000000AE   0128               CMP      R0,#+1
   \   000000B0   05D1               BNE.N    ??USBH_MSC_TestUnitReady_8
    156                {
    157                  /* Failure Mode */
    158                  USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
   \   000000B2   ........           LDR.W    R0,??DataTable5
   \   000000B6   0121               MOVS     R1,#+1
   \   000000B8   C170               STRB     R1,[R0, #+3]
    159                  status = USBH_MSC_FAIL;
   \   000000BA   0124               MOVS     R4,#+1
   \   000000BC   09E0               B.N      ??USBH_MSC_TestUnitReady_7
    160                }
    161                
    162                else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_PHASE_ERROR )
   \                     ??USBH_MSC_TestUnitReady_8:
   \   000000BE   ........           LDR.W    R0,??DataTable5
   \   000000C2   C07B               LDRB     R0,[R0, #+15]
   \   000000C4   0228               CMP      R0,#+2
   \   000000C6   04D1               BNE.N    ??USBH_MSC_TestUnitReady_7
    163                {
    164                  /* Failure Mode */
    165                  USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
   \   000000C8   ........           LDR.W    R0,??DataTable5
   \   000000CC   0121               MOVS     R1,#+1
   \   000000CE   C170               STRB     R1,[R0, #+3]
    166                  status = USBH_MSC_PHASE_ERROR;    
   \   000000D0   0224               MOVS     R4,#+2
    167                }  
    168                break;
   \                     ??USBH_MSC_TestUnitReady_7:
   \   000000D2   FFE7               B.N      ??USBH_MSC_TestUnitReady_0
    169                
    170              default:
    171                break;
    172              }
    173            }
    174            return status;
   \                     ??USBH_MSC_TestUnitReady_3:
   \                     ??USBH_MSC_TestUnitReady_0:
   \   000000D4   2000               MOVS     R0,R4
   \   000000D6   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D8   10BD               POP      {R4,PC}          ;; return
    175          }
    176          
    177          
    178          /**
    179            * @brief  USBH_MSC_ReadCapacity10  
    180            *         Issue the read capacity command to the device. Once the response 
    181            *         received, it updates the status to upper layer
    182            * @param  None
    183            * @retval Status
    184            */

   \                                 In section .text, align 2, keep-with-next
    185          uint8_t USBH_MSC_ReadCapacity10(USB_OTG_CORE_HANDLE *pdev)
    186          {
   \                     USBH_MSC_ReadCapacity10:
   \   00000000   10B5               PUSH     {R4,LR}
    187            uint8_t index;
    188            USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
   \   00000002   0324               MOVS     R4,#+3
    189            
    190            if(HCD_IsDeviceConnected(pdev))
   \   00000004   ........           BL       HCD_IsDeviceConnected
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   00F08480           BEQ.W    ??USBH_MSC_ReadCapacity10_0
    191            {  
    192              switch(USBH_MSC_BOTXferParam.CmdStateMachine)
   \   0000000E   ........           LDR.W    R0,??DataTable5
   \   00000012   C078               LDRB     R0,[R0, #+3]
   \   00000014   0128               CMP      R0,#+1
   \   00000016   02D0               BEQ.N    ??USBH_MSC_ReadCapacity10_1
   \   00000018   0228               CMP      R0,#+2
   \   0000001A   37D0               BEQ.N    ??USBH_MSC_ReadCapacity10_2
   \   0000001C   7BE0               B.N      ??USBH_MSC_ReadCapacity10_3
    193              {
    194              case CMD_SEND_STATE:
    195                /*Prepare the CBW and relevent field*/
    196                USBH_MSC_CBWData.field.CBWTransferLength = XFER_LEN_READ_CAPACITY10;
   \                     ??USBH_MSC_ReadCapacity10_1:
   \   0000001E   ........           LDR.W    R0,??DataTable5_1
   \   00000022   0821               MOVS     R1,#+8
   \   00000024   8160               STR      R1,[R0, #+8]
    197                USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_IN;
   \   00000026   ........           LDR.W    R0,??DataTable5_1
   \   0000002A   8021               MOVS     R1,#+128
   \   0000002C   0173               STRB     R1,[R0, #+12]
    198                USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
   \   0000002E   ........           LDR.W    R0,??DataTable5_1
   \   00000032   0A21               MOVS     R1,#+10
   \   00000034   8173               STRB     R1,[R0, #+14]
    199                
    200                USBH_MSC_BOTXferParam.pRxTxBuff = USBH_DataInBuffer;
   \   00000036   ........           LDR.W    R0,??DataTable5
   \   0000003A   ........           LDR.W    R1,??DataTable5_3
   \   0000003E   8160               STR      R1,[R0, #+8]
    201                USBH_MSC_BOTXferParam.MSCStateCurrent = USBH_MSC_READ_CAPACITY10;
   \   00000040   ........           LDR.W    R0,??DataTable5
   \   00000044   0421               MOVS     R1,#+4
   \   00000046   8170               STRB     R1,[R0, #+2]
    202                
    203                for(index = CBW_CB_LENGTH; index != 0; index--)
   \   00000048   1020               MOVS     R0,#+16
   \   0000004A   06E0               B.N      ??USBH_MSC_ReadCapacity10_4
    204                {
    205                  USBH_MSC_CBWData.field.CBWCB[index] = 0x00;
   \                     ??USBH_MSC_ReadCapacity10_5:
   \   0000004C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   ........           LDR.W    R1,??DataTable5_1
   \   00000052   4118               ADDS     R1,R0,R1
   \   00000054   0022               MOVS     R2,#+0
   \   00000056   CA73               STRB     R2,[R1, #+15]
    206                }    
   \   00000058   401E               SUBS     R0,R0,#+1
   \                     ??USBH_MSC_ReadCapacity10_4:
   \   0000005A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005C   0028               CMP      R0,#+0
   \   0000005E   F5D1               BNE.N    ??USBH_MSC_ReadCapacity10_5
    207                
    208                USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_READ_CAPACITY10; 
   \   00000060   ........           LDR.W    R0,??DataTable5_1
   \   00000064   2521               MOVS     R1,#+37
   \   00000066   C173               STRB     R1,[R0, #+15]
    209                USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SEND_CBW;
   \   00000068   ........           LDR.W    R0,??DataTable5
   \   0000006C   0121               MOVS     R1,#+1
   \   0000006E   0171               STRB     R1,[R0, #+4]
    210                
    211                /* Start the transfer, then let the state machine manage the other 
    212                                                                          transactions */
    213                USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
   \   00000070   ........           LDR.W    R0,??DataTable5
   \   00000074   0721               MOVS     R1,#+7
   \   00000076   0170               STRB     R1,[R0, #+0]
    214                USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
   \   00000078   ........           LDR.W    R0,??DataTable5
   \   0000007C   0321               MOVS     R1,#+3
   \   0000007E   C173               STRB     R1,[R0, #+15]
    215                USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
   \   00000080   ........           LDR.W    R0,??DataTable5
   \   00000084   0221               MOVS     R1,#+2
   \   00000086   C170               STRB     R1,[R0, #+3]
    216                
    217                status = USBH_MSC_BUSY;
   \   00000088   0324               MOVS     R4,#+3
    218                break;
   \   0000008A   44E0               B.N      ??USBH_MSC_ReadCapacity10_0
    219                
    220              case CMD_WAIT_STATUS:
    221                if(USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_OK)
   \                     ??USBH_MSC_ReadCapacity10_2:
   \   0000008C   ........           LDR.W    R0,??DataTable5
   \   00000090   C07B               LDRB     R0,[R0, #+15]
   \   00000092   0028               CMP      R0,#+0
   \   00000094   29D1               BNE.N    ??USBH_MSC_ReadCapacity10_6
    222                {
    223                  /*assign the capacity*/
    224                  (((uint8_t*)&USBH_MSC_Param.MSCapacity )[3]) = USBH_DataInBuffer[0];
   \   00000096   ........           LDR.W    R0,??DataTable5_4
   \   0000009A   ........           LDR.W    R1,??DataTable5_3
   \   0000009E   0978               LDRB     R1,[R1, #+0]
   \   000000A0   C170               STRB     R1,[R0, #+3]
    225                  (((uint8_t*)&USBH_MSC_Param.MSCapacity )[2]) = USBH_DataInBuffer[1];
   \   000000A2   ........           LDR.W    R0,??DataTable5_4
   \   000000A6   ........           LDR.W    R1,??DataTable5_3
   \   000000AA   4978               LDRB     R1,[R1, #+1]
   \   000000AC   8170               STRB     R1,[R0, #+2]
    226                  (((uint8_t*)&USBH_MSC_Param.MSCapacity )[1]) = USBH_DataInBuffer[2];
   \   000000AE   ........           LDR.W    R0,??DataTable5_4
   \   000000B2   ........           LDR.W    R1,??DataTable5_3
   \   000000B6   8978               LDRB     R1,[R1, #+2]
   \   000000B8   4170               STRB     R1,[R0, #+1]
    227                  (((uint8_t*)&USBH_MSC_Param.MSCapacity )[0]) = USBH_DataInBuffer[3];
   \   000000BA   ........           LDR.W    R0,??DataTable5_3
   \   000000BE   C078               LDRB     R0,[R0, #+3]
   \   000000C0   ........           LDR.W    R1,??DataTable5_4
   \   000000C4   0870               STRB     R0,[R1, #+0]
    228                  
    229                  /*assign the page length*/
    230                  (((uint8_t*)&USBH_MSC_Param.MSPageLength )[1]) = USBH_DataInBuffer[6];
   \   000000C6   ........           LDR.W    R0,??DataTable5_4
   \   000000CA   ........           LDR.W    R1,??DataTable5_3
   \   000000CE   8979               LDRB     R1,[R1, #+6]
   \   000000D0   4172               STRB     R1,[R0, #+9]
    231                  (((uint8_t*)&USBH_MSC_Param.MSPageLength )[0]) = USBH_DataInBuffer[7];
   \   000000D2   ........           LDR.W    R0,??DataTable5_4
   \   000000D6   ........           LDR.W    R1,??DataTable5_3
   \   000000DA   C979               LDRB     R1,[R1, #+7]
   \   000000DC   0172               STRB     R1,[R0, #+8]
    232                  
    233                  /* Commands successfully sent and Response Received  */       
    234                  USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
   \   000000DE   ........           LDR.W    R0,??DataTable5
   \   000000E2   0121               MOVS     R1,#+1
   \   000000E4   C170               STRB     R1,[R0, #+3]
    235                  status = USBH_MSC_OK;      
   \   000000E6   0024               MOVS     R4,#+0
   \   000000E8   14E0               B.N      ??USBH_MSC_ReadCapacity10_7
    236                }
    237                else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_FAIL )
   \                     ??USBH_MSC_ReadCapacity10_6:
   \   000000EA   ........           LDR.W    R0,??DataTable5
   \   000000EE   C07B               LDRB     R0,[R0, #+15]
   \   000000F0   0128               CMP      R0,#+1
   \   000000F2   05D1               BNE.N    ??USBH_MSC_ReadCapacity10_8
    238                {
    239                  /* Failure Mode */
    240                  USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
   \   000000F4   ........           LDR.W    R0,??DataTable5
   \   000000F8   0121               MOVS     R1,#+1
   \   000000FA   C170               STRB     R1,[R0, #+3]
    241                  status = USBH_MSC_FAIL;
   \   000000FC   0124               MOVS     R4,#+1
   \   000000FE   09E0               B.N      ??USBH_MSC_ReadCapacity10_7
    242                }  
    243                else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_PHASE_ERROR )
   \                     ??USBH_MSC_ReadCapacity10_8:
   \   00000100   ........           LDR.W    R0,??DataTable5
   \   00000104   C07B               LDRB     R0,[R0, #+15]
   \   00000106   0228               CMP      R0,#+2
   \   00000108   04D1               BNE.N    ??USBH_MSC_ReadCapacity10_7
    244                {
    245                  /* Failure Mode */
    246                  USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
   \   0000010A   ........           LDR.W    R0,??DataTable5
   \   0000010E   0121               MOVS     R1,#+1
   \   00000110   C170               STRB     R1,[R0, #+3]
    247                  status = USBH_MSC_PHASE_ERROR;    
   \   00000112   0224               MOVS     R4,#+2
    248                } 
    249                else
    250                {
    251                  /* Wait for the Commands to get Completed */
    252                  /* NO Change in state Machine */
    253                }
    254                break;
   \                     ??USBH_MSC_ReadCapacity10_7:
   \   00000114   FFE7               B.N      ??USBH_MSC_ReadCapacity10_0
    255                
    256              default:
    257                break;
    258              }
    259            }
    260            return status;
   \                     ??USBH_MSC_ReadCapacity10_3:
   \                     ??USBH_MSC_ReadCapacity10_0:
   \   00000116   2000               MOVS     R0,R4
   \   00000118   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011A   10BD               POP      {R4,PC}          ;; return
    261          }
    262          
    263          
    264          /**
    265            * @brief  USBH_MSC_ModeSense6  
    266            *         Issue the Mode Sense6 Command to the device. This function is used 
    267            *          for reading the WriteProtect Status of the Mass-Storage device. 
    268            * @param  None
    269            * @retval Status
    270            */

   \                                 In section .text, align 2, keep-with-next
    271          uint8_t USBH_MSC_ModeSense6(USB_OTG_CORE_HANDLE *pdev)
    272          {
   \                     USBH_MSC_ModeSense6:
   \   00000000   10B5               PUSH     {R4,LR}
    273            uint8_t index;
    274            USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
   \   00000002   0324               MOVS     R4,#+3
    275            
    276            if(HCD_IsDeviceConnected(pdev))
   \   00000004   ........           BL       HCD_IsDeviceConnected
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   72D0               BEQ.N    ??USBH_MSC_ModeSense6_0
    277            {  
    278              switch(USBH_MSC_BOTXferParam.CmdStateMachine)
   \   0000000C   ........           LDR.W    R0,??DataTable5
   \   00000010   C078               LDRB     R0,[R0, #+3]
   \   00000012   0128               CMP      R0,#+1
   \   00000014   02D0               BEQ.N    ??USBH_MSC_ModeSense6_1
   \   00000016   0228               CMP      R0,#+2
   \   00000018   3FD0               BEQ.N    ??USBH_MSC_ModeSense6_2
   \   0000001A   6AE0               B.N      ??USBH_MSC_ModeSense6_3
    279              {
    280              case CMD_SEND_STATE:
    281                /*Prepare the CBW and relevent field*/
    282                USBH_MSC_CBWData.field.CBWTransferLength = XFER_LEN_MODE_SENSE6;
   \                     ??USBH_MSC_ModeSense6_1:
   \   0000001C   ........           LDR.W    R0,??DataTable5_1
   \   00000020   3F21               MOVS     R1,#+63
   \   00000022   8160               STR      R1,[R0, #+8]
    283                USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_IN;
   \   00000024   ........           LDR.W    R0,??DataTable5_1
   \   00000028   8021               MOVS     R1,#+128
   \   0000002A   0173               STRB     R1,[R0, #+12]
    284                USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
   \   0000002C   ........           LDR.W    R0,??DataTable5_1
   \   00000030   0A21               MOVS     R1,#+10
   \   00000032   8173               STRB     R1,[R0, #+14]
    285                
    286                USBH_MSC_BOTXferParam.pRxTxBuff = USBH_DataInBuffer;
   \   00000034   ........           LDR.W    R0,??DataTable5
   \   00000038   ........           LDR.W    R1,??DataTable5_3
   \   0000003C   8160               STR      R1,[R0, #+8]
    287                USBH_MSC_BOTXferParam.MSCStateCurrent = USBH_MSC_MODE_SENSE6;
   \   0000003E   ........           LDR.W    R0,??DataTable5
   \   00000042   0521               MOVS     R1,#+5
   \   00000044   8170               STRB     R1,[R0, #+2]
    288                
    289                for(index = CBW_CB_LENGTH; index != 0; index--)
   \   00000046   1020               MOVS     R0,#+16
   \   00000048   06E0               B.N      ??USBH_MSC_ModeSense6_4
    290                {
    291                  USBH_MSC_CBWData.field.CBWCB[index] = 0x00;
   \                     ??USBH_MSC_ModeSense6_5:
   \   0000004A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   ........           LDR.W    R1,??DataTable5_1
   \   00000050   4118               ADDS     R1,R0,R1
   \   00000052   0022               MOVS     R2,#+0
   \   00000054   CA73               STRB     R2,[R1, #+15]
    292                }    
   \   00000056   401E               SUBS     R0,R0,#+1
   \                     ??USBH_MSC_ModeSense6_4:
   \   00000058   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0028               CMP      R0,#+0
   \   0000005C   F5D1               BNE.N    ??USBH_MSC_ModeSense6_5
    293                
    294                USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_MODE_SENSE6; 
   \   0000005E   ........           LDR.W    R0,??DataTable5_1
   \   00000062   1A21               MOVS     R1,#+26
   \   00000064   C173               STRB     R1,[R0, #+15]
    295                USBH_MSC_CBWData.field.CBWCB[2]  = MODE_SENSE_PAGE_CONTROL_FIELD | \
    296                                                   MODE_SENSE_PAGE_CODE;
   \   00000066   ........           LDR.W    R0,??DataTable5_1
   \   0000006A   3F21               MOVS     R1,#+63
   \   0000006C   4174               STRB     R1,[R0, #+17]
    297                                                     
    298                USBH_MSC_CBWData.field.CBWCB[4]  = XFER_LEN_MODE_SENSE6;
   \   0000006E   ........           LDR.W    R0,??DataTable5_1
   \   00000072   3F21               MOVS     R1,#+63
   \   00000074   C174               STRB     R1,[R0, #+19]
    299                                                                                                
    300                USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SEND_CBW;
   \   00000076   ........           LDR.W    R0,??DataTable5
   \   0000007A   0121               MOVS     R1,#+1
   \   0000007C   0171               STRB     R1,[R0, #+4]
    301                
    302                /* Start the transfer, then let the state machine manage the other 
    303                                                                          transactions */
    304                USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
   \   0000007E   ........           LDR.W    R0,??DataTable5
   \   00000082   0721               MOVS     R1,#+7
   \   00000084   0170               STRB     R1,[R0, #+0]
    305                USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
   \   00000086   ........           LDR.W    R0,??DataTable5
   \   0000008A   0321               MOVS     R1,#+3
   \   0000008C   C173               STRB     R1,[R0, #+15]
    306                USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
   \   0000008E   ........           LDR.W    R0,??DataTable5
   \   00000092   0221               MOVS     R1,#+2
   \   00000094   C170               STRB     R1,[R0, #+3]
    307                
    308                status = USBH_MSC_BUSY;
   \   00000096   0324               MOVS     R4,#+3
    309                break;
   \   00000098   2BE0               B.N      ??USBH_MSC_ModeSense6_0
    310                
    311              case CMD_WAIT_STATUS:
    312                if(USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_OK)
   \                     ??USBH_MSC_ModeSense6_2:
   \   0000009A   ........           LDR.W    R0,??DataTable5
   \   0000009E   C07B               LDRB     R0,[R0, #+15]
   \   000000A0   0028               CMP      R0,#+0
   \   000000A2   13D1               BNE.N    ??USBH_MSC_ModeSense6_6
    313                {
    314                  /* Assign the Write Protect status */
    315                  /* If WriteProtect = 0, Writing is allowed 
    316                     If WriteProtect != 0, Disk is Write Protected */
    317                  if ( USBH_DataInBuffer[2] & MASK_MODE_SENSE_WRITE_PROTECT)
   \   000000A4   ........           LDR.W    R0,??DataTable5_3
   \   000000A8   8078               LDRB     R0,[R0, #+2]
   \   000000AA   0006               LSLS     R0,R0,#+24
   \   000000AC   04D5               BPL.N    ??USBH_MSC_ModeSense6_7
    318                  {
    319                    USBH_MSC_Param.MSWriteProtect   = DISK_WRITE_PROTECTED;
   \   000000AE   ........           LDR.W    R0,??DataTable5_4
   \   000000B2   0121               MOVS     R1,#+1
   \   000000B4   0173               STRB     R1,[R0, #+12]
   \   000000B6   03E0               B.N      ??USBH_MSC_ModeSense6_8
    320                  }
    321                  else
    322                  {
    323                    USBH_MSC_Param.MSWriteProtect   = 0;
   \                     ??USBH_MSC_ModeSense6_7:
   \   000000B8   ........           LDR.W    R0,??DataTable5_4
   \   000000BC   0021               MOVS     R1,#+0
   \   000000BE   0173               STRB     R1,[R0, #+12]
    324                  }
    325                  
    326                  /* Commands successfully sent and Response Received  */       
    327                  USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
   \                     ??USBH_MSC_ModeSense6_8:
   \   000000C0   ........           LDR.W    R0,??DataTable5
   \   000000C4   0121               MOVS     R1,#+1
   \   000000C6   C170               STRB     R1,[R0, #+3]
    328                  status = USBH_MSC_OK;      
   \   000000C8   0024               MOVS     R4,#+0
   \   000000CA   11E0               B.N      ??USBH_MSC_ModeSense6_9
    329                }
    330                else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_FAIL )
   \                     ??USBH_MSC_ModeSense6_6:
   \   000000CC   ........           LDR.W    R0,??DataTable5
   \   000000D0   C07B               LDRB     R0,[R0, #+15]
   \   000000D2   0128               CMP      R0,#+1
   \   000000D4   04D1               BNE.N    ??USBH_MSC_ModeSense6_10
    331                {
    332                  /* Failure Mode */
    333                  USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
   \   000000D6   ....               LDR.N    R0,??DataTable5
   \   000000D8   0121               MOVS     R1,#+1
   \   000000DA   C170               STRB     R1,[R0, #+3]
    334                  status = USBH_MSC_FAIL;
   \   000000DC   0124               MOVS     R4,#+1
   \   000000DE   07E0               B.N      ??USBH_MSC_ModeSense6_9
    335                }
    336                else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_PHASE_ERROR )
   \                     ??USBH_MSC_ModeSense6_10:
   \   000000E0   ....               LDR.N    R0,??DataTable5
   \   000000E2   C07B               LDRB     R0,[R0, #+15]
   \   000000E4   0228               CMP      R0,#+2
   \   000000E6   03D1               BNE.N    ??USBH_MSC_ModeSense6_9
    337                {
    338                  /* Failure Mode */
    339                  USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
   \   000000E8   ....               LDR.N    R0,??DataTable5
   \   000000EA   0121               MOVS     R1,#+1
   \   000000EC   C170               STRB     R1,[R0, #+3]
    340                  status = USBH_MSC_PHASE_ERROR;    
   \   000000EE   0224               MOVS     R4,#+2
    341                }
    342                else
    343                {
    344                  /* Wait for the Commands to get Completed */
    345                  /* NO Change in state Machine */
    346                }
    347                break;
   \                     ??USBH_MSC_ModeSense6_9:
   \   000000F0   FFE7               B.N      ??USBH_MSC_ModeSense6_0
    348                
    349              default:
    350                break;
    351              }
    352            }
    353            return status;
   \                     ??USBH_MSC_ModeSense6_3:
   \                     ??USBH_MSC_ModeSense6_0:
   \   000000F2   2000               MOVS     R0,R4
   \   000000F4   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F6   10BD               POP      {R4,PC}          ;; return
    354          }
    355          
    356          /**
    357            * @brief  USBH_MSC_RequestSense  
    358            *         Issues the Request Sense command to the device. Once the response 
    359            *         received, it updates the status to upper layer
    360            * @param  None
    361            * @retval Status
    362            */

   \                                 In section .text, align 2, keep-with-next
    363          uint8_t USBH_MSC_RequestSense(USB_OTG_CORE_HANDLE *pdev)
    364          {
   \                     USBH_MSC_RequestSense:
   \   00000000   10B5               PUSH     {R4,LR}
    365            USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
   \   00000002   0324               MOVS     R4,#+3
    366            
    367            uint8_t index;
    368            
    369            
    370            if(HCD_IsDeviceConnected(pdev))
   \   00000004   ........           BL       HCD_IsDeviceConnected
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   66D0               BEQ.N    ??USBH_MSC_RequestSense_0
    371            {  
    372              switch(USBH_MSC_BOTXferParam.CmdStateMachine)
   \   0000000C   ....               LDR.N    R0,??DataTable5
   \   0000000E   C078               LDRB     R0,[R0, #+3]
   \   00000010   0128               CMP      R0,#+1
   \   00000012   02D0               BEQ.N    ??USBH_MSC_RequestSense_1
   \   00000014   0228               CMP      R0,#+2
   \   00000016   35D0               BEQ.N    ??USBH_MSC_RequestSense_2
   \   00000018   5FE0               B.N      ??USBH_MSC_RequestSense_3
    373              {
    374              case CMD_SEND_STATE:
    375                
    376                /*Prepare the CBW and relevent field*/
    377                USBH_MSC_CBWData.field.CBWTransferLength = \
    378                                                          ALLOCATION_LENGTH_REQUEST_SENSE;
   \                     ??USBH_MSC_RequestSense_1:
   \   0000001A   ....               LDR.N    R0,??DataTable5_1
   \   0000001C   3F21               MOVS     R1,#+63
   \   0000001E   8160               STR      R1,[R0, #+8]
    379                USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_IN;
   \   00000020   ....               LDR.N    R0,??DataTable5_1
   \   00000022   8021               MOVS     R1,#+128
   \   00000024   0173               STRB     R1,[R0, #+12]
    380                USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
   \   00000026   ....               LDR.N    R0,??DataTable5_1
   \   00000028   0A21               MOVS     R1,#+10
   \   0000002A   8173               STRB     R1,[R0, #+14]
    381                
    382                USBH_MSC_BOTXferParam.pRxTxBuff = USBH_DataInBuffer;
   \   0000002C   ....               LDR.N    R0,??DataTable5
   \   0000002E   ....               LDR.N    R1,??DataTable5_3
   \   00000030   8160               STR      R1,[R0, #+8]
    383                USBH_MSC_BOTXferParam.MSCStateBkp = USBH_MSC_BOTXferParam.MSCStateCurrent;
   \   00000032   ....               LDR.N    R0,??DataTable5
   \   00000034   ....               LDR.N    R1,??DataTable5
   \   00000036   8978               LDRB     R1,[R1, #+2]
   \   00000038   4170               STRB     R1,[R0, #+1]
    384                USBH_MSC_BOTXferParam.MSCStateCurrent = USBH_MSC_REQUEST_SENSE;
   \   0000003A   ....               LDR.N    R0,??DataTable5
   \   0000003C   0621               MOVS     R1,#+6
   \   0000003E   8170               STRB     R1,[R0, #+2]
    385                
    386          
    387                for(index = CBW_CB_LENGTH; index != 0; index--)
   \   00000040   1020               MOVS     R0,#+16
   \   00000042   05E0               B.N      ??USBH_MSC_RequestSense_4
    388                {
    389                  USBH_MSC_CBWData.field.CBWCB[index] = 0x00;
   \                     ??USBH_MSC_RequestSense_5:
   \   00000044   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   ....               LDR.N    R1,??DataTable5_1
   \   00000048   4118               ADDS     R1,R0,R1
   \   0000004A   0022               MOVS     R2,#+0
   \   0000004C   CA73               STRB     R2,[R1, #+15]
    390                }    
   \   0000004E   401E               SUBS     R0,R0,#+1
   \                     ??USBH_MSC_RequestSense_4:
   \   00000050   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0028               CMP      R0,#+0
   \   00000054   F6D1               BNE.N    ??USBH_MSC_RequestSense_5
    391                
    392                USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_REQUEST_SENSE; 
   \   00000056   ....               LDR.N    R0,??DataTable5_1
   \   00000058   0321               MOVS     R1,#+3
   \   0000005A   C173               STRB     R1,[R0, #+15]
    393                USBH_MSC_CBWData.field.CBWCB[1]  = DESC_REQUEST_SENSE;
   \   0000005C   ....               LDR.N    R0,??DataTable5_1
   \   0000005E   0021               MOVS     R1,#+0
   \   00000060   0174               STRB     R1,[R0, #+16]
    394                USBH_MSC_CBWData.field.CBWCB[4]  = ALLOCATION_LENGTH_REQUEST_SENSE;
   \   00000062   ....               LDR.N    R0,??DataTable5_1
   \   00000064   3F21               MOVS     R1,#+63
   \   00000066   C174               STRB     R1,[R0, #+19]
    395                
    396                USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SEND_CBW;
   \   00000068   ....               LDR.N    R0,??DataTable5
   \   0000006A   0121               MOVS     R1,#+1
   \   0000006C   0171               STRB     R1,[R0, #+4]
    397                /* Start the transfer, then let the state machine magage 
    398                the other transactions */
    399                USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
   \   0000006E   ....               LDR.N    R0,??DataTable5
   \   00000070   0721               MOVS     R1,#+7
   \   00000072   0170               STRB     R1,[R0, #+0]
    400                USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
   \   00000074   ....               LDR.N    R0,??DataTable5
   \   00000076   0321               MOVS     R1,#+3
   \   00000078   C173               STRB     R1,[R0, #+15]
    401                USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
   \   0000007A   ....               LDR.N    R0,??DataTable5
   \   0000007C   0221               MOVS     R1,#+2
   \   0000007E   C170               STRB     R1,[R0, #+3]
    402                
    403                status = USBH_MSC_BUSY;
   \   00000080   0324               MOVS     R4,#+3
    404                
    405                break;
   \   00000082   2AE0               B.N      ??USBH_MSC_RequestSense_0
    406                
    407              case CMD_WAIT_STATUS:
    408                
    409                if(USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_OK)
   \                     ??USBH_MSC_RequestSense_2:
   \   00000084   ....               LDR.N    R0,??DataTable5
   \   00000086   C07B               LDRB     R0,[R0, #+15]
   \   00000088   0028               CMP      R0,#+0
   \   0000008A   14D1               BNE.N    ??USBH_MSC_RequestSense_6
    410                {
    411                  /* Get Sense data*/
    412                  (((uint8_t*)&USBH_MSC_Param.MSSenseKey )[3]) = USBH_DataInBuffer[0];
   \   0000008C   ....               LDR.N    R0,??DataTable5_4
   \   0000008E   ....               LDR.N    R1,??DataTable5_3
   \   00000090   0978               LDRB     R1,[R1, #+0]
   \   00000092   C171               STRB     R1,[R0, #+7]
    413                  (((uint8_t*)&USBH_MSC_Param.MSSenseKey )[2]) = USBH_DataInBuffer[1];
   \   00000094   ....               LDR.N    R0,??DataTable5_4
   \   00000096   ....               LDR.N    R1,??DataTable5_3
   \   00000098   4978               LDRB     R1,[R1, #+1]
   \   0000009A   8171               STRB     R1,[R0, #+6]
    414                  (((uint8_t*)&USBH_MSC_Param.MSSenseKey )[1]) = USBH_DataInBuffer[2];
   \   0000009C   ....               LDR.N    R0,??DataTable5_4
   \   0000009E   ....               LDR.N    R1,??DataTable5_3
   \   000000A0   8978               LDRB     R1,[R1, #+2]
   \   000000A2   4171               STRB     R1,[R0, #+5]
    415                  (((uint8_t*)&USBH_MSC_Param.MSSenseKey )[0]) = USBH_DataInBuffer[3];
   \   000000A4   ....               LDR.N    R0,??DataTable5_4
   \   000000A6   ....               LDR.N    R1,??DataTable5_3
   \   000000A8   C978               LDRB     R1,[R1, #+3]
   \   000000AA   0171               STRB     R1,[R0, #+4]
    416                  
    417                  /* Commands successfully sent and Response Received  */       
    418                  USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
   \   000000AC   ....               LDR.N    R0,??DataTable5
   \   000000AE   0121               MOVS     R1,#+1
   \   000000B0   C170               STRB     R1,[R0, #+3]
    419                  status = USBH_MSC_OK;      
   \   000000B2   0024               MOVS     R4,#+0
   \   000000B4   10E0               B.N      ??USBH_MSC_RequestSense_7
    420                }
    421                else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_FAIL )
   \                     ??USBH_MSC_RequestSense_6:
   \   000000B6   ....               LDR.N    R0,??DataTable5
   \   000000B8   C07B               LDRB     R0,[R0, #+15]
   \   000000BA   0128               CMP      R0,#+1
   \   000000BC   04D1               BNE.N    ??USBH_MSC_RequestSense_8
    422                {
    423                  /* Failure Mode */
    424                  USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
   \   000000BE   ....               LDR.N    R0,??DataTable5
   \   000000C0   0121               MOVS     R1,#+1
   \   000000C2   C170               STRB     R1,[R0, #+3]
    425                  status = USBH_MSC_FAIL;
   \   000000C4   0124               MOVS     R4,#+1
   \   000000C6   07E0               B.N      ??USBH_MSC_RequestSense_7
    426                }
    427                
    428                else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_PHASE_ERROR )
   \                     ??USBH_MSC_RequestSense_8:
   \   000000C8   ....               LDR.N    R0,??DataTable5
   \   000000CA   C07B               LDRB     R0,[R0, #+15]
   \   000000CC   0228               CMP      R0,#+2
   \   000000CE   03D1               BNE.N    ??USBH_MSC_RequestSense_7
    429                {
    430                  /* Failure Mode */
    431                  USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
   \   000000D0   ....               LDR.N    R0,??DataTable5
   \   000000D2   0121               MOVS     R1,#+1
   \   000000D4   C170               STRB     R1,[R0, #+3]
    432                  status = USBH_MSC_PHASE_ERROR;    
   \   000000D6   0224               MOVS     R4,#+2
    433                }
    434                
    435                else
    436                {
    437                  /* Wait for the Commands to get Completed */
    438                  /* NO Change in state Machine */
    439                }
    440                break;
   \                     ??USBH_MSC_RequestSense_7:
   \   000000D8   FFE7               B.N      ??USBH_MSC_RequestSense_0
    441                
    442              default:
    443                break;
    444              }
    445            }
    446            return status;
   \                     ??USBH_MSC_RequestSense_3:
   \                     ??USBH_MSC_RequestSense_0:
   \   000000DA   2000               MOVS     R0,R4
   \   000000DC   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DE   10BD               POP      {R4,PC}          ;; return
    447          }
    448          
    449          
    450          /**
    451            * @brief  USBH_MSC_Write10 
    452            *         Issue the write command to the device. Once the response received, 
    453            *         it updates the status to upper layer
    454            * @param  dataBuffer : DataBuffer contains the data to write
    455            * @param  address : Address to which the data will be written
    456            * @param  nbOfbytes : NbOfbytes to be written
    457            * @retval Status
    458            */

   \                                 In section .text, align 2, keep-with-next
    459          uint8_t USBH_MSC_Write10(USB_OTG_CORE_HANDLE *pdev, 
    460                                   uint8_t *dataBuffer,
    461                                   uint32_t address,
    462                                   uint32_t nbOfbytes)
    463          {
   \                     USBH_MSC_Write10:
   \   00000000   76B5               PUSH     {R1,R2,R4-R6,LR}
   \   00000002   0D00               MOVS     R5,R1
   \   00000004   1C00               MOVS     R4,R3
    464            uint8_t index;
    465            USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
   \   00000006   0326               MOVS     R6,#+3
    466            uint16_t nbOfPages;
    467            
    468            if(HCD_IsDeviceConnected(pdev))
   \   00000008   ........           BL       HCD_IsDeviceConnected
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   61D0               BEQ.N    ??USBH_MSC_Write10_0
    469            {  
    470              switch(USBH_MSC_BOTXferParam.CmdStateMachine)
   \   00000010   ....               LDR.N    R0,??DataTable5
   \   00000012   C078               LDRB     R0,[R0, #+3]
   \   00000014   0128               CMP      R0,#+1
   \   00000016   02D0               BEQ.N    ??USBH_MSC_Write10_1
   \   00000018   0228               CMP      R0,#+2
   \   0000001A   41D0               BEQ.N    ??USBH_MSC_Write10_2
   \   0000001C   5AE0               B.N      ??USBH_MSC_Write10_3
    471              {
    472              case CMD_SEND_STATE:   
    473                USBH_MSC_CBWData.field.CBWTransferLength = nbOfbytes;
   \                     ??USBH_MSC_Write10_1:
   \   0000001E   ....               LDR.N    R0,??DataTable5_1
   \   00000020   8460               STR      R4,[R0, #+8]
    474                USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_OUT;
   \   00000022   ....               LDR.N    R0,??DataTable5_1
   \   00000024   0021               MOVS     R1,#+0
   \   00000026   0173               STRB     R1,[R0, #+12]
    475                USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
   \   00000028   ....               LDR.N    R0,??DataTable5_1
   \   0000002A   0A21               MOVS     R1,#+10
   \   0000002C   8173               STRB     R1,[R0, #+14]
    476                USBH_MSC_BOTXferParam.pRxTxBuff = dataBuffer;
   \   0000002E   ....               LDR.N    R0,??DataTable5
   \   00000030   8560               STR      R5,[R0, #+8]
    477                
    478                
    479                for(index = CBW_CB_LENGTH; index != 0; index--)  
   \   00000032   1020               MOVS     R0,#+16
   \   00000034   05E0               B.N      ??USBH_MSC_Write10_4
    480                {
    481                  USBH_MSC_CBWData.field.CBWCB[index] = 0x00;
   \                     ??USBH_MSC_Write10_5:
   \   00000036   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   ....               LDR.N    R1,??DataTable5_1
   \   0000003A   4118               ADDS     R1,R0,R1
   \   0000003C   0022               MOVS     R2,#+0
   \   0000003E   CA73               STRB     R2,[R1, #+15]
    482                }
   \   00000040   401E               SUBS     R0,R0,#+1
   \                     ??USBH_MSC_Write10_4:
   \   00000042   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0028               CMP      R0,#+0
   \   00000046   F6D1               BNE.N    ??USBH_MSC_Write10_5
    483                
    484                USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_WRITE10; 
   \   00000048   ....               LDR.N    R0,??DataTable5_1
   \   0000004A   2A21               MOVS     R1,#+42
   \   0000004C   C173               STRB     R1,[R0, #+15]
    485                
    486                /*logical block address*/
    487                USBH_MSC_CBWData.field.CBWCB[2]  = (((uint8_t*)&address)[3]) ;
   \   0000004E   ....               LDR.N    R0,??DataTable5_1
   \   00000050   9DF80710           LDRB     R1,[SP, #+7]
   \   00000054   4174               STRB     R1,[R0, #+17]
    488                USBH_MSC_CBWData.field.CBWCB[3]  = (((uint8_t*)&address)[2]);
   \   00000056   ....               LDR.N    R0,??DataTable5_1
   \   00000058   9DF80610           LDRB     R1,[SP, #+6]
   \   0000005C   8174               STRB     R1,[R0, #+18]
    489                USBH_MSC_CBWData.field.CBWCB[4]  = (((uint8_t*)&address)[1]);
   \   0000005E   ....               LDR.N    R0,??DataTable5_1
   \   00000060   9DF80510           LDRB     R1,[SP, #+5]
   \   00000064   C174               STRB     R1,[R0, #+19]
    490                USBH_MSC_CBWData.field.CBWCB[5]  = (((uint8_t*)&address)[0]);
   \   00000066   ....               LDR.N    R0,??DataTable5_1
   \   00000068   9DF80410           LDRB     R1,[SP, #+4]
   \   0000006C   0175               STRB     R1,[R0, #+20]
    491                
    492                /*USBH_MSC_PAGE_LENGTH = 512*/
    493                nbOfPages = nbOfbytes/ USBH_MSC_PAGE_LENGTH; 
   \   0000006E   600A               LSRS     R0,R4,#+9
   \   00000070   ADF80000           STRH     R0,[SP, #+0]
    494                
    495                /*Tranfer length */
    496                USBH_MSC_CBWData.field.CBWCB[7]  = (((uint8_t *)&nbOfPages)[1]) ; 
   \   00000074   ....               LDR.N    R0,??DataTable5_1
   \   00000076   9DF80110           LDRB     R1,[SP, #+1]
   \   0000007A   8175               STRB     R1,[R0, #+22]
    497                USBH_MSC_CBWData.field.CBWCB[8]  = (((uint8_t *)&nbOfPages)[0]) ; 
   \   0000007C   ....               LDR.N    R0,??DataTable5_1
   \   0000007E   9DF80010           LDRB     R1,[SP, #+0]
   \   00000082   C175               STRB     R1,[R0, #+23]
    498                
    499                USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SEND_CBW;
   \   00000084   ....               LDR.N    R0,??DataTable5
   \   00000086   0121               MOVS     R1,#+1
   \   00000088   0171               STRB     R1,[R0, #+4]
    500                /* Start the transfer, then let the state machine 
    501                magage the other transactions */
    502                USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
   \   0000008A   ....               LDR.N    R0,??DataTable5
   \   0000008C   0721               MOVS     R1,#+7
   \   0000008E   0170               STRB     R1,[R0, #+0]
    503                USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
   \   00000090   ....               LDR.N    R0,??DataTable5
   \   00000092   0321               MOVS     R1,#+3
   \   00000094   C173               STRB     R1,[R0, #+15]
    504                USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
   \   00000096   ....               LDR.N    R0,??DataTable5
   \   00000098   0221               MOVS     R1,#+2
   \   0000009A   C170               STRB     R1,[R0, #+3]
    505                
    506                status = USBH_MSC_BUSY;
   \   0000009C   0326               MOVS     R6,#+3
    507                
    508                break;
   \   0000009E   19E0               B.N      ??USBH_MSC_Write10_0
    509                
    510              case CMD_WAIT_STATUS:
    511                if(USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_OK)
   \                     ??USBH_MSC_Write10_2:
   \   000000A0   ....               LDR.N    R0,??DataTable5
   \   000000A2   C07B               LDRB     R0,[R0, #+15]
   \   000000A4   0028               CMP      R0,#+0
   \   000000A6   04D1               BNE.N    ??USBH_MSC_Write10_6
    512                { 
    513                  /* Commands successfully sent and Response Received  */       
    514                  USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
   \   000000A8   ....               LDR.N    R0,??DataTable5
   \   000000AA   0121               MOVS     R1,#+1
   \   000000AC   C170               STRB     R1,[R0, #+3]
    515                  status = USBH_MSC_OK;      
   \   000000AE   0026               MOVS     R6,#+0
   \   000000B0   0FE0               B.N      ??USBH_MSC_Write10_7
    516                }
    517                else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_FAIL )
   \                     ??USBH_MSC_Write10_6:
   \   000000B2   ....               LDR.N    R0,??DataTable5
   \   000000B4   C07B               LDRB     R0,[R0, #+15]
   \   000000B6   0128               CMP      R0,#+1
   \   000000B8   03D1               BNE.N    ??USBH_MSC_Write10_8
    518                {
    519                  /* Failure Mode */
    520                  USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
   \   000000BA   ....               LDR.N    R0,??DataTable5
   \   000000BC   0121               MOVS     R1,#+1
   \   000000BE   C170               STRB     R1,[R0, #+3]
   \   000000C0   07E0               B.N      ??USBH_MSC_Write10_7
    521                }
    522                
    523                else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_PHASE_ERROR )
   \                     ??USBH_MSC_Write10_8:
   \   000000C2   ....               LDR.N    R0,??DataTable5
   \   000000C4   C07B               LDRB     R0,[R0, #+15]
   \   000000C6   0228               CMP      R0,#+2
   \   000000C8   03D1               BNE.N    ??USBH_MSC_Write10_7
    524                {
    525                  /* Failure Mode */
    526                  USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
   \   000000CA   ....               LDR.N    R0,??DataTable5
   \   000000CC   0121               MOVS     R1,#+1
   \   000000CE   C170               STRB     R1,[R0, #+3]
    527                  status = USBH_MSC_PHASE_ERROR;    
   \   000000D0   0226               MOVS     R6,#+2
    528                }
    529                break;
   \                     ??USBH_MSC_Write10_7:
   \   000000D2   FFE7               B.N      ??USBH_MSC_Write10_0
    530                
    531              default:
    532                break;
    533              }
    534            }
    535            return status;
   \                     ??USBH_MSC_Write10_3:
   \                     ??USBH_MSC_Write10_0:
   \   000000D4   3000               MOVS     R0,R6
   \   000000D6   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D8   76BD               POP      {R1,R2,R4-R6,PC}  ;; return
    536          }
    537          
    538          /**
    539            * @brief  USBH_MSC_Read10 
    540            *         Issue the read command to the device. Once the response received, 
    541            *         it updates the status to upper layer
    542            * @param  dataBuffer : DataBuffer will contain the data to be read
    543            * @param  address : Address from which the data will be read
    544            * @param  nbOfbytes : NbOfbytes to be read
    545            * @retval Status
    546            */

   \                                 In section .text, align 2, keep-with-next
    547          uint8_t USBH_MSC_Read10(USB_OTG_CORE_HANDLE *pdev,
    548                                  uint8_t *dataBuffer,
    549                                  uint32_t address,
    550                                  uint32_t nbOfbytes)
    551          {
   \                     USBH_MSC_Read10:
   \   00000000   76B5               PUSH     {R1,R2,R4-R6,LR}
   \   00000002   0600               MOVS     R6,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1C00               MOVS     R4,R3
    552            uint8_t index;
    553            static USBH_MSC_Status_TypeDef status = USBH_MSC_BUSY;
    554            uint16_t nbOfPages;
    555            status = USBH_MSC_BUSY;
   \   00000008   ....               LDR.N    R0,??DataTable5_5
   \   0000000A   0321               MOVS     R1,#+3
   \   0000000C   0170               STRB     R1,[R0, #+0]
    556            
    557            if(HCD_IsDeviceConnected(pdev))
   \   0000000E   3000               MOVS     R0,R6
   \   00000010   ........           BL       HCD_IsDeviceConnected
   \   00000014   0028               CMP      R0,#+0
   \   00000016   71D0               BEQ.N    ??USBH_MSC_Read10_0
    558            {
    559              switch(USBH_MSC_BOTXferParam.CmdStateMachine)
   \   00000018   ....               LDR.N    R0,??DataTable5
   \   0000001A   C078               LDRB     R0,[R0, #+3]
   \   0000001C   0128               CMP      R0,#+1
   \   0000001E   02D0               BEQ.N    ??USBH_MSC_Read10_1
   \   00000020   0228               CMP      R0,#+2
   \   00000022   43D0               BEQ.N    ??USBH_MSC_Read10_2
   \   00000024   6AE0               B.N      ??USBH_MSC_Read10_3
    560              {
    561              case CMD_SEND_STATE:
    562                /*Prepare the CBW and relevent field*/
    563                USBH_MSC_CBWData.field.CBWTransferLength = nbOfbytes;
   \                     ??USBH_MSC_Read10_1:
   \   00000026   ....               LDR.N    R0,??DataTable5_1
   \   00000028   8460               STR      R4,[R0, #+8]
    564                USBH_MSC_CBWData.field.CBWFlags = USB_EP_DIR_IN;
   \   0000002A   ....               LDR.N    R0,??DataTable5_1
   \   0000002C   8021               MOVS     R1,#+128
   \   0000002E   0173               STRB     R1,[R0, #+12]
    565                USBH_MSC_CBWData.field.CBWLength = CBW_LENGTH;
   \   00000030   ....               LDR.N    R0,??DataTable5_1
   \   00000032   0A21               MOVS     R1,#+10
   \   00000034   8173               STRB     R1,[R0, #+14]
    566                
    567                USBH_MSC_BOTXferParam.pRxTxBuff = dataBuffer;
   \   00000036   ....               LDR.N    R0,??DataTable5
   \   00000038   8560               STR      R5,[R0, #+8]
    568                
    569                for(index = CBW_CB_LENGTH; index != 0; index--)
   \   0000003A   1020               MOVS     R0,#+16
   \   0000003C   05E0               B.N      ??USBH_MSC_Read10_4
    570                {
    571                  USBH_MSC_CBWData.field.CBWCB[index] = 0x00;
   \                     ??USBH_MSC_Read10_5:
   \   0000003E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   ....               LDR.N    R1,??DataTable5_1
   \   00000042   4118               ADDS     R1,R0,R1
   \   00000044   0022               MOVS     R2,#+0
   \   00000046   CA73               STRB     R2,[R1, #+15]
    572                }
   \   00000048   401E               SUBS     R0,R0,#+1
   \                     ??USBH_MSC_Read10_4:
   \   0000004A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0028               CMP      R0,#+0
   \   0000004E   F6D1               BNE.N    ??USBH_MSC_Read10_5
    573                
    574                USBH_MSC_CBWData.field.CBWCB[0]  = OPCODE_READ10; 
   \   00000050   ....               LDR.N    R0,??DataTable5_1
   \   00000052   2821               MOVS     R1,#+40
   \   00000054   C173               STRB     R1,[R0, #+15]
    575                
    576                /*logical block address*/
    577                
    578                USBH_MSC_CBWData.field.CBWCB[2]  = (((uint8_t*)&address)[3]);
   \   00000056   ....               LDR.N    R0,??DataTable5_1
   \   00000058   9DF80710           LDRB     R1,[SP, #+7]
   \   0000005C   4174               STRB     R1,[R0, #+17]
    579                USBH_MSC_CBWData.field.CBWCB[3]  = (((uint8_t*)&address)[2]);
   \   0000005E   ....               LDR.N    R0,??DataTable5_1
   \   00000060   9DF80610           LDRB     R1,[SP, #+6]
   \   00000064   8174               STRB     R1,[R0, #+18]
    580                USBH_MSC_CBWData.field.CBWCB[4]  = (((uint8_t*)&address)[1]);
   \   00000066   ....               LDR.N    R0,??DataTable5_1
   \   00000068   9DF80510           LDRB     R1,[SP, #+5]
   \   0000006C   C174               STRB     R1,[R0, #+19]
    581                USBH_MSC_CBWData.field.CBWCB[5]  = (((uint8_t*)&address)[0]);
   \   0000006E   ....               LDR.N    R0,??DataTable5_1
   \   00000070   9DF80410           LDRB     R1,[SP, #+4]
   \   00000074   0175               STRB     R1,[R0, #+20]
    582                
    583                /*USBH_MSC_PAGE_LENGTH = 512*/
    584                nbOfPages = nbOfbytes/ USBH_MSC_PAGE_LENGTH;  
   \   00000076   600A               LSRS     R0,R4,#+9
   \   00000078   ADF80000           STRH     R0,[SP, #+0]
    585                
    586                /*Tranfer length */
    587                USBH_MSC_CBWData.field.CBWCB[7]  = (((uint8_t *)&nbOfPages)[1]) ; 
   \   0000007C   ....               LDR.N    R0,??DataTable5_1
   \   0000007E   9DF80110           LDRB     R1,[SP, #+1]
   \   00000082   8175               STRB     R1,[R0, #+22]
    588                USBH_MSC_CBWData.field.CBWCB[8]  = (((uint8_t *)&nbOfPages)[0]) ; 
   \   00000084   ....               LDR.N    R0,??DataTable5_1
   \   00000086   9DF80010           LDRB     R1,[SP, #+0]
   \   0000008A   C175               STRB     R1,[R0, #+23]
    589                
    590                
    591                USBH_MSC_BOTXferParam.BOTState = USBH_MSC_SEND_CBW;
   \   0000008C   ....               LDR.N    R0,??DataTable5
   \   0000008E   0121               MOVS     R1,#+1
   \   00000090   0171               STRB     R1,[R0, #+4]
    592                /* Start the transfer, then let the state machine 
    593                magage the other transactions */
    594                USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_USB_TRANSFERS;
   \   00000092   ....               LDR.N    R0,??DataTable5
   \   00000094   0721               MOVS     R1,#+7
   \   00000096   0170               STRB     R1,[R0, #+0]
    595                USBH_MSC_BOTXferParam.BOTXferStatus = USBH_MSC_BUSY;
   \   00000098   ....               LDR.N    R0,??DataTable5
   \   0000009A   0321               MOVS     R1,#+3
   \   0000009C   C173               STRB     R1,[R0, #+15]
    596                USBH_MSC_BOTXferParam.CmdStateMachine = CMD_WAIT_STATUS;
   \   0000009E   ....               LDR.N    R0,??DataTable5
   \   000000A0   0221               MOVS     R1,#+2
   \   000000A2   C170               STRB     R1,[R0, #+3]
    597                
    598                status = USBH_MSC_BUSY;
   \   000000A4   ....               LDR.N    R0,??DataTable5_5
   \   000000A6   0321               MOVS     R1,#+3
   \   000000A8   0170               STRB     R1,[R0, #+0]
    599                
    600                break;
   \   000000AA   27E0               B.N      ??USBH_MSC_Read10_0
    601                
    602              case CMD_WAIT_STATUS:
    603                
    604                if((USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_OK) && \
    605                  (HCD_IsDeviceConnected(pdev)))
   \                     ??USBH_MSC_Read10_2:
   \   000000AC   ....               LDR.N    R0,??DataTable5
   \   000000AE   C07B               LDRB     R0,[R0, #+15]
   \   000000B0   0028               CMP      R0,#+0
   \   000000B2   0BD1               BNE.N    ??USBH_MSC_Read10_6
   \   000000B4   3000               MOVS     R0,R6
   \   000000B6   ........           BL       HCD_IsDeviceConnected
   \   000000BA   0028               CMP      R0,#+0
   \   000000BC   06D0               BEQ.N    ??USBH_MSC_Read10_6
    606                { 
    607                  /* Commands successfully sent and Response Received  */       
    608                  USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
   \   000000BE   ....               LDR.N    R0,??DataTable5
   \   000000C0   0121               MOVS     R1,#+1
   \   000000C2   C170               STRB     R1,[R0, #+3]
    609                  status = USBH_MSC_OK;      
   \   000000C4   ....               LDR.N    R0,??DataTable5_5
   \   000000C6   0021               MOVS     R1,#+0
   \   000000C8   0170               STRB     R1,[R0, #+0]
   \   000000CA   16E0               B.N      ??USBH_MSC_Read10_7
    610                }
    611                else if (( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_FAIL ) && \
    612                  (HCD_IsDeviceConnected(pdev)))
   \                     ??USBH_MSC_Read10_6:
   \   000000CC   ....               LDR.N    R0,??DataTable5
   \   000000CE   C07B               LDRB     R0,[R0, #+15]
   \   000000D0   0128               CMP      R0,#+1
   \   000000D2   08D1               BNE.N    ??USBH_MSC_Read10_8
   \   000000D4   3000               MOVS     R0,R6
   \   000000D6   ........           BL       HCD_IsDeviceConnected
   \   000000DA   0028               CMP      R0,#+0
   \   000000DC   03D0               BEQ.N    ??USBH_MSC_Read10_8
    613                {
    614                  /* Failure Mode */
    615                  USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
   \   000000DE   ....               LDR.N    R0,??DataTable5
   \   000000E0   0121               MOVS     R1,#+1
   \   000000E2   C170               STRB     R1,[R0, #+3]
   \   000000E4   09E0               B.N      ??USBH_MSC_Read10_7
    616                }
    617                
    618                else if ( USBH_MSC_BOTXferParam.BOTXferStatus == USBH_MSC_PHASE_ERROR )
   \                     ??USBH_MSC_Read10_8:
   \   000000E6   ....               LDR.N    R0,??DataTable5
   \   000000E8   C07B               LDRB     R0,[R0, #+15]
   \   000000EA   0228               CMP      R0,#+2
   \   000000EC   05D1               BNE.N    ??USBH_MSC_Read10_7
    619                {
    620                  /* Failure Mode */
    621                  USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
   \   000000EE   ....               LDR.N    R0,??DataTable5
   \   000000F0   0121               MOVS     R1,#+1
   \   000000F2   C170               STRB     R1,[R0, #+3]
    622                  status = USBH_MSC_PHASE_ERROR;    
   \   000000F4   ....               LDR.N    R0,??DataTable5_5
   \   000000F6   0221               MOVS     R1,#+2
   \   000000F8   0170               STRB     R1,[R0, #+0]
    623                }
    624                else
    625                {
    626                  /* Wait for the Commands to get Completed */
    627                  /* NO Change in state Machine */
    628                }
    629                break;
   \                     ??USBH_MSC_Read10_7:
   \   000000FA   FFE7               B.N      ??USBH_MSC_Read10_0
    630                
    631              default:
    632                break;
    633              }
    634            }
    635            return status;
   \                     ??USBH_MSC_Read10_3:
   \                     ??USBH_MSC_Read10_0:
   \   000000FC   ....               LDR.N    R0,??DataTable5_5
   \   000000FE   0078               LDRB     R0,[R0, #+0]
   \   00000100   76BD               POP      {R1,R2,R4-R6,PC}  ;; return
    636          }

   \                                 In section .data, align 1
   \                     ??status:
   \   00000000   03                 DC8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     USBH_MSC_BOTXferParam

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   ........           DC32     USBH_MSC_CBWData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   ........           DC32     USBH_MSC_CSWData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   ........           DC32     USBH_DataInBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   ........           DC32     USBH_MSC_Param

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   ........           DC32     ??status
    637          
    638          
    639          /**
    640            * @}
    641            */ 
    642          
    643          /**
    644            * @}
    645            */ 
    646          
    647          /**
    648            * @}
    649            */
    650          
    651          /**
    652            * @}
    653            */ 
    654          
    655          /**
    656            * @}
    657            */
    658          
    659          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
    660          
    661          
    662          

   Maximum stack usage in bytes:

     Function                .cstack
     --------                -------
     USBH_MSC_ModeSense6          8
     USBH_MSC_Read10             24
     USBH_MSC_ReadCapacity10      8
     USBH_MSC_RequestSense        8
     USBH_MSC_TestUnitReady       8
     USBH_MSC_Write10            24


   Section sizes:

     Function/Label          Bytes
     --------------          -----
     USBH_MSC_Param            16
     USBH_DataInBuffer        512
     USBH_DataOutBuffer       512
     USBH_MSC_TestUnitReady   218
     USBH_MSC_ReadCapacity10  284
     USBH_MSC_ModeSense6      248
     USBH_MSC_RequestSense    224
     USBH_MSC_Write10         218
     USBH_MSC_Read10          258
     status                     1
     ??DataTable5               4
     ??DataTable5_1             4
     ??DataTable5_2             4
     ??DataTable5_3             4
     ??DataTable5_4             4
     ??DataTable5_5             4

 
 1 040 bytes in section .bss
     1 byte  in section .data
 1 474 bytes in section .text
 
 1 474 bytes of CODE memory
 1 041 bytes of DATA memory

Errors: none
Warnings: none
