###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     16/May/2011  15:08:15 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4 #
#                    \STM32F2xx_StdPeriph_Lib_V0.0.4\Libraries\STM32_USB_OTG_ #
#                    Driver\src\usb_dcd_int.c                                 #
#    Command line =  "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Libraries\STM32_USB_OTG #
#                    _Driver\src\usb_dcd_int.c" -D USE_STDPERIPH_DRIVER -D    #
#                    STM32F2XX -D USE_STM3220F_EVAL -D USE_USB_OTG_FS -D      #
#                    USE_ULPI_PHY -lC "D:\¹¬ÀÛ¾÷\[ NewDTG                     #
#                    ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    STM3220F_EVAL\List\" -lA "D:\¹¬ÀÛ¾÷\[ NewDTG             #
#                    ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    STM3220F_EVAL\List\" -o "D:\¹¬ÀÛ¾÷\[ NewDTG              #
#                    ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    STM3220F_EVAL\Obj\" --no_cse --no_unroll --no_inline     #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "D:\¹¬ÀÛ¾÷\[ NewDTG                              #
#                    ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\" -I "D:\¹¬ÀÛ¾÷\[ NewDTG                              #
#                    ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\..\..\Libraries\CMSIS\CM3\CoreSupport\" -I            #
#                    "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Libraries\CMSIS\CM3\DeviceS #
#                    upport\ST\STM32F2xx\" -I "D:\¹¬ÀÛ¾÷\[ NewDTG             #
#                    ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I   #
#                    "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Utilities\STM32_EVAL\" -I   #
#                    "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Utilities\STM32_EVAL\Common #
#                    \" -I "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib #
#                    _V0.0.4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx #
#                    _StdPeriph_Template\EWARM\..\..\..\Utilities\STM32_EVAL\ #
#                    STM3220F_EVAL\" -I "D:\¹¬ÀÛ¾÷\[ NewDTG                   #
#                    ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I         #
#                    "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Libraries\STM32_USB_Device_ #
#                    Library\Core\inc\" -I "D:\¹¬ÀÛ¾÷\[ NewDTG                #
#                    ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\..\..\Libraries\STM32_USB_Device_Library\Class\msc\in #
#                    c\" -Ol --use_c++_inline                                 #
#    List file    =  D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4 #
#                    \STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPer #
#                    iph_Template\EWARM\STM3220F_EVAL\List\usb_dcd_int.lst    #
#    Object file  =  D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4 #
#                    \STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPer #
#                    iph_Template\EWARM\STM3220F_EVAL\Obj\usb_dcd_int.o       #
#                                                                             #
#                                                                             #
###############################################################################

D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPeriph_Lib_V0.0.4\Libraries\STM32_USB_OTG_Driver\src\usb_dcd_int.c
      1          /**
      2            ******************************************************************************
      3            * @file    usb_dcd_int.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    11/12/2010
      7            * @brief   Peripheral Device interrupt subroutines
      8            ******************************************************************************
      9            * @copy 
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     19            */
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "usb_dcd_int.h"
     23          /** @addtogroup USB_OTG_DRIVER
     24          * @{
     25          */
     26          
     27          /** @defgroup USB_DCD_INT 
     28          * @brief This file is the interface between EFSL ans Host mass-storage class
     29          * @{
     30          */
     31          
     32          
     33          /** @defgroup USB_DCD_INT_Private_Defines
     34          * @{
     35          */ 
     36          /**
     37          * @}
     38          */ 
     39          
     40          
     41          /** @defgroup USB_DCD_INT_Private_TypesDefinitions
     42          * @{
     43          */ 
     44          /**
     45          * @}
     46          */ 
     47          
     48          
     49          
     50          /** @defgroup USB_DCD_INT_Private_Macros
     51          * @{
     52          */ 
     53          /**
     54          * @}
     55          */ 
     56          
     57          
     58          /** @defgroup USB_DCD_INT_Private_Variables
     59          * @{
     60          */ 
     61          /**
     62          * @}
     63          */ 
     64          
     65          
     66          /** @defgroup USB_DCD_INT_Private_FunctionPrototypes
     67          * @{
     68          */ 
     69          /* static functions */
     70          static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum);
     71          
     72          /* Interrupt Handlers */
     73          static uint32_t DCD_HandleInEP_ISR(USB_OTG_CORE_HANDLE *pdev);
     74          static uint32_t DCD_HandleOutEP_ISR(USB_OTG_CORE_HANDLE *pdev);
     75          static uint32_t DCD_HandleSof_ISR(USB_OTG_CORE_HANDLE *pdev);
     76          
     77          static uint32_t DCD_HandleRxStatusQueueLevel_ISR(USB_OTG_CORE_HANDLE *pdev);
     78          static uint32_t DCD_WriteEmptyTxFifo(USB_OTG_CORE_HANDLE *pdev , uint32_t epnum);
     79          
     80          static uint32_t DCD_HandleUsbReset_ISR(USB_OTG_CORE_HANDLE *pdev);
     81          static uint32_t DCD_HandleEnumDone_ISR(USB_OTG_CORE_HANDLE *pdev);
     82          static uint32_t DCD_HandleResume_ISR(USB_OTG_CORE_HANDLE *pdev);
     83          static uint32_t DCD_HandleUSBSuspend_ISR(USB_OTG_CORE_HANDLE *pdev);
     84          
     85          /**
     86          * @}
     87          */ 
     88          
     89          
     90          /** @defgroup USB_DCD_INT_Private_Functions
     91          * @{
     92          */ 
     93          
     94          
     95          #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED  
     96          /**
     97          * @brief  USBD_OTG_EP1OUT_ISR_Handler
     98          *         handles all USB Interrupts
     99          * @param  pdev: device instance
    100          * @retval status
    101          */
    102          uint32_t USBD_OTG_EP1OUT_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
    103          {
    104            
    105            USB_OTG_DOEPINTn_TypeDef  doepint;
    106            USB_OTG_DEPXFRSIZ_TypeDef  deptsiz;  
    107            
    108            doepint.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[1]->DOEPINT);
    109            doepint.d32&= USB_OTG_READ_REG32(&pdev->regs.DREGS->DOUTEP1MSK);
    110            
    111            /* Transfer complete */
    112            if ( doepint.b.xfercompl )
    113            {
    114              /* Clear the bit in DOEPINTn for this interrupt */
    115              CLEAR_OUT_EP_INTR(1, xfercompl);
    116              if (pdev->cfg.dma_enable == 1)
    117              {
    118                deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[1]->DOEPTSIZ));
    119                /*ToDo : handle more than one single MPS size packet */
    120                pdev->dev.out_ep[1].xfer_count = pdev->dev.out_ep[1].maxpacket - \
    121                  deptsiz.b.xfersize;
    122              }    
    123              /* Inform upper layer: data ready */
    124              /* RX COMPLETE */
    125              USBD_DCD_INT_fops->DataOutStage(pdev , 1);
    126              
    127            }
    128            
    129            /* Endpoint disable  */
    130            if ( doepint.b.epdisabled )
    131            {
    132              /* Clear the bit in DOEPINTn for this interrupt */
    133              CLEAR_OUT_EP_INTR(1, epdisabled);
    134            }
    135            /* AHB Error */
    136            if ( doepint.b.ahberr )
    137            {
    138              CLEAR_OUT_EP_INTR(1, ahberr);
    139            } 
    140            return 1;
    141          }
    142          
    143          /**
    144          * @brief  USBD_OTG_EP1IN_ISR_Handler
    145          *         handles all USB Interrupts
    146          * @param  pdev: device instance
    147          * @retval status
    148          */
    149          uint32_t USBD_OTG_EP1IN_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
    150          {
    151            
    152            USB_OTG_DIEPINTn_TypeDef  diepint;
    153            uint32_t fifoemptymsk, msk, emp;
    154            
    155            msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DINEP1MSK);
    156            emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
    157            msk |= ((emp >> 1 ) & 0x1) << 7;
    158            diepint.d32  = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[1]->DIEPINT) & msk;  
    159            
    160            if ( diepint.b.xfercompl )
    161            {
    162              fifoemptymsk = 0x1 << 1;
    163              USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
    164              CLEAR_IN_EP_INTR(1, xfercompl);
    165              /* TX COMPLETE */
    166              USBD_DCD_INT_fops->DataInStage(pdev , 1);
    167            }
    168            if ( diepint.b.ahberr )
    169            {
    170              CLEAR_IN_EP_INTR(1, ahberr);
    171            }
    172            if ( diepint.b.timeout )
    173            {
    174              CLEAR_IN_EP_INTR(1, timeout);
    175            }
    176            if (diepint.b.intktxfemp)
    177            {
    178              CLEAR_IN_EP_INTR(1, intktxfemp);
    179            }
    180            if (diepint.b.intknepmis)
    181            {
    182              CLEAR_IN_EP_INTR(1, intknepmis);
    183            }
    184            if (diepint.b.inepnakeff)
    185            {
    186              CLEAR_IN_EP_INTR(1, inepnakeff);
    187            }
    188            if (diepint.b.emptyintr)
    189            {
    190              DCD_WriteEmptyTxFifo(pdev , 1);
    191              CLEAR_IN_EP_INTR(1, emptyintr);
    192            }
    193            return 1;
    194          }
    195          #endif
    196          
    197          /**
    198          * @brief  STM32_USBF_OTG_ISR_Handler
    199          *         handles all USB Interrupts
    200          * @param  pdev: device instance
    201          * @retval status
    202          */

   \                                 In section .text, align 2, keep-with-next
    203          uint32_t USBD_OTG_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
    204          {
   \                     USBD_OTG_ISR_Handler:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
    205            USB_OTG_GINTSTS_TypeDef  gintr_status;
    206            uint32_t retval = 0;
   \   00000004   0026               MOVS     R6,#+0
    207            
    208            if (USB_OTG_IsDeviceMode(pdev)) /* ensure that we are in device mode */
   \   00000006   2000               MOVS     R0,R4
   \   00000008   ........           BL       USB_OTG_IsDeviceMode
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   4ED0               BEQ.N    ??USBD_OTG_ISR_Handler_0
    209            {
    210              gintr_status.d32 = USB_OTG_ReadCoreItr(pdev);
   \   00000010   2000               MOVS     R0,R4
   \   00000012   ........           BL       USB_OTG_ReadCoreItr
   \   00000016   0500               MOVS     R5,R0
    211              if (!gintr_status.d32) /* avoid spurious intrrupt */
   \   00000018   002D               CMP      R5,#+0
   \   0000001A   01D1               BNE.N    ??USBD_OTG_ISR_Handler_1
    212              {
    213                return 0;
   \   0000001C   0020               MOVS     R0,#+0
   \   0000001E   47E0               B.N      ??USBD_OTG_ISR_Handler_2
    214              }
    215              
    216              if (gintr_status.b.outepintr)
   \                     ??USBD_OTG_ISR_Handler_1:
   \   00000020   C5F3C040           UBFX     R0,R5,#+19,#+1
   \   00000024   C007               LSLS     R0,R0,#+31
   \   00000026   03D5               BPL.N    ??USBD_OTG_ISR_Handler_3
    217              {
    218                retval |= DCD_HandleOutEP_ISR(pdev);
   \   00000028   2000               MOVS     R0,R4
   \   0000002A   ........           BL       DCD_HandleOutEP_ISR
   \   0000002E   0643               ORRS     R6,R0,R6
    219              }    
    220              
    221              if (gintr_status.b.inepint)
   \                     ??USBD_OTG_ISR_Handler_3:
   \   00000030   C5F38040           UBFX     R0,R5,#+18,#+1
   \   00000034   C007               LSLS     R0,R0,#+31
   \   00000036   03D5               BPL.N    ??USBD_OTG_ISR_Handler_4
    222              {
    223                retval |= DCD_HandleInEP_ISR(pdev);
   \   00000038   2000               MOVS     R0,R4
   \   0000003A   ........           BL       DCD_HandleInEP_ISR
   \   0000003E   0643               ORRS     R6,R0,R6
    224              }
    225              
    226              if (gintr_status.b.modemismatch)
   \                     ??USBD_OTG_ISR_Handler_4:
   \   00000040   C5F34000           UBFX     R0,R5,#+1,#+1
   \   00000044   C007               LSLS     R0,R0,#+31
   \   00000046   04D5               BPL.N    ??USBD_OTG_ISR_Handler_5
    227              {
    228                USB_OTG_GINTSTS_TypeDef  gintsts;
    229                
    230                /* Clear interrupt */
    231                gintsts.d32 = 0;
   \   00000048   0020               MOVS     R0,#+0
    232                gintsts.b.modemismatch = 1;
   \   0000004A   50F00200           ORRS     R0,R0,#0x2
    233                USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
   \   0000004E   E168               LDR      R1,[R4, #+12]
   \   00000050   4861               STR      R0,[R1, #+20]
    234              }
    235              
    236              if (gintr_status.b.wkupintr)
   \                     ??USBD_OTG_ISR_Handler_5:
   \   00000052   002D               CMP      R5,#+0
   \   00000054   03D5               BPL.N    ??USBD_OTG_ISR_Handler_6
    237              {
    238                retval |= DCD_HandleResume_ISR(pdev);
   \   00000056   2000               MOVS     R0,R4
   \   00000058   ........           BL       DCD_HandleResume_ISR
   \   0000005C   0643               ORRS     R6,R0,R6
    239              }
    240              
    241              if (gintr_status.b.usbsuspend)
   \                     ??USBD_OTG_ISR_Handler_6:
   \   0000005E   C5F3C020           UBFX     R0,R5,#+11,#+1
   \   00000062   C007               LSLS     R0,R0,#+31
   \   00000064   03D5               BPL.N    ??USBD_OTG_ISR_Handler_7
    242              {
    243                retval |= DCD_HandleUSBSuspend_ISR(pdev);
   \   00000066   2000               MOVS     R0,R4
   \   00000068   ........           BL       DCD_HandleUSBSuspend_ISR
   \   0000006C   0643               ORRS     R6,R0,R6
    244              }
    245              if (gintr_status.b.sofintr)
   \                     ??USBD_OTG_ISR_Handler_7:
   \   0000006E   C5F3C000           UBFX     R0,R5,#+3,#+1
   \   00000072   C007               LSLS     R0,R0,#+31
   \   00000074   03D5               BPL.N    ??USBD_OTG_ISR_Handler_8
    246              {
    247                retval |= DCD_HandleSof_ISR(pdev);
   \   00000076   2000               MOVS     R0,R4
   \   00000078   ........           BL       DCD_HandleSof_ISR
   \   0000007C   0643               ORRS     R6,R0,R6
    248                
    249              }
    250              
    251              if (gintr_status.b.rxstsqlvl)
   \                     ??USBD_OTG_ISR_Handler_8:
   \   0000007E   C5F30010           UBFX     R0,R5,#+4,#+1
   \   00000082   C007               LSLS     R0,R0,#+31
   \   00000084   03D5               BPL.N    ??USBD_OTG_ISR_Handler_9
    252              {
    253                retval |= DCD_HandleRxStatusQueueLevel_ISR(pdev);
   \   00000086   2000               MOVS     R0,R4
   \   00000088   ........           BL       DCD_HandleRxStatusQueueLevel_ISR
   \   0000008C   0643               ORRS     R6,R0,R6
    254                
    255              }
    256              
    257              if (gintr_status.b.usbreset)
   \                     ??USBD_OTG_ISR_Handler_9:
   \   0000008E   C5F30030           UBFX     R0,R5,#+12,#+1
   \   00000092   C007               LSLS     R0,R0,#+31
   \   00000094   03D5               BPL.N    ??USBD_OTG_ISR_Handler_10
    258              {
    259                retval |= DCD_HandleUsbReset_ISR(pdev);
   \   00000096   2000               MOVS     R0,R4
   \   00000098   ........           BL       DCD_HandleUsbReset_ISR
   \   0000009C   0643               ORRS     R6,R0,R6
    260                
    261              }
    262              if (gintr_status.b.enumdone)
   \                     ??USBD_OTG_ISR_Handler_10:
   \   0000009E   C5F34030           UBFX     R0,R5,#+13,#+1
   \   000000A2   C007               LSLS     R0,R0,#+31
   \   000000A4   03D5               BPL.N    ??USBD_OTG_ISR_Handler_0
    263              {
    264                retval |= DCD_HandleEnumDone_ISR(pdev);
   \   000000A6   2000               MOVS     R0,R4
   \   000000A8   ........           BL       DCD_HandleEnumDone_ISR
   \   000000AC   0643               ORRS     R6,R0,R6
    265              }
    266            }
    267            return retval;
   \                     ??USBD_OTG_ISR_Handler_0:
   \   000000AE   3000               MOVS     R0,R6
   \                     ??USBD_OTG_ISR_Handler_2:
   \   000000B0   70BD               POP      {R4-R6,PC}       ;; return
    268          }
    269          
    270          /**
    271          * @brief  DCD_HandleResume_ISR
    272          *         Indicates that the USB_OTG controller has detected a resume or
    273          *                 remote wakeup sequence
    274          * @param  pdev: device instance
    275          * @retval status
    276          */

   \                                 In section .text, align 2, keep-with-next
    277          static uint32_t DCD_HandleResume_ISR(USB_OTG_CORE_HANDLE *pdev)
    278          {
   \                     DCD_HandleResume_ISR:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    279            USB_OTG_GINTSTS_TypeDef  gintsts;
    280            USB_OTG_DCTL_TypeDef     devctl;
    281            USB_OTG_PCGCCTL_TypeDef  power;
    282            
    283            if(pdev->cfg.low_power)
   \   00000004   A07A               LDRB     R0,[R4, #+10]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   08D0               BEQ.N    ??DCD_HandleResume_ISR_0
    284            {
    285              /* un-gate USB Core clock */
    286              power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
   \   0000000A   D4F80C01           LDR      R0,[R4, #+268]
    287              power.b.gatehclk = 0;
   \   0000000E   30F00200           BICS     R0,R0,#0x2
    288              power.b.stoppclk = 0;
   \   00000012   4008               LSRS     R0,R0,#+1
   \   00000014   4000               LSLS     R0,R0,#+1
    289              USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
   \   00000016   D4F80C11           LDR      R1,[R4, #+268]
   \   0000001A   0860               STR      R0,[R1, #+0]
    290            }
    291            
    292            /* Clear the Remote Wakeup Signalling */
    293            devctl.d32 = 0;
   \                     ??DCD_HandleResume_ISR_0:
   \   0000001C   0020               MOVS     R0,#+0
    294            devctl.b.rmtwkupsig = 1;
   \   0000001E   50F00100           ORRS     R0,R0,#0x1
    295            USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, devctl.d32, 0);
   \   00000022   2169               LDR      R1,[R4, #+16]
   \   00000024   4968               LDR      R1,[R1, #+4]
   \   00000026   31EA0000           BICS     R0,R1,R0
   \   0000002A   2169               LDR      R1,[R4, #+16]
   \   0000002C   4860               STR      R0,[R1, #+4]
    296            
    297            /* Inform upper layer by the Resume Event */
    298            USBD_DCD_INT_fops->Resume (pdev);
   \   0000002E   2000               MOVS     R0,R4
   \   00000030   ........           LDR.W    R1,??DataTable5
   \   00000034   0968               LDR      R1,[R1, #+0]
   \   00000036   8969               LDR      R1,[R1, #+24]
   \   00000038   8847               BLX      R1
    299            
    300            /* Clear interrupt */
    301            gintsts.d32 = 0;
   \   0000003A   0020               MOVS     R0,#+0
    302            gintsts.b.wkupintr = 1;
   \   0000003C   50F00040           ORRS     R0,R0,#0x80000000
    303            USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
   \   00000040   E168               LDR      R1,[R4, #+12]
   \   00000042   4861               STR      R0,[R1, #+20]
    304            return 1;
   \   00000044   0120               MOVS     R0,#+1
   \   00000046   10BD               POP      {R4,PC}          ;; return
    305          }
    306          
    307          /**
    308          * @brief  USB_OTG_HandleUSBSuspend_ISR
    309          *         Indicates that SUSPEND state has been detected on the USB
    310          * @param  pdev: device instance
    311          * @retval status
    312          */

   \                                 In section .text, align 2, keep-with-next
    313          static uint32_t DCD_HandleUSBSuspend_ISR(USB_OTG_CORE_HANDLE *pdev)
    314          {
   \                     DCD_HandleUSBSuspend_ISR:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    315            USB_OTG_GINTSTS_TypeDef  gintsts;
    316            USB_OTG_PCGCCTL_TypeDef  power;
    317            
    318            USBD_DCD_INT_fops->Suspend (pdev);  
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           LDR.W    R1,??DataTable5
   \   0000000A   0968               LDR      R1,[R1, #+0]
   \   0000000C   4969               LDR      R1,[R1, #+20]
   \   0000000E   8847               BLX      R1
    319            
    320            /* Clear interrupt */
    321            gintsts.d32 = 0;
   \   00000010   0020               MOVS     R0,#+0
    322            gintsts.b.usbsuspend = 1;
   \   00000012   50F40060           ORRS     R0,R0,#0x800
    323            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
   \   00000016   E168               LDR      R1,[R4, #+12]
   \   00000018   4861               STR      R0,[R1, #+20]
    324            
    325            if(pdev->cfg.low_power)
   \   0000001A   A07A               LDRB     R0,[R4, #+10]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   1AD0               BEQ.N    ??DCD_HandleUSBSuspend_ISR_0
    326            {
    327              power.d32 = 0;
   \   00000020   0020               MOVS     R0,#+0
    328              power.b.stoppclk = 1;
   \   00000022   50F00100           ORRS     R0,R0,#0x1
    329              USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);  
   \   00000026   D4F80C11           LDR      R1,[R4, #+268]
   \   0000002A   0968               LDR      R1,[R1, #+0]
   \   0000002C   0143               ORRS     R1,R0,R1
   \   0000002E   D4F80C21           LDR      R2,[R4, #+268]
   \   00000032   1160               STR      R1,[R2, #+0]
    330              
    331              power.b.gatehclk = 1;
   \   00000034   50F00200           ORRS     R0,R0,#0x2
    332              USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);
   \   00000038   D4F80C11           LDR      R1,[R4, #+268]
   \   0000003C   0968               LDR      R1,[R1, #+0]
   \   0000003E   0843               ORRS     R0,R0,R1
   \   00000040   D4F80C11           LDR      R1,[R4, #+268]
   \   00000044   0860               STR      R0,[R1, #+0]
    333              
    334              /* switch-off the clocks */
    335              *(uint32_t *)(0xE000ED10) |= 0x00000006 ; // DeepSleepOnExit
   \   00000046   ........           LDR.W    R0,??DataTable5_1  ;; 0xe000ed10
   \   0000004A   0068               LDR      R0,[R0, #+0]
   \   0000004C   50F00600           ORRS     R0,R0,#0x6
   \   00000050   ........           LDR.W    R1,??DataTable5_1  ;; 0xe000ed10
   \   00000054   0860               STR      R0,[R1, #+0]
    336            }
    337            return 1;
   \                     ??DCD_HandleUSBSuspend_ISR_0:
   \   00000056   0120               MOVS     R0,#+1
   \   00000058   10BD               POP      {R4,PC}          ;; return
    338          }
    339          
    340          /**
    341          * @brief  DCD_HandleInEP_ISR
    342          *         Indicates that an IN EP has a pending Interrupt
    343          * @param  pdev: device instance
    344          * @retval status
    345          */

   \                                 In section .text, align 2, keep-with-next
    346          static uint32_t DCD_HandleInEP_ISR(USB_OTG_CORE_HANDLE *pdev)
    347          {
   \                     DCD_HandleInEP_ISR:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0400               MOVS     R4,R0
    348            USB_OTG_DIEPINTn_TypeDef  diepint;
    349            
    350            uint32_t ep_intr;
    351            uint32_t epnum = 0;
   \   00000004   0025               MOVS     R5,#+0
    352            uint32_t fifoemptymsk;
    353            diepint.d32 = 0;
   \   00000006   0027               MOVS     R7,#+0
    354            ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
   \   00000008   2000               MOVS     R0,R4
   \   0000000A   ........           BL       USB_OTG_ReadDevAllInEPItr
   \   0000000E   0600               MOVS     R6,R0
   \   00000010   78E0               B.N      ??DCD_HandleInEP_ISR_0
    355            
    356            while ( ep_intr )
    357            {
    358              if (ep_intr&0x1) /* In ITR */
   \                     ??DCD_HandleInEP_ISR_1:
   \   00000012   3000               MOVS     R0,R6
   \   00000014   C007               LSLS     R0,R0,#+31
   \   00000016   73D5               BPL.N    ??DCD_HandleInEP_ISR_2
    359              {
    360                diepint.d32 = DCD_ReadDevInEP(pdev , epnum); /* Get In ITR status */
   \   00000018   2900               MOVS     R1,R5
   \   0000001A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   2000               MOVS     R0,R4
   \   0000001E   ........           BL       DCD_ReadDevInEP
   \   00000022   0700               MOVS     R7,R0
    361                if ( diepint.b.xfercompl )
   \   00000024   17F00100           ANDS     R0,R7,#0x1
   \   00000028   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0028               CMP      R0,#+0
   \   0000002C   22D0               BEQ.N    ??DCD_HandleInEP_ISR_3
    362                {
    363                  fifoemptymsk = 0x1 << epnum;
   \   0000002E   0120               MOVS     R0,#+1
   \   00000030   A840               LSLS     R0,R0,R5
    364                  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
   \   00000032   2169               LDR      R1,[R4, #+16]
   \   00000034   496B               LDR      R1,[R1, #+52]
   \   00000036   31EA0000           BICS     R0,R1,R0
   \   0000003A   2169               LDR      R1,[R4, #+16]
   \   0000003C   4863               STR      R0,[R1, #+52]
    365                  CLEAR_IN_EP_INTR(epnum, xfercompl);
   \   0000003E   0027               MOVS     R7,#+0
   \   00000040   57F00107           ORRS     R7,R7,#0x1
   \   00000044   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   00000048   8069               LDR      R0,[R0, #+24]
   \   0000004A   8760               STR      R7,[R0, #+8]
    366                  /* TX COMPLETE */
    367                  USBD_DCD_INT_fops->DataInStage(pdev , epnum);
   \   0000004C   2900               MOVS     R1,R5
   \   0000004E   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000050   2000               MOVS     R0,R4
   \   00000052   ........           LDR.W    R2,??DataTable5
   \   00000056   1268               LDR      R2,[R2, #+0]
   \   00000058   5268               LDR      R2,[R2, #+4]
   \   0000005A   9047               BLX      R2
    368                  
    369                  if (pdev->cfg.dma_enable == 1)
   \   0000005C   E078               LDRB     R0,[R4, #+3]
   \   0000005E   0128               CMP      R0,#+1
   \   00000060   08D1               BNE.N    ??DCD_HandleInEP_ISR_3
    370                  {
    371                    if((epnum == 0) && (pdev->dev.device_state == USB_OTG_EP0_STATUS_IN))
   \   00000062   002D               CMP      R5,#+0
   \   00000064   06D1               BNE.N    ??DCD_HandleInEP_ISR_3
   \   00000066   94F81101           LDRB     R0,[R4, #+273]
   \   0000006A   0428               CMP      R0,#+4
   \   0000006C   02D1               BNE.N    ??DCD_HandleInEP_ISR_3
    372                    {
    373                      /* prepare to rx more setup packets */
    374                      USB_OTG_EP0_OutStart(pdev);
   \   0000006E   2000               MOVS     R0,R4
   \   00000070   ........           BL       USB_OTG_EP0_OutStart
    375                    }
    376                  }           
    377                }
    378                if ( diepint.b.ahberr )
   \                     ??DCD_HandleInEP_ISR_3:
   \   00000074   C7F38000           UBFX     R0,R7,#+2,#+1
   \   00000078   C007               LSLS     R0,R0,#+31
   \   0000007A   06D5               BPL.N    ??DCD_HandleInEP_ISR_4
    379                {
    380                  CLEAR_IN_EP_INTR(epnum, ahberr);
   \   0000007C   0027               MOVS     R7,#+0
   \   0000007E   57F00407           ORRS     R7,R7,#0x4
   \   00000082   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   00000086   8069               LDR      R0,[R0, #+24]
   \   00000088   8760               STR      R7,[R0, #+8]
    381                }
    382                if ( diepint.b.timeout )
   \                     ??DCD_HandleInEP_ISR_4:
   \   0000008A   C7F3C000           UBFX     R0,R7,#+3,#+1
   \   0000008E   C007               LSLS     R0,R0,#+31
   \   00000090   06D5               BPL.N    ??DCD_HandleInEP_ISR_5
    383                {
    384                  CLEAR_IN_EP_INTR(epnum, timeout);
   \   00000092   0027               MOVS     R7,#+0
   \   00000094   57F00807           ORRS     R7,R7,#0x8
   \   00000098   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   0000009C   8069               LDR      R0,[R0, #+24]
   \   0000009E   8760               STR      R7,[R0, #+8]
    385                }
    386                if (diepint.b.intktxfemp)
   \                     ??DCD_HandleInEP_ISR_5:
   \   000000A0   C7F30010           UBFX     R0,R7,#+4,#+1
   \   000000A4   C007               LSLS     R0,R0,#+31
   \   000000A6   06D5               BPL.N    ??DCD_HandleInEP_ISR_6
    387                {
    388                  CLEAR_IN_EP_INTR(epnum, intktxfemp);
   \   000000A8   0027               MOVS     R7,#+0
   \   000000AA   57F01007           ORRS     R7,R7,#0x10
   \   000000AE   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   000000B2   8069               LDR      R0,[R0, #+24]
   \   000000B4   8760               STR      R7,[R0, #+8]
    389                }
    390                if (diepint.b.intknepmis)
   \                     ??DCD_HandleInEP_ISR_6:
   \   000000B6   C7F34010           UBFX     R0,R7,#+5,#+1
   \   000000BA   C007               LSLS     R0,R0,#+31
   \   000000BC   06D5               BPL.N    ??DCD_HandleInEP_ISR_7
    391                {
    392                  CLEAR_IN_EP_INTR(epnum, intknepmis);
   \   000000BE   0027               MOVS     R7,#+0
   \   000000C0   57F02007           ORRS     R7,R7,#0x20
   \   000000C4   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   000000C8   8069               LDR      R0,[R0, #+24]
   \   000000CA   8760               STR      R7,[R0, #+8]
    393                }
    394                if (diepint.b.inepnakeff)
   \                     ??DCD_HandleInEP_ISR_7:
   \   000000CC   C7F38010           UBFX     R0,R7,#+6,#+1
   \   000000D0   C007               LSLS     R0,R0,#+31
   \   000000D2   06D5               BPL.N    ??DCD_HandleInEP_ISR_8
    395                {
    396                  CLEAR_IN_EP_INTR(epnum, inepnakeff);
   \   000000D4   0027               MOVS     R7,#+0
   \   000000D6   57F04007           ORRS     R7,R7,#0x40
   \   000000DA   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   000000DE   8069               LDR      R0,[R0, #+24]
   \   000000E0   8760               STR      R7,[R0, #+8]
    397                }
    398                if (diepint.b.emptyintr)
   \                     ??DCD_HandleInEP_ISR_8:
   \   000000E2   C7F3C010           UBFX     R0,R7,#+7,#+1
   \   000000E6   C007               LSLS     R0,R0,#+31
   \   000000E8   0AD5               BPL.N    ??DCD_HandleInEP_ISR_2
    399                {
    400                  
    401                  DCD_WriteEmptyTxFifo(pdev , epnum);
   \   000000EA   2900               MOVS     R1,R5
   \   000000EC   2000               MOVS     R0,R4
   \   000000EE   ........           BL       DCD_WriteEmptyTxFifo
    402                  
    403                  CLEAR_IN_EP_INTR(epnum, emptyintr);
   \   000000F2   0027               MOVS     R7,#+0
   \   000000F4   57F08007           ORRS     R7,R7,#0x80
   \   000000F8   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   000000FC   8069               LDR      R0,[R0, #+24]
   \   000000FE   8760               STR      R7,[R0, #+8]
    404                }
    405              }
    406              epnum++;
   \                     ??DCD_HandleInEP_ISR_2:
   \   00000100   6D1C               ADDS     R5,R5,#+1
    407              ep_intr >>= 1;
   \   00000102   7608               LSRS     R6,R6,#+1
    408            }
   \                     ??DCD_HandleInEP_ISR_0:
   \   00000104   002E               CMP      R6,#+0
   \   00000106   84D1               BNE.N    ??DCD_HandleInEP_ISR_1
    409            
    410            return 1;
   \   00000108   0120               MOVS     R0,#+1
   \   0000010A   F2BD               POP      {R1,R4-R7,PC}    ;; return
    411          }
    412          
    413          /**
    414          * @brief  DCD_HandleOutEP_ISR
    415          *         Indicates that an OUT EP has a pending Interrupt
    416          * @param  pdev: device instance
    417          * @retval status
    418          */

   \                                 In section .text, align 2, keep-with-next
    419          static uint32_t DCD_HandleOutEP_ISR(USB_OTG_CORE_HANDLE *pdev)
    420          {
   \                     DCD_HandleOutEP_ISR:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0400               MOVS     R4,R0
    421            uint32_t ep_intr;
    422            USB_OTG_DOEPINTn_TypeDef  doepint;
    423            USB_OTG_DEPXFRSIZ_TypeDef  deptsiz;
    424            uint32_t epnum = 0;
   \   00000004   0025               MOVS     R5,#+0
    425            
    426            doepint.d32 = 0;
   \   00000006   0027               MOVS     R7,#+0
    427            
    428            /* Read in the device interrupt bits */
    429            ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
   \   00000008   2000               MOVS     R0,R4
   \   0000000A   ........           BL       USB_OTG_ReadDevAllOutEp_itr
   \   0000000E   0600               MOVS     R6,R0
   \   00000010   63E0               B.N      ??DCD_HandleOutEP_ISR_0
    430            
    431            while ( ep_intr )
    432            {
    433              if (ep_intr&0x1)
   \                     ??DCD_HandleOutEP_ISR_1:
   \   00000012   3000               MOVS     R0,R6
   \   00000014   C007               LSLS     R0,R0,#+31
   \   00000016   5ED5               BPL.N    ??DCD_HandleOutEP_ISR_2
    434              {
    435                
    436                doepint.d32 = USB_OTG_ReadDevOutEP_itr(pdev, epnum);
   \   00000018   2900               MOVS     R1,R5
   \   0000001A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   2000               MOVS     R0,R4
   \   0000001E   ........           BL       USB_OTG_ReadDevOutEP_itr
   \   00000022   0700               MOVS     R7,R0
    437                
    438                /* Transfer complete */
    439                if ( doepint.b.xfercompl )
   \   00000024   17F00100           ANDS     R0,R7,#0x1
   \   00000028   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0028               CMP      R0,#+0
   \   0000002C   2DD0               BEQ.N    ??DCD_HandleOutEP_ISR_3
    440                {
    441                  /* Clear the bit in DOEPINTn for this interrupt */
    442                  CLEAR_OUT_EP_INTR(epnum, xfercompl);
   \   0000002E   0027               MOVS     R7,#+0
   \   00000030   57F00107           ORRS     R7,R7,#0x1
   \   00000034   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   00000038   406D               LDR      R0,[R0, #+84]
   \   0000003A   8760               STR      R7,[R0, #+8]
    443                  if (pdev->cfg.dma_enable == 1)
   \   0000003C   E078               LDRB     R0,[R4, #+3]
   \   0000003E   0128               CMP      R0,#+1
   \   00000040   10D1               BNE.N    ??DCD_HandleOutEP_ISR_4
    444                  {
    445                    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[epnum]->DOEPTSIZ));
   \   00000042   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   00000046   406D               LDR      R0,[R0, #+84]
   \   00000048   0069               LDR      R0,[R0, #+16]
    446                    /*ToDo : handle more than one single MPS size packet */
    447                    pdev->dev.out_ep[epnum].xfer_count = pdev->dev.out_ep[epnum].maxpacket - \
    448                      deptsiz.b.xfersize;
   \   0000004A   2821               MOVS     R1,#+40
   \   0000004C   01FB0541           MLA      R1,R1,R5,R4
   \   00000050   D1F87813           LDR      R1,[R1, #+888]
   \   00000054   4003               LSLS     R0,R0,#+13
   \   00000056   400B               LSRS     R0,R0,#+13
   \   00000058   081A               SUBS     R0,R1,R0
   \   0000005A   2821               MOVS     R1,#+40
   \   0000005C   01FB0541           MLA      R1,R1,R5,R4
   \   00000060   C1F88803           STR      R0,[R1, #+904]
    449                  }
    450                  /* Inform upper layer: data ready */
    451                  /* RX COMPLETE */
    452                  USBD_DCD_INT_fops->DataOutStage(pdev , epnum);
   \                     ??DCD_HandleOutEP_ISR_4:
   \   00000064   2900               MOVS     R1,R5
   \   00000066   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000068   2000               MOVS     R0,R4
   \   0000006A   ....               LDR.N    R2,??DataTable5
   \   0000006C   1268               LDR      R2,[R2, #+0]
   \   0000006E   1268               LDR      R2,[R2, #+0]
   \   00000070   9047               BLX      R2
    453                  
    454                  if (pdev->cfg.dma_enable == 1)
   \   00000072   E078               LDRB     R0,[R4, #+3]
   \   00000074   0128               CMP      R0,#+1
   \   00000076   08D1               BNE.N    ??DCD_HandleOutEP_ISR_3
    455                  {
    456                    if((epnum == 0) && (pdev->dev.device_state == USB_OTG_EP0_STATUS_OUT))
   \   00000078   002D               CMP      R5,#+0
   \   0000007A   06D1               BNE.N    ??DCD_HandleOutEP_ISR_3
   \   0000007C   94F81101           LDRB     R0,[R4, #+273]
   \   00000080   0528               CMP      R0,#+5
   \   00000082   02D1               BNE.N    ??DCD_HandleOutEP_ISR_3
    457                    {
    458                      /* prepare to rx more setup packets */
    459                      USB_OTG_EP0_OutStart(pdev);
   \   00000084   2000               MOVS     R0,R4
   \   00000086   ........           BL       USB_OTG_EP0_OutStart
    460                    }
    461                  }        
    462                }
    463                /* Endpoint disable  */
    464                if ( doepint.b.epdisabled )
   \                     ??DCD_HandleOutEP_ISR_3:
   \   0000008A   C7F34000           UBFX     R0,R7,#+1,#+1
   \   0000008E   C007               LSLS     R0,R0,#+31
   \   00000090   06D5               BPL.N    ??DCD_HandleOutEP_ISR_5
    465                {
    466                  /* Clear the bit in DOEPINTn for this interrupt */
    467                  CLEAR_OUT_EP_INTR(epnum, epdisabled);
   \   00000092   0027               MOVS     R7,#+0
   \   00000094   57F00207           ORRS     R7,R7,#0x2
   \   00000098   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   0000009C   406D               LDR      R0,[R0, #+84]
   \   0000009E   8760               STR      R7,[R0, #+8]
    468                }
    469                /* AHB Error */
    470                if ( doepint.b.ahberr )
   \                     ??DCD_HandleOutEP_ISR_5:
   \   000000A0   C7F38000           UBFX     R0,R7,#+2,#+1
   \   000000A4   C007               LSLS     R0,R0,#+31
   \   000000A6   06D5               BPL.N    ??DCD_HandleOutEP_ISR_6
    471                {
    472                  CLEAR_OUT_EP_INTR(epnum, ahberr);
   \   000000A8   0027               MOVS     R7,#+0
   \   000000AA   57F00407           ORRS     R7,R7,#0x4
   \   000000AE   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   000000B2   406D               LDR      R0,[R0, #+84]
   \   000000B4   8760               STR      R7,[R0, #+8]
    473                }
    474                /* Setup Phase Done (control EPs) */
    475                if ( doepint.b.setup )
   \                     ??DCD_HandleOutEP_ISR_6:
   \   000000B6   C7F3C000           UBFX     R0,R7,#+3,#+1
   \   000000BA   C007               LSLS     R0,R0,#+31
   \   000000BC   0BD5               BPL.N    ??DCD_HandleOutEP_ISR_2
    476                {
    477                  
    478                  /* inform the upper layer that a setup packet is available */
    479                  /* SETUP COMPLETE */
    480                  USBD_DCD_INT_fops->SetupStage(pdev);
   \   000000BE   2000               MOVS     R0,R4
   \   000000C0   ....               LDR.N    R1,??DataTable5
   \   000000C2   0968               LDR      R1,[R1, #+0]
   \   000000C4   8968               LDR      R1,[R1, #+8]
   \   000000C6   8847               BLX      R1
    481                  CLEAR_OUT_EP_INTR(epnum, setup);
   \   000000C8   0027               MOVS     R7,#+0
   \   000000CA   57F00807           ORRS     R7,R7,#0x8
   \   000000CE   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   000000D2   406D               LDR      R0,[R0, #+84]
   \   000000D4   8760               STR      R7,[R0, #+8]
    482                }
    483              }
    484              epnum++;
   \                     ??DCD_HandleOutEP_ISR_2:
   \   000000D6   6D1C               ADDS     R5,R5,#+1
    485              ep_intr >>= 1;
   \   000000D8   7608               LSRS     R6,R6,#+1
    486            }
   \                     ??DCD_HandleOutEP_ISR_0:
   \   000000DA   002E               CMP      R6,#+0
   \   000000DC   99D1               BNE.N    ??DCD_HandleOutEP_ISR_1
    487            return 1;
   \   000000DE   0120               MOVS     R0,#+1
   \   000000E0   F2BD               POP      {R1,R4-R7,PC}    ;; return
    488          }
    489          
    490          /**
    491          * @brief  DCD_HandleSof_ISR
    492          *         Handles the SOF Interrupts
    493          * @param  pdev: device instance
    494          * @retval status
    495          */

   \                                 In section .text, align 2, keep-with-next
    496          static uint32_t DCD_HandleSof_ISR(USB_OTG_CORE_HANDLE *pdev)
    497          {
   \                     DCD_HandleSof_ISR:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    498            USB_OTG_GINTSTS_TypeDef  GINTSTS;
    499            
    500            
    501            USBD_DCD_INT_fops->SOF(pdev);
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ....               LDR.N    R1,??DataTable5
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   C968               LDR      R1,[R1, #+12]
   \   0000000C   8847               BLX      R1
    502            
    503            /* Clear interrupt */
    504            GINTSTS.d32 = 0;
   \   0000000E   0020               MOVS     R0,#+0
    505            GINTSTS.b.sofintr = 1;
   \   00000010   50F00800           ORRS     R0,R0,#0x8
    506            USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, GINTSTS.d32);
   \   00000014   E168               LDR      R1,[R4, #+12]
   \   00000016   4861               STR      R0,[R1, #+20]
    507            
    508            return 1;
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   10BD               POP      {R4,PC}          ;; return
    509          }
    510          
    511          /**
    512          * @brief  DCD_HandleRxStatusQueueLevel_ISR
    513          *         Handles the Rx Status Queue Level Interrupt
    514          * @param  pdev: device instance
    515          * @retval status
    516          */

   \                                 In section .text, align 2, keep-with-next
    517          static uint32_t DCD_HandleRxStatusQueueLevel_ISR(USB_OTG_CORE_HANDLE *pdev)
    518          {
   \                     DCD_HandleRxStatusQueueLevel_ISR:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0400               MOVS     R4,R0
    519            USB_OTG_GINTMSK_TypeDef  int_mask;
    520            USB_OTG_DRXSTS_TypeDef   status;
    521            USB_OTG_EP *ep;
    522            
    523            /* Disable the Rx Status Queue Level interrupt */
    524            int_mask.d32 = 0;
   \   00000004   0025               MOVS     R5,#+0
    525            int_mask.b.rxstsqlvl = 1;
   \   00000006   55F01005           ORRS     R5,R5,#0x10
    526            USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32, 0);
   \   0000000A   E068               LDR      R0,[R4, #+12]
   \   0000000C   8069               LDR      R0,[R0, #+24]
   \   0000000E   A843               BICS     R0,R0,R5
   \   00000010   E168               LDR      R1,[R4, #+12]
   \   00000012   8861               STR      R0,[R1, #+24]
    527            
    528            /* Get the Status from the top of the FIFO */
    529            status.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRXSTSP );
   \   00000014   E068               LDR      R0,[R4, #+12]
   \   00000016   066A               LDR      R6,[R0, #+32]
    530            
    531            ep = &pdev->dev.out_ep[status.b.epnum];
   \   00000018   16F00F00           ANDS     R0,R6,#0xF
   \   0000001C   2821               MOVS     R1,#+40
   \   0000001E   01FB0040           MLA      R0,R1,R0,R4
   \   00000022   00F27037           ADDW     R7,R0,#+880
    532            
    533            switch (status.b.pktsts)
   \   00000026   700C               LSRS     R0,R6,#+17
   \   00000028   10F00F00           ANDS     R0,R0,#0xF
   \   0000002C   0128               CMP      R0,#+1
   \   0000002E   08D0               BEQ.N    ??DCD_HandleRxStatusQueueLevel_ISR_0
   \   00000030   0228               CMP      R0,#+2
   \   00000032   07D0               BEQ.N    ??DCD_HandleRxStatusQueueLevel_ISR_1
   \   00000034   0328               CMP      R0,#+3
   \   00000036   1DD0               BEQ.N    ??DCD_HandleRxStatusQueueLevel_ISR_2
   \   00000038   0428               CMP      R0,#+4
   \   0000003A   1CD0               BEQ.N    ??DCD_HandleRxStatusQueueLevel_ISR_3
   \   0000003C   0628               CMP      R0,#+6
   \   0000003E   1BD0               BEQ.N    ??DCD_HandleRxStatusQueueLevel_ISR_4
   \   00000040   26E0               B.N      ??DCD_HandleRxStatusQueueLevel_ISR_5
    534            {
    535            case STS_GOUT_NAK:
    536              break;
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_0:
   \   00000042   25E0               B.N      ??DCD_HandleRxStatusQueueLevel_ISR_6
    537            case STS_DATA_UPDT:
    538              if (status.b.bcnt)
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_1:
   \   00000044   3009               LSRS     R0,R6,#+4
   \   00000046   4005               LSLS     R0,R0,#+21
   \   00000048   400D               LSRS     R0,R0,#+21
   \   0000004A   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004C   0028               CMP      R0,#+0
   \   0000004E   10D0               BEQ.N    ??DCD_HandleRxStatusQueueLevel_ISR_7
    539              {
    540                USB_OTG_ReadPacket(pdev,ep->xfer_buff, status.b.bcnt);
   \   00000050   C6F30A12           UBFX     R2,R6,#+4,#+11
   \   00000054   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000056   F968               LDR      R1,[R7, #+12]
   \   00000058   2000               MOVS     R0,R4
   \   0000005A   ........           BL       USB_OTG_ReadPacket
    541                ep->xfer_buff += status.b.bcnt;
   \   0000005E   C6F30A10           UBFX     R0,R6,#+4,#+11
   \   00000062   F968               LDR      R1,[R7, #+12]
   \   00000064   4018               ADDS     R0,R0,R1
   \   00000066   F860               STR      R0,[R7, #+12]
    542                ep->xfer_count += status.b.bcnt;
   \   00000068   B869               LDR      R0,[R7, #+24]
   \   0000006A   C6F30A11           UBFX     R1,R6,#+4,#+11
   \   0000006E   0818               ADDS     R0,R1,R0
   \   00000070   B861               STR      R0,[R7, #+24]
    543              }
    544              break;
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_7:
   \   00000072   0DE0               B.N      ??DCD_HandleRxStatusQueueLevel_ISR_6
    545            case STS_XFER_COMP:
    546              break;
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_2:
   \   00000074   0CE0               B.N      ??DCD_HandleRxStatusQueueLevel_ISR_6
    547            case STS_SETUP_COMP:
    548              break;
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_3:
   \   00000076   0BE0               B.N      ??DCD_HandleRxStatusQueueLevel_ISR_6
    549            case STS_SETUP_UPDT:
    550              /* Copy the setup packet received in Fifo into the setup buffer in RAM */
    551              USB_OTG_ReadPacket(pdev , pdev->dev.setup_packet, 8);
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_4:
   \   00000078   0822               MOVS     R2,#+8
   \   0000007A   14F5B961           ADDS     R1,R4,#+1480
   \   0000007E   2000               MOVS     R0,R4
   \   00000080   ........           BL       USB_OTG_ReadPacket
    552              ep->xfer_count += status.b.bcnt;
   \   00000084   B869               LDR      R0,[R7, #+24]
   \   00000086   C6F30A11           UBFX     R1,R6,#+4,#+11
   \   0000008A   0818               ADDS     R0,R1,R0
   \   0000008C   B861               STR      R0,[R7, #+24]
    553              break;
   \   0000008E   FFE7               B.N      ??DCD_HandleRxStatusQueueLevel_ISR_6
    554            default:
    555              break;
    556            }
    557            
    558            /* Enable the Rx Status Queue Level interrupt */
    559            USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, int_mask.d32);
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_5:
   \                     ??DCD_HandleRxStatusQueueLevel_ISR_6:
   \   00000090   E068               LDR      R0,[R4, #+12]
   \   00000092   8069               LDR      R0,[R0, #+24]
   \   00000094   2843               ORRS     R0,R5,R0
   \   00000096   E168               LDR      R1,[R4, #+12]
   \   00000098   8861               STR      R0,[R1, #+24]
    560            
    561            return 1;
   \   0000009A   0120               MOVS     R0,#+1
   \   0000009C   F2BD               POP      {R1,R4-R7,PC}    ;; return
    562          }
    563          
    564          /**
    565          * @brief  DCD_WriteEmptyTxFifo
    566          *         check Fifo for the next packet to be loaded
    567          * @param  pdev: device instance
    568          * @retval status
    569          */

   \                                 In section .text, align 2, keep-with-next
    570          static uint32_t DCD_WriteEmptyTxFifo(USB_OTG_CORE_HANDLE *pdev, uint32_t epnum)
    571          {
   \                     DCD_WriteEmptyTxFifo:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   0400               MOVS     R4,R0
   \   00000006   0D00               MOVS     R5,R1
    572            USB_OTG_DIEPTSIZn_TypeDef  txstatus;
    573            USB_OTG_EP *ep;
    574            uint32_t len = 0;
   \   00000008   0026               MOVS     R6,#+0
    575            uint32_t len32b;
    576            txstatus.d32 = 0;
   \   0000000A   0020               MOVS     R0,#+0
    577            
    578            ep = &pdev->dev.in_ep[epnum];    
   \   0000000C   2821               MOVS     R1,#+40
   \   0000000E   01FB0541           MLA      R1,R1,R5,R4
   \   00000012   01F21817           ADDW     R7,R1,#+280
    579            
    580            len = ep->xfer_len - ep->xfer_count;
   \   00000016   7969               LDR      R1,[R7, #+20]
   \   00000018   BA69               LDR      R2,[R7, #+24]
   \   0000001A   891A               SUBS     R1,R1,R2
   \   0000001C   0E00               MOVS     R6,R1
    581            
    582            if (len > ep->maxpacket)
   \   0000001E   B968               LDR      R1,[R7, #+8]
   \   00000020   B142               CMP      R1,R6
   \   00000022   00D2               BCS.N    ??DCD_WriteEmptyTxFifo_0
    583            {
    584              len = ep->maxpacket;
   \   00000024   BE68               LDR      R6,[R7, #+8]
    585            }
    586            
    587            len32b = (len + 3) / 4;
   \                     ??DCD_WriteEmptyTxFifo_0:
   \   00000026   F01C               ADDS     R0,R6,#+3
   \   00000028   5FEA9008           LSRS     R8,R0,#+2
    588            txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DIEPTSIZ);
   \   0000002C   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   00000030   8069               LDR      R0,[R0, #+24]
   \   00000032   8069               LDR      R0,[R0, #+24]
   \   00000034   1BE0               B.N      ??DCD_WriteEmptyTxFifo_1
    589            
    590            
    591            
    592            while  (txstatus.b.txfspcavail > len32b &&
    593                    ep->xfer_count < ep->xfer_len &&
    594                      ep->xfer_len != 0)
    595            {
    596              /* Write the FIFO */
    597              len = ep->xfer_len - ep->xfer_count;
   \                     ??DCD_WriteEmptyTxFifo_2:
   \   00000036   7869               LDR      R0,[R7, #+20]
   \   00000038   B969               LDR      R1,[R7, #+24]
   \   0000003A   461A               SUBS     R6,R0,R1
    598              
    599              if (len > ep->maxpacket)
   \   0000003C   B868               LDR      R0,[R7, #+8]
   \   0000003E   B042               CMP      R0,R6
   \   00000040   00D2               BCS.N    ??DCD_WriteEmptyTxFifo_3
    600              {
    601                len = ep->maxpacket;
   \   00000042   BE68               LDR      R6,[R7, #+8]
    602              }
    603              len32b = (len + 3) / 4;
   \                     ??DCD_WriteEmptyTxFifo_3:
   \   00000044   F01C               ADDS     R0,R6,#+3
   \   00000046   5FEA9008           LSRS     R8,R0,#+2
    604              
    605              USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
   \   0000004A   3300               MOVS     R3,R6
   \   0000004C   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000004E   2A00               MOVS     R2,R5
   \   00000050   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000052   F968               LDR      R1,[R7, #+12]
   \   00000054   2000               MOVS     R0,R4
   \   00000056   ........           BL       USB_OTG_WritePacket
    606              
    607              ep->xfer_buff  += len;
   \   0000005A   F868               LDR      R0,[R7, #+12]
   \   0000005C   3018               ADDS     R0,R6,R0
   \   0000005E   F860               STR      R0,[R7, #+12]
    608              ep->xfer_count += len;
   \   00000060   B869               LDR      R0,[R7, #+24]
   \   00000062   3018               ADDS     R0,R6,R0
   \   00000064   B861               STR      R0,[R7, #+24]
    609              
    610              txstatus.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPTSIZ);
   \   00000066   14EB8500           ADDS     R0,R4,R5, LSL #+2
   \   0000006A   8069               LDR      R0,[R0, #+24]
   \   0000006C   8069               LDR      R0,[R0, #+24]
    611            }
   \                     ??DCD_WriteEmptyTxFifo_1:
   \   0000006E   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000070   8045               CMP      R8,R0
   \   00000072   06D2               BCS.N    ??DCD_WriteEmptyTxFifo_4
   \   00000074   B869               LDR      R0,[R7, #+24]
   \   00000076   7969               LDR      R1,[R7, #+20]
   \   00000078   8842               CMP      R0,R1
   \   0000007A   02D2               BCS.N    ??DCD_WriteEmptyTxFifo_4
   \   0000007C   7869               LDR      R0,[R7, #+20]
   \   0000007E   0028               CMP      R0,#+0
   \   00000080   D9D1               BNE.N    ??DCD_WriteEmptyTxFifo_2
    612            
    613            return 1;
   \                     ??DCD_WriteEmptyTxFifo_4:
   \   00000082   0120               MOVS     R0,#+1
   \   00000084   BDE8F081           POP      {R4-R8,PC}       ;; return
    614          }
    615          
    616          /**
    617          * @brief  DCD_HandleUsbReset_ISR
    618          *         This interrupt occurs when a USB Reset is detected
    619          * @param  pdev: device instance
    620          * @retval status
    621          */

   \                                 In section .text, align 2, keep-with-next
    622          static uint32_t DCD_HandleUsbReset_ISR(USB_OTG_CORE_HANDLE *pdev)
    623          {
   \                     DCD_HandleUsbReset_ISR:
   \   00000000   2DE9F843           PUSH     {R3-R9,LR}
   \   00000004   0400               MOVS     R4,R0
    624            USB_OTG_DAINT_TypeDef    daintmsk;
    625            USB_OTG_DOEPMSK_TypeDef  doepmsk;
    626            USB_OTG_DIEPMSK_TypeDef  diepmsk;
    627            USB_OTG_DCFG_TypeDef     dcfg;
    628            USB_OTG_DCTL_TypeDef     dctl;
    629            USB_OTG_GINTSTS_TypeDef  gintsts;
    630            uint32_t i;
    631            
    632            dctl.d32 = 0;
   \   00000006   0020               MOVS     R0,#+0
    633            daintmsk.d32 = 0;
   \   00000008   0025               MOVS     R5,#+0
    634            doepmsk.d32 = 0;
   \   0000000A   0026               MOVS     R6,#+0
    635            diepmsk.d32 = 0;
   \   0000000C   0027               MOVS     R7,#+0
    636            dcfg.d32 = 0;
   \   0000000E   5FF00008           MOVS     R8,#+0
    637            gintsts.d32 = 0;
   \   00000012   5FF00009           MOVS     R9,#+0
    638            
    639            /* Clear the Remote Wakeup Signalling */
    640            dctl.b.rmtwkupsig = 1;
   \   00000016   50F00100           ORRS     R0,R0,#0x1
    641            USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
   \   0000001A   2169               LDR      R1,[R4, #+16]
   \   0000001C   4968               LDR      R1,[R1, #+4]
   \   0000001E   31EA0000           BICS     R0,R1,R0
   \   00000022   2169               LDR      R1,[R4, #+16]
   \   00000024   4860               STR      R0,[R1, #+4]
    642            
    643            /* Flush the Tx FIFO */
    644            USB_OTG_FlushTxFifo(pdev ,  0 );
   \   00000026   0021               MOVS     R1,#+0
   \   00000028   2000               MOVS     R0,R4
   \   0000002A   ........           BL       USB_OTG_FlushTxFifo
    645            
    646            for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
   \   0000002E   0020               MOVS     R0,#+0
   \   00000030   0AE0               B.N      ??DCD_HandleUsbReset_ISR_0
    647            {
    648              USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
   \                     ??DCD_HandleUsbReset_ISR_1:
   \   00000032   14EB8001           ADDS     R1,R4,R0, LSL #+2
   \   00000036   8969               LDR      R1,[R1, #+24]
   \   00000038   FF22               MOVS     R2,#+255
   \   0000003A   8A60               STR      R2,[R1, #+8]
    649              USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
   \   0000003C   14EB8001           ADDS     R1,R4,R0, LSL #+2
   \   00000040   496D               LDR      R1,[R1, #+84]
   \   00000042   FF22               MOVS     R2,#+255
   \   00000044   8A60               STR      R2,[R1, #+8]
    650            }
   \   00000046   401C               ADDS     R0,R0,#+1
   \                     ??DCD_HandleUsbReset_ISR_0:
   \   00000048   6178               LDRB     R1,[R4, #+1]
   \   0000004A   8842               CMP      R0,R1
   \   0000004C   F1D3               BCC.N    ??DCD_HandleUsbReset_ISR_1
    651            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
   \   0000004E   2069               LDR      R0,[R4, #+16]
   \   00000050   5FF0FF31           MOVS     R1,#-1
   \   00000054   8161               STR      R1,[R0, #+24]
    652            
    653            daintmsk.ep.in = 1;
   \   00000056   0120               MOVS     R0,#+1
   \   00000058   60F30F05           BFI      R5,R0,#+0,#+16
    654            daintmsk.ep.out = 1;
   \   0000005C   0120               MOVS     R0,#+1
   \   0000005E   60F31F45           BFI      R5,R0,#+16,#+16
    655            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, daintmsk.d32 );
   \   00000062   2069               LDR      R0,[R4, #+16]
   \   00000064   C561               STR      R5,[R0, #+28]
    656            
    657            doepmsk.b.setup = 1;
   \   00000066   56F00806           ORRS     R6,R6,#0x8
    658            doepmsk.b.xfercompl = 1;
   \   0000006A   56F00106           ORRS     R6,R6,#0x1
    659            doepmsk.b.ahberr = 1;
   \   0000006E   56F00406           ORRS     R6,R6,#0x4
    660            doepmsk.b.epdisabled = 1;
   \   00000072   56F00206           ORRS     R6,R6,#0x2
    661            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, doepmsk.d32 );
   \   00000076   2069               LDR      R0,[R4, #+16]
   \   00000078   4661               STR      R6,[R0, #+20]
    662          #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED   
    663            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOUTEP1MSK, doepmsk.d32 );
    664          #endif
    665            diepmsk.b.xfercompl = 1;
   \   0000007A   57F00107           ORRS     R7,R7,#0x1
    666            diepmsk.b.timeout = 1;
   \   0000007E   57F00807           ORRS     R7,R7,#0x8
    667            diepmsk.b.epdisabled = 1;
   \   00000082   57F00207           ORRS     R7,R7,#0x2
    668            diepmsk.b.ahberr = 1;
   \   00000086   57F00407           ORRS     R7,R7,#0x4
    669            diepmsk.b.intknepmis = 1;
   \   0000008A   57F02007           ORRS     R7,R7,#0x20
    670            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, diepmsk.d32 );
   \   0000008E   2069               LDR      R0,[R4, #+16]
   \   00000090   0761               STR      R7,[R0, #+16]
    671          #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED  
    672            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DINEP1MSK, diepmsk.d32 );
    673          #endif
    674            /* Reset Device Address */
    675            dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
   \   00000092   2069               LDR      R0,[R4, #+16]
   \   00000094   D0F80080           LDR      R8,[R0, #+0]
    676            dcfg.b.devaddr = 0;
   \   00000098   38F4FE68           BICS     R8,R8,#0x7F0
    677            USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32);
   \   0000009C   2069               LDR      R0,[R4, #+16]
   \   0000009E   C0F80080           STR      R8,[R0, #+0]
    678            
    679            
    680            /* setup EP0 to receive SETUP packets */
    681            USB_OTG_EP0_OutStart(pdev);
   \   000000A2   2000               MOVS     R0,R4
   \   000000A4   ........           BL       USB_OTG_EP0_OutStart
    682            
    683            /* Clear interrupt */
    684            gintsts.d32 = 0;
   \   000000A8   5FF00009           MOVS     R9,#+0
    685            gintsts.b.usbreset = 1;
   \   000000AC   59F48059           ORRS     R9,R9,#0x1000
    686            USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
   \   000000B0   E068               LDR      R0,[R4, #+12]
   \   000000B2   C0F81490           STR      R9,[R0, #+20]
    687            
    688            /*Reset internal state machine */
    689            USBD_DCD_INT_fops->Reset(pdev);
   \   000000B6   2000               MOVS     R0,R4
   \   000000B8   ....               LDR.N    R1,??DataTable5
   \   000000BA   0968               LDR      R1,[R1, #+0]
   \   000000BC   0969               LDR      R1,[R1, #+16]
   \   000000BE   8847               BLX      R1
    690            return 1;
   \   000000C0   0120               MOVS     R0,#+1
   \   000000C2   BDE8F283           POP      {R1,R4-R9,PC}    ;; return
    691          }
    692          
    693          /**
    694          * @brief  DCD_HandleEnumDone_ISR
    695          *         Read the device status register and set the device speed
    696          * @param  pdev: device instance
    697          * @retval status
    698          */

   \                                 In section .text, align 2, keep-with-next
    699          static uint32_t DCD_HandleEnumDone_ISR(USB_OTG_CORE_HANDLE *pdev)
    700          {
   \                     DCD_HandleEnumDone_ISR:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
    701            USB_OTG_GINTSTS_TypeDef  gintsts;
    702            USB_OTG_GUSBCFG_TypeDef  gusbcfg;
    703            
    704            USB_OTG_EP0Activate(pdev);
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           BL       USB_OTG_EP0Activate
    705            
    706            /* Set USB turnaround time based on device speed and PHY interface. */
    707            gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
   \   0000000A   E068               LDR      R0,[R4, #+12]
   \   0000000C   C568               LDR      R5,[R0, #+12]
    708            
    709            /* Full or High speed */
    710            if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
   \   0000000E   2000               MOVS     R0,R4
   \   00000010   ........           BL       USB_OTG_GetDeviceSpeed
   \   00000014   0328               CMP      R0,#+3
   \   00000016   08D1               BNE.N    ??DCD_HandleEnumDone_ISR_0
    711            {
    712              pdev->cfg.speed            = USB_OTG_SPEED_HIGH;
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   A070               STRB     R0,[R4, #+2]
    713              pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
   \   0000001C   4FF40070           MOV      R0,#+512
   \   00000020   A080               STRH     R0,[R4, #+4]
    714              gusbcfg.b.usbtrdtim = 9;
   \   00000022   0920               MOVS     R0,#+9
   \   00000024   60F38D25           BFI      R5,R0,#+10,#+4
   \   00000028   06E0               B.N      ??DCD_HandleEnumDone_ISR_1
    715            }
    716            else
    717            {
    718              pdev->cfg.speed            = USB_OTG_SPEED_FULL;
   \                     ??DCD_HandleEnumDone_ISR_0:
   \   0000002A   0120               MOVS     R0,#+1
   \   0000002C   A070               STRB     R0,[R4, #+2]
    719              pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;  
   \   0000002E   4020               MOVS     R0,#+64
   \   00000030   A080               STRH     R0,[R4, #+4]
    720              gusbcfg.b.usbtrdtim = 5;
   \   00000032   0520               MOVS     R0,#+5
   \   00000034   60F38D25           BFI      R5,R0,#+10,#+4
    721            }
    722            
    723            USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, gusbcfg.d32);
   \                     ??DCD_HandleEnumDone_ISR_1:
   \   00000038   E068               LDR      R0,[R4, #+12]
   \   0000003A   C560               STR      R5,[R0, #+12]
    724            
    725            /* Clear interrupt */
    726            gintsts.d32 = 0;
   \   0000003C   0020               MOVS     R0,#+0
    727            gintsts.b.enumdone = 1;
   \   0000003E   50F40050           ORRS     R0,R0,#0x2000
    728            USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, gintsts.d32 );
   \   00000042   E168               LDR      R1,[R4, #+12]
   \   00000044   4861               STR      R0,[R1, #+20]
    729            return 1;
   \   00000046   0120               MOVS     R0,#+1
   \   00000048   32BD               POP      {R1,R4,R5,PC}    ;; return
    730          }
    731          
    732          /**
    733          * @brief  DCD_ReadDevInEP
    734          *         Reads ep flags
    735          * @param  pdev: device instance
    736          * @retval status
    737          */

   \                                 In section .text, align 2, keep-with-next
    738          static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
    739          {
    740            uint32_t v, msk, emp;
    741            msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
   \                     DCD_ReadDevInEP:
   \   00000000   0269               LDR      R2,[R0, #+16]
   \   00000002   1269               LDR      R2,[R2, #+16]
    742            emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
   \   00000004   0369               LDR      R3,[R0, #+16]
   \   00000006   5B6B               LDR      R3,[R3, #+52]
    743            msk |= ((emp >> epnum) & 0x1) << 7;
   \   00000008   CB40               LSRS     R3,R3,R1
   \   0000000A   13F00103           ANDS     R3,R3,#0x1
   \   0000000E   52EAC312           ORRS     R2,R2,R3, LSL #+7
    744            v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
   \   00000012   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   10EB8100           ADDS     R0,R0,R1, LSL #+2
   \   00000018   8069               LDR      R0,[R0, #+24]
   \   0000001A   8068               LDR      R0,[R0, #+8]
   \   0000001C   1040               ANDS     R0,R2,R0
    745            return v;
   \   0000001E   7047               BX       LR               ;; return
    746          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     USBD_DCD_INT_fops

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   10ED00E0           DC32     0xe000ed10
    747          
    748          
    749          
    750          /**
    751          * @}
    752          */ 
    753          
    754          /**
    755          * @}
    756          */ 
    757          
    758          /**
    759          * @}
    760          */
    761          
    762          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     DCD_HandleEnumDone_ISR             16
     DCD_HandleInEP_ISR                 24
     DCD_HandleOutEP_ISR                24
     DCD_HandleResume_ISR                8
     DCD_HandleRxStatusQueueLevel_ISR
                                        24
     DCD_HandleSof_ISR                   8
     DCD_HandleUSBSuspend_ISR            8
     DCD_HandleUsbReset_ISR             32
     DCD_ReadDevInEP                     0
     DCD_WriteEmptyTxFifo               24
     USBD_OTG_ISR_Handler               16


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     USBD_OTG_ISR_Handler            178
     DCD_HandleResume_ISR             72
     DCD_HandleUSBSuspend_ISR         90
     DCD_HandleInEP_ISR              268
     DCD_HandleOutEP_ISR             226
     DCD_HandleSof_ISR                28
     DCD_HandleRxStatusQueueLevel_ISR
                                     158
     DCD_WriteEmptyTxFifo            136
     DCD_HandleUsbReset_ISR          198
     DCD_HandleEnumDone_ISR           74
     DCD_ReadDevInEP                  32
     ??DataTable5                      4
     ??DataTable5_1                    4

 
 1 468 bytes in section .text
 
 1 468 bytes of CODE memory

Errors: none
Warnings: none
