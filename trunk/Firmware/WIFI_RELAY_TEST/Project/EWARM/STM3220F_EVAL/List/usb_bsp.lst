###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     12/Nov/2011  19:31:40 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\USB\usb #
#                    _bsp.c                                                   #
#    Command line =  "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\USB\us #
#                    b_bsp.c" -D USE_STDPERIPH_DRIVER -D STM32F2XX -D         #
#                    USE_STM3220F_EVAL -D USE_USB_OTG_FS -D                   #
#                    RTC_CLOCK_SOURCE_LSE -lC "F:\¹¬ÀÛ¾÷\[ NewDTG             #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\STM3220F_EVAL\List\" #
#                     -lA "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\E #
#                    WARM\STM3220F_EVAL\List\" -o "F:\¹¬ÀÛ¾÷\[ NewDTG         #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\STM3220F_EVAL\Obj\"  #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0\arm\INC\c\DLib_Config_Full.h" -I           #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                              #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\CMSI #
#                    S\CM3\CoreSupport\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG               #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\CMSI #
#                    S\CM3\DeviceSupport\ST\STM32F2xx\" -I "F:\¹¬ÀÛ¾÷\[       #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Librari #
#                    es\STM32F2xx_StdPeriph_Driver\inc\" -I "F:\¹¬ÀÛ¾÷\[      #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utiliti #
#                    es\STM32_EVAL\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\Common\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\STM3220F_EVAL\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_OTG_Driver\inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Core\inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Class\msc\inc\" -I "F:\¹¬ÀÛ¾÷\[     #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\" -I   #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\Usb\Inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                      #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\src\" -I      #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Core\inc\" -I     #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\"   #
#                    -Ol --use_c++_inline                                     #
#    List file    =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\List\usb_bsp.lst                            #
#    Object file  =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\Obj\usb_bsp.o                               #
#                                                                             #
#                                                                             #
###############################################################################

F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\USB\usb_bsp.c
      1          /**
      2          ******************************************************************************
      3          * @file    usb_bsp.c
      4          * @author  MCD Application Team
      5          * @version V2.0.0RC1
      6          * @date    18-March-2011
      7          * @brief   This file implements the board support package for the USB host library
      8          ******************************************************************************
      9          * @attention
     10          *
     11          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13          * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14          * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15          * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16          * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17          *
     18          * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19          ******************************************************************************
     20          */ 
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          
     24          #include "usb_bsp.h"
     25          
     26          /** @addtogroup USBH_USER
     27          * @{
     28          */
     29          
     30          /** @defgroup USB_BSP
     31          * @brief This file is responsible to offer board support package
     32          * @{
     33          */ 
     34          
     35          /** @defgroup USB_BSP_Private_Defines
     36          * @{
     37          */ 
     38          #define USE_ACCURATE_TIME
     39          #define TIM_MSEC_DELAY       0x01
     40          #define TIM_USEC_DELAY       0x02
     41          #define HOST_OVRCURR_PORT                  GPIOE
     42          #define HOST_OVRCURR_LINE                  GPIO_Pin_1
     43          #define HOST_OVRCURR_PORT_SOURCE           GPIO_PortSourceGPIOE
     44          #define HOST_OVRCURR_PIN_SOURCE            GPIO_PinSource1
     45          #define HOST_OVRCURR_PORT_RCC              RCC_APB2Periph_GPIOE
     46          #define HOST_OVRCURR_EXTI_LINE             EXTI_Line1
     47          #define HOST_OVRCURR_IRQn                  EXTI1_IRQn 
     48          
     49          #ifdef USE_STM3210C_EVAL
     50          #define HOST_POWERSW_PORT_RCC              RCC_APB2Periph_GPIOC
     51          #define HOST_POWERSW_PORT                  GPIOC
     52          #define HOST_POWERSW_VBUS                  GPIO_Pin_9
     53          #else
     54          #ifdef USE_USB_OTG_FS 
     55          #define HOST_POWERSW_PORT_RCC              RCC_AHB1Periph_GPIOH
     56          #define HOST_POWERSW_PORT                  GPIOH
     57          #define HOST_POWERSW_VBUS                  GPIO_Pin_5
     58          #endif
     59          #endif
     60          
     61          
     62          #define HOST_SOF_OUTPUT_RCC                RCC_APB2Periph_GPIOA
     63          #define HOST_SOF_PORT                      GPIOA
     64          #define HOST_SOF_SIGNAL                    GPIO_Pin_8
     65          
     66          #define STM322xG_EVAL_RevB 
     67          //#define STM3220F_EVAL_RevA 
     68          /**
     69          * @}
     70          */ 
     71          
     72          
     73          /** @defgroup USB_BSP_Private_TypesDefinitions
     74          * @{
     75          */ 
     76          /**
     77          * @}
     78          */ 
     79          
     80          
     81          
     82          /** @defgroup USB_BSP_Private_Macros
     83          * @{
     84          */ 
     85          /**
     86          * @}
     87          */ 
     88          
     89          /** @defgroup USBH_BSP_Private_Variables
     90          * @{
     91          */ 
     92          
     93          #ifdef USE_ACCURATE_TIME 

   \                                 In section .bss, align 4
     94          __IO uint32_t BSP_delay = 0;
   \                     BSP_delay:
   \   00000000                      DS8 4
     95          #endif
     96          /**
     97          * @}
     98          */ 
     99          
    100          /** @defgroup USBH_BSP_Private_FunctionPrototypes
    101          * @{
    102          */ 
    103          
    104          #ifdef USE_ACCURATE_TIME 
    105          static void BSP_SetTime(uint8_t Unit);
    106          static void BSP_Delay(uint32_t nTime,uint8_t Unit);
    107          static void USB_OTG_BSP_TimeInit ( void );
    108          #endif
    109          /**
    110          * @}
    111          */ 
    112          
    113          /** @defgroup USB_BSP_Private_Functions
    114          * @{
    115          */ 
    116          
    117          /**
    118          * @brief  USB_OTG_BSP_Init
    119          *         Initilizes BSP configurations
    120          * @param  None
    121          * @retval None
    122          */
    123          

   \                                 In section .text, align 2, keep-with-next
    124          void USB_OTG_BSP_Init(USB_OTG_CORE_HANDLE *pdev)
    125          {
   \                     USB_OTG_BSP_Init:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   83B0               SUB      SP,SP,#+12
    126          	
    127          	// EXTI_InitTypeDef EXTI_InitStructure;
    128          #ifdef USE_STM3210C_EVAL
    129          	
    130          	RCC_OTGFSCLKConfig(RCC_OTGFSCLKSource_PLLVCO_Div3);
    131          	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_OTG_FS, ENABLE) ;
    132          	
    133          #else // USE_STM322xG_EVAL  
    134          	GPIO_InitTypeDef GPIO_InitStructure;
    135          	#ifdef USE_USB_OTG_FS 
    136          		#ifdef USE_I2C_FS_PHY 
    137          	
    138          			RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOB , ENABLE);  
    139          			/* Configure INTN SCL SDA (Phy/I2C) Pins */
    140          			GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | 
    141          				GPIO_Pin_8 | 
    142          				GPIO_Pin_9;
    143          	
    144          			GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    145          			GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    146          			GPIO_Init(GPIOB, &GPIO_InitStructure);  
    147          			
    148          			GPIO_PinAFConfig(GPIOB,GPIO_PinSource6,GPIO_AF_OTG1_FS) ; 
    149          			GPIO_PinAFConfig(GPIOB,GPIO_PinSource8,GPIO_AF_OTG1_FS) ; 
    150          			GPIO_PinAFConfig(GPIOB,GPIO_PinSource9,GPIO_AF_OTG1_FS) ;  
    151          		#else  
    152          			RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOA , ENABLE);  	
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   0120               MOVS     R0,#+1
   \   00000008   ........           BL       RCC_AHB1PeriphClockCmd
    153          			/* Configure SOF VBUS ID DM DP Pins */
    154          			GPIO_InitStructure.GPIO_Pin = //GPIO_Pin_8  | 	// ID
    155          			//	GPIO_Pin_9  | 		// VBUS
    156          				GPIO_Pin_11 | 		// DM
    157          				GPIO_Pin_12;		// DP
   \   0000000C   4FF4C050           MOV      R0,#+6144
   \   00000010   0090               STR      R0,[SP, #+0]
    158          	
    159          			GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   \   00000012   0320               MOVS     R0,#+3
   \   00000014   8DF80500           STRB     R0,[SP, #+5]
    160          			GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   00000018   0220               MOVS     R0,#+2
   \   0000001A   8DF80400           STRB     R0,[SP, #+4]
    161          			GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   0000001E   0020               MOVS     R0,#+0
   \   00000020   8DF80600           STRB     R0,[SP, #+6]
    162          			GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
   \   00000024   0020               MOVS     R0,#+0
   \   00000026   8DF80700           STRB     R0,[SP, #+7]
    163          			GPIO_Init(GPIOA, &GPIO_InitStructure);  
   \   0000002A   00A9               ADD      R1,SP,#+0
   \   0000002C   ....               LDR.N    R0,??DataTable4  ;; 0x40020000
   \   0000002E   ........           BL       GPIO_Init
    164          	
    165          			//GPIO_PinAFConfig(GPIOA,GPIO_PinSource8,GPIO_AF_OTG1_FS) ;
    166            //			GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_OTG1_FS) ; 
    167          			GPIO_PinAFConfig(GPIOA,GPIO_PinSource11,GPIO_AF_OTG1_FS) ; 
   \   00000032   0A22               MOVS     R2,#+10
   \   00000034   0B21               MOVS     R1,#+11
   \   00000036   ....               LDR.N    R0,??DataTable4  ;; 0x40020000
   \   00000038   ........           BL       GPIO_PinAFConfig
    168          			GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;
   \   0000003C   0A22               MOVS     R2,#+10
   \   0000003E   0C21               MOVS     R1,#+12
   \   00000040   ....               LDR.N    R0,??DataTable4  ;; 0x40020000
   \   00000042   ........           BL       GPIO_PinAFConfig
    169          	
    170          			/* this for ID line debug */
    171          	
    172          //			GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
    173          //			GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
    174          //			GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;  
    175          //			GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    176          //			GPIO_Init(GPIOA, &GPIO_InitStructure);  
    177          //			GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_OTG1_FS) ;   
    178          	
    179          		#endif  	// End of USE_I2C_FS_PHY	
    180          		RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
   \   00000046   0121               MOVS     R1,#+1
   \   00000048   4FF48040           MOV      R0,#+16384
   \   0000004C   ........           BL       RCC_APB2PeriphClockCmd
    181          		
    182          		RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_OTG_FS, ENABLE) ; 
   \   00000050   0121               MOVS     R1,#+1
   \   00000052   8020               MOVS     R0,#+128
   \   00000054   ........           BL       RCC_AHB2PeriphClockCmd
    183          		
    184          	#else // USE_USB_OTG_HS ÀÏ °æ¿ì
    185          	
    186          		#ifdef USE_ULPI_PHY // ULPI
    187          		
    188          		RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOB | 
    189          		RCC_AHB1Periph_GPIOC | RCC_AHB1Periph_GPIOH | 
    190          		RCC_AHB1Periph_GPIOI, ENABLE);    
    191          	
    192          	
    193          	GPIO_PinAFConfig(GPIOA,GPIO_PinSource3, GPIO_AF_OTG2_HS) ; // D0
    194          	GPIO_PinAFConfig(GPIOA,GPIO_PinSource5, GPIO_AF_OTG2_HS) ; // CLK
    195          	GPIO_PinAFConfig(GPIOB,GPIO_PinSource0, GPIO_AF_OTG2_HS) ; // D1
    196          	GPIO_PinAFConfig(GPIOB,GPIO_PinSource1, GPIO_AF_OTG2_HS) ; // D2
    197          	GPIO_PinAFConfig(GPIOB,GPIO_PinSource5, GPIO_AF_OTG2_HS) ; // D7
    198          	GPIO_PinAFConfig(GPIOB,GPIO_PinSource10,GPIO_AF_OTG2_HS) ; // D3
    199          	GPIO_PinAFConfig(GPIOB,GPIO_PinSource11,GPIO_AF_OTG2_HS) ; // D4
    200          	GPIO_PinAFConfig(GPIOB,GPIO_PinSource12,GPIO_AF_OTG2_HS) ; // D5
    201          	GPIO_PinAFConfig(GPIOB,GPIO_PinSource13,GPIO_AF_OTG2_HS) ; // D6
    202          	GPIO_PinAFConfig(GPIOH,GPIO_PinSource4, GPIO_AF_OTG2_HS) ; // NXT
    203          	GPIO_PinAFConfig(GPIOI,GPIO_PinSource11,GPIO_AF_OTG2_HS) ; // DIR
    204          	GPIO_PinAFConfig(GPIOC,GPIO_PinSource0, GPIO_AF_OTG2_HS) ; // STP
    205          	
    206          	// CLK
    207          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 ; 
    208          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    209          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    210          	GPIO_Init(GPIOA, &GPIO_InitStructure);  
    211          	
    212          	// D0
    213          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3  ; 
    214          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    215          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    216          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    217          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
    218          	GPIO_Init(GPIOA, &GPIO_InitStructure);  
    219          	
    220          	
    221          	
    222          	// D1 D2 D3 D4 D5 D6 D7
    223          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1  |
    224          		GPIO_Pin_5 | GPIO_Pin_10 | 
    225          		GPIO_Pin_11| GPIO_Pin_12 | 
    226          		GPIO_Pin_13 ;
    227          	
    228          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    229          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    230          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    231          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
    232          	GPIO_Init(GPIOB, &GPIO_InitStructure);  
    233          	
    234          	
    235          	// STP
    236          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  ;
    237          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    238          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    239          	GPIO_Init(GPIOC, &GPIO_InitStructure);  
    240          	
    241          	//NXT  
    242          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
    243          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    244          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    245          	GPIO_Init(GPIOH, &GPIO_InitStructure);  
    246          	
    247          	
    248          	//DIR
    249          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 ; 
    250          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    251          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    252          	GPIO_Init(GPIOI, &GPIO_InitStructure);  
    253          	
    254          	
    255          	RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_OTG_HS | 
    256          		RCC_AHB1Periph_OTG_HS_ULPI, ENABLE) ;    
    257          	
    258          		#else
    259          	
    260          		#ifdef USE_I2C_FS_PHY    
    261          	RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOB , ENABLE);  
    262          	/* Configure RESET INTN SCL SDA (Phy/I2C) Pins */
    263          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | 
    264          		GPIO_Pin_1 | 
    265          		GPIO_Pin_10 | 
    266          		GPIO_Pin_11;
    267          	
    268          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    269          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    270          	GPIO_Init(GPIOB, &GPIO_InitStructure);  
    271          	
    272          	GPIO_PinAFConfig(GPIOB,GPIO_PinSource0,GPIO_AF_OTG2_FS) ; 
    273          	GPIO_PinAFConfig(GPIOB,GPIO_PinSource1,GPIO_AF_OTG2_FS) ; 
    274          	GPIO_PinAFConfig(GPIOB,GPIO_PinSource10,GPIO_AF_OTG2_FS) ; 
    275          	GPIO_PinAFConfig(GPIOB,GPIO_PinSource11,GPIO_AF_OTG2_FS);
    276          	RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_OTG_HS, ENABLE) ;  
    277          	
    278          #endif  
    279          	
    280          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB , ENABLE);
    281          	
    282          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12  | 
    283          		GPIO_Pin_13 |
    284          		GPIO_Pin_14 | 
    285          		GPIO_Pin_15;
    286          	
    287          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    288          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    289          	GPIO_Init(GPIOB, &GPIO_InitStructure);  
    290          	
    291          	GPIO_PinAFConfig(GPIOB,GPIO_PinSource12, GPIO_AF_OTG2_FS) ; 
    292          	GPIO_PinAFConfig(GPIOB,GPIO_PinSource13,GPIO_AF_OTG2_FS) ; 
    293          	GPIO_PinAFConfig(GPIOB,GPIO_PinSource14,GPIO_AF_OTG2_FS) ; 
    294          	GPIO_PinAFConfig(GPIOB,GPIO_PinSource15,GPIO_AF_OTG2_FS) ;
    295          	RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_OTG_HS, ENABLE) ;  
    296          		#endif
    297          	#endif //USB_OTG_HS
    298          #endif //USE_STM322xG_EVAL
    299          	
    300          	/* Intialize Timer for delay function */
    301          	// Delay(¼³Á¤) //Å¸ÀÌ¸Ó¸¦ »ç¿ëÇÏ±â À§ÇØ¼­´Â Define À» USE_ACCURATE_TIME 
    302          	// Á¤È®ÇÑ Å¸ÀÌ¸Ó°¡ ÇÊ¿äÇÏ´Ù¸é 
    303          	USB_OTG_BSP_TimeInit();   		
   \   00000058   ........           BL       USB_OTG_BSP_TimeInit
    304          	//
    305          }
   \   0000005C   07BD               POP      {R0-R2,PC}       ;; return
    306          /**
    307          * @brief  USB_OTG_BSP_EnableInterrupt
    308          *         Configures USB Global interrupt
    309          * @param  None
    310          * @retval None
    311          */

   \                                 In section .text, align 2, keep-with-next
    312          void USB_OTG_BSP_EnableInterrupt(USB_OTG_CORE_HANDLE *pdev)
    313          {
   \                     USB_OTG_BSP_EnableInterrupt:
   \   00000000   80B5               PUSH     {R7,LR}
    314          	NVIC_InitTypeDef NVIC_InitStructure; 
    315          	
    316          	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
   \   00000002   4FF4C060           MOV      R0,#+1536
   \   00000006   ........           BL       NVIC_PriorityGroupConfig
    317          #ifdef USE_USB_OTG_HS   
    318          	NVIC_InitStructure.NVIC_IRQChannel = OTG_HS_IRQn;
    319          #else
    320          	NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;  
   \   0000000A   4320               MOVS     R0,#+67
   \   0000000C   8DF80000           STRB     R0,[SP, #+0]
    321          #endif
    322          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
   \   00000010   0120               MOVS     R0,#+1
   \   00000012   8DF80100           STRB     R0,[SP, #+1]
    323          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
   \   00000016   0320               MOVS     R0,#+3
   \   00000018   8DF80200           STRB     R0,[SP, #+2]
    324          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000001C   0120               MOVS     R0,#+1
   \   0000001E   8DF80300           STRB     R0,[SP, #+3]
    325          	NVIC_Init(&NVIC_InitStructure);  
   \   00000022   00A8               ADD      R0,SP,#+0
   \   00000024   ........           BL       NVIC_Init
    326          
    327          }
   \   00000028   01BD               POP      {R0,PC}          ;; return
    328          
    329          /**
    330          * @brief  BSP_Drive_VBUS
    331          *         Drives the Vbus signal through IO
    332          * @param  state : VBUS states
    333          * @retval None
    334          */
    335          

   \                                 In section .text, align 2, keep-with-next
    336          void USB_OTG_BSP_DriveVBUS(USB_OTG_CORE_HANDLE *pdev, uint8_t state)
    337          {
   \                     USB_OTG_BSP_DriveVBUS:
   \   00000000   80B5               PUSH     {R7,LR}
    338          /*
    339          On-chip 5 V VBUS generation is not supported. For this reason, a charge pump 
    340          or, if 5 V are available on the application board, a basic power switch, must 
    341          be added externally to drive the 5 V VBUS line. The external charge pump can 
    342          be driven by any GPIO output. When the application decides to power on VBUS 
    343          using the chosen GPIO, it must also set the port power bit in the host port 
    344          control and status register (PPWR bit in OTG_FS_HPRT).
    345          
    346            Bit 12 PPWR: Port power
    347            The application uses this field to control power to this port, and the core 
    348            clears this bit on an overcurrent condition.
    349          	*/
    350          	
    351          #ifndef USE_USB_OTG_HS   
    352          #if defined (STM3220F_EVAL_RevA) && defined (USE_STM322xG_EVAL)  
    353          	if (1 == state)
    354          #else
    355          		if (0 == state)
   \   00000002   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0029               CMP      R1,#+0
   \   00000006   04D1               BNE.N    ??USB_OTG_BSP_DriveVBUS_0
    356          #endif  
    357          		{ 
    358          			/* DISABLE is needed on output of the Power Switch */
    359          			GPIO_SetBits(HOST_POWERSW_PORT, HOST_POWERSW_VBUS);
   \   00000008   2021               MOVS     R1,#+32
   \   0000000A   ....               LDR.N    R0,??DataTable4_1  ;; 0x40021c00
   \   0000000C   ........           BL       GPIO_SetBits
   \   00000010   03E0               B.N      ??USB_OTG_BSP_DriveVBUS_1
    360          		}
    361          		else
    362          		{
    363          			/*ENABLE the Power Switch by driving the Enable LOW */
    364          			GPIO_ResetBits(HOST_POWERSW_PORT, HOST_POWERSW_VBUS);
   \                     ??USB_OTG_BSP_DriveVBUS_0:
   \   00000012   2021               MOVS     R1,#+32
   \   00000014   ....               LDR.N    R0,??DataTable4_1  ;; 0x40021c00
   \   00000016   ........           BL       GPIO_ResetBits
    365          		}
    366          #endif  
    367          }
   \                     ??USB_OTG_BSP_DriveVBUS_1:
   \   0000001A   01BD               POP      {R0,PC}          ;; return
    368          
    369          /**
    370          * @brief  USB_OTG_BSP_ConfigVBUS
    371          *         Configures the IO for the Vbus and OverCurrent
    372          * @param  None
    373          * @retval None
    374          */
    375          

   \                                 In section .text, align 2, keep-with-next
    376          void  USB_OTG_BSP_ConfigVBUS(USB_OTG_CORE_HANDLE *pdev)
    377          {
   \                     USB_OTG_BSP_ConfigVBUS:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   83B0               SUB      SP,SP,#+12
    378          #ifndef USE_USB_OTG_HS 
    379          	GPIO_InitTypeDef GPIO_InitStructure; 
    380          	
    381          #ifdef USE_STM3210C_EVAL
    382          	RCC_APB2PeriphClockCmd(HOST_POWERSW_PORT_RCC, ENABLE);
    383          	
    384          	
    385          	/* Configure Power Switch Vbus Pin */
    386          	GPIO_InitStructure.GPIO_Pin = HOST_POWERSW_VBUS;
    387          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    388          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    389          	GPIO_Init(HOST_POWERSW_PORT, &GPIO_InitStructure);
    390          #else
    391          #ifdef USE_USB_OTG_FS  
    392          	RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOH , ENABLE);  
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   8020               MOVS     R0,#+128
   \   00000008   ........           BL       RCC_AHB1PeriphClockCmd
    393          	
    394          	GPIO_InitStructure.GPIO_Pin = HOST_POWERSW_VBUS;
   \   0000000C   2020               MOVS     R0,#+32
   \   0000000E   0090               STR      R0,[SP, #+0]
    395          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   \   00000010   0320               MOVS     R0,#+3
   \   00000012   8DF80500           STRB     R0,[SP, #+5]
    396          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   \   00000016   0120               MOVS     R0,#+1
   \   00000018   8DF80400           STRB     R0,[SP, #+4]
    397          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   0000001C   0020               MOVS     R0,#+0
   \   0000001E   8DF80600           STRB     R0,[SP, #+6]
    398          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
   \   00000022   0020               MOVS     R0,#+0
   \   00000024   8DF80700           STRB     R0,[SP, #+7]
    399          	GPIO_Init(HOST_POWERSW_PORT,&GPIO_InitStructure);
   \   00000028   00A9               ADD      R1,SP,#+0
   \   0000002A   ....               LDR.N    R0,??DataTable4_1  ;; 0x40021c00
   \   0000002C   ........           BL       GPIO_Init
    400          #endif  
    401          #endif
    402          	
    403          	/* By Default, DISABLE is needed on output of the Power Switch */
    404          	GPIO_SetBits(HOST_POWERSW_PORT, HOST_POWERSW_VBUS);
   \   00000030   2021               MOVS     R1,#+32
   \   00000032   ....               LDR.N    R0,??DataTable4_1  ;; 0x40021c00
   \   00000034   ........           BL       GPIO_SetBits
    405          	
    406          	USB_OTG_BSP_mDelay(200);   /* Delay is need for stabilising the Vbus Low 
   \   00000038   C820               MOVS     R0,#+200
   \   0000003A   ........           BL       USB_OTG_BSP_mDelay
    407          	in Reset Condition, when Vbus=1 and Reset-button is pressed by user */
    408          #endif  
    409          }
   \   0000003E   07BD               POP      {R0-R2,PC}       ;; return
    410          
    411          /**
    412          * @brief  USB_OTG_BSP_TimeInit
    413          *         Initializes delay unit using Timer2
    414          * @param  None
    415          * @retval None
    416          */

   \                                 In section .text, align 2, keep-with-next
    417          static void USB_OTG_BSP_TimeInit ( void )
    418          {
   \                     USB_OTG_BSP_TimeInit:
   \   00000000   80B5               PUSH     {R7,LR}
    419          #ifdef USE_ACCURATE_TIME   
    420          	NVIC_InitTypeDef NVIC_InitStructure;
    421          	
    422          	/* Set the Vector Table base address at 0x08000000 */
    423          	//NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x00);
    424          	
    425          	/* Configure the Priority Group to 2 bits */
    426          	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
   \   00000002   4FF4A060           MOV      R0,#+1280
   \   00000006   ........           BL       NVIC_PriorityGroupConfig
    427          	
    428          	/* Enable the TIM2 gloabal Interrupt */
    429          	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
   \   0000000A   1C20               MOVS     R0,#+28
   \   0000000C   8DF80000           STRB     R0,[SP, #+0]
    430          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
   \   00000010   0120               MOVS     R0,#+1
   \   00000012   8DF80100           STRB     R0,[SP, #+1]
    431          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
   \   00000016   0120               MOVS     R0,#+1
   \   00000018   8DF80200           STRB     R0,[SP, #+2]
    432          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000001C   0120               MOVS     R0,#+1
   \   0000001E   8DF80300           STRB     R0,[SP, #+3]
    433          	
    434          	NVIC_Init(&NVIC_InitStructure);
   \   00000022   00A8               ADD      R0,SP,#+0
   \   00000024   ........           BL       NVIC_Init
    435          	
    436          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);  
   \   00000028   0121               MOVS     R1,#+1
   \   0000002A   0120               MOVS     R0,#+1
   \   0000002C   ........           BL       RCC_APB1PeriphClockCmd
    437          #endif  
    438          }
   \   00000030   01BD               POP      {R0,PC}          ;; return
    439          
    440          /**
    441          * @brief  USB_OTG_BSP_uDelay
    442          *         This function provides delay time in micro sec
    443          * @param  usec : Value of delay required in micro sec
    444          * @retval None
    445          */

   \                                 In section .text, align 2, keep-with-next
    446          void USB_OTG_BSP_uDelay (const uint32_t usec)
    447          {
   \                     USB_OTG_BSP_uDelay:
   \   00000000   80B5               PUSH     {R7,LR}
    448          	
    449          #ifdef USE_ACCURATE_TIME    
    450          	BSP_Delay(usec,TIM_USEC_DELAY); 
   \   00000002   0221               MOVS     R1,#+2
   \   00000004   ........           BL       BSP_Delay
    451          #else
    452          	__IO uint32_t count = 0;
    453          	const uint32_t utime = (120 * usec / 7);
    454          	do
    455          	{
    456          		if ( ++count > utime )
    457          		{
    458          			return ;
    459          		}
    460          	}
    461          	while (1);
    462          #endif   
    463          	
    464          }
   \   00000008   01BD               POP      {R0,PC}          ;; return
    465          
    466          
    467          /**
    468          * @brief  USB_OTG_BSP_mDelay
    469          *          This function provides delay time in milli sec
    470          * @param  msec : Value of delay required in milli sec
    471          * @retval None
    472          */

   \                                 In section .text, align 2, keep-with-next
    473          void USB_OTG_BSP_mDelay (const uint32_t msec)
    474          { 
   \                     USB_OTG_BSP_mDelay:
   \   00000000   80B5               PUSH     {R7,LR}
    475          #ifdef USE_ACCURATE_TIME  
    476          	BSP_Delay(msec,TIM_MSEC_DELAY);   
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   ........           BL       BSP_Delay
    477          #else
    478          	USB_OTG_BSP_uDelay(msec * 1000);   
    479          #endif    
    480          	
    481          }
   \   00000008   01BD               POP      {R0,PC}          ;; return
    482          
    483          
    484          /**
    485          * @brief  USB_OTG_BSP_TimerIRQ
    486          *         Time base IRQ
    487          * @param  None
    488          * @retval None
    489          */
    490          

   \                                 In section .text, align 2, keep-with-next
    491          void USB_OTG_BSP_TimerIRQ (void)
    492          {
   \                     USB_OTG_BSP_TimerIRQ:
   \   00000000   80B5               PUSH     {R7,LR}
    493          #ifdef USE_ACCURATE_TIME 
    494          	
    495          	if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   5FF08040           MOVS     R0,#+1073741824
   \   00000008   ........           BL       TIM_GetITStatus
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   13D0               BEQ.N    ??USB_OTG_BSP_TimerIRQ_0
    496          	{
    497          		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
   \   00000010   0121               MOVS     R1,#+1
   \   00000012   5FF08040           MOVS     R0,#+1073741824
   \   00000016   ........           BL       TIM_ClearITPendingBit
    498          		if (BSP_delay > 0x00)
   \   0000001A   ....               LDR.N    R0,??DataTable4_2
   \   0000001C   0068               LDR      R0,[R0, #+0]
   \   0000001E   0028               CMP      R0,#+0
   \   00000020   05D0               BEQ.N    ??USB_OTG_BSP_TimerIRQ_1
    499          		{ 
    500          			BSP_delay--;
   \   00000022   ....               LDR.N    R0,??DataTable4_2
   \   00000024   0068               LDR      R0,[R0, #+0]
   \   00000026   401E               SUBS     R0,R0,#+1
   \   00000028   ....               LDR.N    R1,??DataTable4_2
   \   0000002A   0860               STR      R0,[R1, #+0]
   \   0000002C   04E0               B.N      ??USB_OTG_BSP_TimerIRQ_0
    501          		}
    502          		else
    503          		{
    504          			TIM_Cmd(TIM2,DISABLE);
   \                     ??USB_OTG_BSP_TimerIRQ_1:
   \   0000002E   0021               MOVS     R1,#+0
   \   00000030   5FF08040           MOVS     R0,#+1073741824
   \   00000034   ........           BL       TIM_Cmd
    505          		}
    506          	}
    507          #endif  
    508          } 
   \                     ??USB_OTG_BSP_TimerIRQ_0:
   \   00000038   01BD               POP      {R0,PC}          ;; return
    509          
    510          #ifdef USE_ACCURATE_TIME 
    511          /**
    512          * @brief  BSP_Delay
    513          *         Delay routine based on TIM2
    514          * @param  nTime : Delay Time 
    515          * @param  unit : Delay Time unit : mili sec / micro sec
    516          * @retval None
    517          */

   \                                 In section .text, align 2, keep-with-next
    518          static void BSP_Delay(uint32_t nTime, uint8_t unit)
    519          {
   \                     BSP_Delay:
   \   00000000   80B5               PUSH     {R7,LR}
    520          	
    521          	BSP_delay = nTime;
   \   00000002   ....               LDR.N    R2,??DataTable4_2
   \   00000004   1060               STR      R0,[R2, #+0]
    522          	BSP_SetTime(unit);  
   \   00000006   0800               MOVS     R0,R1
   \   00000008   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   ........           BL       BSP_SetTime
    523          	while(BSP_delay != 0);
   \                     ??BSP_Delay_0:
   \   0000000E   ....               LDR.N    R0,??DataTable4_2
   \   00000010   0068               LDR      R0,[R0, #+0]
   \   00000012   0028               CMP      R0,#+0
   \   00000014   FBD1               BNE.N    ??BSP_Delay_0
    524          	TIM_Cmd(TIM2,DISABLE);
   \   00000016   0021               MOVS     R1,#+0
   \   00000018   5FF08040           MOVS     R0,#+1073741824
   \   0000001C   ........           BL       TIM_Cmd
    525          }
   \   00000020   01BD               POP      {R0,PC}          ;; return
    526          
    527          /**
    528          * @brief  BSP_SetTime
    529          *         Configures TIM2 for delay routine based on TIM2
    530          * @param  unit : msec /usec
    531          * @retval None
    532          */

   \                                 In section .text, align 2, keep-with-next
    533          static void BSP_SetTime(uint8_t unit)
    534          {
   \                     BSP_SetTime:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   84B0               SUB      SP,SP,#+16
   \   00000004   0400               MOVS     R4,R0
    535          	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
    536          	
    537          	TIM_Cmd(TIM2,DISABLE);
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   5FF08040           MOVS     R0,#+1073741824
   \   0000000C   ........           BL       TIM_Cmd
    538          	TIM_ITConfig(TIM2, TIM_IT_Update, DISABLE); 
   \   00000010   0022               MOVS     R2,#+0
   \   00000012   0121               MOVS     R1,#+1
   \   00000014   5FF08040           MOVS     R0,#+1073741824
   \   00000018   ........           BL       TIM_ITConfig
    539          	
    540          	
    541          	if(unit == TIM_USEC_DELAY)
   \   0000001C   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   022C               CMP      R4,#+2
   \   00000020   02D1               BNE.N    ??BSP_SetTime_0
    542          	{  
    543          		TIM_TimeBaseStructure.TIM_Period = 11;
   \   00000022   0B20               MOVS     R0,#+11
   \   00000024   0190               STR      R0,[SP, #+4]
   \   00000026   05E0               B.N      ??BSP_SetTime_1
    544          	}
    545          	else if(unit == TIM_MSEC_DELAY)
   \                     ??BSP_SetTime_0:
   \   00000028   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   012C               CMP      R4,#+1
   \   0000002C   02D1               BNE.N    ??BSP_SetTime_1
    546          	{
    547          		TIM_TimeBaseStructure.TIM_Period = 11999;
   \   0000002E   42F6DF60           MOVW     R0,#+11999
   \   00000032   0190               STR      R0,[SP, #+4]
    548          	}
    549          	TIM_TimeBaseStructure.TIM_Prescaler = 5;
   \                     ??BSP_SetTime_1:
   \   00000034   0520               MOVS     R0,#+5
   \   00000036   ADF80000           STRH     R0,[SP, #+0]
    550          	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
   \   0000003A   0020               MOVS     R0,#+0
   \   0000003C   ADF80800           STRH     R0,[SP, #+8]
    551          	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
   \   00000040   0020               MOVS     R0,#+0
   \   00000042   ADF80200           STRH     R0,[SP, #+2]
    552          	
    553          	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
   \   00000046   00A9               ADD      R1,SP,#+0
   \   00000048   5FF08040           MOVS     R0,#+1073741824
   \   0000004C   ........           BL       TIM_TimeBaseInit
    554          	TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
   \   00000050   0121               MOVS     R1,#+1
   \   00000052   5FF08040           MOVS     R0,#+1073741824
   \   00000056   ........           BL       TIM_ClearITPendingBit
    555          	
    556          	TIM_ARRPreloadConfig(TIM2, ENABLE);
   \   0000005A   0121               MOVS     R1,#+1
   \   0000005C   5FF08040           MOVS     R0,#+1073741824
   \   00000060   ........           BL       TIM_ARRPreloadConfig
    557          	
    558          	/* TIM IT enable */
    559          	TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);
   \   00000064   0122               MOVS     R2,#+1
   \   00000066   0121               MOVS     R1,#+1
   \   00000068   5FF08040           MOVS     R0,#+1073741824
   \   0000006C   ........           BL       TIM_ITConfig
    560          	
    561          	/* TIM2 enable counter */ 
    562          	TIM_Cmd(TIM2, ENABLE);  
   \   00000070   0121               MOVS     R1,#+1
   \   00000072   5FF08040           MOVS     R0,#+1073741824
   \   00000076   ........           BL       TIM_Cmd
    563          } 
   \   0000007A   1FBD               POP      {R0-R4,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   00000240           DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   001C0240           DC32     0x40021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   ........           DC32     BSP_delay
    564          
    565          #endif
    566          
    567          /**
    568          * @}
    569          */ 
    570          
    571          /**
    572          * @}
    573          */ 
    574          
    575          /**
    576          * @}
    577          */
    578          
    579          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                    .cstack
     --------                    -------
     BSP_Delay                        8
     BSP_SetTime                     24
     USB_OTG_BSP_ConfigVBUS          16
     USB_OTG_BSP_DriveVBUS            8
     USB_OTG_BSP_EnableInterrupt      8
     USB_OTG_BSP_Init                16
     USB_OTG_BSP_TimeInit             8
     USB_OTG_BSP_TimerIRQ             8
     USB_OTG_BSP_mDelay               8
     USB_OTG_BSP_uDelay               8


   Section sizes:

     Function/Label              Bytes
     --------------              -----
     BSP_delay                      4
     USB_OTG_BSP_Init              94
     USB_OTG_BSP_EnableInterrupt   42
     USB_OTG_BSP_DriveVBUS         28
     USB_OTG_BSP_ConfigVBUS        64
     USB_OTG_BSP_TimeInit          50
     USB_OTG_BSP_uDelay            10
     USB_OTG_BSP_mDelay            10
     USB_OTG_BSP_TimerIRQ          58
     BSP_Delay                     34
     BSP_SetTime                  124
     ??DataTable4                   4
     ??DataTable4_1                 4
     ??DataTable4_2                 4

 
   4 bytes in section .bss
 526 bytes in section .text
 
 526 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: none
