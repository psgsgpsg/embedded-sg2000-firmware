###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     12/Nov/2011  19:31:26 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Libraries\STM32 #
#                    F2xx_StdPeriph_Driver\src\stm32f2xx_hash.c               #
#    Command line =  "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Libraries\STM3 #
#                    2F2xx_StdPeriph_Driver\src\stm32f2xx_hash.c" -D          #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D RTC_CLOCK_SOURCE_LSE -lC            #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    STM3220F_EVAL\List\" -lA "F:\¹¬ÀÛ¾÷\[ NewDTG             #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\STM3220F_EVAL\List\" #
#                     -o "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EW #
#                    ARM\STM3220F_EVAL\Obj\" --no_cse --no_unroll             #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                              #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\" -I              #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\CMSIS\CM3\CoreSupport\" -I "F:\¹¬ÀÛ¾÷\[  #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Librari #
#                    es\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\" -I             #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I      #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Utilities\STM32_EVAL\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG      #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\Common\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\STM3220F_EVAL\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_OTG_Driver\inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Core\inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Class\msc\inc\" -I "F:\¹¬ÀÛ¾÷\[     #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\" -I   #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\Usb\Inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                      #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\src\" -I      #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Core\inc\" -I     #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\"   #
#                    -Ol --use_c++_inline                                     #
#    List file    =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\List\stm32f2xx_hash.lst                     #
#    Object file  =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\Obj\stm32f2xx_hash.o                        #
#                                                                             #
#                                                                             #
###############################################################################

F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_hash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_hash.c
      4            * @author  MCD Application Team
      5            * @version V0.0.4
      6            * @date    13-January-2011
      7            * @brief   This file provides all the HASH firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f2xx_hash.h"
     24          #include "stm32f2xx_rcc.h"
     25          
     26          /** @addtogroup STM32F2xx_StdPeriph_Driver
     27            * @{
     28            */
     29          
     30          
     31          
     32          /** @defgroup HASH 
     33            * @brief HASH driver modules
     34            * @{
     35            */ 
     36          
     37          /** @defgroup HASH_Private_TypesDefinitions
     38            * @{
     39            */ 
     40          /**
     41            * @}
     42            */ 
     43          
     44          
     45          /** @defgroup HASH_Private_Defines
     46            * @{
     47            */ 
     48          /**
     49            * @}
     50            */ 
     51          
     52          
     53          /** @defgroup HASH_Private_Macros
     54            * @{
     55            */ 
     56          /**
     57            * @}
     58            */ 
     59          
     60          
     61          /** @defgroup HASH_Private_Variables
     62            * @{
     63            */ 
     64          /**
     65            * @}
     66            */ 
     67          
     68          
     69          /** @defgroup HASH_Private_FunctionPrototypes
     70            * @{
     71            */ 
     72          /**
     73            * @}
     74            */ 
     75          
     76          
     77          /** @defgroup HASH_Private_Functions
     78            * @{
     79            */ 
     80          
     81          
     82          /**
     83            * @brief  Deinitializes the HASH peripheral registers to their default reset values
     84            * @param  None
     85            * @retval None
     86            */

   \                                 In section .text, align 2, keep-with-next
     87          void HASH_DeInit(void)
     88          {
   \                     HASH_DeInit:
   \   00000000   80B5               PUSH     {R7,LR}
     89            /* Enable HASH reset state */
     90            RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, ENABLE);
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   2020               MOVS     R0,#+32
   \   00000006   ........           BL       RCC_AHB2PeriphResetCmd
     91            /* Release HASH from reset state */
     92            RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, DISABLE);
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   2020               MOVS     R0,#+32
   \   0000000E   ........           BL       RCC_AHB2PeriphResetCmd
     93          }
   \   00000012   01BD               POP      {R0,PC}          ;; return
     94          
     95          /**
     96            * @brief  Initializes the HASH peripheral according to the specified parameters 
     97            *   in the HASH_InitStruct.
     98            * @param  HASH_InitStruct: pointer to a HASH_InitTypeDef structure that contains
     99            *   the configuration information for the HASH peripheral.
    100            * @retval None
    101            */

   \                                 In section .text, align 2, keep-with-next
    102          void HASH_Init(HASH_InitTypeDef* HASH_InitStruct)
    103          {
    104            assert_param(IS_HASH_ALGOSELECTION(HASH_InitStruct->HASH_AlgoSelection));
    105            assert_param(IS_HASH_DATATYPE(HASH_InitStruct->HASH_DataType));
    106            assert_param(IS_HASH_ALGOMODE(HASH_InitStruct->HASH_AlgoMode));
    107            
    108            HASH->CR &= ~ (HASH_CR_ALGO | HASH_CR_DATATYPE | HASH_CR_MODE);
   \                     HASH_Init:
   \   00000000   ....               LDR.N    R1,??DataTable11  ;; 0x50060400
   \   00000002   0968               LDR      R1,[R1, #+0]
   \   00000004   31F0F001           BICS     R1,R1,#0xF0
   \   00000008   ....               LDR.N    R2,??DataTable11  ;; 0x50060400
   \   0000000A   1160               STR      R1,[R2, #+0]
    109            HASH->CR |= (HASH_InitStruct->HASH_AlgoSelection | HASH_InitStruct->HASH_DataType | \
    110                         HASH_InitStruct->HASH_AlgoMode);
   \   0000000C   ....               LDR.N    R1,??DataTable11  ;; 0x50060400
   \   0000000E   0968               LDR      R1,[R1, #+0]
   \   00000010   0268               LDR      R2,[R0, #+0]
   \   00000012   8368               LDR      R3,[R0, #+8]
   \   00000014   1A43               ORRS     R2,R3,R2
   \   00000016   4368               LDR      R3,[R0, #+4]
   \   00000018   1A43               ORRS     R2,R3,R2
   \   0000001A   1143               ORRS     R1,R2,R1
   \   0000001C   ....               LDR.N    R2,??DataTable11  ;; 0x50060400
   \   0000001E   1160               STR      R1,[R2, #+0]
    111              
    112            if(HASH_InitStruct->HASH_AlgoMode == HASH_AlgoMode_HMAC) 
   \   00000020   4168               LDR      R1,[R0, #+4]
   \   00000022   4029               CMP      R1,#+64
   \   00000024   0BD1               BNE.N    ??HASH_Init_0
    113            {
    114              assert_param(IS_HASH_KEYTYPE(HASH_InitStruct->HASH_KeyType));
    115              HASH->CR &= ~HASH_CR_LKEY;
   \   00000026   ....               LDR.N    R1,??DataTable11  ;; 0x50060400
   \   00000028   0968               LDR      R1,[R1, #+0]
   \   0000002A   31F48031           BICS     R1,R1,#0x10000
   \   0000002E   ....               LDR.N    R2,??DataTable11  ;; 0x50060400
   \   00000030   1160               STR      R1,[R2, #+0]
    116              HASH->CR |= HASH_InitStruct->HASH_KeyType;
   \   00000032   ....               LDR.N    R1,??DataTable11  ;; 0x50060400
   \   00000034   0968               LDR      R1,[R1, #+0]
   \   00000036   C068               LDR      R0,[R0, #+12]
   \   00000038   0843               ORRS     R0,R0,R1
   \   0000003A   ....               LDR.N    R1,??DataTable11  ;; 0x50060400
   \   0000003C   0860               STR      R0,[R1, #+0]
    117            }
    118          
    119            /* Reset the HASH processor core, so that the HASH will be ready to compute 
    120               the message digest of a new message */
    121            HASH->CR |= HASH_CR_INIT;  
   \                     ??HASH_Init_0:
   \   0000003E   ....               LDR.N    R0,??DataTable11  ;; 0x50060400
   \   00000040   0068               LDR      R0,[R0, #+0]
   \   00000042   50F00400           ORRS     R0,R0,#0x4
   \   00000046   ....               LDR.N    R1,??DataTable11  ;; 0x50060400
   \   00000048   0860               STR      R0,[R1, #+0]
    122          }
   \   0000004A   7047               BX       LR               ;; return
    123          
    124          /**
    125            * @brief  Fills each HASH_InitStruct member with its default value.
    126            * @param  HASH_InitStruct : pointer to a HASH_InitTypeDef structure which will
    127            *   be initialized.
    128            * @retval None
    129            */

   \                                 In section .text, align 2, keep-with-next
    130          void HASH_StructInit(HASH_InitTypeDef* HASH_InitStruct)
    131          {
    132            /* Initialize the HASH_AlgoSelection member */
    133            HASH_InitStruct->HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
   \                     HASH_StructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0160               STR      R1,[R0, #+0]
    134          
    135            /* Initialize the HASH_AlgoMode member */
    136            HASH_InitStruct->HASH_AlgoMode = HASH_AlgoMode_HASH;
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   4160               STR      R1,[R0, #+4]
    137          
    138            /* Initialize the HASH_DataType member */
    139            HASH_InitStruct->HASH_DataType = HASH_DataType_32b;
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   8160               STR      R1,[R0, #+8]
    140          
    141            /* Initialize the HASH_KeyType member */
    142            HASH_InitStruct->HASH_KeyType = HASH_KeyType_ShortKey;
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   C160               STR      R1,[R0, #+12]
    143          }
   \   00000010   7047               BX       LR               ;; return
    144          
    145          /**
    146            * @brief  Starts the message padding and calculation of the final message
    147            * @param  None
    148            * @retval None
    149            */

   \                                 In section .text, align 2, keep-with-next
    150          void HASH_Start(void)
    151          {
    152            /* Start the Digest calculation */
    153            HASH->STR |= HASH_STR_DCAL;
   \                     HASH_Start:
   \   00000000   ....               LDR.N    R0,??DataTable11_1  ;; 0x50060408
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   4FF48071           MOV      R1,#+256
   \   00000008   0843               ORRS     R0,R1,R0
   \   0000000A   ....               LDR.N    R1,??DataTable11_1  ;; 0x50060408
   \   0000000C   0860               STR      R0,[R1, #+0]
    154          }
   \   0000000E   7047               BX       LR               ;; return
    155          
    156          /**
    157            * @brief  Resets the HASH processor core, so that the HASH will be ready
    158            *   to compute the message digest of a new message.
    159            * @param  None
    160            * @retval None
    161            */

   \                                 In section .text, align 2, keep-with-next
    162          void HASH_Reset(void)
    163          {
    164            /* Reset the HASH processor core */
    165            HASH->CR |= HASH_CR_INIT;
   \                     HASH_Reset:
   \   00000000   ....               LDR.N    R0,??DataTable11  ;; 0x50060400
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   50F00400           ORRS     R0,R0,#0x4
   \   00000008   ....               LDR.N    R1,??DataTable11  ;; 0x50060400
   \   0000000A   0860               STR      R0,[R1, #+0]
    166          }
   \   0000000C   7047               BX       LR               ;; return
    167          
    168          /**
    169            * @brief  Configure the Number of valid bits in last word of the message
    170            * @param  HASH_ValidNumber: Number of valid bits in last word of the message.
    171            * @note The  Number of valid bits must be set  before to start the message digest competition (in Hash and HMAC) and key treatement(in HMAC).    
    172            *   This parameter must be a number between 0 and 0x1F.
    173            * @retval None
    174            */

   \                                 In section .text, align 2, keep-with-next
    175          void HASH_NbValidBits(uint16_t HASH_ValidNumber)
    176          {
    177            assert_param(IS_HASH_VALIDBITSNUMBER(HASH_ValidNumber));
    178            
    179            /* Configure the Number of valid bits in last word of the message */
    180            HASH->STR &= ~(HASH_STR_NBW);
   \                     HASH_NbValidBits:
   \   00000000   ....               LDR.N    R1,??DataTable11_1  ;; 0x50060408
   \   00000002   0968               LDR      R1,[R1, #+0]
   \   00000004   4909               LSRS     R1,R1,#+5
   \   00000006   4901               LSLS     R1,R1,#+5
   \   00000008   ....               LDR.N    R2,??DataTable11_1  ;; 0x50060408
   \   0000000A   1160               STR      R1,[R2, #+0]
    181            HASH->STR |= HASH_ValidNumber;
   \   0000000C   ....               LDR.N    R1,??DataTable11_1  ;; 0x50060408
   \   0000000E   0968               LDR      R1,[R1, #+0]
   \   00000010   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000012   0843               ORRS     R0,R0,R1
   \   00000014   ....               LDR.N    R1,??DataTable11_1  ;; 0x50060408
   \   00000016   0860               STR      R0,[R1, #+0]
    182          }
   \   00000018   7047               BX       LR               ;; return
    183          
    184          /**
    185            * @brief  Enables or disables the HASH DMA interface.
    186            * @note   The DMA is disabled by hardware after the end of transfer of message data.  
    187            * @param  NewState: new state of the selected HASH DMA transfer request.
    188            *   This parameter can be: ENABLE or DISABLE.
    189            * @retval None
    190            */

   \                                 In section .text, align 2, keep-with-next
    191          void HASH_DMACmd(FunctionalState NewState)
    192          {
    193            /* Check the parameters */
    194            assert_param(IS_FUNCTIONAL_STATE(NewState));
    195          
    196            if (NewState != DISABLE)
   \                     HASH_DMACmd:
   \   00000000   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0028               CMP      R0,#+0
   \   00000004   06D0               BEQ.N    ??HASH_DMACmd_0
    197            {
    198              /* Enable the HASH DMA request */
    199              HASH->CR |= HASH_CR_DMAE;
   \   00000006   ....               LDR.N    R0,??DataTable11  ;; 0x50060400
   \   00000008   0068               LDR      R0,[R0, #+0]
   \   0000000A   50F00800           ORRS     R0,R0,#0x8
   \   0000000E   ....               LDR.N    R1,??DataTable11  ;; 0x50060400
   \   00000010   0860               STR      R0,[R1, #+0]
   \   00000012   05E0               B.N      ??HASH_DMACmd_1
    200            }
    201            else
    202            {
    203              /* Disable the HASH DMA request */
    204              HASH->CR &= ~HASH_CR_DMAE;
   \                     ??HASH_DMACmd_0:
   \   00000014   ....               LDR.N    R0,??DataTable11  ;; 0x50060400
   \   00000016   0068               LDR      R0,[R0, #+0]
   \   00000018   30F00800           BICS     R0,R0,#0x8
   \   0000001C   ....               LDR.N    R1,??DataTable11  ;; 0x50060400
   \   0000001E   0860               STR      R0,[R1, #+0]
    205            }
    206          }
   \                     ??HASH_DMACmd_1:
   \   00000020   7047               BX       LR               ;; return
    207          
    208          /**
    209            * @brief  Writes data in the Data Input regiset (DIN).
    210            * @param  Data: new data of the message to be processed.
    211            * @retval None
    212            */

   \                                 In section .text, align 2, keep-with-next
    213          void HASH_DataIn(uint32_t Data)
    214          {
    215            /* Write in the DIN register a new data */
    216            HASH->DIN = Data;
   \                     HASH_DataIn:
   \   00000000   ....               LDR.N    R1,??DataTable11_2  ;; 0x50060404
   \   00000002   0860               STR      R0,[R1, #+0]
    217          }
   \   00000004   7047               BX       LR               ;; return
    218          
    219          /**
    220            * @brief  Provides the message digest result.
    221            * @note   In MD5 mode, Data[4] filed of HASH_MsgDigest structure is not used
    222            *         and is read as zero.  
    223            * @param  HASH_MessageDigest: pointer to a HASH_MsgDigest structure which will hold
    224            *   the message digest result 
    225            * @retval None
    226            */

   \                                 In section .text, align 2, keep-with-next
    227          void HASH_DataOut(HASH_MsgDigest* HASH_MessageDigest)
    228          {
    229            /* Get the data field */
    230            HASH_MessageDigest->Data[0] = HASH->HR[0];
   \                     HASH_DataOut:
   \   00000000   ....               LDR.N    R1,??DataTable11_3  ;; 0x5006040c
   \   00000002   0968               LDR      R1,[R1, #+0]
   \   00000004   0160               STR      R1,[R0, #+0]
    231            HASH_MessageDigest->Data[1] = HASH->HR[1];
   \   00000006   ....               LDR.N    R1,??DataTable11_4  ;; 0x50060410
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   4160               STR      R1,[R0, #+4]
    232            HASH_MessageDigest->Data[2] = HASH->HR[2];
   \   0000000C   ....               LDR.N    R1,??DataTable11_5  ;; 0x50060414
   \   0000000E   0968               LDR      R1,[R1, #+0]
   \   00000010   8160               STR      R1,[R0, #+8]
    233            HASH_MessageDigest->Data[3] = HASH->HR[3];
   \   00000012   ....               LDR.N    R1,??DataTable11_6  ;; 0x50060418
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   C160               STR      R1,[R0, #+12]
    234            HASH_MessageDigest->Data[4] = HASH->HR[4];
   \   00000018   ....               LDR.N    R1,??DataTable11_7  ;; 0x5006041c
   \   0000001A   0968               LDR      R1,[R1, #+0]
   \   0000001C   0161               STR      R1,[R0, #+16]
    235          }
   \   0000001E   7047               BX       LR               ;; return
    236          
    237          /**
    238            * @brief  Enables or disables the specified HASH interrupts.
    239            * @param  HASH_IT: specifies the HASH interrupt source to be enabled or disabled.
    240            *   This parameter can be any combination of the following values:
    241            *     @arg HASH_IT_DINI: Data Input interrupt
    242            *     @arg HASH_IT_DCI: Digest Calculation Completion Interrupt
    243            * @param  NewState: new state of the specified HASH interrupt.
    244            *   This parameter can be: ENABLE or DISABLE.
    245            * @retval None
    246            */

   \                                 In section .text, align 2, keep-with-next
    247          void HASH_ITConfig(uint8_t HASH_IT, FunctionalState NewState)
    248          {
    249            /* Check the parameters */
    250            assert_param(IS_HASH_IT(HASH_IT));
    251            assert_param(IS_FUNCTIONAL_STATE(NewState));
    252          
    253            if (NewState != DISABLE)
   \                     HASH_ITConfig:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   06D0               BEQ.N    ??HASH_ITConfig_0
    254            {
    255              /* Enable the selected HASH interrupt */
    256              HASH->IMR |= HASH_IT;
   \   00000006   ....               LDR.N    R1,??DataTable11_8  ;; 0x50060420
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0843               ORRS     R0,R0,R1
   \   0000000E   ....               LDR.N    R1,??DataTable11_8  ;; 0x50060420
   \   00000010   0860               STR      R0,[R1, #+0]
   \   00000012   06E0               B.N      ??HASH_ITConfig_1
    257            }
    258            else
    259            {
    260              /* Disable the selected HASH interrupt */
    261              HASH->IMR &= ~HASH_IT;
   \                     ??HASH_ITConfig_0:
   \   00000014   ....               LDR.N    R1,??DataTable11_8  ;; 0x50060420
   \   00000016   0968               LDR      R1,[R1, #+0]
   \   00000018   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   31EA0000           BICS     R0,R1,R0
   \   0000001E   ....               LDR.N    R1,??DataTable11_8  ;; 0x50060420
   \   00000020   0860               STR      R0,[R1, #+0]
    262            }
    263          }
   \                     ??HASH_ITConfig_1:
   \   00000022   7047               BX       LR               ;; return
    264          
    265          /**
    266            * @brief  Checks whether the specified HASH interrupt has occurred or not.
    267            * @param  HASH_IT: specifies the HASH interrupt source to check.
    268            *   This parameter can be one of the following values:
    269            *     @arg HASH_IT_DINI: Data Input interrupt
    270            *     @arg HASH_IT_DCI: Digest Calculation Completion Interrupt
    271            * @retval The new state of HASH_IT (SET or RESET).
    272            */

   \                                 In section .text, align 2, keep-with-next
    273          ITStatus HASH_GetITStatus(uint8_t HASH_IT)
    274          {
    275            ITStatus bitstatus = RESET;
   \                     HASH_GetITStatus:
   \   00000000   0021               MOVS     R1,#+0
    276            /* Check the parameters */
    277            assert_param(IS_HASH_GET_IT(HASH_IT));
    278          
    279            /* Check the status of the specified HASH interrupt */
    280            if ((HASH->SR & HASH_IT) != (uint8_t)RESET)
   \   00000002   ....               LDR.N    R2,??DataTable11_9  ;; 0x50060424
   \   00000004   1268               LDR      R2,[R2, #+0]
   \   00000006   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0242               TST      R2,R0
   \   0000000A   01D0               BEQ.N    ??HASH_GetITStatus_0
    281            {
    282              /* HASH_IT is set */
    283              bitstatus = SET;
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   00E0               B.N      ??HASH_GetITStatus_1
    284            }
    285            else
    286            {
    287              /* HASH_IT is reset */
    288              bitstatus = RESET;
   \                     ??HASH_GetITStatus_0:
   \   00000010   0021               MOVS     R1,#+0
    289            }
    290            /* Return the HASH_IT status */
    291            return bitstatus;
   \                     ??HASH_GetITStatus_1:
   \   00000012   0800               MOVS     R0,R1
   \   00000014   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   7047               BX       LR               ;; return
    292          }
    293          
    294          /**
    295            * @brief  Clears the HASH interrupt pending bit(s).
    296            * @param  HASH_IT: specifies the HASH interrupt pending bit(s) to clear.
    297            *   This parameter can be any combination of the following values:
    298            *     @arg HASH_IT_DINI: Data Input interrupt
    299            *     @arg HASH_IT_DCI: Digest Calculation Completion Interrupt
    300            * @retval None
    301            */

   \                                 In section .text, align 2, keep-with-next
    302          void HASH_ClearITPendingBit(uint8_t HASH_IT)
    303          {
    304            /* Check the parameters */
    305            assert_param(IS_HASH_IT(HASH_IT));
    306          
    307            /* Clear the selected HASH interrupt pending bit */
    308            HASH->SR = (uint8_t)~HASH_IT;
   \                     HASH_ClearITPendingBit:
   \   00000000   C043               MVNS     R0,R0
   \   00000002   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   ....               LDR.N    R1,??DataTable11_9  ;; 0x50060424
   \   00000006   0860               STR      R0,[R1, #+0]
    309          }
   \   00000008   7047               BX       LR               ;; return
    310          
    311          /**
    312            * @brief  Checks whether the specified HASH flag is set or not.
    313            * @param  HASH_FLAG: specifies the HASH flag to check.
    314            *   This parameter can be one of the following values:
    315            *     @arg HASH_FLAG_DINIS: Data input interrupt status flag
    316            *     @arg HASH_FLAG_DCIS: Digest calculation completion interrupt status flag
    317            *     @arg HASH_FLAG_BUSY: Busy flag
    318            *     @arg HASH_FLAG_DMAS: DMAS Status flag
    319            *     @arg HASH_FLAG_DINNE: Data Input regiset (DIN) not empty status flag
    320            * @retval The new state of HASH_FLAG (SET or RESET)
    321            */

   \                                 In section .text, align 2, keep-with-next
    322          FlagStatus HASH_GetFlagStatus(uint16_t HASH_FLAG)
    323          {
    324            FlagStatus bitstatus = RESET;
   \                     HASH_GetFlagStatus:
   \   00000000   0021               MOVS     R1,#+0
    325            uint32_t hashreg, tempreg = 0;
   \   00000002   0023               MOVS     R3,#+0
    326          
    327            /* Check the parameters */
    328            assert_param(IS_HASH_GET_FLAG(HASH_FLAG));
    329          
    330            /* Get the HASH register index */
    331            hashreg = (((uint16_t)HASH_FLAG) >> 12);
   \   00000004   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000006   020B               LSRS     R2,R0,#+12
   \   00000008   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
    332          
    333            if (hashreg == 0x01) /* The FLAG is in CR register */
   \   0000000A   012A               CMP      R2,#+1
   \   0000000C   02D1               BNE.N    ??HASH_GetFlagStatus_0
    334            {
    335              tempreg = HASH->CR;
   \   0000000E   ....               LDR.N    R1,??DataTable11  ;; 0x50060400
   \   00000010   0B68               LDR      R3,[R1, #+0]
   \   00000012   01E0               B.N      ??HASH_GetFlagStatus_1
    336            }
    337            else /* The FLAG is in SR register */
    338            {
    339              tempreg = HASH->SR;
   \                     ??HASH_GetFlagStatus_0:
   \   00000014   ....               LDR.N    R1,??DataTable11_9  ;; 0x50060424
   \   00000016   0B68               LDR      R3,[R1, #+0]
    340            }
    341          
    342            /* Check the status of the specified HASH flag */
    343            if ((tempreg & HASH_FLAG) != (uint8_t)RESET)
   \                     ??HASH_GetFlagStatus_1:
   \   00000018   1900               MOVS     R1,R3
   \   0000001A   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001C   0142               TST      R1,R0
   \   0000001E   01D0               BEQ.N    ??HASH_GetFlagStatus_2
    344            {
    345              /* HASH is set */
    346              bitstatus = SET;
   \   00000020   0121               MOVS     R1,#+1
   \   00000022   00E0               B.N      ??HASH_GetFlagStatus_3
    347            }
    348            else
    349            {
    350              /* HASH_FLAG is reset */
    351              bitstatus = RESET;
   \                     ??HASH_GetFlagStatus_2:
   \   00000024   0021               MOVS     R1,#+0
    352            }
    353          
    354            /* Return the HASH_FLAG status */
    355            return  bitstatus;
   \                     ??HASH_GetFlagStatus_3:
   \   00000026   0800               MOVS     R0,R1
   \   00000028   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   7047               BX       LR               ;; return
    356          }
    357          
    358          
    359          /**
    360            * @brief  Returns the number of words already pushed into the IN FIFO.
    361            * @param  None
    362            * @retval The value of words already pushed into the IN FIFO.
    363            */

   \                                 In section .text, align 2, keep-with-next
    364          uint8_t HASH_GetFIFOWordsNumber(void)
    365          {
    366            /* Return the value of NBW bits */
    367            return ((HASH->CR & HASH_CR_NBW) >> 8);
   \                     HASH_GetFIFOWordsNumber:
   \   00000000   ....               LDR.N    R0,??DataTable11  ;; 0x50060400
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   000A               LSRS     R0,R0,#+8
   \   00000006   10F00F00           ANDS     R0,R0,#0xF
   \   0000000A   7047               BX       LR               ;; return
    368          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   00040650           DC32     0x50060400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   08040650           DC32     0x50060408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   04040650           DC32     0x50060404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0C040650           DC32     0x5006040c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   10040650           DC32     0x50060410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   14040650           DC32     0x50060414

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   18040650           DC32     0x50060418

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   1C040650           DC32     0x5006041c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   20040650           DC32     0x50060420

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   24040650           DC32     0x50060424
    369          
    370          /**
    371            * @}
    372            */ 
    373          
    374          
    375          /**
    376            * @}
    377            */ 
    378          
    379          
    380          /**
    381            * @}
    382            */ 
    383          
    384          
    385          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                .cstack
     --------                -------
     HASH_ClearITPendingBit       0
     HASH_DMACmd                  0
     HASH_DataIn                  0
     HASH_DataOut                 0
     HASH_DeInit                  8
     HASH_GetFIFOWordsNumber      0
     HASH_GetFlagStatus           0
     HASH_GetITStatus             0
     HASH_ITConfig                0
     HASH_Init                    0
     HASH_NbValidBits             0
     HASH_Reset                   0
     HASH_Start                   0
     HASH_StructInit              0


   Section sizes:

     Function/Label          Bytes
     --------------          -----
     HASH_DeInit               20
     HASH_Init                 76
     HASH_StructInit           18
     HASH_Start                16
     HASH_Reset                14
     HASH_NbValidBits          26
     HASH_DMACmd               34
     HASH_DataIn                6
     HASH_DataOut              32
     HASH_ITConfig             36
     HASH_GetITStatus          24
     HASH_ClearITPendingBit    10
     HASH_GetFlagStatus        44
     HASH_GetFIFOWordsNumber   12
     ??DataTable11              4
     ??DataTable11_1            4
     ??DataTable11_2            4
     ??DataTable11_3            4
     ??DataTable11_4            4
     ??DataTable11_5            4
     ??DataTable11_6            4
     ??DataTable11_7            4
     ??DataTable11_8            4
     ??DataTable11_9            4

 
 408 bytes in section .text
 
 408 bytes of CODE memory

Errors: none
Warnings: none
