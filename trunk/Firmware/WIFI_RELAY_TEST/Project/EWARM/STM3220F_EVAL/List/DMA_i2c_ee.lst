###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     14/Sep/2011  14:26:11 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\DMA_i2c #
#                    _ee.c                                                    #
#    Command line =  "E:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\DMA_i2 #
#                    c_ee.c" -D USE_STDPERIPH_DRIVER -D STM32F2XX -D          #
#                    USE_STM3220F_EVAL -D USE_USB_OTG_FS -D                   #
#                    RTC_CLOCK_SOURCE_LSE -lC "E:\¹¬ÀÛ¾÷\[ NewDTG             #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\STM3220F_EVAL\List\" #
#                     -lA "E:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\E #
#                    WARM\STM3220F_EVAL\List\" -o "E:\¹¬ÀÛ¾÷\[ NewDTG         #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\STM3220F_EVAL\Obj\"  #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0\arm\INC\c\DLib_Config_Full.h" -I           #
#                    "E:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\" -I "E:\¹¬ÀÛ¾÷\[ NewDTG                              #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\CMSI #
#                    S\CM3\CoreSupport\" -I "E:\¹¬ÀÛ¾÷\[ NewDTG               #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\CMSI #
#                    S\CM3\DeviceSupport\ST\STM32F2xx\" -I "E:\¹¬ÀÛ¾÷\[       #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Librari #
#                    es\STM32F2xx_StdPeriph_Driver\inc\" -I "E:\¹¬ÀÛ¾÷\[      #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utiliti #
#                    es\STM32_EVAL\" -I "E:\¹¬ÀÛ¾÷\[ NewDTG                   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\Common\" -I "E:\¹¬ÀÛ¾÷\[ NewDTG                   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\STM3220F_EVAL\" -I "E:\¹¬ÀÛ¾÷\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_OTG_Driver\inc\" -I "E:\¹¬ÀÛ¾÷\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Core\inc\" -I "E:\¹¬ÀÛ¾÷\[ NewDTG   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Class\msc\inc\" -I "E:\¹¬ÀÛ¾÷\[     #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\" -I   #
#                    "E:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\Usb\Inc\" -I "E:\¹¬ÀÛ¾÷\[ NewDTG                      #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\src\" -I      #
#                    "E:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Core\inc\" -I     #
#                    "E:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\"   #
#                    -On --use_c++_inline                                     #
#    List file    =  E:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\List\DMA_i2c_ee.lst                         #
#    Object file  =  E:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\Obj\DMA_i2c_ee.o                            #
#                                                                             #
#                                                                             #
###############################################################################

E:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\DMA_i2c_ee.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm322xg_eval_i2c_ee.c
      4            * @author  MCD Application Team
      5            * @version V4.6.1
      6            * @date    18-April-2011
      7            * @brief   This file provides a set of functions needed to manage the I2C M24CXX 
      8            *          EEPROM memory mounted on STM322xG-EVAL evaluation board(MB786) RevA
      9            *          and RevB.
     10            *          
     11            *          ===================================================================      
     12            *          Note: This driver is intended for STM32F2xx families devices only.
     13            *          ===================================================================
     14            *              
     15            *          It implements a high level communication layer for read and write 
     16            *          from/to this memory. The needed STM32 hardware resources (I2C and 
     17            *          GPIO) are defined in stm322xg_eval.h file, and the initialization is 
     18            *          performed in sEE_LowLevel_Init() function declared in stm322xg_eval.c 
     19            *          file.
     20            *          You can easily tailor this driver to any other development board, 
     21            *          by just adapting the defines for hardware resources and 
     22            *          sEE_LowLevel_Init() function. 
     23            *        
     24            *          @note In this driver, basic read and write functions (sEE_ReadBuffer() 
     25            *                and sEE_WritePage()) use the DMA to perform the data transfer 
     26            *                to/from EEPROM memory (except when number of requested data is
     27            *                equal to 1). Thus, after calling these two functions, user 
     28            *                application may perform other tasks while DMA is transferring
     29            *                data. The application should then monitor the variable holding 
     30            *                the number of data in order to determine when the transfer is
     31            *                completed (variable decremented to 0). Stopping transfer tasks
     32            *                are performed into DMA interrupt handlers (which are integrated
     33            *                into this driver).
     34            *            
     35            *     +-----------------------------------------------------------------+
     36            *     |                        Pin assignment                           |                 
     37            *     +---------------------------------------+-----------+-------------+
     38            *     |  STM32 I2C Pins                       |   sEE     |   Pin       |
     39            *     +---------------------------------------+-----------+-------------+
     40            *     | .                                     |   E0(GND) |    1  (0V)  |
     41            *     | .                                     |   E1(GND) |    2  (0V)  |
     42            *     | .                                     |   E2(GND) |    3  (0V)  |
     43            *     | .                                     |   E0(VSS) |    4  (0V)  |
     44            *     | EE_I2C_SDA_PIN/ SDA                  |   SDA     |    5        |
     45            *     | EE_I2C_SCL_PIN/ SCL                  |   SCL     |    6        |
     46            *     | .                                     |   /WC(VDD)|    7 (3.3V) |
     47            *     | .                                     |   VDD     |    8 (3.3V) |
     48            *     +---------------------------------------+-----------+-------------+  
     49            ******************************************************************************
     50            * @attention
     51            *
     52            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     53            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     54            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     55            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     56            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     57            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     58            *
     59            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     60            ******************************************************************************  
     61            */ 
     62          
     63          /* Includes ------------------------------------------------------------------*/
     64          #include "DMA_i2c_ee.h"
     65          
     66          /** @addtogroup Utilities
     67            * @{
     68            */
     69            
     70          /** @addtogroup STM32_EVAL
     71            * @{
     72            */ 
     73          
     74          /** @addtogroup STM322xG_EVAL
     75            * @{
     76            */
     77            
     78          /** @addtogroup STM322xG_EVAL_I2C_EE
     79            * @brief      This file includes the I2C EEPROM driver of STM32-EVAL boards.
     80            * @{
     81            */ 
     82          
     83          /** @defgroup STM322xG_EVAL_I2C_EE_Private_Types
     84            * @{
     85            */ 
     86          /**
     87            * @}
     88            */ 
     89          
     90          
     91          /** @defgroup STM322xG_EVAL_I2C_EE_Private_Defines
     92            * @{
     93            */  
     94          /**
     95            * @}
     96            */ 
     97          
     98          
     99          /** @defgroup STM322xG_EVAL_I2C_EE_Private_Macros
    100            * @{
    101            */
    102          /**
    103            * @}
    104            */ 
    105            
    106          
    107          /** @defgroup STM322xG_EVAL_I2C_EE_Private_Variables
    108            * @{
    109            */
    110          __IO uint16_t  sEEAddress = 0;   
    111          __IO uint32_t  sEETimeout = sEE_LONG_TIMEOUT;   
    112          __IO uint16_t* sEEDataReadPointer;   
    113          __IO uint8_t*  sEEDataWritePointer;  
    114          __IO uint8_t   sEEDataNum;
    115          /**
    116            * @}
    117            */ 
    118          
    119          
    120          /** @defgroup STM322xG_EVAL_I2C_EE_Private_Function_Prototypes
    121            * @{
    122            */ 
    123          /**
    124            * @}
    125            */ 
    126          
    127          
    128          /** @defgroup STM322xG_EVAL_I2C_EE_Private_Functions
    129            * @{
    130            */ 
    131          
    132          /**
    133            * @brief  DeInitializes peripherals used by the I2C EEPROM driver.
    134            * @param  None
    135            * @retval None
    136            */
    137          void sEE_DeInit(void)
    138          {
    139            sEE_LowLevel_DeInit(); 
                   ^
Warning[Pe223]: function "sEE_LowLevel_DeInit" declared implicitly
    140          }
    141          
    142          /**
    143            * @brief  Initializes peripherals used by the I2C EEPROM driver.
    144            * @param  None
    145            * @retval None
    146            */
    147          void sEE_Init(void)
    148          { 
    149            I2C_InitTypeDef  I2C_InitStructure;
    150            
    151            sEE_LowLevel_Init();
                   ^
Warning[Pe223]: function "sEE_LowLevel_Init" declared implicitly
    152            
    153            /*!< I2C configuration */
    154            /* EE_I2C configuration */
    155            I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
    156            I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
    157            I2C_InitStructure.I2C_OwnAddress1 = I2C_SLAVE_ADDRESS7;
    158            I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
    159            I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
    160            I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;
    161            
    162            /* EE_I2C Peripheral Enable */
    163            I2C_Cmd(EE_I2C, ENABLE);
    164            /* Apply EE_I2C configuration after enabling it */
    165            I2C_Init(EE_I2C, &I2C_InitStructure);
    166          
    167            /* Enable the EE_I2C peripheral DMA requests */
    168            I2C_DMACmd(EE_I2C, ENABLE);
    169            
    170          #if defined (sEE_M24C64_32)
    171            /*!< Select the EEPROM address according to the state of E0, E1, E2 pins */
    172            sEEAddress = sEE_HW_ADDRESS;  
    173          #elif defined (sEE_M24C08)
    174            /*!< depending on the sEE Address selected in the stm322xg_eval_i2c_ee.h file */
    175           #ifdef sEE_Block0_ADDRESS
    176            /*!< Select the sEE Block0 to write on */
    177            sEEAddress = sEE_Block0_ADDRESS;
    178           #endif
    179            
    180           #ifdef sEE_Block1_ADDRESS
    181            /*!< Select the sEE Block1 to write on */
    182            sEEAddress = sEE_Block1_ADDRESS;
    183           #endif
    184          
    185           #ifdef sEE_Block2_ADDRESS
    186            /*!< Select the sEE Block2 to write on */
    187            sEEAddress = sEE_Block2_ADDRESS;
    188           #endif
    189            
    190           #ifdef sEE_Block3_ADDRESS
    191            /*!< Select the sEE Block3 to write on */
    192            sEEAddress = sEE_Block3_ADDRESS;
    193           #endif 
    194          #endif /*!< sEE_M24C64_32 */    
    195          }
    196          
    197          /**
    198            * @brief  Reads a block of data from the EEPROM.
    199            * @param  pBuffer : pointer to the buffer that receives the data read from 
    200            *         the EEPROM.
    201            * @param  ReadAddr : EEPROM's internal address to start reading from.
    202            * @param  NumByteToRead : pointer to the variable holding number of bytes to 
    203            *         be read from the EEPROM.
    204            * 
    205            *        @note The variable pointed by NumByteToRead is reset to 0 when all the 
    206            *              data are read from the EEPROM. Application should monitor this 
    207            *              variable in order know when the transfer is complete.
    208            * 
    209            * @note When number of data to be read is higher than 1, this function just 
    210            *       configures the communication and enable the DMA channel to transfer data.
    211            *       Meanwhile, the user application may perform other tasks.
    212            *       When number of data to be read is 1, then the DMA is not used. The byte
    213            *       is read in polling mode.
    214            * 
    215            * @retval sEE_OK (0) if operation is correctly performed, else return value 
    216            *         different from sEE_OK (0) or the timeout user callback.
    217            */
    218          uint32_t sEE_ReadBuffer(uint8_t* pBuffer, uint16_t ReadAddr, uint16_t* NumByteToRead)
    219          {  
    220            /* Set the pointer to the Number of data to be read. This pointer will be used 
    221                by the DMA Transfer Completer interrupt Handler in order to reset the 
    222                variable to 0. User should check on this variable in order to know if the 
    223                DMA transfer has been complete or not. */
    224            sEEDataReadPointer = NumByteToRead;
    225            
    226            /*!< While the bus is busy */
    227            sEETimeout = sEE_LONG_TIMEOUT;
    228            while(I2C_GetFlagStatus(EE_I2C, I2C_FLAG_BUSY))
    229            {
    230              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
    231            }
    232            
    233            /*!< Send START condition */
    234            I2C_GenerateSTART(EE_I2C, ENABLE);
    235            
    236            /*!< Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
    237            sEETimeout = sEE_FLAG_TIMEOUT;
    238            while(!I2C_CheckEvent(EE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
    239            {
    240              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
    241            }
    242            
    243            /*!< Send EEPROM address for write */
    244            I2C_Send7bitAddress(EE_I2C, sEEAddress, I2C_Direction_Transmitter);
    245          
    246            /*!< Test on EV6 and clear it */
    247            sEETimeout = sEE_FLAG_TIMEOUT;
    248            while(!I2C_CheckEvent(EE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
    249            {
    250              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
    251            } 
    252          
    253          #ifdef sEE_M24C08  
    254            
    255            /*!< Send the EEPROM's internal address to read from: Only one byte address */
    256            I2C_SendData(EE_I2C, ReadAddr);  
    257          
    258          #elif defined (sEE_M24C64_32)
    259          
    260            /*!< Send the EEPROM's internal address to read from: MSB of the address first */
    261            I2C_SendData(EE_I2C, (uint8_t)((ReadAddr & 0xFF00) >> 8));    
    262          
    263            /*!< Test on EV8 and clear it */
    264            sEETimeout = sEE_FLAG_TIMEOUT;
    265            while(!I2C_CheckEvent(EE_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING))
    266            {
    267              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
    268            }
    269          
    270            /*!< Send the EEPROM's internal address to read from: LSB of the address */
    271            I2C_SendData(EE_I2C, (uint8_t)(ReadAddr & 0x00FF));    
    272            
    273          #endif /*!< sEE_M24C08 */
    274          
    275            /*!< Test on EV8 and clear it */
    276            sEETimeout = sEE_FLAG_TIMEOUT;
    277            while(I2C_GetFlagStatus(EE_I2C, I2C_FLAG_BTF) == RESET)
    278            {
    279              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
    280            }
    281            
    282            /*!< Send STRAT condition a second time */  
    283            I2C_GenerateSTART(EE_I2C, ENABLE);
    284            
    285            /*!< Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
    286            sEETimeout = sEE_FLAG_TIMEOUT;
    287            while(!I2C_CheckEvent(EE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
    288            {
    289              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
    290            } 
    291            
    292            /*!< Send EEPROM address for read */
    293            I2C_Send7bitAddress(EE_I2C, sEEAddress, I2C_Direction_Receiver);  
    294            
    295            /* If number of data to be read is 1, then DMA couldn't be used */
    296            /* One Byte Master Reception procedure (POLLING) ---------------------------*/
    297            if ((uint16_t)(*NumByteToRead) < 2)
    298            {
    299              /* Wait on ADDR flag to be set (ADDR is still not cleared at this level */
    300              sEETimeout = sEE_FLAG_TIMEOUT;
    301              while(I2C_GetFlagStatus(EE_I2C, I2C_FLAG_ADDR) == RESET)
    302              {
    303                if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
    304              }     
    305              
    306              /*!< Disable Acknowledgment */
    307              I2C_AcknowledgeConfig(EE_I2C, DISABLE);   
    308              
    309              /* Clear ADDR register by reading SR1 then SR2 register (SR1 has already been read) */
    310              (void)EE_I2C->SR2;
    311              
    312              /*!< Send STOP Condition */
    313              I2C_GenerateSTOP(EE_I2C, ENABLE);
    314              
    315              /* Wait for the byte to be received */
    316              sEETimeout = sEE_FLAG_TIMEOUT;
    317              while(I2C_GetFlagStatus(EE_I2C, I2C_FLAG_RXNE) == RESET)
    318              {
    319                if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
    320              }
    321              
    322              /*!< Read the byte received from the EEPROM */
    323              *pBuffer = I2C_ReceiveData(EE_I2C);
    324              
    325              /*!< Decrement the read bytes counter */
    326              (uint16_t)(*NumByteToRead)--;        
    327              
    328              /* Wait to make sure that STOP control bit has been cleared */
    329              sEETimeout = sEE_FLAG_TIMEOUT;
    330              while(EE_I2C->CR1 & I2C_CR1_STOP)
    331              {
    332                if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
    333              }  
    334              
    335              /*!< Re-Enable Acknowledgment to be ready for another reception */
    336              I2C_AcknowledgeConfig(EE_I2C, ENABLE);    
    337            }
    338            else/* More than one Byte Master Reception procedure (DMA) -----------------*/
    339            {
    340              /*!< Test on EV6 and clear it */
    341              sEETimeout = sEE_FLAG_TIMEOUT;
    342              while(!I2C_CheckEvent(EE_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
    343              {
    344                if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
    345              }  
    346              
    347              /* Configure the DMA Rx Channel with the buffer address and the buffer size */
    348              sEE_LowLevel_DMAConfig((uint32_t)pBuffer, (uint16_t)(*NumByteToRead), sEE_DIRECTION_RX);
                     ^
Warning[Pe223]: function "sEE_LowLevel_DMAConfig" declared implicitly
    349              
    350              /* Inform the DMA that the next End Of Transfer Signal will be the last one */
    351              I2C_DMALastTransferCmd(EE_I2C, ENABLE); 
    352              
    353              /* Enable the DMA Rx Stream */
    354              DMA_Cmd(sEE_I2C_DMA_STREAM_RX, ENABLE);    
                             ^
Error[Pe020]: identifier "sEE_I2C_DMA_STREAM_RX" is undefined
    355            }
    356            
    357            /* If all operations OK, return sEE_OK (0) */
    358            return sEE_OK;
    359          }
    360          
    361          /**
    362            * @brief  Writes more than one byte to the EEPROM with a single WRITE cycle.
    363            *
    364            * @note   The number of bytes (combined to write start address) must not 
    365            *         cross the EEPROM page boundary. This function can only write into
    366            *         the boundaries of an EEPROM page.
    367            *         This function doesn't check on boundaries condition (in this driver 
    368            *         the function sEE_WriteBuffer() which calls sEE_WritePage() is 
    369            *         responsible of checking on Page boundaries).
    370            * 
    371            * @param  pBuffer : pointer to the buffer containing the data to be written to 
    372            *         the EEPROM.
    373            * @param  WriteAddr : EEPROM's internal address to write to.
    374            * @param  NumByteToWrite : pointer to the variable holding number of bytes to 
    375            *         be written into the EEPROM. 
    376            * 
    377            *        @note The variable pointed by NumByteToWrite is reset to 0 when all the 
    378            *              data are written to the EEPROM. Application should monitor this 
    379            *              variable in order know when the transfer is complete.
    380            * 
    381            * @note This function just configure the communication and enable the DMA 
    382            *       channel to transfer data. Meanwhile, the user application may perform 
    383            *       other tasks in parallel.
    384            * 
    385            * @retval sEE_OK (0) if operation is correctly performed, else return value 
    386            *         different from sEE_OK (0) or the timeout user callback.
    387            */
    388          uint32_t sEE_WritePage(uint8_t* pBuffer, uint16_t WriteAddr, uint8_t* NumByteToWrite)
    389          { 
    390            /* Set the pointer to the Number of data to be written. This pointer will be used 
    391                by the DMA Transfer Completer interrupt Handler in order to reset the 
    392                variable to 0. User should check on this variable in order to know if the 
    393                DMA transfer has been complete or not. */
    394            sEEDataWritePointer = NumByteToWrite;  
    395            
    396            /*!< While the bus is busy */
    397            sEETimeout = sEE_LONG_TIMEOUT;
    398            while(I2C_GetFlagStatus(EE_I2C, I2C_FLAG_BUSY))
    399            {
    400              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
    401            }
    402            
    403            /*!< Send START condition */
    404            I2C_GenerateSTART(EE_I2C, ENABLE);
    405            
    406            /*!< Test on EV5 and clear it */
    407            sEETimeout = sEE_FLAG_TIMEOUT;
    408            while(!I2C_CheckEvent(EE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
    409            {
    410              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
    411            }
    412            
    413            /*!< Send EEPROM address for write */
    414            sEETimeout = sEE_FLAG_TIMEOUT;
    415            I2C_Send7bitAddress(EE_I2C, sEEAddress, I2C_Direction_Transmitter);
    416          
    417            /*!< Test on EV6 and clear it */
    418            sEETimeout = sEE_FLAG_TIMEOUT;
    419            while(!I2C_CheckEvent(EE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
    420            {
    421              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
    422            }
    423          
    424          #ifdef sEE_M24C08
    425            
    426            /*!< Send the EEPROM's internal address to write to : only one byte Address */
    427            I2C_SendData(EE_I2C, WriteAddr);
    428            
    429          #elif defined(sEE_M24C64_32)
    430            
    431            /*!< Send the EEPROM's internal address to write to : MSB of the address first */
    432            I2C_SendData(EE_I2C, (uint8_t)((WriteAddr & 0xFF00) >> 8));
    433          
    434            /*!< Test on EV8 and clear it */
    435            sEETimeout = sEE_FLAG_TIMEOUT;  
    436            while(!I2C_CheckEvent(EE_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING))
    437            {
    438              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
    439            }  
    440            
    441            /*!< Send the EEPROM's internal address to write to : LSB of the address */
    442            I2C_SendData(EE_I2C, (uint8_t)(WriteAddr & 0x00FF));
    443            
    444          #endif /*!< sEE_M24C08 */  
    445            
    446            /*!< Test on EV8 and clear it */
    447            sEETimeout = sEE_FLAG_TIMEOUT; 
    448            while(!I2C_CheckEvent(EE_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTING))
    449            {
    450              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
    451            }  
    452            
    453            /* Configure the DMA Tx Channel with the buffer address and the buffer size */
    454            sEE_LowLevel_DMAConfig((uint32_t)pBuffer, (uint8_t)(*NumByteToWrite), sEE_DIRECTION_TX);
                   ^
Warning[Pe223]: function "sEE_LowLevel_DMAConfig" declared implicitly
    455            
    456            /* Enable the DMA Tx Stream */
    457            DMA_Cmd(sEE_I2C_DMA_STREAM_TX, ENABLE);
                           ^
Error[Pe020]: identifier "sEE_I2C_DMA_STREAM_TX" is undefined
    458            
    459            /* If all operations OK, return sEE_OK (0) */
    460            return sEE_OK;
    461          }
    462          
    463          /**
    464            * @brief  Writes buffer of data to the I2C EEPROM.
    465            * @param  pBuffer : pointer to the buffer  containing the data to be written 
    466            *         to the EEPROM.
    467            * @param  WriteAddr : EEPROM's internal address to write to.
    468            * @param  NumByteToWrite : number of bytes to write to the EEPROM.
    469            * @retval None
    470            */
    471          void sEE_WriteBuffer(uint8_t* pBuffer, uint16_t WriteAddr, uint16_t NumByteToWrite)
    472          {
    473            uint8_t NumOfPage = 0, NumOfSingle = 0, count = 0;
    474            uint16_t Addr = 0;
    475          
    476            Addr = WriteAddr % sEE_PAGESIZE;
    477            count = sEE_PAGESIZE - Addr;
    478            NumOfPage =  NumByteToWrite / sEE_PAGESIZE;
    479            NumOfSingle = NumByteToWrite % sEE_PAGESIZE;
    480           
    481            /*!< If WriteAddr is sEE_PAGESIZE aligned  */
    482            if(Addr == 0) 
    483            {
    484              /*!< If NumByteToWrite < sEE_PAGESIZE */
    485              if(NumOfPage == 0) 
    486              {
    487                /* Store the number of data to be written */
    488                sEEDataNum = NumOfSingle;
    489                /* Start writing data */
    490                sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
    491                /* Wait transfer through DMA to be complete */
    492                sEETimeout = sEE_LONG_TIMEOUT;
    493                while (sEEDataNum > 0)
    494                {
    495                  if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
    496                }
    497                sEE_WaitEepromStandbyState();
    498              }
    499              /*!< If NumByteToWrite > sEE_PAGESIZE */
    500              else  
    501              {
    502                while(NumOfPage--)
    503                {
    504                  /* Store the number of data to be written */
    505                  sEEDataNum = sEE_PAGESIZE;        
    506                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum)); 
    507                  /* Wait transfer through DMA to be complete */
    508                  sEETimeout = sEE_LONG_TIMEOUT;
    509                  while (sEEDataNum > 0)
    510                  {
    511                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
    512                  }      
    513                  sEE_WaitEepromStandbyState();
    514                  WriteAddr +=  sEE_PAGESIZE;
    515                  pBuffer += sEE_PAGESIZE;
    516                }
    517          
    518                if(NumOfSingle!=0)
    519                {
    520                  /* Store the number of data to be written */
    521                  sEEDataNum = NumOfSingle;          
    522                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
    523                  /* Wait transfer through DMA to be complete */
    524                  sEETimeout = sEE_LONG_TIMEOUT;
    525                  while (sEEDataNum > 0)
    526                  {
    527                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
    528                  }    
    529                  sEE_WaitEepromStandbyState();
    530                }
    531              }
    532            }
    533            /*!< If WriteAddr is not sEE_PAGESIZE aligned  */
    534            else 
    535            {
    536              /*!< If NumByteToWrite < sEE_PAGESIZE */
    537              if(NumOfPage== 0) 
    538              {
    539                /*!< If the number of data to be written is more than the remaining space 
    540                in the current page: */
    541                if (NumByteToWrite > count)
    542                {
    543                  /* Store the number of data to be written */
    544                  sEEDataNum = count;        
    545                  /*!< Write the data contained in same page */
    546                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
    547                  /* Wait transfer through DMA to be complete */
    548                  sEETimeout = sEE_LONG_TIMEOUT;
    549                  while (sEEDataNum > 0)
    550                  {
    551                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
    552                  }          
    553                  sEE_WaitEepromStandbyState();      
    554                  
    555                  /* Store the number of data to be written */
    556                  sEEDataNum = (NumByteToWrite - count);          
    557                  /*!< Write the remaining data in the following page */
    558                  sEE_WritePage((uint8_t*)(pBuffer + count), (WriteAddr + count), (uint8_t*)(&sEEDataNum));
    559                  /* Wait transfer through DMA to be complete */
    560                  sEETimeout = sEE_LONG_TIMEOUT;
    561                  while (sEEDataNum > 0)
    562                  {
    563                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
    564                  }     
    565                  sEE_WaitEepromStandbyState();        
    566                }      
    567                else      
    568                {
    569                  /* Store the number of data to be written */
    570                  sEEDataNum = NumOfSingle;         
    571                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
    572                  /* Wait transfer through DMA to be complete */
    573                  sEETimeout = sEE_LONG_TIMEOUT;
    574                  while (sEEDataNum > 0)
    575                  {
    576                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
    577                  }          
    578                  sEE_WaitEepromStandbyState();        
    579                }     
    580              }
    581              /*!< If NumByteToWrite > sEE_PAGESIZE */
    582              else
    583              {
    584                NumByteToWrite -= count;
    585                NumOfPage =  NumByteToWrite / sEE_PAGESIZE;
    586                NumOfSingle = NumByteToWrite % sEE_PAGESIZE;
    587                
    588                if(count != 0)
    589                {  
    590                  /* Store the number of data to be written */
    591                  sEEDataNum = count;         
    592                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
    593                  /* Wait transfer through DMA to be complete */
    594                  sEETimeout = sEE_LONG_TIMEOUT;
    595                  while (sEEDataNum > 0)
    596                  {
    597                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
    598                  }     
    599                  sEE_WaitEepromStandbyState();
    600                  WriteAddr += count;
    601                  pBuffer += count;
    602                } 
    603                
    604                while(NumOfPage--)
    605                {
    606                  /* Store the number of data to be written */
    607                  sEEDataNum = sEE_PAGESIZE;          
    608                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
    609                  /* Wait transfer through DMA to be complete */
    610                  sEETimeout = sEE_LONG_TIMEOUT;
    611                  while (sEEDataNum > 0)
    612                  {
    613                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
    614                  }        
    615                  sEE_WaitEepromStandbyState();
    616                  WriteAddr +=  sEE_PAGESIZE;
    617                  pBuffer += sEE_PAGESIZE;  
    618                }
    619                if(NumOfSingle != 0)
    620                {
    621                  /* Store the number of data to be written */
    622                  sEEDataNum = NumOfSingle;           
    623                  sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum)); 
    624                  /* Wait transfer through DMA to be complete */
    625                  sEETimeout = sEE_LONG_TIMEOUT;
    626                  while (sEEDataNum > 0)
    627                  {
    628                    if((sEETimeout--) == 0) {sEE_TIMEOUT_UserCallback(); return;};
    629                  }         
    630                  sEE_WaitEepromStandbyState();
    631                }
    632              }
    633            }  
    634          }
    635          
    636          /**
    637            * @brief  Wait for EEPROM Standby state.
    638            * 
    639            * @note  This function allows to wait and check that EEPROM has finished the 
    640            *        last operation. It is mostly used after Write operation: after receiving
    641            *        the buffer to be written, the EEPROM may need additional time to actually
    642            *        perform the write operation. During this time, it doesn't answer to
    643            *        I2C packets addressed to it. Once the write operation is complete
    644            *        the EEPROM responds to its address.
    645            * 
    646            * @param  None
    647            * @retval sEE_OK (0) if operation is correctly performed, else return value 
    648            *         different from sEE_OK (0) or the timeout user callback.
    649            */
    650          uint32_t sEE_WaitEepromStandbyState(void)      
    651          {
    652            __IO uint16_t tmpSR1 = 0;
    653            __IO uint32_t sEETrials = 0;
    654          
    655            /*!< While the bus is busy */
    656            sEETimeout = sEE_LONG_TIMEOUT;
    657            while(I2C_GetFlagStatus(EE_I2C, I2C_FLAG_BUSY))
    658            {
    659              if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
    660            }
    661          
    662            /* Keep looping till the slave acknowledge his address or maximum number 
    663               of trials is reached (this number is defined by sEE_MAX_TRIALS_NUMBER define
    664               in stm322xg_eval_i2c_ee.h file) */
    665            while (1)
    666            {
    667              /*!< Send START condition */
    668              I2C_GenerateSTART(EE_I2C, ENABLE);
    669          
    670              /*!< Test on EV5 and clear it */
    671              sEETimeout = sEE_FLAG_TIMEOUT;
    672              while(!I2C_CheckEvent(EE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
    673              {
    674                if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
    675              }    
    676          
    677              /*!< Send EEPROM address for write */
    678              I2C_Send7bitAddress(EE_I2C, sEEAddress, I2C_Direction_Transmitter);
    679              
    680              /* Wait for ADDR flag to be set (Slave acknowledged his address) */
    681              sEETimeout = sEE_LONG_TIMEOUT;
    682              do
    683              {     
    684                /* Get the current value of the SR1 register */
    685                tmpSR1 = EE_I2C->SR1;
    686                
    687                /* Update the timeout value and exit if it reach 0 */
    688                if((sEETimeout--) == 0) return sEE_TIMEOUT_UserCallback();
    689              }
    690              /* Keep looping till the Address is acknowledged or the AF flag is 
    691                 set (address not acknowledged at time) */
    692              while((tmpSR1 & (I2C_SR1_ADDR | I2C_SR1_AF)) == 0);
    693               
    694              /* Check if the ADDR flag has been set */
    695              if (tmpSR1 & I2C_SR1_ADDR)
    696              {
    697                /* Clear ADDR Flag by reading SR1 then SR2 registers (SR1 have already 
    698                   been read) */
    699                (void)EE_I2C->SR2;
    700                
    701                /*!< STOP condition */    
    702                I2C_GenerateSTOP(EE_I2C, ENABLE);
    703                  
    704                /* Exit the function */
    705                return sEE_OK;
    706              }
    707              else
    708              {
    709                /*!< Clear AF flag */
    710                I2C_ClearFlag(EE_I2C, I2C_FLAG_AF);                  
    711              }
    712              
    713              /* Check if the maximum allowed number of trials has bee reached */
    714              if (sEETrials++ == sEE_MAX_TRIALS_NUMBER)
    715              {
    716                /* If the maximum number of trials has been reached, exit the function */
    717                return sEE_TIMEOUT_UserCallback();
    718              }
    719            }
    720          }
    721          
    722          /**
    723            * @brief  This function handles the DMA Tx Channel interrupt Handler.
    724            * @param  None
    725            * @retval None
    726            */
    727          void EE_I2C_DMA_TX_IRQHandler(void)
    728          {
    729            /* Check if the DMA transfer is complete */
    730            if(DMA_GetFlagStatus(sEE_I2C_DMA_STREAM_TX, sEE_TX_DMA_FLAG_TCIF) != RESET)
                                        ^
Error[Pe020]: identifier "sEE_I2C_DMA_STREAM_TX" is undefined
    731            {  
    732              /* Disable the DMA Tx Stream and Clear TC flag */  
    733              DMA_Cmd(EE_I2C_DMA_STREAM_TX, DISABLE);
                             ^
Error[Pe020]: identifier "EE_I2C_DMA_STREAM_TX" is undefined
    734              DMA_ClearFlag(EE_I2C_DMA_STREAM_TX, sEE_TX_DMA_FLAG_TCIF);
    735          
    736              /*!< Wait till all data have been physically transferred on the bus */
    737              sEETimeout = sEE_LONG_TIMEOUT;
    738              while(!I2C_GetFlagStatus(EE_I2C, I2C_FLAG_BTF))
    739              {
    740                if((sEETimeout--) == 0) sEE_TIMEOUT_UserCallback();
    741              }
    742              
    743              /*!< Send STOP condition */
    744              I2C_GenerateSTOP(EE_I2C, ENABLE);
    745              
    746              /* Reset the variable holding the number of data to be written */
    747              *sEEDataWritePointer = 0;  
    748            }
    749          }
    750          
    751          /**
    752            * @brief  This function handles the DMA Rx Channel interrupt Handler.
    753            * @param  None
    754            * @retval None
    755            */
    756          void EE_I2C_DMA_RX_IRQHandler(void)
    757          {
    758            /* Check if the DMA transfer is complete */
    759            if(DMA_GetFlagStatus(EE_I2C_DMA_STREAM_RX, sEE_RX_DMA_FLAG_TCIF) != RESET)
                                        ^
Error[Pe020]: identifier "EE_I2C_DMA_STREAM_RX" is undefined
    760            {      
    761              /*!< Send STOP Condition */
    762              I2C_GenerateSTOP(EE_I2C, ENABLE);    
    763              
    764              /* Disable the DMA Rx Stream and Clear TC Flag */  
    765              DMA_Cmd(EE_I2C_DMA_STREAM_RX, DISABLE);
    766              DMA_ClearFlag(EE_I2C_DMA_STREAM_RX, sEE_RX_DMA_FLAG_TCIF);
    767              
    768              /* Reset the variable holding the number of data to be read */
    769              *sEEDataReadPointer = 0;
    770            }
    771          }
    772          
    773          #ifdef USE_DEFAULT_TIMEOUT_CALLBACK
    774          /**
    775            * @brief  Basic management of the timeout situation.
    776            * @param  None.
    777            * @retval None.
    778            */
    779          uint32_t sEE_TIMEOUT_UserCallback(void)
    780          {
    781            /* Block communication and all processes */
    782            while (1)
    783            {   
    784            }
    785          }
    786          #endif /* USE_DEFAULT_TIMEOUT_CALLBACK */
    787          
    788          /**
    789            * @}
    790            */
    791          
    792          /**
    793            * @}
    794            */
    795          
    796          /**
    797            * @}
    798            */
    799          
    800          /**
    801            * @}
    802            */
    803          
    804          /**
    805            * @}
    806            */  
    807          
    808          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

Errors: 5
Warnings: 4
