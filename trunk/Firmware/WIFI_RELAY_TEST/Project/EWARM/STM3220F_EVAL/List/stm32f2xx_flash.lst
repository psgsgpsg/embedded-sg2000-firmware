###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     12/Nov/2011  19:31:38 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Libraries\STM32 #
#                    F2xx_StdPeriph_Driver\src\stm32f2xx_flash.c              #
#    Command line =  "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Libraries\STM3 #
#                    2F2xx_StdPeriph_Driver\src\stm32f2xx_flash.c" -D         #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D RTC_CLOCK_SOURCE_LSE -lC            #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    STM3220F_EVAL\List\" -lA "F:\¹¬ÀÛ¾÷\[ NewDTG             #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\STM3220F_EVAL\List\" #
#                     -o "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EW #
#                    ARM\STM3220F_EVAL\Obj\" --no_cse --no_unroll             #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                              #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\" -I              #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\CMSIS\CM3\CoreSupport\" -I "F:\¹¬ÀÛ¾÷\[  #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Librari #
#                    es\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\" -I             #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I      #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Utilities\STM32_EVAL\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG      #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\Common\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\STM3220F_EVAL\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_OTG_Driver\inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Core\inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Class\msc\inc\" -I "F:\¹¬ÀÛ¾÷\[     #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\" -I   #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\Usb\Inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                      #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\src\" -I      #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Core\inc\" -I     #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\"   #
#                    -Ol --use_c++_inline                                     #
#    List file    =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\List\stm32f2xx_flash.lst                    #
#    Object file  =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\Obj\stm32f2xx_flash.o                       #
#                                                                             #
#                                                                             #
###############################################################################

F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_flash.c
      4            * @author  MCD Application Team
      5            * @version V0.0.4
      6            * @date    13-January-2011
      7            * @brief   This file provides all the FLASH firmware functions.
      8            * 
      9            * This driver provides functions to configure and program the Flash memory of all STM32F2xx devices 
     10            * These functions are split in 3 groups:
     11            * 
     12            * 1/ FLASH_Interface configuration_functions, this group includes the management of following features:
     13            * - Set the latency
     14            * - Enable/Disable the prefetch buffer
     15            * - Enable/Disable the Instruction cache and the Data cache
     16            * - Reset the instruction cache and the Data cache
     17            * - Enable/Disable the flash interrupt sources.
     18            *  
     19            * 2/ FLASH_Memory Programming_functions, this group includes all needed functions
     20            * to erase and program the main memory:
     21            * - Lock and Unlock the Flash interface.
     22            * - Erase function: Erase sector, erase all sectors.
     23            * - Program functions: Byte, Half-word, word and double word.
     24            * - Program the OTP Bytes  
     25            *  
     26            * 3/ FLASH_Option Bytes Programming_functions, this group includes all needed functions to:
     27            * - Set/Reset the write protection
     28            * - Set the Read protection Level
     29            * - Set the BOR level
     30            * - Program the user option Bytes: 
     31            * - Launch the Option Bytes loader
     32            *  
     33            * 4/ FLASH_FLAG management_Functions, this group includes all needed functions to
     34            * - Get flags status
     35            * - Clear flags
     36            * - Get Flash operation status
     37            * - Wait for last flash operation      
     38            ******************************************************************************
     39            * @attention
     40            *
     41            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     42            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     43            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     44            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     45            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     46            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     47            *
     48            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     49            ******************************************************************************
     50            */
     51          
     52          /* Includes ------------------------------------------------------------------*/
     53          #include "stm32f2xx_flash.h"
     54          
     55          /** @addtogroup STM32F2xx_StdPeriph_Driver
     56            * @{
     57            */
     58          
     59          
     60          
     61          /** @defgroup FLASH 
     62            * @brief FLASH driver modules
     63            * @{
     64            */ 
     65          
     66          /** @defgroup FLASH_Private_TypesDefinitions
     67            * @{
     68            */ 
     69          /**
     70            * @}
     71            */ 
     72          
     73          
     74          /** @defgroup FLASH_Private_Defines
     75            * @{
     76            */ 
     77          #define SECTOR_MASK               ((uint32_t)0xFFFFFF07)
     78          /* Delay definition */   
     79          #define ERASE_TIMEOUT             ((uint32_t)0xFFFFFFFF)
     80          #define PROGRAM_TIMEOUT           ((uint32_t)0xFFFFFFFF)
     81          /**
     82            * @}
     83            */ 
     84          
     85          
     86          /** @defgroup FLASH_Private_Macros
     87            * @{
     88            */ 
     89          /**
     90            * @}
     91            */ 
     92          
     93          
     94          /** @defgroup FLASH_Private_Variables
     95            * @{
     96            */ 
     97          /**
     98            * @}
     99            */ 
    100          
    101          
    102          /** @defgroup FLASH_Private_FunctionPrototypes
    103            * @{
    104            */ 
    105          /**
    106            * @}
    107            */ 
    108          
    109          
    110          /** @defgroup FLASH_Private_Functions
    111            * @{
    112            */ 
    113          
    114          /**
    115          @code  
    116           *******************************************************************************
    117                             FLASH_Interface configuration_Functions
    118           *******************************************************************************  
    119             FLASH_Interface configuration_Functions, includes the following functions:
    120             - void FLASH_SetLatency(uint32_t FLASH_Latency):
    121               To correctly read data from Flash memory, the number of wait states (LATENCY) 
    122               must be correctly programmed according to the frequency of the CPU clock 
    123               (HCLK) and the supply voltage of the device.
    124           --------------------------------------------------------------------------------------     
    125           | Latency       |                HCLK clock frequency (MHz)                           |
    126           |               |---------------------------------------------------------------------|     
    127           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    128           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V(*)|
    129           |---------------|----------------|----------------|-----------------|-----------------|              
    130           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 18   |0 < HCLK <= 16   |
    131           |---------------|----------------|----------------|-----------------|-----------------|   
    132           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |18 < HCLK <= 36  |16 < HCLK <= 32  | 
    133           |---------------|----------------|----------------|-----------------|-----------------|   
    134           |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |36 < HCLK <= 54  |32 < HCLK <= 48  |
    135           |---------------|----------------|----------------|-----------------|-----------------| 
    136           |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |54 < HCLK <= 72  |48 < HCLK <= 64  |
    137           |---------------|----------------|----------------|-----------------|-----------------| 
    138           |4WS(5CPU cycle)|      NA        |96 < HCLK <= 120|72 < HCLK <= 90  |64 < HCLK <= 80  |
    139           |---------------|----------------|----------------|-----------------|-----------------| 
    140           |5WS(6CPU cycle)|      NA        |      NA        |90 < HCLK <= 108 |80 < HCLK <= 96  | 
    141           |---------------|----------------|----------------|-----------------|-----------------| 
    142           |6WS(7CPU cycle)|      NA        |      NA        |108 < HCLK <= 120|96 < HCLK <= 112 | 
    143           |---------------|----------------|----------------|-----------------|-----------------| 
    144           |7WS(8CPU cycle)|      NA        |     NA         |     NA          |112 < HCLK <= 120| 
    145           |***************|****************|****************|*****************|*****************|*****************************|
    146           |               | voltage range  | voltage range  | voltage range   | voltage range   | voltage range 2.7 V - 3.6 V |
    147           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V(*)| with External Vpp = 9V      |
    148           |---------------|----------------|----------------|-----------------|-----------------|-----------------------------| 
    149           |Max Parallelism|      x32       |               x16                |       x8        |          x64                |              
    150           |---------------|----------------|----------------|-----------------|-----------------|-----------------------------|   
    151           |PSIZE[1:0]     |      10        |               01                 |       00        |           11                |
    152           --------------------------------------------------------------------------------------------------------------------     
    153             (*) The operating votlage can down to 1.65 V only for CSP Package.  
    154              
    155             - void FLASH_PrefetchBufferCmd(FunctionalState NewState)
    156             - void FLASH_InstructionCacheCmd(FunctionalState NewState)
    157             - void FLASH_DataCacheCmd(FunctionalState NewState)
    158             - void FLASH_InstructionCacheReset(void)
    159             - void FLASH_DataCacheReset(void)
    160             - void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
    161             
    162             All these functions don't need the unlock sequence.
    163           
    164          @endcode
    165          */
    166           
    167          /**
    168            * @brief  Sets the code latency value.
    169            * @param  FLASH_Latency: specifies the FLASH Latency value.
    170            *   This parameter can be one of the following values:
    171            *     @arg FLASH_Latency_0: FLASH Zero Latency cycle
    172            *     @arg FLASH_Latency_1: FLASH One Latency cycle
    173            *     @arg FLASH_Latency_2: FLASH Two Latency cycles
    174            *     @arg FLASH_Latency_3: FLASH Three Latency cycles
    175            *     @arg FLASH_Latency_4: FLASH Four Latency cycles 
    176            *     @arg FLASH_Latency_5: FLASH Five Latency cycles 
    177            *     @arg FLASH_Latency_6: FLASH Six Latency cycles
    178            *     @arg FLASH_Latency_7: FLASH Seven Latency cycles      
    179            * @retval None
    180            */

   \                                 In section .text, align 2, keep-with-next
    181          void FLASH_SetLatency(uint32_t FLASH_Latency)
    182          {
    183            /* Check the parameters */
    184            assert_param(IS_FLASH_LATENCY(FLASH_Latency));
    185            
    186            /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
    187            *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
   \                     FLASH_SetLatency:
   \   00000000   ........           LDR.W    R1,??DataTable28  ;; 0x40023c00
   \   00000004   0870               STRB     R0,[R1, #+0]
    188          }
   \   00000006   7047               BX       LR               ;; return
    189          
    190          /**
    191            * @brief  Enables or disables the Prefetch Buffer.
    192            * @param  NewState: new state of the Prefetch Buffer.
    193            *   This parameter can be: ENABLE or DISABLE.
    194            * @retval None
    195            */

   \                                 In section .text, align 2, keep-with-next
    196          void FLASH_PrefetchBufferCmd(FunctionalState NewState)
    197          {
    198            /* Check the parameters */
    199            assert_param(IS_FUNCTIONAL_STATE(NewState));
    200            
    201            /* Enable or disable the Prefetch Buffer */
    202            if(NewState != DISABLE)
   \                     FLASH_PrefetchBufferCmd:
   \   00000000   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0028               CMP      R0,#+0
   \   00000004   09D0               BEQ.N    ??FLASH_PrefetchBufferCmd_0
    203            {
    204              FLASH->ACR |= FLASH_ACR_PRFTEN;
   \   00000006   ........           LDR.W    R0,??DataTable28  ;; 0x40023c00
   \   0000000A   0068               LDR      R0,[R0, #+0]
   \   0000000C   4FF48071           MOV      R1,#+256
   \   00000010   0843               ORRS     R0,R1,R0
   \   00000012   ........           LDR.W    R1,??DataTable28  ;; 0x40023c00
   \   00000016   0860               STR      R0,[R1, #+0]
   \   00000018   07E0               B.N      ??FLASH_PrefetchBufferCmd_1
    205            }
    206            else
    207            {
    208              FLASH->ACR &= (~FLASH_ACR_PRFTEN);
   \                     ??FLASH_PrefetchBufferCmd_0:
   \   0000001A   ........           LDR.W    R0,??DataTable28  ;; 0x40023c00
   \   0000001E   0068               LDR      R0,[R0, #+0]
   \   00000020   30F48070           BICS     R0,R0,#0x100
   \   00000024   ........           LDR.W    R1,??DataTable28  ;; 0x40023c00
   \   00000028   0860               STR      R0,[R1, #+0]
    209            }
    210          }
   \                     ??FLASH_PrefetchBufferCmd_1:
   \   0000002A   7047               BX       LR               ;; return
    211          
    212          /**
    213            * @brief  Enables or disables the Instruction Cache feature.
    214            * @param  NewState: new state of the Instruction Cache.
    215            *   This parameter can be: ENABLE or DISABLE.
    216            * @retval None
    217            */

   \                                 In section .text, align 2, keep-with-next
    218          void FLASH_InstructionCacheCmd(FunctionalState NewState)
    219          {
    220            /* Check the parameters */
    221            assert_param(IS_FUNCTIONAL_STATE(NewState));
    222            
    223            if(NewState != DISABLE)
   \                     FLASH_InstructionCacheCmd:
   \   00000000   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0028               CMP      R0,#+0
   \   00000004   09D0               BEQ.N    ??FLASH_InstructionCacheCmd_0
    224            {
    225              FLASH->ACR |= FLASH_ACR_ICEN;
   \   00000006   ........           LDR.W    R0,??DataTable28  ;; 0x40023c00
   \   0000000A   0068               LDR      R0,[R0, #+0]
   \   0000000C   4FF40071           MOV      R1,#+512
   \   00000010   0843               ORRS     R0,R1,R0
   \   00000012   ........           LDR.W    R1,??DataTable28  ;; 0x40023c00
   \   00000016   0860               STR      R0,[R1, #+0]
   \   00000018   07E0               B.N      ??FLASH_InstructionCacheCmd_1
    226            }
    227            else
    228            {
    229              FLASH->ACR &= (~FLASH_ACR_ICEN);
   \                     ??FLASH_InstructionCacheCmd_0:
   \   0000001A   ........           LDR.W    R0,??DataTable28  ;; 0x40023c00
   \   0000001E   0068               LDR      R0,[R0, #+0]
   \   00000020   30F40070           BICS     R0,R0,#0x200
   \   00000024   ........           LDR.W    R1,??DataTable28  ;; 0x40023c00
   \   00000028   0860               STR      R0,[R1, #+0]
    230            }
    231          }
   \                     ??FLASH_InstructionCacheCmd_1:
   \   0000002A   7047               BX       LR               ;; return
    232          
    233          /**
    234            * @brief   Enables or disables the Data Cache feature.
    235            * @param  NewState: new state of the Data Cache.
    236            *   This parameter can be: ENABLE or DISABLE.
    237            * @retval None
    238            */

   \                                 In section .text, align 2, keep-with-next
    239          void FLASH_DataCacheCmd(FunctionalState NewState)
    240          {
    241            /* Check the parameters */
    242            assert_param(IS_FUNCTIONAL_STATE(NewState));
    243            
    244            if(NewState != DISABLE)
   \                     FLASH_DataCacheCmd:
   \   00000000   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0028               CMP      R0,#+0
   \   00000004   08D0               BEQ.N    ??FLASH_DataCacheCmd_0
    245            {
    246              FLASH->ACR |= FLASH_ACR_DCEN;
   \   00000006   ........           LDR.W    R0,??DataTable28  ;; 0x40023c00
   \   0000000A   0068               LDR      R0,[R0, #+0]
   \   0000000C   50F48060           ORRS     R0,R0,#0x400
   \   00000010   ........           LDR.W    R1,??DataTable28  ;; 0x40023c00
   \   00000014   0860               STR      R0,[R1, #+0]
   \   00000016   07E0               B.N      ??FLASH_DataCacheCmd_1
    247            }
    248            else
    249            {
    250              FLASH->ACR &= (~FLASH_ACR_DCEN);
   \                     ??FLASH_DataCacheCmd_0:
   \   00000018   ........           LDR.W    R0,??DataTable28  ;; 0x40023c00
   \   0000001C   0068               LDR      R0,[R0, #+0]
   \   0000001E   30F48060           BICS     R0,R0,#0x400
   \   00000022   ........           LDR.W    R1,??DataTable28  ;; 0x40023c00
   \   00000026   0860               STR      R0,[R1, #+0]
    251            }
    252          }
   \                     ??FLASH_DataCacheCmd_1:
   \   00000028   7047               BX       LR               ;; return
    253          
    254          /**
    255            * @brief  Resets the Instruction Cache.
    256            * @note  This function must be used only when the Instruction Cache is disabled.  
    257            * @param  None
    258            * @retval None
    259            */

   \                                 In section .text, align 2, keep-with-next
    260          void FLASH_InstructionCacheReset(void)
    261          {
    262            FLASH->ACR |= FLASH_ACR_ICRST;
   \                     FLASH_InstructionCacheReset:
   \   00000000   ........           LDR.W    R0,??DataTable28  ;; 0x40023c00
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   50F40060           ORRS     R0,R0,#0x800
   \   0000000A   ........           LDR.W    R1,??DataTable28  ;; 0x40023c00
   \   0000000E   0860               STR      R0,[R1, #+0]
    263          }
   \   00000010   7047               BX       LR               ;; return
    264          
    265          /**
    266            * @brief  Resets the Data Cache.
    267            * @note  This function must be used only when the Data Cache is disabled.  
    268            * @param  None
    269            * @retval None
    270            */

   \                                 In section .text, align 2, keep-with-next
    271          void FLASH_DataCacheReset(void)
    272          {
    273            FLASH->ACR |= FLASH_ACR_DCRST;
   \                     FLASH_DataCacheReset:
   \   00000000   ........           LDR.W    R0,??DataTable28  ;; 0x40023c00
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   50F48050           ORRS     R0,R0,#0x1000
   \   0000000A   ........           LDR.W    R1,??DataTable28  ;; 0x40023c00
   \   0000000E   0860               STR      R0,[R1, #+0]
    274          }
   \   00000010   7047               BX       LR               ;; return
    275          
    276          /**
    277            * @brief  Enables or disables the specified FLASH interrupts.
    278            * @param  FLASH_IT: specifies the FLASH interrupt sources to be enabled or disabled.
    279            *   This parameter can be any combination of the following values:
    280            *     @arg FLASH_IT_ERROR: FLASH Error Interrupt
    281            *     @arg FLASH_IT_EOP: FLASH end of operation Interrupt
    282            * @retval None 
    283            */

   \                                 In section .text, align 2, keep-with-next
    284          void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
    285          {
    286            /* Check the parameters */
    287            assert_param(IS_FLASH_IT(FLASH_IT)); 
    288            assert_param(IS_FUNCTIONAL_STATE(NewState));
    289            if(NewState != DISABLE)
   \                     FLASH_ITConfig:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   07D0               BEQ.N    ??FLASH_ITConfig_0
    290            {
    291              /* Enable the interrupt sources */
    292              FLASH->CR |= FLASH_IT;
   \   00000006   ........           LDR.W    R1,??DataTable28_1  ;; 0x40023c10
   \   0000000A   0968               LDR      R1,[R1, #+0]
   \   0000000C   0843               ORRS     R0,R0,R1
   \   0000000E   ........           LDR.W    R1,??DataTable28_1  ;; 0x40023c10
   \   00000012   0860               STR      R0,[R1, #+0]
   \   00000014   07E0               B.N      ??FLASH_ITConfig_1
    293            }
    294            else
    295            {
    296              /* Disable the interrupt sources */
    297              FLASH->CR &= ~(uint32_t)FLASH_IT;
   \                     ??FLASH_ITConfig_0:
   \   00000016   ........           LDR.W    R1,??DataTable28_1  ;; 0x40023c10
   \   0000001A   0968               LDR      R1,[R1, #+0]
   \   0000001C   31EA0000           BICS     R0,R1,R0
   \   00000020   ........           LDR.W    R1,??DataTable28_1  ;; 0x40023c10
   \   00000024   0860               STR      R0,[R1, #+0]
    298            }
    299          }
   \                     ??FLASH_ITConfig_1:
   \   00000026   7047               BX       LR               ;; return
    300          
    301          /**
    302          @code  
    303           *******************************************************************************
    304                             FLASH_Memory Programming_functions
    305           *******************************************************************************  
    306             The FLASH Memory Programming functions, includes the following functions:
    307              - void FLASH_Unlock(void);
    308              - void FLASH_Lock(void);
    309              - FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange);
    310              - FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange);
    311              - FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data);
    312              - FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data);
    313              - FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data);
    314              - FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data);
    315             
    316             Any operation of erase or program should follow these steps:
    317             - Call the FLASH_Unlock() function to enable the flash control register access
    318             - Call the desired function to erase sector (s) or program data
    319             - Call the FLASH_Lock() to disable the flash control register access (recommended
    320               to protect the FLASH memory against possible unwanted operation)
    321              
    322          @endcode
    323          */
    324          
    325          
    326          /**
    327            * @brief  Unlocks the FLASH Registers access.
    328            * @param  None
    329            * @retval None
    330            */

   \                                 In section .text, align 2, keep-with-next
    331          void FLASH_Unlock(void)
    332          {
    333            if((FLASH->CR & FLASH_CR_LOCK) != RESET)
   \                     FLASH_Unlock:
   \   00000000   ........           LDR.W    R0,??DataTable28_1  ;; 0x40023c10
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   09D5               BPL.N    ??FLASH_Unlock_0
    334            {
    335              /* Authorize the FLASH Registers access */
    336              FLASH->KEYR = FLASH_KEY1;
   \   0000000A   ........           LDR.W    R0,??DataTable28_2  ;; 0x40023c04
   \   0000000E   ........           LDR.W    R1,??DataTable28_3  ;; 0x45670123
   \   00000012   0160               STR      R1,[R0, #+0]
    337              FLASH->KEYR = FLASH_KEY2;
   \   00000014   ........           LDR.W    R0,??DataTable28_2  ;; 0x40023c04
   \   00000018   ........           LDR.W    R1,??DataTable28_4  ;; 0xcdef89ab
   \   0000001C   0160               STR      R1,[R0, #+0]
    338            }  
    339          }
   \                     ??FLASH_Unlock_0:
   \   0000001E   7047               BX       LR               ;; return
    340          
    341          /**
    342            * @brief  Locks the FLASH Registers access.
    343            * @param  None
    344            * @retval None
    345            */

   \                                 In section .text, align 2, keep-with-next
    346          void FLASH_Lock(void)
    347          {
    348            /* Set the LOCK Bit to lock the FLASH Registers access */
    349            FLASH->CR |= FLASH_CR_LOCK;
   \                     FLASH_Lock:
   \   00000000   ........           LDR.W    R0,??DataTable28_1  ;; 0x40023c10
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   50F00040           ORRS     R0,R0,#0x80000000
   \   0000000A   ........           LDR.W    R1,??DataTable28_1  ;; 0x40023c10
   \   0000000E   0860               STR      R0,[R1, #+0]
    350          }
   \   00000010   7047               BX       LR               ;; return
    351          
    352          /**
    353            * @brief  Erases a specified FLASH Sector.
    354            * @note   - To correctly run this function, the FLASH_Unlock() function
    355            *           must be called before.
    356            *         - Call the FLASH_Lock() to disable the flash control register access 
    357            *          (recommended to protect the FLASH memory against possible unwanted operation)  
    358            * @param  FLASH_Sector: The Sector number to be erased.
    359            *   This parameter can be a value between FLASH_Sector_0 and FLASH_Sector_11  
    360            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    361            *   This parameter can be:
    362            *   - VoltageRange_1: if the device voltage range: 1.8V to 2.1V, the operation will be done by byte. 
    363            *   - VoltageRange_2: if the device voltage range: 2.1V to 2.7V, the operation will be done by Half_word. 
    364            *   - VoltageRange_3: if the device voltage range: 2.7V to 3.6V , the operation will be done by word.
    365            *   - VoltageRange_4: if the device voltage range: 2.7V to 3.6V + External Vpp, the operation will be done 
    366            *     by double word.     
    367            * @retval FLASH Status: The returned value can be: FLASH_BUSY, 
    368            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or 
    369            *   FLASH_COMPLETE.
    370            */

   \                                 In section .text, align 2, keep-with-next
    371          FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
    372          {
   \                     FLASH_EraseSector:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
    373            uint32_t tmp_psize = 0x0;
   \   00000004   0025               MOVS     R5,#+0
    374            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0820               MOVS     R0,#+8
    375            /* Check the parameters */
    376            assert_param(IS_FLASH_SECTOR(FLASH_Sector));
    377            assert_param(IS_VOLTAGERANGE(VoltageRange));
    378            
    379            if(VoltageRange == VoltageRange_1)
   \   00000008   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0029               CMP      R1,#+0
   \   0000000C   01D1               BNE.N    ??FLASH_EraseSector_0
    380            {
    381               tmp_psize = FLASH_PSIZE_BYTE;
   \   0000000E   0025               MOVS     R5,#+0
   \   00000010   0DE0               B.N      ??FLASH_EraseSector_1
    382            }
    383            else if(VoltageRange == VoltageRange_2)
   \                     ??FLASH_EraseSector_0:
   \   00000012   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0129               CMP      R1,#+1
   \   00000016   02D1               BNE.N    ??FLASH_EraseSector_2
    384            {
    385              tmp_psize = FLASH_PSIZE_HALF_WORD;
   \   00000018   4FF48075           MOV      R5,#+256
   \   0000001C   07E0               B.N      ??FLASH_EraseSector_1
    386            }
    387            else if(VoltageRange == VoltageRange_3)
   \                     ??FLASH_EraseSector_2:
   \   0000001E   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0229               CMP      R1,#+2
   \   00000022   02D1               BNE.N    ??FLASH_EraseSector_3
    388            {
    389              tmp_psize = FLASH_PSIZE_WORD;
   \   00000024   4FF40075           MOV      R5,#+512
   \   00000028   01E0               B.N      ??FLASH_EraseSector_1
    390            }
    391            else
    392            {
    393              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
   \                     ??FLASH_EraseSector_3:
   \   0000002A   4FF44075           MOV      R5,#+768
    394            }
    395            /* Wait for last operation to be completed */
    396            status = FLASH_WaitForLastOperation();
   \                     ??FLASH_EraseSector_1:
   \   0000002E   ........           BL       FLASH_WaitForLastOperation
    397            
    398            if(status == FLASH_COMPLETE)
   \   00000032   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0828               CMP      R0,#+8
   \   00000036   39D1               BNE.N    ??FLASH_EraseSector_4
    399            { 
    400              /* if the previous operation is completed, proceed to erase the sector */
    401              FLASH->CR &= CR_PSIZE_MASK;
   \   00000038   ........           LDR.W    R0,??DataTable28_1  ;; 0x40023c10
   \   0000003C   0068               LDR      R0,[R0, #+0]
   \   0000003E   30F44070           BICS     R0,R0,#0x300
   \   00000042   ........           LDR.W    R1,??DataTable28_1  ;; 0x40023c10
   \   00000046   0860               STR      R0,[R1, #+0]
    402              FLASH->CR |= tmp_psize;
   \   00000048   ........           LDR.W    R0,??DataTable28_1  ;; 0x40023c10
   \   0000004C   0068               LDR      R0,[R0, #+0]
   \   0000004E   2843               ORRS     R0,R5,R0
   \   00000050   ........           LDR.W    R1,??DataTable28_1  ;; 0x40023c10
   \   00000054   0860               STR      R0,[R1, #+0]
    403              FLASH->CR &= SECTOR_MASK;
   \   00000056   ........           LDR.W    R0,??DataTable28_1  ;; 0x40023c10
   \   0000005A   0068               LDR      R0,[R0, #+0]
   \   0000005C   30F0F800           BICS     R0,R0,#0xF8
   \   00000060   ........           LDR.W    R1,??DataTable28_1  ;; 0x40023c10
   \   00000064   0860               STR      R0,[R1, #+0]
    404              FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
   \   00000066   ........           LDR.W    R0,??DataTable28_1  ;; 0x40023c10
   \   0000006A   0068               LDR      R0,[R0, #+0]
   \   0000006C   54F00201           ORRS     R1,R4,#0x2
   \   00000070   0843               ORRS     R0,R1,R0
   \   00000072   ........           LDR.W    R1,??DataTable28_1  ;; 0x40023c10
   \   00000076   0860               STR      R0,[R1, #+0]
    405              FLASH->CR |= FLASH_CR_STRT;
   \   00000078   ........           LDR.W    R0,??DataTable28_1  ;; 0x40023c10
   \   0000007C   0068               LDR      R0,[R0, #+0]
   \   0000007E   50F48030           ORRS     R0,R0,#0x10000
   \   00000082   ........           LDR.W    R1,??DataTable28_1  ;; 0x40023c10
   \   00000086   0860               STR      R0,[R1, #+0]
    406              
    407              /* Wait for last operation to be completed */
    408              status = FLASH_WaitForLastOperation();
   \   00000088   ........           BL       FLASH_WaitForLastOperation
    409              
    410              /* if the erase operation is completed, disable the SER Bit */
    411              FLASH->CR &= (~FLASH_CR_SER);
   \   0000008C   ........           LDR.W    R1,??DataTable28_1  ;; 0x40023c10
   \   00000090   0968               LDR      R1,[R1, #+0]
   \   00000092   31F00201           BICS     R1,R1,#0x2
   \   00000096   ........           LDR.W    R2,??DataTable28_1  ;; 0x40023c10
   \   0000009A   1160               STR      R1,[R2, #+0]
    412              FLASH->CR &= SECTOR_MASK; 
   \   0000009C   ........           LDR.W    R1,??DataTable28_1  ;; 0x40023c10
   \   000000A0   0968               LDR      R1,[R1, #+0]
   \   000000A2   31F0F801           BICS     R1,R1,#0xF8
   \   000000A6   ........           LDR.W    R2,??DataTable28_1  ;; 0x40023c10
   \   000000AA   1160               STR      R1,[R2, #+0]
    413            }
    414            /* Return the Erase Status */
    415            return status;
   \                     ??FLASH_EraseSector_4:
   \   000000AC   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AE   32BD               POP      {R1,R4,R5,PC}    ;; return
    416          }
    417          
    418          /**
    419            * @brief  Erases all FLASH Sectors.
    420            * @note   To correctly run this function, the FLASH_Unlock() function
    421            *           must be called before.
    422            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    423            *   This parameter can be:
    424            *   - VoltageRange_1: if the device voltage range: 1.8V to 2.1V, the operation will be done by byte. 
    425            *   - VoltageRange_2: if the device voltage range: 2.1V to 2.7V, the operation will be done by Half_word. 
    426            *   - VoltageRange_3: if the device voltage range: 2.7V to 3.6V , the operation will be done by word.
    427            *   - VoltageRange_4: if the device voltage range: 2.7V to 3.6V + External Vpp, the operation will be done 
    428            *     by double word.
    429            * @retval FLASH Status: The returned value can be: FLASH_BUSY, 
    430            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or 
    431            *   FLASH_COMPLETE.
    432            */

   \                                 In section .text, align 2, keep-with-next
    433          FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
    434          {
   \                     FLASH_EraseAllSectors:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0500               MOVS     R5,R0
    435            uint32_t tmp_psize = 0x0;
   \   00000004   0024               MOVS     R4,#+0
    436            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0826               MOVS     R6,#+8
    437            
    438            /* Wait for last operation to be completed */
    439            status = FLASH_WaitForLastOperation();
   \   00000008   ........           BL       FLASH_WaitForLastOperation
   \   0000000C   0600               MOVS     R6,R0
    440            assert_param(IS_VOLTAGERANGE(VoltageRange));
    441            
    442            if(VoltageRange == VoltageRange_1)
   \   0000000E   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   002D               CMP      R5,#+0
   \   00000012   01D1               BNE.N    ??FLASH_EraseAllSectors_0
    443            {
    444               tmp_psize = FLASH_PSIZE_BYTE;
   \   00000014   0024               MOVS     R4,#+0
   \   00000016   0DE0               B.N      ??FLASH_EraseAllSectors_1
    445            }
    446            else if(VoltageRange == VoltageRange_2)
   \                     ??FLASH_EraseAllSectors_0:
   \   00000018   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   012D               CMP      R5,#+1
   \   0000001C   02D1               BNE.N    ??FLASH_EraseAllSectors_2
    447            {
    448              tmp_psize = FLASH_PSIZE_HALF_WORD;
   \   0000001E   4FF48074           MOV      R4,#+256
   \   00000022   07E0               B.N      ??FLASH_EraseAllSectors_1
    449            }
    450            else if(VoltageRange == VoltageRange_3)
   \                     ??FLASH_EraseAllSectors_2:
   \   00000024   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   022D               CMP      R5,#+2
   \   00000028   02D1               BNE.N    ??FLASH_EraseAllSectors_3
    451            {
    452              tmp_psize = FLASH_PSIZE_WORD;
   \   0000002A   4FF40074           MOV      R4,#+512
   \   0000002E   01E0               B.N      ??FLASH_EraseAllSectors_1
    453            }
    454            else
    455            {
    456              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
   \                     ??FLASH_EraseAllSectors_3:
   \   00000030   4FF44074           MOV      R4,#+768
    457            }  
    458            if(status == FLASH_COMPLETE)
   \                     ??FLASH_EraseAllSectors_1:
   \   00000034   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   082E               CMP      R6,#+8
   \   00000038   1FD1               BNE.N    ??FLASH_EraseAllSectors_4
    459            {
    460              /* if the previous operation is completed, proceed to erase all sectors */
    461               FLASH->CR &= CR_PSIZE_MASK;
   \   0000003A   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   0000003C   0068               LDR      R0,[R0, #+0]
   \   0000003E   30F44070           BICS     R0,R0,#0x300
   \   00000042   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   00000044   0860               STR      R0,[R1, #+0]
    462               FLASH->CR |= tmp_psize;
   \   00000046   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   00000048   0068               LDR      R0,[R0, #+0]
   \   0000004A   2043               ORRS     R0,R4,R0
   \   0000004C   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   0000004E   0860               STR      R0,[R1, #+0]
    463               FLASH->CR |= FLASH_CR_MER;
   \   00000050   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   00000052   0068               LDR      R0,[R0, #+0]
   \   00000054   50F00400           ORRS     R0,R0,#0x4
   \   00000058   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   0000005A   0860               STR      R0,[R1, #+0]
    464               FLASH->CR |= FLASH_CR_STRT;
   \   0000005C   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   0000005E   0068               LDR      R0,[R0, #+0]
   \   00000060   50F48030           ORRS     R0,R0,#0x10000
   \   00000064   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   00000066   0860               STR      R0,[R1, #+0]
    465              
    466              /* Wait for last operation to be completed */
    467              status = FLASH_WaitForLastOperation();
   \   00000068   ........           BL       FLASH_WaitForLastOperation
   \   0000006C   0600               MOVS     R6,R0
    468          
    469              /* if the erase operation is completed, disable the MER Bit */
    470              FLASH->CR &= (~FLASH_CR_MER);
   \   0000006E   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   00000070   0068               LDR      R0,[R0, #+0]
   \   00000072   30F00400           BICS     R0,R0,#0x4
   \   00000076   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   00000078   0860               STR      R0,[R1, #+0]
    471          
    472            }   
    473            /* Return the Erase Status */
    474            return status;
   \                     ??FLASH_EraseAllSectors_4:
   \   0000007A   3000               MOVS     R0,R6
   \   0000007C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   70BD               POP      {R4-R6,PC}       ;; return
    475          }
    476          
    477          /**
    478            * @brief  Programs a Double word at a specified address.
    479            * @note  - To correctly run this function, the FLASH_Unlock() function
    480            *           must be called before.
    481            *         - Call the FLASH_Lock() to disable the flash control register access 
    482            *          (recommended to protect the FLASH memory against possible unwanted operation) 
    483            * @note  This function must be used when the device voltage range is from 2.7V to 3.6V 
    484            *         and an External Vpp is present.           
    485            * @param  Address: specifies the address to be programmed.
    486            * @param  Data: specifies the data to be programmed.
    487            * @retval FLASH Status: The returned value can be: FLASH_BUSY, 
    488            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or 
    489            *   FLASH_COMPLETE. 
    490            */

   \                                 In section .text, align 2, keep-with-next
    491          FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
    492          {
   \                     FLASH_ProgramDoubleWord:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0600               MOVS     R6,R0
   \   00000004   1400               MOVS     R4,R2
   \   00000006   1D00               MOVS     R5,R3
    493            FLASH_Status status = FLASH_COMPLETE;
   \   00000008   0827               MOVS     R7,#+8
    494            /* Check the parameters */
    495            assert_param(IS_FLASH_ADDRESS(Address));
    496            /* Wait for last operation to be completed */
    497            status = FLASH_WaitForLastOperation();
   \   0000000A   ........           BL       FLASH_WaitForLastOperation
   \   0000000E   0700               MOVS     R7,R0
    498            
    499            if(status == FLASH_COMPLETE)
   \   00000010   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000012   082F               CMP      R7,#+8
   \   00000014   1DD1               BNE.N    ??FLASH_ProgramDoubleWord_0
    500            {
    501              /* if the previous operation is completed, proceed to program the new data */
    502              FLASH->CR &= CR_PSIZE_MASK;
   \   00000016   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   00000018   0068               LDR      R0,[R0, #+0]
   \   0000001A   30F44070           BICS     R0,R0,#0x300
   \   0000001E   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   00000020   0860               STR      R0,[R1, #+0]
    503              FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
   \   00000022   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   00000024   0068               LDR      R0,[R0, #+0]
   \   00000026   4FF44071           MOV      R1,#+768
   \   0000002A   0843               ORRS     R0,R1,R0
   \   0000002C   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   0000002E   0860               STR      R0,[R1, #+0]
    504              FLASH->CR |= FLASH_CR_PG;
   \   00000030   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   00000032   0068               LDR      R0,[R0, #+0]
   \   00000034   50F00100           ORRS     R0,R0,#0x1
   \   00000038   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   0000003A   0860               STR      R0,[R1, #+0]
    505            
    506              *(__IO uint64_t*)Address = Data;
   \   0000003C   C6E90045           STRD     R4,R5,[R6, #+0]
    507                  
    508              /* Wait for last operation to be completed */
    509              status = FLASH_WaitForLastOperation();
   \   00000040   ........           BL       FLASH_WaitForLastOperation
   \   00000044   0700               MOVS     R7,R0
    510          
    511              /* if the program operation is completed, disable the PG Bit */
    512              FLASH->CR &= (~FLASH_CR_PG);
   \   00000046   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   00000048   0068               LDR      R0,[R0, #+0]
   \   0000004A   4008               LSRS     R0,R0,#+1
   \   0000004C   4000               LSLS     R0,R0,#+1
   \   0000004E   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   00000050   0860               STR      R0,[R1, #+0]
    513            } 
    514            /* Return the Program Status */
    515            return status;
   \                     ??FLASH_ProgramDoubleWord_0:
   \   00000052   3800               MOVS     R0,R7
   \   00000054   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   F2BD               POP      {R1,R4-R7,PC}    ;; return
    516          }
    517          
    518          /**
    519            * @brief  Programs a word at a specified address.
    520            * @note  - To correctly run this function, the FLASH_Unlock() function
    521            *           must be called before.
    522            *         - Call the FLASH_Lock() to disable the flash control register access 
    523            *          (recommended to protect the FLASH memory against possible unwanted operation) 
    524            * @param  Address: specifies the address to be programmed.
    525            *         This parameter can be any address in Program memory zone or in OTP zone.  
    526            * @note  This function must be used when the device voltage range is from 2.7V to 3.6V. 
    527            * @param  Data: specifies the data to be programmed.
    528            * @retval FLASH Status: The returned value can be: FLASH_BUSY, 
    529            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or 
    530            *   FLASH_COMPLETE.
    531            */

   \                                 In section .text, align 2, keep-with-next
    532          FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    533          {
   \                     FLASH_ProgramWord:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    534            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0826               MOVS     R6,#+8
    535            /* Check the parameters */
    536            assert_param(IS_FLASH_ADDRESS(Address));
    537            /* Wait for last operation to be completed */
    538            status = FLASH_WaitForLastOperation();
   \   00000008   ........           BL       FLASH_WaitForLastOperation
   \   0000000C   0600               MOVS     R6,R0
    539            
    540            if(status == FLASH_COMPLETE)
   \   0000000E   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000010   082E               CMP      R6,#+8
   \   00000012   1CD1               BNE.N    ??FLASH_ProgramWord_0
    541            {
    542              /* if the previous operation is completed, proceed to program the new data */
    543              FLASH->CR &= CR_PSIZE_MASK;
   \   00000014   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   00000016   0068               LDR      R0,[R0, #+0]
   \   00000018   30F44070           BICS     R0,R0,#0x300
   \   0000001C   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   0000001E   0860               STR      R0,[R1, #+0]
    544              FLASH->CR |= FLASH_PSIZE_WORD;
   \   00000020   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   00000022   0068               LDR      R0,[R0, #+0]
   \   00000024   4FF40071           MOV      R1,#+512
   \   00000028   0843               ORRS     R0,R1,R0
   \   0000002A   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   0000002C   0860               STR      R0,[R1, #+0]
    545              FLASH->CR |= FLASH_CR_PG;
   \   0000002E   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   00000030   0068               LDR      R0,[R0, #+0]
   \   00000032   50F00100           ORRS     R0,R0,#0x1
   \   00000036   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   00000038   0860               STR      R0,[R1, #+0]
    546            
    547              *(__IO uint32_t*)Address = Data;
   \   0000003A   2560               STR      R5,[R4, #+0]
    548                  
    549              /* Wait for last operation to be completed */
    550              status = FLASH_WaitForLastOperation();
   \   0000003C   ........           BL       FLASH_WaitForLastOperation
   \   00000040   0600               MOVS     R6,R0
    551          
    552              /* if the program operation is completed, disable the PG Bit */
    553              FLASH->CR &= (~FLASH_CR_PG);
   \   00000042   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   00000044   0068               LDR      R0,[R0, #+0]
   \   00000046   4008               LSRS     R0,R0,#+1
   \   00000048   4000               LSLS     R0,R0,#+1
   \   0000004A   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   0000004C   0860               STR      R0,[R1, #+0]
    554            } 
    555            /* Return the Program Status */
    556            return status;
   \                     ??FLASH_ProgramWord_0:
   \   0000004E   3000               MOVS     R0,R6
   \   00000050   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   70BD               POP      {R4-R6,PC}       ;; return
    557          }
    558          
    559          /**
    560            * @brief  Programs a half word at a specified address.
    561            * @note  - To correctly run this function, the FLASH_Unlock() function
    562            *           must be called before.
    563            *         - Call the FLASH_Lock() to disable the flash control register access 
    564            *          (recommended to protect the FLASH memory against possible unwanted operation)  
    565            * @note  This function must be used when the device voltage range is from 2.1V to 2.7V.               
    566            * @param  Address: specifies the address to be programmed.
    567            *         This parameter can be any address in Program memory zone or in OTP zone.  
    568            * @param  Data: specifies the data to be programmed.
    569            * @retval FLASH Status: The returned value can be: FLASH_BUSY, 
    570            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or 
    571            *   FLASH_COMPLETE.
    572            */

   \                                 In section .text, align 2, keep-with-next
    573          FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
    574          {
   \                     FLASH_ProgramHalfWord:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    575            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0826               MOVS     R6,#+8
    576            /* Check the parameters */
    577            assert_param(IS_FLASH_ADDRESS(Address));
    578          
    579            /* Wait for last operation to be completed */
    580            status = FLASH_WaitForLastOperation();
   \   00000008   ........           BL       FLASH_WaitForLastOperation
   \   0000000C   0600               MOVS     R6,R0
    581            
    582            if(status == FLASH_COMPLETE)
   \   0000000E   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000010   082E               CMP      R6,#+8
   \   00000012   1CD1               BNE.N    ??FLASH_ProgramHalfWord_0
    583            {
    584              /* if the previous operation is completed, proceed to program the new data */
    585              FLASH->CR &= CR_PSIZE_MASK;
   \   00000014   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   00000016   0068               LDR      R0,[R0, #+0]
   \   00000018   30F44070           BICS     R0,R0,#0x300
   \   0000001C   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   0000001E   0860               STR      R0,[R1, #+0]
    586              FLASH->CR |= FLASH_PSIZE_HALF_WORD;
   \   00000020   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   00000022   0068               LDR      R0,[R0, #+0]
   \   00000024   4FF48071           MOV      R1,#+256
   \   00000028   0843               ORRS     R0,R1,R0
   \   0000002A   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   0000002C   0860               STR      R0,[R1, #+0]
    587              FLASH->CR |= FLASH_CR_PG;
   \   0000002E   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   00000030   0068               LDR      R0,[R0, #+0]
   \   00000032   50F00100           ORRS     R0,R0,#0x1
   \   00000036   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   00000038   0860               STR      R0,[R1, #+0]
    588            
    589              *(__IO uint16_t*)Address = Data;
   \   0000003A   2580               STRH     R5,[R4, #+0]
    590                  
    591              /* Wait for last operation to be completed */
    592              status = FLASH_WaitForLastOperation();
   \   0000003C   ........           BL       FLASH_WaitForLastOperation
   \   00000040   0600               MOVS     R6,R0
    593          
    594              /* if the program operation is completed, disable the PG Bit */
    595              FLASH->CR &= (~FLASH_CR_PG);
   \   00000042   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   00000044   0068               LDR      R0,[R0, #+0]
   \   00000046   4008               LSRS     R0,R0,#+1
   \   00000048   4000               LSLS     R0,R0,#+1
   \   0000004A   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   0000004C   0860               STR      R0,[R1, #+0]
    596            } 
    597            /* Return the Program Status */
    598            return status;
   \                     ??FLASH_ProgramHalfWord_0:
   \   0000004E   3000               MOVS     R0,R6
   \   00000050   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   70BD               POP      {R4-R6,PC}       ;; return
    599          }
    600          
    601          /**
    602            * @brief  Programs a byte at a specified address.
    603            * @note  - To correctly run this function, the FLASH_Unlock() function
    604            *           must be called before.
    605            *         - Call the FLASH_Lock() to disable the flash control register access 
    606            *          (recommended to protect the FLASH memory against possible unwanted operation) 
    607            * @note  This function must be used when the device voltage range is from 1.8V to 2.1V.               
    608            * @param  Address: specifies the address to be programmed.
    609            *         This parameter can be any address in Program memory zone or in OTP zone.  
    610            * @param  Data: specifies the data to be programmed.
    611            * @retval FLASH Status: The returned value can be: FLASH_BUSY, 
    612            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or 
    613            *   FLASH_COMPLETE.
    614            */

   \                                 In section .text, align 2, keep-with-next
    615          FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
    616          {
   \                     FLASH_ProgramByte:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    617            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0826               MOVS     R6,#+8
    618            /* Check the parameters */
    619            assert_param(IS_FLASH_ADDRESS(Address));
    620          
    621            /* Wait for last operation to be completed */
    622            status = FLASH_WaitForLastOperation();
   \   00000008   ........           BL       FLASH_WaitForLastOperation
   \   0000000C   0600               MOVS     R6,R0
    623            
    624            if(status == FLASH_COMPLETE)
   \   0000000E   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000010   082E               CMP      R6,#+8
   \   00000012   19D1               BNE.N    ??FLASH_ProgramByte_0
    625            {
    626              /* if the previous operation is completed, proceed to program the new data */
    627              FLASH->CR &= CR_PSIZE_MASK;
   \   00000014   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   00000016   0068               LDR      R0,[R0, #+0]
   \   00000018   30F44070           BICS     R0,R0,#0x300
   \   0000001C   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   0000001E   0860               STR      R0,[R1, #+0]
    628              FLASH->CR |= FLASH_PSIZE_BYTE;
   \   00000020   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   00000022   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   00000024   0968               LDR      R1,[R1, #+0]
   \   00000026   0160               STR      R1,[R0, #+0]
    629              FLASH->CR |= FLASH_CR_PG;
   \   00000028   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   0000002A   0068               LDR      R0,[R0, #+0]
   \   0000002C   50F00100           ORRS     R0,R0,#0x1
   \   00000030   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   00000032   0860               STR      R0,[R1, #+0]
    630            
    631              *(__IO uint8_t*)Address = Data;
   \   00000034   2570               STRB     R5,[R4, #+0]
    632                  
    633              /* Wait for last operation to be completed */
    634              status = FLASH_WaitForLastOperation();
   \   00000036   ........           BL       FLASH_WaitForLastOperation
   \   0000003A   0600               MOVS     R6,R0
    635          
    636              /* if the program operation is completed, disable the PG Bit */
    637              FLASH->CR &= (~FLASH_CR_PG);
   \   0000003C   ....               LDR.N    R0,??DataTable28_1  ;; 0x40023c10
   \   0000003E   0068               LDR      R0,[R0, #+0]
   \   00000040   4008               LSRS     R0,R0,#+1
   \   00000042   4000               LSLS     R0,R0,#+1
   \   00000044   ....               LDR.N    R1,??DataTable28_1  ;; 0x40023c10
   \   00000046   0860               STR      R0,[R1, #+0]
    638          
    639            } 
    640            /* Return the Program Status */
    641            return status;
   \                     ??FLASH_ProgramByte_0:
   \   00000048   3000               MOVS     R0,R6
   \   0000004A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   70BD               POP      {R4-R6,PC}       ;; return
    642          }
    643          
    644          /**
    645          @code  
    646           ******************************************************************************* 
    647                             FLASH_Option Bytes Programming_functions
    648           *******************************************************************************  
    649             The FLASH_Option Bytes Programming_functions, includes the following functions:
    650             - void FLASH_OB_Unlock(void);
    651             - void FLASH_OB_Lock(void);
    652             - void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState);
    653             - void FLASH_OB_RDPConfig(uint8_t OB_RDP);
    654             - void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY);
    655             - void FLASH_OB_BORConfig(uint8_t OB_BOR);
    656             - FLASH_Status FLASH_ProgramOTP(uint32_t Address, uint32_t Data);							
    657             - FLASH_Status FLASH_OB_Launch(void);							
    658             - uint32_t FLASH_OB_GetUser(void);							
    659             - uint8_t FLASH_OB_GetWRP(void);							
    660             - uint8_t FLASH_OB_GetRDP(void);							
    661             - uint8_t FLASH_OB_GetBOR(void);
    662             
    663             Any operation of erase or program should follow these steps:
    664             1/ Call the FLASH_OB_Unlock() function to enable the Flash option control register access
    665             2/ Call one or several functions to program the desired option bytes 
    666                - void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState) => to Enable/Disable 
    667                  the desired sector write protection
    668                - void FLASH_OB_RDPConfig(uint8_t OB_RDP) => to set the desired read Protection Level
    669                - void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY) => to configure 
    670                  the user option Bytes: IWDG, STOP and the Standby.
    671                - void FLASH_OB_BORConfig(uint8_t OB_BOR) => to Set the BOR level 			 
    672             3/ Once all needed option bytes to be programmed are correctly written, call the
    673               FLASH_OB_Launch(void) function to launch the Option Bytes programming process.
    674               Note: When changing the WDG mode from HW to SW or from SW to HW 
    675               a system reset is needed to make the change effective.  
    676             4/ Call the FLASH_OB_Lock() to disable the Flash option control register access (recommended
    677                to protect the option Bytes against possible unwanted operations)
    678              
    679          @endcode
    680          */
    681          
    682          /**
    683            * @brief  Unlocks the FLASH Option Control Registers access.
    684            * @param  None
    685            * @retval None
    686            */

   \                                 In section .text, align 2, keep-with-next
    687          void FLASH_OB_Unlock(void)
    688          {
    689            if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
   \                     FLASH_OB_Unlock:
   \   00000000   ....               LDR.N    R0,??DataTable28_5  ;; 0x40023c14
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   C007               LSLS     R0,R0,#+31
   \   00000006   05D5               BPL.N    ??FLASH_OB_Unlock_0
    690            {
    691              /* Authorizes the Option Byte register programming */
    692              FLASH->OPTKEYR = FLASH_OPT_KEY1;
   \   00000008   ....               LDR.N    R0,??DataTable28_6  ;; 0x40023c08
   \   0000000A   ....               LDR.N    R1,??DataTable28_7  ;; 0x8192a3b
   \   0000000C   0160               STR      R1,[R0, #+0]
    693              FLASH->OPTKEYR = FLASH_OPT_KEY2;
   \   0000000E   ....               LDR.N    R0,??DataTable28_6  ;; 0x40023c08
   \   00000010   ....               LDR.N    R1,??DataTable28_8  ;; 0x4c5d6e7f
   \   00000012   0160               STR      R1,[R0, #+0]
    694            }  
    695          }
   \                     ??FLASH_OB_Unlock_0:
   \   00000014   7047               BX       LR               ;; return
    696          
    697          /**
    698            * @brief  Locks the FLASH Option Control Registers access.
    699            * @param  None
    700            * @retval None
    701            */

   \                                 In section .text, align 2, keep-with-next
    702          void FLASH_OB_Lock(void)
    703          {
    704            /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
    705            FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
   \                     FLASH_OB_Lock:
   \   00000000   ....               LDR.N    R0,??DataTable28_5  ;; 0x40023c14
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   50F00100           ORRS     R0,R0,#0x1
   \   00000008   ....               LDR.N    R1,??DataTable28_5  ;; 0x40023c14
   \   0000000A   0860               STR      R0,[R1, #+0]
    706          }
   \   0000000C   7047               BX       LR               ;; return
    707          
    708          /**
    709            * @brief  Enables or disables the write protection of the desired sectors
    710            * @note   - To correctly program the WRP option bytes, the FLASH_OB_Unlock() function
    711            *         must be called before this function.
    712            *         - Once the WRP option bytes are correctly written, the FLASH_OB_Launch ()
    713            *         must be called to load the new option bytes.
    714            *         - Call the FLASH_OB_Lock() to disable the Flash option control register access
    715            *          (recommended to protect the option Bytes against possible unwanted operations)  
    716            * @param  OB_WRP: specifies the address of the sectors to be write
    717            *   protected or unprotected. This parameter can be:
    718            *     @arg A value between OB_WRP_Sector0 and OB_WRP_Sector11                      
    719            *     @arg OB_WRP_AllSector
    720            * @param  Newstate: new state of the Write Protection.
    721            *   This parameter can be: ENABLE or DISABLE.
    722            * @retval FLASH Status: The returned value can be: FLASH_BUSY, 
    723            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or 
    724            *   FLASH_COMPLETE.
    725            */

   \                                 In section .text, align 2, keep-with-next
    726          void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
    727          { 
   \                     FLASH_OB_WRPConfig:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    728            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0826               MOVS     R6,#+8
    729            
    730            /* Check the parameters */
    731            assert_param(IS_OB_WRP(OB_WRP));
    732            assert_param(IS_FUNCTIONAL_STATE(NewState));
    733              
    734            status = FLASH_WaitForLastOperation();
   \   00000008   ........           BL       FLASH_WaitForLastOperation
   \   0000000C   0600               MOVS     R6,R0
    735          
    736            if(status == FLASH_COMPLETE)
   \   0000000E   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000010   082E               CMP      R6,#+8
   \   00000012   0DD1               BNE.N    ??FLASH_OB_WRPConfig_0
    737            { 
    738              if(NewState != DISABLE)
   \   00000014   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   002D               CMP      R5,#+0
   \   00000018   05D0               BEQ.N    ??FLASH_OB_WRPConfig_1
    739              {
    740                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
   \   0000001A   ....               LDR.N    R0,??DataTable28_9  ;; 0x40023c16
   \   0000001C   0088               LDRH     R0,[R0, #+0]
   \   0000001E   A043               BICS     R0,R0,R4
   \   00000020   ....               LDR.N    R1,??DataTable28_9  ;; 0x40023c16
   \   00000022   0880               STRH     R0,[R1, #+0]
   \   00000024   04E0               B.N      ??FLASH_OB_WRPConfig_0
    741              }
    742              else
    743              {
    744                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
   \                     ??FLASH_OB_WRPConfig_1:
   \   00000026   ....               LDR.N    R0,??DataTable28_9  ;; 0x40023c16
   \   00000028   0088               LDRH     R0,[R0, #+0]
   \   0000002A   2043               ORRS     R0,R4,R0
   \   0000002C   ....               LDR.N    R1,??DataTable28_9  ;; 0x40023c16
   \   0000002E   0880               STRH     R0,[R1, #+0]
    745              }
    746            }
    747          }
   \                     ??FLASH_OB_WRPConfig_0:
   \   00000030   70BD               POP      {R4-R6,PC}       ;; return
    748          
    749          /**
    750            * @brief  Sets the read protection level.
    751            * @note   - To correctly program the RDP level, the FLASH_OB_Unlock() function
    752            *         must be called before this function.
    753            *         - Once the RDP level is correctly written, the FLASH_OB_Launch ()
    754            *         must be called to load the new option bytes.
    755            *         - Call the FLASH_OB_Lock() to disable the Flash option control register access
    756            *          (recommended to protect the option Bytes against possible unwanted operations)  
    757            * @param  OB_RDP: specifies the read protection level.
    758            *   This parameter can be:
    759            *     @arg OB_RDP_Level_0: No protection
    760            *     @arg OB_RDP_Level_1: Read protection of the memory
    761            *     @arg OB_RDP_Level_2: Full chip protection 
    762            *      !!!Warning!!! When enabling OB_RDP level 2 it's no more possible
    763            *                    to go back to level 1 or 0 
    764            * @retval None
    765            */

   \                                 In section .text, align 2, keep-with-next
    766          void FLASH_OB_RDPConfig(uint8_t OB_RDP)
    767          {
   \                     FLASH_OB_RDPConfig:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
    768            FLASH_Status status = FLASH_COMPLETE;
   \   00000004   0825               MOVS     R5,#+8
    769            /* Check the parameters */
    770            assert_param(IS_OB_RDP(OB_RDP));
    771          
    772            status = FLASH_WaitForLastOperation();
   \   00000006   ........           BL       FLASH_WaitForLastOperation
   \   0000000A   0500               MOVS     R5,R0
    773          
    774            if(status == FLASH_COMPLETE)
   \   0000000C   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   082D               CMP      R5,#+8
   \   00000010   01D1               BNE.N    ??FLASH_OB_RDPConfig_0
    775            {
    776              *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = OB_RDP;
   \   00000012   ....               LDR.N    R0,??DataTable28_10  ;; 0x40023c15
   \   00000014   0470               STRB     R4,[R0, #+0]
    777          
    778            }
    779          }
   \                     ??FLASH_OB_RDPConfig_0:
   \   00000016   31BD               POP      {R0,R4,R5,PC}    ;; return
    780          
    781          /**
    782            * @brief  Programs the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.
    783            * @note   - To correctly program the USER option bytes, the FLASH_OB_Unlock() function
    784            *         must be called before this function.
    785            *         - Once the USER option bytes are correctly written, the FLASH_OB_Launch ()
    786            *         must be called to load the new option bytes.
    787            *         - Call the FLASH_OB_Lock() to disable the Flash option control register access
    788            *          (recommended to protect the option Bytes against possible unwanted operations)         
    789            * @param  OB_IWDG: Selects the IWDG mode
    790            *   This parameter can be one of the following values:
    791            *     @arg OB_IWDG_SW: Software IWDG selected
    792            *     @arg OB_IWDG_HW: Hardware IWDG selected
    793            * @param  OB_STOP: Reset event when entering STOP mode.
    794            *   This parameter can be one of the following values:
    795            *     @arg OB_STOP_NoRST: No reset generated when entering in STOP
    796            *     @arg OB_STOP_RST: Reset generated when entering in STOP
    797            * @param  OB_STDBY: Reset event when entering Standby mode.
    798            *   This parameter can be one of the following values:
    799            *     @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
    800            *     @arg OB_STDBY_RST: Reset generated when entering in STANDBY
    801            * @retval None
    802            */

   \                                 In section .text, align 2, keep-with-next
    803          void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
    804          {
   \                     FLASH_OB_UserConfig:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   0400               MOVS     R4,R0
   \   00000006   0D00               MOVS     R5,R1
   \   00000008   1600               MOVS     R6,R2
    805            uint8_t optiontmp = 0xFF;
   \   0000000A   FF27               MOVS     R7,#+255
    806            FLASH_Status status = FLASH_COMPLETE; 
   \   0000000C   5FF00808           MOVS     R8,#+8
    807            /* Check the parameters */
    808            assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
    809            assert_param(IS_OB_STOP_SOURCE(OB_STOP));
    810            assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
    811          
    812            /* Wait for last operation to be completed */
    813            status = FLASH_WaitForLastOperation();
   \   00000010   ........           BL       FLASH_WaitForLastOperation
   \   00000014   8046               MOV      R8,R0
    814            
    815            if(status == FLASH_COMPLETE)
   \   00000016   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000001A   B8F1080F           CMP      R8,#+8
   \   0000001E   0AD1               BNE.N    ??FLASH_OB_UserConfig_0
    816            { 
    817              optiontmp = (uint8_t)(OB_IWDG | OB_STDBY | OB_STOP)|((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & 0x0F); 
   \   00000020   56EA0400           ORRS     R0,R6,R4
   \   00000024   2843               ORRS     R0,R5,R0
   \   00000026   ....               LDR.N    R1,??DataTable28_5  ;; 0x40023c14
   \   00000028   0978               LDRB     R1,[R1, #+0]
   \   0000002A   11F00F01           ANDS     R1,R1,#0xF
   \   0000002E   51EA0007           ORRS     R7,R1,R0
    818              /* Enable the Option Bytes Programming operation */
    819              *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = optiontmp; 
   \   00000032   ....               LDR.N    R0,??DataTable28_5  ;; 0x40023c14
   \   00000034   0770               STRB     R7,[R0, #+0]
    820          
    821            }  
    822          }
   \                     ??FLASH_OB_UserConfig_0:
   \   00000036   BDE8F081           POP      {R4-R8,PC}       ;; return
    823          
    824          /**
    825            * @brief  Sets the BOR Level.
    826            * @note   - To correctly program the BOR level, the FLASH_OB_Unlock() function
    827            *         must be called before this function.
    828            *         - Once the BOR level is correctly written, the FLASH_OB_Launch ()
    829            *         must be called to load the new option bytes.
    830            *         - Call the FLASH_OB_Lock() to disable the Flash option control register access
    831            *          (recommended to protect the option Bytes against possible unwanted operations)   
    832            * @param  OB_BOR: specifies the Option Bytes BOR Reset Level.
    833            *   This parameter can be one of the following values:
    834            *     @arg OB_BOR_Level_3: FLASH BOR Level 3 : Supply voltage ranges from 2.70 to 3.60 V
    835            *     @arg OB_BOR Level_2: FLASH BOR Level 2 : Supply voltage ranges from 2.40 to 2.70 V
    836            *     @arg OB_BOR Level_1: FLASH BOR Level 1 : Supply voltage ranges from 2.10 to 2.40 V
    837            *     @arg OB_BOR Level_Off: FLASH BOR Off : Supply voltage ranges from 1.62 to 2.10 V.
    838            * @retval None
    839            */

   \                                 In section .text, align 2, keep-with-next
    840          void FLASH_OB_BORConfig(uint8_t OB_BOR)
    841          {
    842            /* Check the parameters */
    843            assert_param(IS_OB_BOR(OB_BOR));
    844          
    845            /* Set the BOR Level */
    846            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
   \                     FLASH_OB_BORConfig:
   \   00000000   ....               LDR.N    R1,??DataTable28_5  ;; 0x40023c14
   \   00000002   0978               LDRB     R1,[R1, #+0]
   \   00000004   11F0F301           ANDS     R1,R1,#0xF3
   \   00000008   ....               LDR.N    R2,??DataTable28_5  ;; 0x40023c14
   \   0000000A   1170               STRB     R1,[R2, #+0]
    847            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOR;
   \   0000000C   ....               LDR.N    R1,??DataTable28_5  ;; 0x40023c14
   \   0000000E   0978               LDRB     R1,[R1, #+0]
   \   00000010   0843               ORRS     R0,R0,R1
   \   00000012   ....               LDR.N    R1,??DataTable28_5  ;; 0x40023c14
   \   00000014   0870               STRB     R0,[R1, #+0]
    848          
    849          }
   \   00000016   7047               BX       LR               ;; return
    850          
    851          /**
    852            * @brief  Launch the option byte loading.
    853            * @param  None
    854            * @retval FLASH Status: The returned value can be: FLASH_BUSY, 
    855            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or 
    856            *   FLASH_COMPLETE.
    857            */

   \                                 In section .text, align 2, keep-with-next
    858          FLASH_Status FLASH_OB_Launch(void)
    859          {
   \                     FLASH_OB_Launch:
   \   00000000   10B5               PUSH     {R4,LR}
    860            FLASH_Status status = FLASH_COMPLETE;
   \   00000002   0824               MOVS     R4,#+8
    861          
    862            /* Set the OPTSTRT bit in OPTCR register */
    863            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
   \   00000004   ....               LDR.N    R0,??DataTable28_5  ;; 0x40023c14
   \   00000006   0078               LDRB     R0,[R0, #+0]
   \   00000008   50F00200           ORRS     R0,R0,#0x2
   \   0000000C   ....               LDR.N    R1,??DataTable28_5  ;; 0x40023c14
   \   0000000E   0870               STRB     R0,[R1, #+0]
    864          
    865            /* Wait for last operation to be completed */
    866            status = FLASH_WaitForLastOperation();
   \   00000010   ........           BL       FLASH_WaitForLastOperation
   \   00000014   0400               MOVS     R4,R0
    867          
    868            return status;
   \   00000016   2000               MOVS     R0,R4
   \   00000018   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   10BD               POP      {R4,PC}          ;; return
    869          }
    870          
    871          /**
    872            * @brief  Returns the FLASH User Option Bytes values.
    873            * @param  None
    874            * @retval The FLASH User Option Bytes values:IWDG_SW(Bit0), RST_STOP(Bit1)
    875            *   and RST_STDBY(Bit2).
    876            */

   \                                 In section .text, align 2, keep-with-next
    877          uint8_t FLASH_OB_GetUser(void)
    878          {
    879            /* Return the User Option Byte */
    880            return (uint8_t)(FLASH->OPTCR >> 5);
   \                     FLASH_OB_GetUser:
   \   00000000   ....               LDR.N    R0,??DataTable28_5  ;; 0x40023c14
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   4009               LSRS     R0,R0,#+5
   \   00000006   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   7047               BX       LR               ;; return
    881          }
    882          
    883          /**
    884            * @brief  Returns the FLASH Write Protection Option Bytes value.
    885            * @param  None
    886            * @retval The FLASH Write Protection  Option Bytes value
    887            */

   \                                 In section .text, align 2, keep-with-next
    888          uint16_t FLASH_OB_GetWRP(void)
    889          {
    890            /* Return the Flash write protection Register value */
    891            return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
   \                     FLASH_OB_GetWRP:
   \   00000000   ....               LDR.N    R0,??DataTable28_9  ;; 0x40023c16
   \   00000002   0088               LDRH     R0,[R0, #+0]
   \   00000004   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000006   7047               BX       LR               ;; return
    892          }
    893          
    894          /**
    895            * @brief  Returns the FLASH Read Protection level.
    896            * @param  None
    897            * @retval FLASH ReadOut Protection Status:
    898            *  - SET(when OB_RDP_Level_1 is set)
    899            *  - RESET(when OB_RDP_Level_0 is set)
    900            */

   \                                 In section .text, align 2, keep-with-next
    901          FlagStatus FLASH_OB_GetRDP(void)
    902          {
    903            FlagStatus readstatus = RESET;
   \                     FLASH_OB_GetRDP:
   \   00000000   0020               MOVS     R0,#+0
    904            if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_Level_0))
   \   00000002   ....               LDR.N    R1,??DataTable28_10  ;; 0x40023c15
   \   00000004   0978               LDRB     R1,[R1, #+0]
   \   00000006   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   AA29               CMP      R1,#+170
   \   0000000A   01D0               BEQ.N    ??FLASH_OB_GetRDP_0
    905            {
    906              readstatus = SET;
   \   0000000C   0120               MOVS     R0,#+1
   \   0000000E   00E0               B.N      ??FLASH_OB_GetRDP_1
    907            }
    908            else
    909            {
    910              readstatus = RESET;
   \                     ??FLASH_OB_GetRDP_0:
   \   00000010   0020               MOVS     R0,#+0
    911            }
    912            return readstatus;
   \                     ??FLASH_OB_GetRDP_1:
   \   00000012   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   7047               BX       LR               ;; return
    913          }
    914          
    915          /**
    916            * @brief  Returns the FLASH BOR level.
    917            * @param  None
    918            * @retval The FLASH BOR level
    919            */

   \                                 In section .text, align 2, keep-with-next
    920          uint8_t FLASH_OB_GetBOR(void)
    921          {
    922            /* Return the Falsh BOR level */
    923            return (((*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & 0x0C) >> 2));
   \                     FLASH_OB_GetBOR:
   \   00000000   ....               LDR.N    R0,??DataTable28_5  ;; 0x40023c14
   \   00000002   0078               LDRB     R0,[R0, #+0]
   \   00000004   C0F38100           UBFX     R0,R0,#+2,#+2
   \   00000008   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   7047               BX       LR               ;; return
    924          }
    925          
    926          /**
    927            * @brief  Checks whether the specified FLASH flag is set or not.
    928            * @param  FLASH_FLAG: specifies the FLASH flag to check.
    929            *   This parameter can be one of the following values:
    930            *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag 
    931            *     @arg FLASH_FLAG_OPERR: FLASH operation Error flag 
    932            *     @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
    933            *     @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag
    934            *     @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
    935            *     @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
    936            *     @arg FLASH_FLAG_BSY: FLASH Busy flag
    937            * @retval The new state of FLASH_FLAG (SET or RESET).
    938            */

   \                                 In section .text, align 2, keep-with-next
    939          FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
    940          {
    941            FlagStatus bitstatus = RESET;
   \                     FLASH_GetFlagStatus:
   \   00000000   0021               MOVS     R1,#+0
    942            /* Check the parameters */
    943            assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));
    944            if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
   \   00000002   ....               LDR.N    R2,??DataTable28_11  ;; 0x40023c0c
   \   00000004   1268               LDR      R2,[R2, #+0]
   \   00000006   0242               TST      R2,R0
   \   00000008   01D0               BEQ.N    ??FLASH_GetFlagStatus_0
    945            {
    946              bitstatus = SET;
   \   0000000A   0121               MOVS     R1,#+1
   \   0000000C   00E0               B.N      ??FLASH_GetFlagStatus_1
    947            }
    948            else
    949            {
    950              bitstatus = RESET;
   \                     ??FLASH_GetFlagStatus_0:
   \   0000000E   0021               MOVS     R1,#+0
    951            }
    952            /* Return the new state of FLASH_FLAG (SET or RESET) */
    953            return bitstatus; 
   \                     ??FLASH_GetFlagStatus_1:
   \   00000010   0800               MOVS     R0,R1
   \   00000012   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   7047               BX       LR               ;; return
    954          }
    955          
    956          /**
    957            * @brief  Clears the FLASHs pending flags.
    958            * @param  FLASH_FLAG: specifies the FLASH flags to clear.
    959            *   This parameter can be any combination of the following values:
    960            *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag 
    961            *     @arg FLASH_FLAG_OPERR: FLASH operation Error flag 
    962            *     @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
    963            *     @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag 
    964            *     @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
    965            *     @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
    966            * @retval None
    967            */

   \                                 In section .text, align 2, keep-with-next
    968          void FLASH_ClearFlag(uint32_t FLASH_FLAG)
    969          {
    970            /* Check the parameters */
    971            assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
    972            
    973            /* Clear the flags */
    974            FLASH->SR = FLASH_FLAG;
   \                     FLASH_ClearFlag:
   \   00000000   ....               LDR.N    R1,??DataTable28_11  ;; 0x40023c0c
   \   00000002   0860               STR      R0,[R1, #+0]
    975          }
   \   00000004   7047               BX       LR               ;; return
    976          
    977          /**
    978            * @brief  Returns the FLASH Status.
    979            * @param  None
    980            * @retval FLASH Status: The returned value can be: FLASH_BUSY, 
    981            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_ERROR_OPERATION
    982               or FLASH_COMPLETE
    983            */

   \                                 In section .text, align 2, keep-with-next
    984          FLASH_Status FLASH_GetStatus(void)
    985          {
    986            FLASH_Status flashstatus = FLASH_COMPLETE;
   \                     FLASH_GetStatus:
   \   00000000   0820               MOVS     R0,#+8
    987            
    988            if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
   \   00000002   ....               LDR.N    R1,??DataTable28_11  ;; 0x40023c0c
   \   00000004   0968               LDR      R1,[R1, #+0]
   \   00000006   C903               LSLS     R1,R1,#+15
   \   00000008   01D5               BPL.N    ??FLASH_GetStatus_0
    989            {
    990              flashstatus = FLASH_BUSY;
   \   0000000A   0120               MOVS     R0,#+1
   \   0000000C   14E0               B.N      ??FLASH_GetStatus_1
    991            }
    992            else 
    993            {  
    994              if(FLASH->SR & FLASH_FLAG_WRPERR)
   \                     ??FLASH_GetStatus_0:
   \   0000000E   ....               LDR.N    R0,??DataTable28_11  ;; 0x40023c0c
   \   00000010   0068               LDR      R0,[R0, #+0]
   \   00000012   C006               LSLS     R0,R0,#+27
   \   00000014   01D5               BPL.N    ??FLASH_GetStatus_2
    995              { 
    996                flashstatus = FLASH_ERROR_WRP;
   \   00000016   0520               MOVS     R0,#+5
   \   00000018   0EE0               B.N      ??FLASH_GetStatus_1
    997              }
    998              else 
    999              {
   1000                if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
   \                     ??FLASH_GetStatus_2:
   \   0000001A   ....               LDR.N    R0,??DataTable28_11  ;; 0x40023c0c
   \   0000001C   0068               LDR      R0,[R0, #+0]
   \   0000001E   10F0EF00           ANDS     R0,R0,#0xEF
   \   00000022   0028               CMP      R0,#+0
   \   00000024   01D0               BEQ.N    ??FLASH_GetStatus_3
   1001                {
   1002                  flashstatus = FLASH_ERROR_PROGRAM; 
   \   00000026   0620               MOVS     R0,#+6
   \   00000028   06E0               B.N      ??FLASH_GetStatus_1
   1003                }
   1004                else
   1005                {
   1006                  if(FLASH->SR & FLASH_FLAG_OPERR)
   \                     ??FLASH_GetStatus_3:
   \   0000002A   ....               LDR.N    R0,??DataTable28_11  ;; 0x40023c0c
   \   0000002C   0068               LDR      R0,[R0, #+0]
   \   0000002E   8007               LSLS     R0,R0,#+30
   \   00000030   01D5               BPL.N    ??FLASH_GetStatus_4
   1007                  {
   1008                    flashstatus = FLASH_ERROR_OPERATION;
   \   00000032   0720               MOVS     R0,#+7
   \   00000034   00E0               B.N      ??FLASH_GetStatus_1
   1009                  }
   1010                  else
   1011                  {
   1012                    flashstatus = FLASH_COMPLETE;
   \                     ??FLASH_GetStatus_4:
   \   00000036   0820               MOVS     R0,#+8
   1013                  }
   1014                }
   1015              }
   1016            }
   1017            /* Return the Flash Status */
   1018            return flashstatus;
   \                     ??FLASH_GetStatus_1:
   \   00000038   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   7047               BX       LR               ;; return
   1019          }
   1020          
   1021          /**
   1022            * @brief  Waits for a Flash operation to complete or a TIMEOUT to occur.
   1023            * @param  Timeout: FLASH programming Timeout
   1024            * @retval FLASH Status: The returned value can be: FLASH_ERROR_OPERATION, 
   1025            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP or FLASH_COMPLETE.
   1026            */

   \                                 In section .text, align 2, keep-with-next
   1027          FLASH_Status FLASH_WaitForLastOperation(void)
   1028          { 
   \                     FLASH_WaitForLastOperation:
   \   00000000   10B5               PUSH     {R4,LR}
   1029            FLASH_Status status = FLASH_COMPLETE;
   \   00000002   0824               MOVS     R4,#+8
   1030             
   1031            /* Check for the Flash Status */
   1032            status = FLASH_GetStatus();
   \   00000004   ........           BL       FLASH_GetStatus
   \   00000008   0400               MOVS     R4,R0
   \   0000000A   02E0               B.N      ??FLASH_WaitForLastOperation_0
   1033            /* Wait for a Flash operation to complete by polling on BUSY flag to 
   1034               be reset. Even if the Flash operation fails the BUSY flag will be reset
   1035              and an error flag will be set */
   1036            while(status == FLASH_BUSY)
   1037            {
   1038              status = FLASH_GetStatus();
   \                     ??FLASH_WaitForLastOperation_1:
   \   0000000C   ........           BL       FLASH_GetStatus
   \   00000010   0400               MOVS     R4,R0
   1039            }
   \                     ??FLASH_WaitForLastOperation_0:
   \   00000012   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   012C               CMP      R4,#+1
   \   00000016   F9D0               BEQ.N    ??FLASH_WaitForLastOperation_1
   1040            /* Return the operation status */
   1041            return status;
   \   00000018   2000               MOVS     R0,R4
   \   0000001A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   10BD               POP      {R4,PC}          ;; return
   1042          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   003C0240           DC32     0x40023c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \   00000000   103C0240           DC32     0x40023c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \   00000000   043C0240           DC32     0x40023c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \   00000000   23016745           DC32     0x45670123

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_4:
   \   00000000   AB89EFCD           DC32     0xcdef89ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_5:
   \   00000000   143C0240           DC32     0x40023c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_6:
   \   00000000   083C0240           DC32     0x40023c08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_7:
   \   00000000   3B2A1908           DC32     0x8192a3b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_8:
   \   00000000   7F6E5D4C           DC32     0x4c5d6e7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_9:
   \   00000000   163C0240           DC32     0x40023c16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_10:
   \   00000000   153C0240           DC32     0x40023c15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_11:
   \   00000000   0C3C0240           DC32     0x40023c0c
   1043          
   1044          /**
   1045            * @}
   1046            */ 
   1047          
   1048          
   1049          /**
   1050            * @}
   1051            */ 
   1052          
   1053          
   1054          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                    .cstack
     --------                    -------
     FLASH_ClearFlag                  0
     FLASH_DataCacheCmd               0
     FLASH_DataCacheReset             0
     FLASH_EraseAllSectors           16
     FLASH_EraseSector               16
     FLASH_GetFlagStatus              0
     FLASH_GetStatus                  0
     FLASH_ITConfig                   0
     FLASH_InstructionCacheCmd        0
     FLASH_InstructionCacheReset      0
     FLASH_Lock                       0
     FLASH_OB_BORConfig               0
     FLASH_OB_GetBOR                  0
     FLASH_OB_GetRDP                  0
     FLASH_OB_GetUser                 0
     FLASH_OB_GetWRP                  0
     FLASH_OB_Launch                  8
     FLASH_OB_Lock                    0
     FLASH_OB_RDPConfig              16
     FLASH_OB_Unlock                  0
     FLASH_OB_UserConfig             24
     FLASH_OB_WRPConfig              16
     FLASH_PrefetchBufferCmd          0
     FLASH_ProgramByte               16
     FLASH_ProgramDoubleWord         24
     FLASH_ProgramHalfWord           16
     FLASH_ProgramWord               16
     FLASH_SetLatency                 0
     FLASH_Unlock                     0
     FLASH_WaitForLastOperation       8


   Section sizes:

     Function/Label              Bytes
     --------------              -----
     FLASH_SetLatency               8
     FLASH_PrefetchBufferCmd       44
     FLASH_InstructionCacheCmd     44
     FLASH_DataCacheCmd            42
     FLASH_InstructionCacheReset   18
     FLASH_DataCacheReset          18
     FLASH_ITConfig                40
     FLASH_Unlock                  32
     FLASH_Lock                    18
     FLASH_EraseSector            176
     FLASH_EraseAllSectors        128
     FLASH_ProgramDoubleWord       88
     FLASH_ProgramWord             84
     FLASH_ProgramHalfWord         84
     FLASH_ProgramByte             78
     FLASH_OB_Unlock               22
     FLASH_OB_Lock                 14
     FLASH_OB_WRPConfig            50
     FLASH_OB_RDPConfig            24
     FLASH_OB_UserConfig           58
     FLASH_OB_BORConfig            24
     FLASH_OB_Launch               28
     FLASH_OB_GetUser              10
     FLASH_OB_GetWRP                8
     FLASH_OB_GetRDP               22
     FLASH_OB_GetBOR               12
     FLASH_GetFlagStatus           22
     FLASH_ClearFlag                6
     FLASH_GetStatus               60
     FLASH_WaitForLastOperation    30
     ??DataTable28                  4
     ??DataTable28_1                4
     ??DataTable28_2                4
     ??DataTable28_3                4
     ??DataTable28_4                4
     ??DataTable28_5                4
     ??DataTable28_6                4
     ??DataTable28_7                4
     ??DataTable28_8                4
     ??DataTable28_9                4
     ??DataTable28_10               4
     ??DataTable28_11               4

 
 1 340 bytes in section .text
 
 1 340 bytes of CODE memory

Errors: none
Warnings: none
