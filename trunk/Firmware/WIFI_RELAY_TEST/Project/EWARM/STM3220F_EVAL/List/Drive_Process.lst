###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     20/Dec/2011  15:57:31 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\Drive_Proces #
#                    s.c                                                      #
#    Command line =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\Drive_Proces #
#                    s.c -D USE_STDPERIPH_DRIVER -D STM32F2XX -D              #
#                    USE_STM3220F_EVAL -D USE_USB_OTG_FS -D                   #
#                    RTC_CLOCK_SOURCE_LSE -lC E:\Work\Firmware\DTG\DTG_EMS_SY #
#                    STEM\Project\EWARM\STM3220F_EVAL\List\ -lA               #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\List\ -o E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Pro #
#                    ject\EWARM\STM3220F_EVAL\Obj\ --no_cse --no_unroll       #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWAR #
#                    M\..\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWA #
#                    RM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I             #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I       #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I             #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Utilities\STM32_EVAL\ -I E:\Work\Firmware\DTG\DTG_EMS_SY #
#                    STEM\Project\EWARM\..\..\Utilities\STM32_EVAL\Common\    #
#                    -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\ #
#                    ..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I                #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_OTG_Driver\inc\ -I                   #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_Device_Library\Core\inc\ -I          #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_Device_Library\Class\msc\inc\ -I     #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\Usb #
#                    \ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\. #
#                    .\Usb\Inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Projec #
#                    t\EWARM\..\Usb\src\ -I E:\Work\Firmware\DTG\DTG_EMS_SYST #
#                    EM\Project\EWARM\..\..\Libraries\STM32_USB_HOST_Library\ #
#                    Core\inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project #
#                    \EWARM\..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\ #
#                    inc\ -Ol --use_c++_inline                                #
#    List file    =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\List\Drive_Process.lst                           #
#    Object file  =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\Obj\Drive_Process.o                              #
#                                                                             #
#                                                                             #
###############################################################################

E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\Drive_Process.c
      1          
      2          #include "main.h"

   \                                 In section .text, align 2
   \   __intrinsic __interwork __softfp void *memcpy(void *, void const *, size_t)
   \                     memcpy:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           BL       __aeabi_memcpy
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   10BD               POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __intrinsic __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   1000               MOVS     R0,R2
   \   00000006   0A00               MOVS     R2,R1
   \   00000008   0100               MOVS     R1,R0
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   ........           BL       __aeabi_memset
   \   00000010   2000               MOVS     R0,R4
   \   00000012   10BD               POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LED1_OFF(void)
   \                     LED1_OFF:
   \   00000000   80B5               PUSH     {R7,LR}
   \   00000002   4FF40051           MOV      R1,#+8192
   \   00000006   ........           LDR.W    R0,??DataTable8  ;; 0x40021800
   \   0000000A   ........           BL       GPIO_SetBits
   \   0000000E   4FF48041           MOV      R1,#+16384
   \   00000012   ........           LDR.W    R0,??DataTable8  ;; 0x40021800
   \   00000016   ........           BL       GPIO_SetBits
   \   0000001A   01BD               POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LED1_RED(void)
   \                     LED1_RED:
   \   00000000   80B5               PUSH     {R7,LR}
   \   00000002   4FF40051           MOV      R1,#+8192
   \   00000006   ........           LDR.W    R0,??DataTable8  ;; 0x40021800
   \   0000000A   ........           BL       GPIO_ResetBits
   \   0000000E   4FF48041           MOV      R1,#+16384
   \   00000012   ........           LDR.W    R0,??DataTable8  ;; 0x40021800
   \   00000016   ........           BL       GPIO_SetBits
   \   0000001A   01BD               POP      {R0,PC}          ;; return
      3          #include "Drive_Process.h"
      4          #include "Voice.h"
      5          #include "Memory.h"
      6          #include "Ems_System.h"
      7          #include "Voice.h"
      8          #include "RTC.h"
      9          #include "GraphicLcd.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void Lcd_Backlight_ON(void)
   \                     Lcd_Backlight_ON:
   \   00000000   80B5               PUSH     {R7,LR}
   \   00000002   4FF40061           MOV      R1,#+2048
   \   00000006   ........           LDR.W    R0,??DataTable8_1  ;; 0x40021400
   \   0000000A   ........           BL       GPIO_SetBits
   \   0000000E   01BD               POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void Lcd_Backlight_OFF(void)
   \                     Lcd_Backlight_OFF:
   \   00000000   80B5               PUSH     {R7,LR}
   \   00000002   4FF40061           MOV      R1,#+2048
   \   00000006   ........           LDR.W    R0,??DataTable8_1  ;; 0x40021400
   \   0000000A   ........           BL       GPIO_ResetBits
   \   0000000E   01BD               POP      {R0,PC}          ;; return
     10          #include "i2c_ee.h"
     11          #include "usbh_usr.h"
     12          

   \                                 In section .text, align 2, keep-with-next
     13          void Driver_Start(void) // 자동차 운전 시작하기 위한 준비
     14          {    
   \                     Driver_Start:
   \   00000000   80B5               PUSH     {R7,LR}
     15               // 해더 위치 잡기
     16          //     Setting_Header_Information(); 
     17          
     18               // EEPROM 에서 먼저 데이터를 읽어와야 한다.	
     19               //현재 헤더를 구한다.
     20          
     21               if( Flag.WatchDog == 0 )                // 전원 온시 와치독이 아니면 시작멘트
   \   00000002   ........           LDR.W    R0,??DataTable8_2
   \   00000006   007A               LDRB     R0,[R0, #+8]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   02D1               BNE.N    ??Driver_Start_0
     22                    Voice_OutAdd(VOICE_DRIVE_ON);
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   ........           BL       Voice_OutAdd
     23          
     24               if( Info.EcoStatus == 0 ) // 에코모드인가
   \                     ??Driver_Start_0:
   \   00000012   ........           LDR.W    R0,??DataTable8_3
   \   00000016   007E               LDRB     R0,[R0, #+24]
   \   00000018   0028               CMP      R0,#+0
   \   0000001A   02D1               BNE.N    ??Driver_Start_1
     25               {          
     26                    LED1_OFF();		// 아님
   \   0000001C   ........           BL       LED1_OFF
   \   00000020   09E0               B.N      ??Driver_Start_2
     27               }else
     28               {
     29                    LED1_RED();      // 에코모드
   \                     ??Driver_Start_1:
   \   00000022   ........           BL       LED1_RED
     30                    if( Flag.WatchDog == 0 )
   \   00000026   ........           LDR.W    R0,??DataTable8_2
   \   0000002A   007A               LDRB     R0,[R0, #+8]
   \   0000002C   0028               CMP      R0,#+0
   \   0000002E   02D1               BNE.N    ??Driver_Start_2
     31                         Voice_OutAdd(VOICE_ECO_ON);
   \   00000030   0620               MOVS     R0,#+6
   \   00000032   ........           BL       Voice_OutAdd
     32               }		     
     33               
     34               memset(&ECO_Driving, 0, sizeof (struct _ECO_Driving ));      //ECO 드라이브 클리어
   \                     ??Driver_Start_2:
   \   00000036   0A22               MOVS     R2,#+10
   \   00000038   0021               MOVS     R1,#+0
   \   0000003A   ........           LDR.W    R0,??DataTable8_4
   \   0000003E   ........           BL       memset
     35               
     36               
     37               if(Info.Total_StartCount > 40000)       // 
   \   00000042   ........           LDR.W    R0,??DataTable8_3
   \   00000046   D0F82600           LDR      R0,[R0, #+38]
   \   0000004A   49F64141           MOVW     R1,#+40001
   \   0000004E   8842               CMP      R0,R1
   \   00000050   02D3               BCC.N    ??Driver_Start_3
     38               {
     39                    Voice_OutAdd(VOICE_STARTOVER);
   \   00000052   0920               MOVS     R0,#+9
   \   00000054   ........           BL       Voice_OutAdd
     40               }
     41               //     Info.Active_Flag = 1;		// 기기 활성화 플래그
     42          }
   \                     ??Driver_Start_3:
   \   00000058   01BD               POP      {R0,PC}          ;; return
     43          
     44          

   \                                 In section .text, align 2, keep-with-next
     45          void Driver_End(void) 			// 자동차 운행 종료
     46          {
   \                     Driver_End:
   \   00000000   80B5               PUSH     {R7,LR}
     47          
     48               DTG_EMS_DataSave(NAND_Header_Index.Page_Count, Info.DTG_DataCount);	     // NAND FLASH 데이터 저장
   \   00000002   ........           LDR.W    R0,??DataTable8_3
   \   00000006   90F86210           LDRB     R1,[R0, #+98]
   \   0000000A   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   ........           LDR.W    R0,??DataTable8_5
   \   00000010   4068               LDR      R0,[R0, #+4]
   \   00000012   ........           BL       DTG_EMS_DataSave
     49          
     50               Info.DTG_DataCount = 0;    // 페이지 처음부터 작성하기
   \   00000016   ........           LDR.W    R0,??DataTable8_3
   \   0000001A   0021               MOVS     R1,#+0
   \   0000001C   80F86210           STRB     R1,[R0, #+98]
     51               memset(DTG_NAND_Binary,0, sizeof(DTG_NAND_Binary));     
   \   00000020   41F6F602           MOVW     R2,#+6390
   \   00000024   0021               MOVS     R1,#+0
   \   00000026   ........           LDR.W    R0,??DataTable8_6
   \   0000002A   ........           BL       memset
     52               
     53               // =========================================================================  
     54          
     55               Write_Header_EMS();                     // 누적 운행거리 저장
   \   0000002E   ........           BL       Write_Header_EMS
     56          
     57               if(NAND_Data_Transmit.End_Page >= MAX_NAND_PAGE)
   \   00000032   ........           LDR.W    R0,??DataTable8_7
   \   00000036   4068               LDR      R0,[R0, #+4]
   \   00000038   ........           LDR.W    R1,??DataTable8_8  ;; 0x3e7ff
   \   0000003C   8842               CMP      R0,R1
   \   0000003E   04D3               BCC.N    ??Driver_End_0
     58                    NAND_Data_Transmit.End_Page = 0;
   \   00000040   ........           LDR.W    R0,??DataTable8_7
   \   00000044   0021               MOVS     R1,#+0
   \   00000046   4160               STR      R1,[R0, #+4]
   \   00000048   06E0               B.N      ??Driver_End_1
     59               else
     60                    NAND_Data_Transmit.End_Page ++;         // 데이터 전송 페이지 저장
   \                     ??Driver_End_0:
   \   0000004A   ........           LDR.W    R0,??DataTable8_7
   \   0000004E   4068               LDR      R0,[R0, #+4]
   \   00000050   401C               ADDS     R0,R0,#+1
   \   00000052   ........           LDR.W    R1,??DataTable8_7
   \   00000056   4860               STR      R0,[R1, #+4]
     61          
     62               if(NAND_Header_Index.Page_Count >= MAX_NAND_PAGE)
   \                     ??Driver_End_1:
   \   00000058   ........           LDR.W    R0,??DataTable8_5
   \   0000005C   4068               LDR      R0,[R0, #+4]
   \   0000005E   ........           LDR.W    R1,??DataTable8_8  ;; 0x3e7ff
   \   00000062   8842               CMP      R0,R1
   \   00000064   04D3               BCC.N    ??Driver_End_2
     63                    NAND_Header_Index.Page_Count = 0;
   \   00000066   ........           LDR.W    R0,??DataTable8_5
   \   0000006A   0021               MOVS     R1,#+0
   \   0000006C   4160               STR      R1,[R0, #+4]
   \   0000006E   06E0               B.N      ??Driver_End_3
     64               else
     65                    NAND_Header_Index.Page_Count ++;
   \                     ??Driver_End_2:
   \   00000070   ........           LDR.W    R0,??DataTable8_5
   \   00000074   4068               LDR      R0,[R0, #+4]
   \   00000076   401C               ADDS     R0,R0,#+1
   \   00000078   ........           LDR.W    R1,??DataTable8_5
   \   0000007C   4860               STR      R0,[R1, #+4]
     66               if(NAND_Header_Info.End_Page >= MAX_NAND_PAGE)        
   \                     ??Driver_End_3:
   \   0000007E   ........           LDR.W    R0,??DataTable8_9
   \   00000082   8068               LDR      R0,[R0, #+8]
   \   00000084   ........           LDR.W    R1,??DataTable8_8  ;; 0x3e7ff
   \   00000088   8842               CMP      R0,R1
   \   0000008A   04D3               BCC.N    ??Driver_End_4
     67                    NAND_Header_Info.End_Page = 0;
   \   0000008C   ........           LDR.W    R0,??DataTable8_9
   \   00000090   0021               MOVS     R1,#+0
   \   00000092   8160               STR      R1,[R0, #+8]
   \   00000094   06E0               B.N      ??Driver_End_5
     68               else
     69                    NAND_Header_Info.End_Page++;
   \                     ??Driver_End_4:
   \   00000096   ........           LDR.W    R0,??DataTable8_9
   \   0000009A   8068               LDR      R0,[R0, #+8]
   \   0000009C   401C               ADDS     R0,R0,#+1
   \   0000009E   ........           LDR.W    R1,??DataTable8_9
   \   000000A2   8860               STR      R0,[R1, #+8]
     70               
     71               Write_Header_Information();                  // 해더 정보를 저장 	
   \                     ??Driver_End_5:
   \   000000A4   ........           BL       Write_Header_Information
     72               
     73               Write_Header_Index();                         // 해더 인덱스 정보를 저장 하고
   \   000000A8   ........           BL       Write_Header_Index
     74               
     75               Write_Transmit_Header();
   \   000000AC   ........           BL       Write_Transmit_Header
     76          }
   \   000000B0   01BD               POP      {R0,PC}          ;; return
     77          

   \                                 In section .text, align 2, keep-with-next
     78          void Drive_Acceident_Check(void)
     79          {
   \                     Drive_Acceident_Check:
   \   00000000   30B5               PUSH     {R4,R5,LR}
   \   00000002   85B0               SUB      SP,SP,#+20
     80               u16 GapTemp;
     81               u16 BufferSize ;
     82               if(Flag.Accident_Step == 0)  //    이벤트가 발생했다면
   \   00000004   ....               LDR.N    R0,??DataTable8_2
   \   00000006   4079               LDRB     R0,[R0, #+5]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   00F09980           BEQ.W    ??Drive_Acceident_Check_0
     83                    return;
     84               
     85               switch(Flag.Accident_Step ) 
   \                     ??Drive_Acceident_Check_1:
   \   0000000E   ....               LDR.N    R0,??DataTable8_2
   \   00000010   4079               LDRB     R0,[R0, #+5]
   \   00000012   0128               CMP      R0,#+1
   \   00000014   07D0               BEQ.N    ??Drive_Acceident_Check_2
   \   00000016   C0F09380           BCC.W    ??Drive_Acceident_Check_3
   \   0000001A   0328               CMP      R0,#+3
   \   0000001C   76D0               BEQ.N    ??Drive_Acceident_Check_4
   \   0000001E   03D3               BCC.N    ??Drive_Acceident_Check_5
   \   00000020   0428               CMP      R0,#+4
   \   00000022   74D0               BEQ.N    ??Drive_Acceident_Check_6
   \   00000024   8CE0               B.N      ??Drive_Acceident_Check_3
     86               {
     87               case 1:
     88                    {
     89                         // 기다리기
     90                    }
     91                    break;
   \                     ??Drive_Acceident_Check_2:
   \   00000026   8BE0               B.N      ??Drive_Acceident_Check_3
     92               case 2:
     93                    {
     94                         sprintf((char *) Accident_Time, "%02d%02d%02d%02d%02d%02d"
     95                                 ,SYSTEM_TIME.tm_year-2000,SYSTEM_TIME.tm_mon,SYSTEM_TIME.tm_mday
     96                                 ,SYSTEM_TIME.tm_hour,SYSTEM_TIME.tm_min,SYSTEM_TIME.tm_sec);          
   \                     ??Drive_Acceident_Check_5:
   \   00000028   ....               LDR.N    R0,??DataTable8_10
   \   0000002A   0068               LDR      R0,[R0, #+0]
   \   0000002C   0390               STR      R0,[SP, #+12]
   \   0000002E   ....               LDR.N    R0,??DataTable8_10
   \   00000030   4068               LDR      R0,[R0, #+4]
   \   00000032   0290               STR      R0,[SP, #+8]
   \   00000034   ....               LDR.N    R0,??DataTable8_10
   \   00000036   8068               LDR      R0,[R0, #+8]
   \   00000038   0190               STR      R0,[SP, #+4]
   \   0000003A   ....               LDR.N    R0,??DataTable8_10
   \   0000003C   C068               LDR      R0,[R0, #+12]
   \   0000003E   0090               STR      R0,[SP, #+0]
   \   00000040   ....               LDR.N    R0,??DataTable8_10
   \   00000042   0369               LDR      R3,[R0, #+16]
   \   00000044   ....               LDR.N    R0,??DataTable8_10
   \   00000046   4069               LDR      R0,[R0, #+20]
   \   00000048   B0F5FA62           SUBS     R2,R0,#+2000
   \   0000004C   ........           ADR.W    R1,`?<Constant "%02d%02d%02d%02d%02d%02d">`
   \   00000050   ....               LDR.N    R0,??DataTable8_11
   \   00000052   ........           BL       sprintf
     97                         GapTemp = 1000 - AccidentPoint;
   \   00000056   4FF47A70           MOV      R0,#+1000
   \   0000005A   ....               LDR.N    R1,??DataTable8_12
   \   0000005C   0988               LDRH     R1,[R1, #+0]
   \   0000005E   441A               SUBS     R4,R0,R1
     98                         BufferSize = sizeof(Accident_Buffer[0]);
   \   00000060   0825               MOVS     R5,#+8
     99                         memcpy(&Accident_SaveBuffer[GapTemp], &Accident_Buffer, AccidentPoint * BufferSize);
   \   00000062   ....               LDR.N    R0,??DataTable8_12
   \   00000064   0088               LDRH     R0,[R0, #+0]
   \   00000066   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000068   05FB00F2           MUL      R2,R5,R0
   \   0000006C   ....               LDR.N    R1,??DataTable8_13
   \   0000006E   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000070   ....               LDR.N    R0,??DataTable8_14
   \   00000072   10EBC400           ADDS     R0,R0,R4, LSL #+3
   \   00000076   ........           BL       memcpy
    100                         memcpy(&Accident_SaveBuffer, &Accident_Buffer[AccidentPoint], GapTemp * BufferSize);
   \   0000007A   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000007C   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000007E   05FB04F2           MUL      R2,R5,R4
   \   00000082   ....               LDR.N    R0,??DataTable8_12
   \   00000084   0088               LDRH     R0,[R0, #+0]
   \   00000086   ....               LDR.N    R1,??DataTable8_13
   \   00000088   11EBC001           ADDS     R1,R1,R0, LSL #+3
   \   0000008C   ....               LDR.N    R0,??DataTable8_14
   \   0000008E   ........           BL       memcpy
    101          
    102                         
    103                         GapTemp = 10 - AccidentPoint2;
   \   00000092   ....               LDR.N    R0,??DataTable8_15
   \   00000094   0088               LDRH     R0,[R0, #+0]
   \   00000096   D0F10A04           RSBS     R4,R0,#+10
    104                         BufferSize = sizeof(Accident2_Buffer[0]);
   \   0000009A   1125               MOVS     R5,#+17
    105                         memcpy(&Accident2_SaveBuffer[GapTemp], &Accident2_Buffer, AccidentPoint2 * BufferSize);
   \   0000009C   ....               LDR.N    R0,??DataTable8_15
   \   0000009E   0088               LDRH     R0,[R0, #+0]
   \   000000A0   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000A2   05FB00F2           MUL      R2,R5,R0
   \   000000A6   ....               LDR.N    R1,??DataTable8_16
   \   000000A8   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000AA   1120               MOVS     R0,#+17
   \   000000AC   ....               LDR.N    R3,??DataTable8_17
   \   000000AE   00FB0430           MLA      R0,R0,R4,R3
   \   000000B2   ........           BL       memcpy
    106                         memcpy(&Accident2_SaveBuffer, &Accident2_Buffer[AccidentPoint2], GapTemp * BufferSize);
   \   000000B6   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000B8   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000BA   05FB04F2           MUL      R2,R5,R4
   \   000000BE   ....               LDR.N    R0,??DataTable8_15
   \   000000C0   0088               LDRH     R0,[R0, #+0]
   \   000000C2   1121               MOVS     R1,#+17
   \   000000C4   ....               LDR.N    R3,??DataTable8_16
   \   000000C6   01FB0031           MLA      R1,R1,R0,R3
   \   000000CA   ....               LDR.N    R0,??DataTable8_17
   \   000000CC   ........           BL       memcpy
    107          
    108                         if(Info.AccidentCount >= 640)
   \   000000D0   ....               LDR.N    R0,??DataTable8_3
   \   000000D2   808C               LDRH     R0,[R0, #+36]
   \   000000D4   4FF42071           MOV      R1,#+640
   \   000000D8   8842               CMP      R0,R1
   \   000000DA   02D3               BCC.N    ??Drive_Acceident_Check_7
    109                              Info.AccidentCount = 0;
   \   000000DC   ....               LDR.N    R0,??DataTable8_3
   \   000000DE   0021               MOVS     R1,#+0
   \   000000E0   8184               STRH     R1,[R0, #+36]
    110                         
    111                         Accident_DataSave(Info.AccidentCount++);
   \                     ??Drive_Acceident_Check_7:
   \   000000E2   ....               LDR.N    R0,??DataTable8_3
   \   000000E4   808C               LDRH     R0,[R0, #+36]
   \   000000E6   ....               LDR.N    R1,??DataTable8_3
   \   000000E8   421C               ADDS     R2,R0,#+1
   \   000000EA   8A84               STRH     R2,[R1, #+36]
   \   000000EC   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000EE   ........           BL       Accident_DataSave
    112                         
    113                         Flag.Accident_Step = 3;       // 후반부 데이터 받기               
   \   000000F2   ....               LDR.N    R0,??DataTable8_2
   \   000000F4   0321               MOVS     R1,#+3
   \   000000F6   4171               STRB     R1,[R0, #+5]
    114                         AccidentPoint = 0;           // 포인트 클리어              
   \   000000F8   ....               LDR.N    R0,??DataTable8_12
   \   000000FA   0021               MOVS     R1,#+0
   \   000000FC   0180               STRH     R1,[R0, #+0]
    115                         AccidentPoint2 = 0;
   \   000000FE   ....               LDR.N    R0,??DataTable8_15
   \   00000100   0021               MOVS     R1,#+0
   \   00000102   0180               STRH     R1,[R0, #+0]
    116                         
    117                         USBH_USR_ActionFlag = USH_USR_FS_WRITEACCIDENT;        // 10초전 데이터 ㄱ기록한다.                  
   \   00000104   ....               LDR.N    R0,??DataTable8_18
   \   00000106   0A21               MOVS     R1,#+10
   \   00000108   0170               STRB     R1,[R0, #+0]
    118                         //------------------------------------------------------------------------------
    119                    }break;
   \   0000010A   19E0               B.N      ??Drive_Acceident_Check_3
    120               case 3:break;
   \                     ??Drive_Acceident_Check_4:
   \   0000010C   18E0               B.N      ??Drive_Acceident_Check_3
    121               case 4:      
    122                    {
    123                         // 난드에 저장 한다.
    124                         //           
    125          
    126                         memcpy(Accident_SaveBuffer, Accident_Buffer,  sizeof(Accident_SaveBuffer));
   \                     ??Drive_Acceident_Check_6:
   \   0000010E   4FF4FA52           MOV      R2,#+8000
   \   00000112   ....               LDR.N    R1,??DataTable8_13
   \   00000114   ....               LDR.N    R0,??DataTable8_14
   \   00000116   ........           BL       memcpy
    127                         memcpy(Accident2_SaveBuffer, Accident2_Buffer,  sizeof(Accident2_SaveBuffer));
   \   0000011A   AA22               MOVS     R2,#+170
   \   0000011C   ....               LDR.N    R1,??DataTable8_16
   \   0000011E   ....               LDR.N    R0,??DataTable8_17
   \   00000120   ........           BL       memcpy
    128                         
    129                         Accident_DataSave(Info.AccidentCount++);
   \   00000124   ....               LDR.N    R0,??DataTable8_3
   \   00000126   808C               LDRH     R0,[R0, #+36]
   \   00000128   ....               LDR.N    R1,??DataTable8_3
   \   0000012A   421C               ADDS     R2,R0,#+1
   \   0000012C   8A84               STRH     R2,[R1, #+36]
   \   0000012E   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000130   ........           BL       Accident_DataSave
    130                         
    131                         //------------------------------------------------------------------------------
    132                         USBH_USR_ActionFlag = USH_USR_FS_WRITEACCIDENT;        // 10초전 데이터 ㄱ기록한다.          
   \   00000134   ....               LDR.N    R0,??DataTable8_18
   \   00000136   0A21               MOVS     R1,#+10
   \   00000138   0170               STRB     R1,[R0, #+0]
    133                         Flag.Accident_Step = 0;
   \   0000013A   ....               LDR.N    R0,??DataTable8_2
   \   0000013C   0021               MOVS     R1,#+0
   \   0000013E   4171               STRB     R1,[R0, #+5]
    134          
    135                    }break;
    136               }
    137          }
   \                     ??Drive_Acceident_Check_3:
   \                     ??Drive_Acceident_Check_0:
   \   00000140   05B0               ADD      SP,SP,#+20
   \   00000142   30BD               POP      {R4,R5,PC}       ;; return
    138          

   \                                 In section .text, align 2, keep-with-next
    139          void Drive_Process(void)          // 운행 관련 체크 
    140          {
   \                     Drive_Process:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   8AB0               SUB      SP,SP,#+40
    141               static u16 Drive_Timer;
    142               static u8 Driver_Count;
    143               static u8 Key_On_Status = 0;
    144               static u8 Driver_Check = 0;
    145               TM_Struct DateCheck;
    146               u32 TimerData;
    147               if(!CheckTimeOver(1100,Drive_Timer))
   \   00000004   ....               LDR.N    R0,??DataTable8_19
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   40F24C40           MOVW     R0,#+1100
   \   0000000C   ........           BL       CheckTimeOver
   \   00000010   0028               CMP      R0,#+0
   \   00000012   00F0C280           BEQ.W    ??Drive_Process_0
    148                    return;      
    149               Drive_Timer = MS_TIMER;  	// 타이머 5	     
   \                     ??Drive_Process_1:
   \   00000016   ....               LDR.N    R0,??DataTable8_20  ;; 0x40000c00
   \   00000018   ........           BL       TIM_GetCounter
   \   0000001C   ....               LDR.N    R1,??DataTable8_19
   \   0000001E   0880               STRH     R0,[R1, #+0]
    150              
    151          //     RTC_AddDay();       // 하루가 증가한다.
    152               if( (Info.Input_Status& INPUT_KEYON_FLAG)  )          // 키온이 되어있으면 운행시간 증가
   \   00000020   ....               LDR.N    R0,??DataTable8_3
   \   00000022   90F85D00           LDRB     R0,[R0, #+93]
   \   00000026   0006               LSLS     R0,R0,#+24
   \   00000028   32D5               BPL.N    ??Drive_Process_2
    153               {
    154                    if(Info.SPEED_Value > 0)
   \   0000002A   ....               LDR.N    R0,??DataTable8_3
   \   0000002C   90F83400           LDRB     R0,[R0, #+52]
   \   00000030   0128               CMP      R0,#+1
   \   00000032   02D3               BCC.N    ??Drive_Process_3
    155                       Flag.DriveOn = 1;                              // 운행을 시작 하였다.  
   \   00000034   ....               LDR.N    R0,??DataTable8_2
   \   00000036   0121               MOVS     R1,#+1
   \   00000038   8172               STRB     R1,[R0, #+10]
    156                    if(Info.RPM_Value > 0)
   \                     ??Drive_Process_3:
   \   0000003A   ....               LDR.N    R0,??DataTable8_3
   \   0000003C   B0F83500           LDRH     R0,[R0, #+53]
   \   00000040   0128               CMP      R0,#+1
   \   00000042   1AD3               BCC.N    ??Drive_Process_4
    157                    {
    158                         if(Info.Driver_Index == NO_DRIVER)           // 시동이 킨상태에서 운전자가 선택되지 않았다면
   \   00000044   ....               LDR.N    R0,??DataTable8_3
   \   00000046   0078               LDRB     R0,[R0, #+0]
   \   00000048   FF28               CMP      R0,#+255
   \   0000004A   16D1               BNE.N    ??Drive_Process_4
    159                         {
    160                              Driver_Count++;                    // 
   \   0000004C   ....               LDR.N    R0,??DataTable8_21
   \   0000004E   0078               LDRB     R0,[R0, #+0]
   \   00000050   401C               ADDS     R0,R0,#+1
   \   00000052   ....               LDR.N    R1,??DataTable8_21
   \   00000054   0870               STRB     R0,[R1, #+0]
    161                              
    162                              if( Driver_Count > 20)             // 20초 후에 USB를 읽어 본다.
   \   00000056   ....               LDR.N    R0,??DataTable8_21
   \   00000058   0078               LDRB     R0,[R0, #+0]
   \   0000005A   1528               CMP      R0,#+21
   \   0000005C   06D3               BCC.N    ??Drive_Process_5
    163                              {
    164                                   if(USBH_USR_ApplicationState == USH_USR_FS_IDLE)                                                   
   \   0000005E   ....               LDR.N    R0,??DataTable8_22
   \   00000060   0078               LDRB     R0,[R0, #+0]
   \   00000062   0128               CMP      R0,#+1
   \   00000064   02D1               BNE.N    ??Drive_Process_5
    165                                   {
    166                                        USBH_USR_ActionFlag = USH_USR_FS_READDRIVER;     
   \   00000066   ....               LDR.N    R0,??DataTable8_18
   \   00000068   0921               MOVS     R1,#+9
   \   0000006A   0170               STRB     R1,[R0, #+0]
    167                                   //     Driver_Check= 1;
    168                                   }                         
    169                              }
    170                              if(Driver_Count > 30)              // 30초 후에 멘트를 내보낸다.
   \                     ??Drive_Process_5:
   \   0000006C   ....               LDR.N    R0,??DataTable8_21
   \   0000006E   0078               LDRB     R0,[R0, #+0]
   \   00000070   1F28               CMP      R0,#+31
   \   00000072   02D3               BCC.N    ??Drive_Process_4
    171                              {
    172                                  // Voice_OutAdd(VOICE_INPUTID);
    173                                   Driver_Count = 0;
   \   00000074   ....               LDR.N    R0,??DataTable8_21
   \   00000076   0021               MOVS     R1,#+0
   \   00000078   0170               STRB     R1,[R0, #+0]
    174                              }
    175                         }
    176                    }
    177                    Lcd_Backlight_ON(); 
   \                     ??Drive_Process_4:
   \   0000007A   ........           BL       Lcd_Backlight_ON
    178                    EMS_Drive_Value.Drive_Time ++;          
   \   0000007E   ....               LDR.N    R0,??DataTable8_23
   \   00000080   4068               LDR      R0,[R0, #+4]
   \   00000082   401C               ADDS     R0,R0,#+1
   \   00000084   ....               LDR.N    R1,??DataTable8_23
   \   00000086   4860               STR      R0,[R1, #+4]
    179                    Key_On_Status = 1;
   \   00000088   ....               LDR.N    R0,??DataTable8_24
   \   0000008A   0121               MOVS     R1,#+1
   \   0000008C   0170               STRB     R1,[R0, #+0]
   \   0000008E   0AE0               B.N      ??Drive_Process_6
    180               }else          // 키가 오프상태일때
    181               {
    182                    if(Key_On_Status == 1)        // 키를 한번 켰었다면
   \                     ??Drive_Process_2:
   \   00000090   ....               LDR.N    R0,??DataTable8_24
   \   00000092   0078               LDRB     R0,[R0, #+0]
   \   00000094   0128               CMP      R0,#+1
   \   00000096   04D1               BNE.N    ??Drive_Process_7
    183                    {
    184                         Driver_End();            // 저장 한다.
   \   00000098   ........           BL       Driver_End
    185                         Key_On_Status = 0;
   \   0000009C   ....               LDR.N    R0,??DataTable8_24
   \   0000009E   0021               MOVS     R1,#+0
   \   000000A0   0170               STRB     R1,[R0, #+0]
    186                    }
    187                   Lcd_Backlight_OFF();           
   \                     ??Drive_Process_7:
   \   000000A2   ........           BL       Lcd_Backlight_OFF
    188               }     
    189               if( Flag.Driver_Change == 1 )                     // 운전자가 변경이 됬는가?
   \                     ??Drive_Process_6:
   \   000000A6   ....               LDR.N    R0,??DataTable8_2
   \   000000A8   407A               LDRB     R0,[R0, #+9]
   \   000000AA   0128               CMP      R0,#+1
   \   000000AC   04D1               BNE.N    ??Drive_Process_8
    190               {
    191                    Driver_End();    
   \   000000AE   ........           BL       Driver_End
    192                    Flag.Driver_Change = 0;
   \   000000B2   ....               LDR.N    R0,??DataTable8_2
   \   000000B4   0021               MOVS     R1,#+0
   \   000000B6   4172               STRB     R1,[R0, #+9]
    193               }     
    194               if( Info.Driver_Index == NO_DRIVER && Driver_Check == 0)
   \                     ??Drive_Process_8:
   \   000000B8   ....               LDR.N    R0,??DataTable8_3
   \   000000BA   0078               LDRB     R0,[R0, #+0]
   \   000000BC   FF28               CMP      R0,#+255
   \   000000BE   0DD1               BNE.N    ??Drive_Process_9
   \   000000C0   ....               LDR.N    R0,??DataTable8_25
   \   000000C2   0078               LDRB     R0,[R0, #+0]
   \   000000C4   0028               CMP      R0,#+0
   \   000000C6   09D1               BNE.N    ??Drive_Process_9
    195               {
    196                    if(USBH_USR_ApplicationState == USH_USR_FS_IDLE)                                                   
   \   000000C8   ....               LDR.N    R0,??DataTable8_22
   \   000000CA   0078               LDRB     R0,[R0, #+0]
   \   000000CC   0128               CMP      R0,#+1
   \   000000CE   05D1               BNE.N    ??Drive_Process_9
    197                    {
    198                         USBH_USR_ActionFlag = USH_USR_FS_READDRIVER;     
   \   000000D0   ....               LDR.N    R0,??DataTable8_18
   \   000000D2   0921               MOVS     R1,#+9
   \   000000D4   0170               STRB     R1,[R0, #+0]
    199                         Driver_Check= 1;
   \   000000D6   ....               LDR.N    R0,??DataTable8_25
   \   000000D8   0121               MOVS     R1,#+1
   \   000000DA   0170               STRB     R1,[R0, #+0]
    200                    }
    201               }
    202               
    203               TimerData = RTC_DateToBinary(&SYSTEM_TIME);
   \                     ??Drive_Process_9:
   \   000000DC   ....               LDR.N    R0,??DataTable8_10
   \   000000DE   ........           BL       RTC_DateToBinary
   \   000000E2   0400               MOVS     R4,R0
    204               if( NAND_Header_Info.Verify == 0 )      // 헤더에 정보가 등록되지 않았다면
   \   000000E4   ....               LDR.N    R0,??DataTable8_9
   \   000000E6   8089               LDRH     R0,[R0, #+12]
   \   000000E8   0028               CMP      R0,#+0
   \   000000EA   07D1               BNE.N    ??Drive_Process_10
    205               {
    206                    if( SYSTEM_TIME.tm_mday != 0)      // 시간이 제대로 읽혀졌다면
   \   000000EC   ....               LDR.N    R0,??DataTable8_10
   \   000000EE   C068               LDR      R0,[R0, #+12]
   \   000000F0   0028               CMP      R0,#+0
   \   000000F2   03D0               BEQ.N    ??Drive_Process_10
    207                    {
    208                         Setting_Header_Information();                   
   \   000000F4   ........           BL       Setting_Header_Information
    209                         Write_Header_Information();             // 해더 정보를 저장 	                
   \   000000F8   ........           BL       Write_Header_Information
    210                    }          
    211               }
    212               
    213               if(EMS_Drive_Value.Datetime != 0)            // 맨처음이 아닌가?
   \                     ??Drive_Process_10:
   \   000000FC   ....               LDR.N    R0,??DataTable8_23
   \   000000FE   0068               LDR      R0,[R0, #+0]
   \   00000100   0028               CMP      R0,#+0
   \   00000102   48D0               BEQ.N    ??Drive_Process_11
    214               {
    215                    RTC_BinaryToDate(EMS_Drive_Value.Datetime,&DateCheck);
   \   00000104   00A9               ADD      R1,SP,#+0
   \   00000106   ....               LDR.N    R0,??DataTable8_23
   \   00000108   0068               LDR      R0,[R0, #+0]
   \   0000010A   ........           BL       RTC_BinaryToDate
    216                    
    217                    if( ( NAND_Header_Info.Date[0] != ( SYSTEM_TIME.tm_year - 2000 ) ) || 
    218                         ( NAND_Header_Info.Date[1] != SYSTEM_TIME.tm_mon ) || 
    219                         ( NAND_Header_Info.Date[2] != SYSTEM_TIME.tm_mday ) )
   \   0000010E   ....               LDR.N    R0,??DataTable8_9
   \   00000110   0078               LDRB     R0,[R0, #+0]
   \   00000112   ....               LDR.N    R1,??DataTable8_10
   \   00000114   4969               LDR      R1,[R1, #+20]
   \   00000116   B1F5FA61           SUBS     R1,R1,#+2000
   \   0000011A   8842               CMP      R0,R1
   \   0000011C   0BD1               BNE.N    ??Drive_Process_12
   \   0000011E   ....               LDR.N    R0,??DataTable8_9
   \   00000120   4078               LDRB     R0,[R0, #+1]
   \   00000122   ....               LDR.N    R1,??DataTable8_10
   \   00000124   0969               LDR      R1,[R1, #+16]
   \   00000126   8842               CMP      R0,R1
   \   00000128   05D1               BNE.N    ??Drive_Process_12
   \   0000012A   ....               LDR.N    R0,??DataTable8_9
   \   0000012C   8078               LDRB     R0,[R0, #+2]
   \   0000012E   ....               LDR.N    R1,??DataTable8_10
   \   00000130   C968               LDR      R1,[R1, #+12]
   \   00000132   8842               CMP      R0,R1
   \   00000134   2CD0               BEQ.N    ??Drive_Process_13
    220                    {
    221                         
    222                         // 하루가 지나면 거기서 한번씩 저장한다.
    223                         Write_Header_EMS();                     // 누적 운행거리 저장
   \                     ??Drive_Process_12:
   \   00000136   ........           BL       Write_Header_EMS
    224                         Write_Header_Information();             // 해더 정보를 저장 	     
   \   0000013A   ........           BL       Write_Header_Information
    225                         Write_Header_Index();                         // 해더 인덱스 정보를 저장 하고     
   \   0000013E   ........           BL       Write_Header_Index
    226                         Write_Transmit_Header();           
   \   00000142   ........           BL       Write_Transmit_Header
    227          
    228                         if( NAND_Header_Index.Write_Point >= MAX_HEADER_PAGE) // 210
   \   00000146   ....               LDR.N    R0,??DataTable8_5
   \   00000148   4088               LDRH     R0,[R0, #+2]
   \   0000014A   D228               CMP      R0,#+210
   \   0000014C   03D3               BCC.N    ??Drive_Process_14
    229                         {
    230                              NAND_Header_Index.Write_Point = 0;
   \   0000014E   ....               LDR.N    R0,??DataTable8_5
   \   00000150   0021               MOVS     R1,#+0
   \   00000152   4180               STRH     R1,[R0, #+2]
   \   00000154   04E0               B.N      ??Drive_Process_15
    231                         }
    232                         else
    233                              NAND_Header_Index.Write_Point++;		// 마지막 헤더의 위치를 증가한다. 
   \                     ??Drive_Process_14:
   \   00000156   ....               LDR.N    R0,??DataTable8_5
   \   00000158   4088               LDRH     R0,[R0, #+2]
   \   0000015A   401C               ADDS     R0,R0,#+1
   \   0000015C   ....               LDR.N    R1,??DataTable8_5
   \   0000015E   4880               STRH     R0,[R1, #+2]
    234          
    235                         if(NAND_Header_Index.Header_Count >= MAX_HEADER_PAGE)
   \                     ??Drive_Process_15:
   \   00000160   ....               LDR.N    R0,??DataTable8_5
   \   00000162   0088               LDRH     R0,[R0, #+0]
   \   00000164   D228               CMP      R0,#+210
   \   00000166   03D3               BCC.N    ??Drive_Process_16
    236                              NAND_Header_Index.Header_Count = MAX_HEADER_PAGE;
   \   00000168   ....               LDR.N    R0,??DataTable8_5
   \   0000016A   D221               MOVS     R1,#+210
   \   0000016C   0180               STRH     R1,[R0, #+0]
   \   0000016E   04E0               B.N      ??Drive_Process_17
    237                         else
    238                              NAND_Header_Index.Header_Count ++;
   \                     ??Drive_Process_16:
   \   00000170   ....               LDR.N    R0,??DataTable8_5
   \   00000172   0088               LDRH     R0,[R0, #+0]
   \   00000174   401C               ADDS     R0,R0,#+1
   \   00000176   ....               LDR.N    R1,??DataTable8_5
   \   00000178   0880               STRH     R0,[R1, #+0]
    239                         EMS_Drive_Value.Datetime = TimerData; 
   \                     ??Drive_Process_17:
   \   0000017A   ....               LDR.N    R0,??DataTable8_23
   \   0000017C   0460               STR      R4,[R0, #+0]
    240                         Setting_Header_Information();
   \   0000017E   ........           BL       Setting_Header_Information
    241                         Driver_End();                           // 하루가 지나가면 거기서 한번끝는다.
   \   00000182   ........           BL       Driver_End
    242          
    243                         memset(&EMS_Drive_Value, 0 ,sizeof(EMS_Drive_Value));    // EMS 클리어                          
   \   00000186   2422               MOVS     R2,#+36
   \   00000188   0021               MOVS     R1,#+0
   \   0000018A   ....               LDR.N    R0,??DataTable8_23
   \   0000018C   ........           BL       memset
    244                    }
    245                    EMS_Drive_Value.Datetime = TimerData;          
   \                     ??Drive_Process_13:
   \   00000190   ....               LDR.N    R0,??DataTable8_23
   \   00000192   0460               STR      R4,[R0, #+0]
   \   00000194   01E0               B.N      ??Drive_Process_18
    246               }
    247               else
    248               {
    249                    EMS_Drive_Value.Datetime = TimerData;
   \                     ??Drive_Process_11:
   \   00000196   ....               LDR.N    R0,??DataTable8_23
   \   00000198   0460               STR      R4,[R0, #+0]
    250               }
    251          }
   \                     ??Drive_Process_18:
   \                     ??Drive_Process_0:
   \   0000019A   0AB0               ADD      SP,SP,#+40
   \   0000019C   10BD               POP      {R4,PC}          ;; return

   \                                 In section .bss, align 2
   \                     ??Drive_Timer:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
   \                     ??Driver_Count:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     ??Key_On_Status:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     ??Driver_Check:
   \   00000000                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   00180240           DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   00140240           DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   ........           DC32     Flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   ........           DC32     Info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   ........           DC32     ECO_Driving

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   ........           DC32     NAND_Header_Index

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   ........           DC32     DTG_NAND_Binary

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   ........           DC32     NAND_Data_Transmit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   FFE70300           DC32     0x3e7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   ........           DC32     NAND_Header_Info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   ........           DC32     SYSTEM_TIME

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   ........           DC32     Accident_Time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \   00000000   ........           DC32     AccidentPoint

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \   00000000   ........           DC32     Accident_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_14:
   \   00000000   ........           DC32     Accident_SaveBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_15:
   \   00000000   ........           DC32     AccidentPoint2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_16:
   \   00000000   ........           DC32     Accident2_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_17:
   \   00000000   ........           DC32     Accident2_SaveBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_18:
   \   00000000   ........           DC32     USBH_USR_ActionFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_19:
   \   00000000   ........           DC32     ??Drive_Timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_20:
   \   00000000   000C0040           DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_21:
   \   00000000   ........           DC32     ??Driver_Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_22:
   \   00000000   ........           DC32     USBH_USR_ApplicationState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_23:
   \   00000000   ........           DC32     EMS_Drive_Value

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_24:
   \   00000000   ........           DC32     ??Key_On_Status

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_25:
   \   00000000   ........           DC32     ??Driver_Check

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%02d%02d%02d%02d%02d%02d">`:
   \   00000000                      ; Initializer data, 28 bytes
   \   00000000   253032642530       DC8 37, 48, 50, 100, 37, 48, 50, 100, 37, 48
   \              32642530    
   \   0000000A   326425303264       DC8 50, 100, 37, 48, 50, 100, 37, 48, 50, 100
   \              25303264    
   \   00000014   253032640000       DC8 37, 48, 50, 100, 0, 0, 0, 0
   \              0000        

   Maximum stack usage in bytes:

     Function              .cstack
     --------              -------
     Drive_Acceident_Check     32
     Drive_Process             48
     Driver_End                 8
     Driver_Start               8
     LED1_OFF                   8
     LED1_RED                   8
     Lcd_Backlight_OFF          8
     Lcd_Backlight_ON           8
     memcpy                     8
     memset                     8


   Section sizes:

     Function/Label                         Bytes
     --------------                         -----
     memcpy                                   14
     memset                                   20
     LED1_OFF                                 28
     LED1_RED                                 28
     Lcd_Backlight_ON                         16
     Lcd_Backlight_OFF                        16
     Driver_Start                             90
     Driver_End                              178
     Drive_Acceident_Check                   324
     Drive_Process                           414
     Drive_Timer                               2
     Driver_Count                              1
     Key_On_Status                             1
     Driver_Check                              1
     ??DataTable8                              4
     ??DataTable8_1                            4
     ??DataTable8_2                            4
     ??DataTable8_3                            4
     ??DataTable8_4                            4
     ??DataTable8_5                            4
     ??DataTable8_6                            4
     ??DataTable8_7                            4
     ??DataTable8_8                            4
     ??DataTable8_9                            4
     ??DataTable8_10                           4
     ??DataTable8_11                           4
     ??DataTable8_12                           4
     ??DataTable8_13                           4
     ??DataTable8_14                           4
     ??DataTable8_15                           4
     ??DataTable8_16                           4
     ??DataTable8_17                           4
     ??DataTable8_18                           4
     ??DataTable8_19                           4
     ??DataTable8_20                           4
     ??DataTable8_21                           4
     ??DataTable8_22                           4
     ??DataTable8_23                           4
     ??DataTable8_24                           4
     ??DataTable8_25                           4
     ?<Constant "%02d%02d%02d%02d%02d%02d">   28

 
     5 bytes in section .bss
 1 260 bytes in section .text
 
 1 226 bytes of CODE memory (+ 34 bytes shared)
     5 bytes of DATA memory

Errors: none
Warnings: none
