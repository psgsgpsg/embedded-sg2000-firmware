###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     19/Dec/2011  16:18:51 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\i2c_ee.c     #
#    Command line =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\i2c_ee.c -D  #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D RTC_CLOCK_SOURCE_LSE -lC            #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\List\ -lA E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Pr #
#                    oject\EWARM\STM3220F_EVAL\List\ -o                       #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\Obj\ --no_cse --no_unroll --no_inline            #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWAR #
#                    M\..\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWA #
#                    RM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I             #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I       #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I             #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Utilities\STM32_EVAL\ -I E:\Work\Firmware\DTG\DTG_EMS_SY #
#                    STEM\Project\EWARM\..\..\Utilities\STM32_EVAL\Common\    #
#                    -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\ #
#                    ..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I                #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_OTG_Driver\inc\ -I                   #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_Device_Library\Core\inc\ -I          #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_Device_Library\Class\msc\inc\ -I     #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\Usb #
#                    \ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\. #
#                    .\Usb\Inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Projec #
#                    t\EWARM\..\Usb\src\ -I E:\Work\Firmware\DTG\DTG_EMS_SYST #
#                    EM\Project\EWARM\..\..\Libraries\STM32_USB_HOST_Library\ #
#                    Core\inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project #
#                    \EWARM\..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\ #
#                    inc\ -Ol --use_c++_inline                                #
#    List file    =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\List\i2c_ee.lst                                  #
#    Object file  =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\Obj\i2c_ee.o                                     #
#                                                                             #
#                                                                             #
###############################################################################

E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\i2c_ee.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : i2c_ee.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.0.3
      5          * Date               : 09/22/2008
      6          * Description        : This file provides a set of functions needed to manage the
      7          *                      communication between I2C peripheral and I2C M24C08 EEPROM.
      8          ********************************************************************************
      9          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     10          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     11          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     12          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     13          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     14          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     15          *******************************************************************************/
     16          
     17          /* Includes ------------------------------------------------------------------*/
     18          #include "i2c_ee.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void EE_DISABLE(void)
   \                     EE_DISABLE:
   \   00000000   80B5               PUSH     {R7,LR}
   \   00000002   4FF48061           MOV      R1,#+1024
   \   00000006   ........           LDR.W    R0,??DataTable9  ;; 0x40021800
   \   0000000A   ........           BL       GPIO_SetBits
   \   0000000E   01BD               POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void EE_ENABLE(void)
   \                     EE_ENABLE:
   \   00000000   80B5               PUSH     {R7,LR}
   \   00000002   4FF48061           MOV      R1,#+1024
   \   00000006   ........           LDR.W    R0,??DataTable9  ;; 0x40021800
   \   0000000A   ........           BL       GPIO_ResetBits
   \   0000000E   01BD               POP      {R0,PC}          ;; return
     19          #include "main.h"
     20          
     21          #include "Log.h"
     22          
     23          /* Private typedef -----------------------------------------------------------*/
     24          /* Private define ------------------------------------------------------------*/
     25          #define I2C_SPEED              100000
     26          #define I2C2_SLAVE_ADDRESS7    0xA0
     27          
     28          
     29          /* Private macro -------------------------------------------------------------*/
     30          /* Private variables ---------------------------------------------------------*/

   \                                 In section .bss, align 2
     31          u16 EEPROM_ADDRESS;
   \                     EEPROM_ADDRESS:
   \   00000000                      DS8 2
     32          

   \                                 In section .bss, align 2
     33          __IO uint16_t  EEAddress = 0;   
   \                     EEAddress:
   \   00000000                      DS8 2

   \                                 In section .data, align 4
     34          __IO uint32_t  EETimeout = EE_LONG_TIMEOUT;   
   \                     EETimeout:
   \   00000000   00600900           DC32 614400

   \                                 In section .bss, align 4
     35          __IO uint16_t* EEDataReadPointer;   
   \                     EEDataReadPointer:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     36          __IO uint8_t*  EEDataWritePointer;  
   \                     EEDataWritePointer:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     37          __IO uint8_t   EEDataNum;
   \                     EEDataNum:
   \   00000000                      DS8 1
     38          
     39          /* Private function prototypes -----------------------------------------------*/
     40          void GPIO_Configuration(void);
     41          void I2C_Configuration(void);
     42          void sEE_LowLevel_Init(void);
     43          /* Private functions ---------------------------------------------------------*/
     44          /*******************************************************************************
     45          * Function Name  : GPIO_Configuration
     46          * Description    : Configure the used I/O ports pin
     47          * Input          : None
     48          * Output         : None
     49          * Return         : None
     50          *******************************************************************************/
     51          

   \                                 In section .text, align 2, keep-with-next
     52          void EE_LowLevel_Init(void)
     53          {
   \                     EE_LowLevel_Init:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   83B0               SUB      SP,SP,#+12
     54          	GPIO_InitTypeDef  GPIO_InitStructure; 
     55          	
     56          	// !< sEE_I2C Periph clock enable 
     57          	RCC_APB1PeriphClockCmd(EE_I2C_CLK, ENABLE);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   5FF48000           MOVS     R0,#+4194304
   \   0000000A   ........           BL       RCC_APB1PeriphClockCmd
     58          	
     59          	// !< sEE_I2C_SCL_GPIO_CLK and sEE_I2C_SDA_GPIO_CLK Periph clock enable 
     60          	RCC_AHB1PeriphClockCmd(EE_I2C_SCL_GPIO_CLK | EE_I2C_SDA_GPIO_CLK, ENABLE);
   \   0000000E   0121               MOVS     R1,#+1
   \   00000010   0220               MOVS     R0,#+2
   \   00000012   ........           BL       RCC_AHB1PeriphClockCmd
     61          	
     62          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
   \   00000016   0121               MOVS     R1,#+1
   \   00000018   4FF48040           MOV      R0,#+16384
   \   0000001C   ........           BL       RCC_APB2PeriphClockCmd
     63          	
     64          	// Reset sEE_I2C IP 
     65          	RCC_APB1PeriphResetCmd(EE_I2C_CLK, ENABLE);
   \   00000020   0121               MOVS     R1,#+1
   \   00000022   5FF48000           MOVS     R0,#+4194304
   \   00000026   ........           BL       RCC_APB1PeriphResetCmd
     66          	
     67          	//  //Release reset signal of sEE_I2C IP 
     68          	RCC_APB1PeriphResetCmd(EE_I2C_CLK, DISABLE);
   \   0000002A   0021               MOVS     R1,#+0
   \   0000002C   5FF48000           MOVS     R0,#+4194304
   \   00000030   ........           BL       RCC_APB1PeriphResetCmd
     69          	
     70          	//!< GPIO configuration 
     71          	//!< Configure sEE_I2C pins: SCL    
     72          	GPIO_InitStructure.GPIO_Pin = EE_I2C_SCL_PIN;
   \   00000034   4FF48060           MOV      R0,#+1024
   \   00000038   0090               STR      R0,[SP, #+0]
     73          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   0000003A   0220               MOVS     R0,#+2
   \   0000003C   8DF80400           STRB     R0,[SP, #+4]
     74          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000040   0220               MOVS     R0,#+2
   \   00000042   8DF80500           STRB     R0,[SP, #+5]
     75          	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
   \   00000046   0120               MOVS     R0,#+1
   \   00000048   8DF80600           STRB     R0,[SP, #+6]
     76          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
   \   0000004C   0020               MOVS     R0,#+0
   \   0000004E   8DF80700           STRB     R0,[SP, #+7]
     77          	GPIO_Init(EE_I2C_SCL_GPIO_PORT, &GPIO_InitStructure);
   \   00000052   00A9               ADD      R1,SP,#+0
   \   00000054   ........           LDR.W    R0,??DataTable9_1  ;; 0x40020400
   \   00000058   ........           BL       GPIO_Init
     78          	
     79          	//!< Configure sEE_I2C pins: SDA 
     80          	GPIO_InitStructure.GPIO_Pin = EE_I2C_SDA_PIN;
   \   0000005C   4FF40060           MOV      R0,#+2048
   \   00000060   0090               STR      R0,[SP, #+0]
     81          	GPIO_Init(EE_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
   \   00000062   00A9               ADD      R1,SP,#+0
   \   00000064   ........           LDR.W    R0,??DataTable9_1  ;; 0x40020400
   \   00000068   ........           BL       GPIO_Init
     82          	
     83          	// Connect PXx to I2C_SCL
     84          	GPIO_PinAFConfig(EE_I2C_SCL_GPIO_PORT, EE_I2C_SCL_SOURCE, EE_I2C_SCL_AF);
   \   0000006C   0422               MOVS     R2,#+4
   \   0000006E   0A21               MOVS     R1,#+10
   \   00000070   ........           LDR.W    R0,??DataTable9_1  ;; 0x40020400
   \   00000074   ........           BL       GPIO_PinAFConfig
     85          	
     86          	// Connect PXx to I2C_SDA
     87          	GPIO_PinAFConfig(EE_I2C_SDA_GPIO_PORT, EE_I2C_SDA_SOURCE, EE_I2C_SDA_AF);  
   \   00000078   0422               MOVS     R2,#+4
   \   0000007A   0B21               MOVS     R1,#+11
   \   0000007C   ........           LDR.W    R0,??DataTable9_1  ;; 0x40020400
   \   00000080   ........           BL       GPIO_PinAFConfig
     88          	
     89          	RCC_AHB1PeriphClockCmd(EE_CHIP_ENABLE_CLK, ENABLE);
   \   00000084   0121               MOVS     R1,#+1
   \   00000086   4020               MOVS     R0,#+64
   \   00000088   ........           BL       RCC_AHB1PeriphClockCmd
     90          	
     91          	GPIO_InitStructure.GPIO_Pin = EE_CHIP_ENABLE_PIN;
   \   0000008C   4FF48060           MOV      R0,#+1024
   \   00000090   0090               STR      R0,[SP, #+0]
     92          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   \   00000092   0120               MOVS     R0,#+1
   \   00000094   8DF80400           STRB     R0,[SP, #+4]
     93          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
   \   00000098   0120               MOVS     R0,#+1
   \   0000009A   8DF80700           STRB     R0,[SP, #+7]
     94          	GPIO_Init(EE_CHIP_ENABLE_PORT, &GPIO_InitStructure);
   \   0000009E   00A9               ADD      R1,SP,#+0
   \   000000A0   ........           LDR.W    R0,??DataTable9  ;; 0x40021800
   \   000000A4   ........           BL       GPIO_Init
     95          	 
     96          	
     97          }
   \   000000A8   07BD               POP      {R0-R2,PC}       ;; return
     98          
     99          /*******************************************************************************
    100          * Function Name  : I2C_Configuration
    101          * Description    : I2C Configuration
    102          * Input          : None
    103          * Output         : None
    104          * Return         : None
    105          *******************************************************************************/
    106          
    107          /*******************************************************************************
    108          * Function Name  : I2C_EE_Init
    109          * Description    : Initializes peripherals used by the I2C EEPROM driver.
    110          * Input          : None
    111          * Output         : None
    112          * Return         : None
    113          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    114          void I2C_EE_Init()
    115          {
   \                     I2C_EE_Init:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   85B0               SUB      SP,SP,#+20
    116          	/* GPIO configuration */
    117          	// GPIO_Configuration();
    118          	
    119          	/* I2C configuration */
    120          	I2C_InitTypeDef  I2C_InitStructure;
    121          	
    122          	EE_LowLevel_Init();
   \   00000004   ........           BL       EE_LowLevel_Init
    123          	EE_DISABLE();
   \   00000008   ........           BL       EE_DISABLE
    124          	/*!< I2C configuration */
    125          	/* sEE_I2C configuration */
    126          	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   ADF80400           STRH     R0,[SP, #+4]
    127          	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
   \   00000012   4BF6FF70           MOVW     R0,#+49151
   \   00000016   ADF80600           STRH     R0,[SP, #+6]
    128          	I2C_InitStructure.I2C_OwnAddress1 = I2C2_SLAVE_ADDRESS7;
   \   0000001A   A020               MOVS     R0,#+160
   \   0000001C   ADF80800           STRH     R0,[SP, #+8]
    129          	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
   \   00000020   4FF48060           MOV      R0,#+1024
   \   00000024   ADF80A00           STRH     R0,[SP, #+10]
    130          	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
   \   00000028   4FF48040           MOV      R0,#+16384
   \   0000002C   ADF80C00           STRH     R0,[SP, #+12]
    131          	I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;
   \   00000030   ........           LDR.W    R0,??DataTable9_2  ;; 0x186a0
   \   00000034   0090               STR      R0,[SP, #+0]
    132          	
    133          	/* sEE_I2C Peripheral Enable */
    134          	I2C_Cmd(EE_I2C, ENABLE);
   \   00000036   0121               MOVS     R1,#+1
   \   00000038   ........           LDR.W    R0,??DataTable9_3  ;; 0x40005800
   \   0000003C   ........           BL       I2C_Cmd
    135          	/* Apply sEE_I2C configuration after enabling it */
    136          	I2C_Init(EE_I2C, &I2C_InitStructure);
   \   00000040   00A9               ADD      R1,SP,#+0
   \   00000042   ........           LDR.W    R0,??DataTable9_3  ;; 0x40005800
   \   00000046   ........           BL       I2C_Init
    137          	
    138          	/* Enable the sEE_I2C peripheral DMA requests */
    139          	
    140          	/* depending on the EEPROM Address selected in the i2c_ee.h file */
    141          #ifdef EEPROM_Block0_ADDRESS
    142          	/* Select the EEPROM Block0 to write on */
    143          	EEPROM_ADDRESS = EEPROM_Block0_ADDRESS;
   \   0000004A   ........           LDR.W    R0,??DataTable9_4
   \   0000004E   A021               MOVS     R1,#+160
   \   00000050   0180               STRH     R1,[R0, #+0]
    144          #endif
    145          #ifdef EEPROM_Block1_ADDRESS
    146          	/* Select the EEPROM Block1 to write on */
    147          	EEPROM_ADDRESS = EEPROM_Block1_ADDRESS;
    148          #endif
    149          #ifdef EEPROM_Block2_ADDRESS
    150          	/* Select the EEPROM Block2 to write on */
    151          	EEPROM_ADDRESS = EEPROM_Block2_ADDRESS;
    152          #endif
    153          #ifdef EEPROM_Block3_ADDRESS
    154          	/* Select the EEPROM Block3 to write on */
    155          	EEPROM_ADDRESS = EEPROM_Block3_ADDRESS;
    156          #endif
    157          }
   \   00000052   05B0               ADD      SP,SP,#+20
   \   00000054   00BD               POP      {PC}             ;; return
    158          
    159          /*******************************************************************************
    160          * Function Name  : I2C_EE_BufferWrite
    161          * Description    : Writes buffer of data to the I2C EEPROM.
    162          * Input          : - pBuffer : pointer to the buffer  containing the data to be 
    163          *                    written to the EEPROM.
    164          *                  - WriteAddr : EEPROM's internal address to write to.
    165          *                  - NumByteToWrite : number of bytes to write to the EEPROM.
    166          * Output         : None
    167          * Return         : None
    168          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    169          void I2C_EE_BufferWrite(u8* pBuffer, u16 WriteAddr, u16 NumByteToWrite)
    170          {
   \                     I2C_EE_BufferWrite:
   \   00000000   2DE9F047           PUSH     {R4-R10,LR}
   \   00000004   0600               MOVS     R6,R0
   \   00000006   0D00               MOVS     R5,R1
   \   00000008   9046               MOV      R8,R2
    171          	u8 NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0;
   \   0000000A   0027               MOVS     R7,#+0
   \   0000000C   0024               MOVS     R4,#+0
   \   0000000E   5FF00009           MOVS     R9,#+0
   \   00000012   5FF0000A           MOVS     R10,#+0
    172          	EE_ENABLE();
   \   00000016   ........           BL       EE_ENABLE
    173          	Delay(10);
   \   0000001A   0A20               MOVS     R0,#+10
   \   0000001C   ........           BL       Delay
    174          	Addr = WriteAddr % I2C_PageSize;
   \   00000020   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000022   4020               MOVS     R0,#+64
   \   00000024   95FBF0F1           SDIV     R1,R5,R0
   \   00000028   01FB1051           MLS      R1,R1,R0,R5
   \   0000002C   8946               MOV      R9,R1
    175          	count = I2C_PageSize - Addr;
   \   0000002E   D9F14000           RSBS     R0,R9,#+64
   \   00000032   8246               MOV      R10,R0
    176          	NumOfPage =  NumByteToWrite / I2C_PageSize;
   \   00000034   1FFA88F8           UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000038   4020               MOVS     R0,#+64
   \   0000003A   98FBF0F0           SDIV     R0,R8,R0
   \   0000003E   0700               MOVS     R7,R0
    177          	NumOfSingle = NumByteToWrite % I2C_PageSize;
   \   00000040   1FFA88F8           UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000044   4020               MOVS     R0,#+64
   \   00000046   98FBF0F1           SDIV     R1,R8,R0
   \   0000004A   01FB1081           MLS      R1,R1,R0,R8
   \   0000004E   0C00               MOVS     R4,R1
    178          	
    179          	
    180          	/* If WriteAddr is I2C_PageSize aligned  */
    181          	if(Addr == 0) 
   \   00000050   5FFA89F9           UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000054   B9F1000F           CMP      R9,#+0
   \   00000058   29D1               BNE.N    ??I2C_EE_BufferWrite_0
    182          	{
    183          		/* If NumByteToWrite < I2C_PageSize */
    184          		if(NumOfPage == 0) 
   \   0000005A   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005C   002F               CMP      R7,#+0
   \   0000005E   14D1               BNE.N    ??I2C_EE_BufferWrite_1
    185          		{
    186          			I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);
   \   00000060   2200               MOVS     R2,R4
   \   00000062   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000064   2900               MOVS     R1,R5
   \   00000066   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000068   3000               MOVS     R0,R6
   \   0000006A   ........           BL       I2C_EE_PageWrite
    187          			I2C_EE_WaitEepromStandbyState();
   \   0000006E   ........           BL       I2C_EE_WaitEepromStandbyState
   \   00000072   6CE0               B.N      ??I2C_EE_BufferWrite_2
    188          		}
    189          		/* If NumByteToWrite > I2C_PageSize */
    190          		else  
    191          		{
    192          			while(NumOfPage--)
    193          			{
    194          				I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_PageSize); 
   \                     ??I2C_EE_BufferWrite_3:
   \   00000074   4022               MOVS     R2,#+64
   \   00000076   2900               MOVS     R1,R5
   \   00000078   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000007A   3000               MOVS     R0,R6
   \   0000007C   ........           BL       I2C_EE_PageWrite
    195          				I2C_EE_WaitEepromStandbyState();
   \   00000080   ........           BL       I2C_EE_WaitEepromStandbyState
    196          				WriteAddr +=  I2C_PageSize;
   \   00000084   4035               ADDS     R5,R5,#+64
    197          				pBuffer += I2C_PageSize;
   \   00000086   06F24006           ADDW     R6,R6,#+64
    198          			}
   \                     ??I2C_EE_BufferWrite_1:
   \   0000008A   3800               MOVS     R0,R7
   \   0000008C   471E               SUBS     R7,R0,#+1
   \   0000008E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000090   0028               CMP      R0,#+0
   \   00000092   EFD1               BNE.N    ??I2C_EE_BufferWrite_3
    199          			
    200          			if(NumOfSingle!=0)
   \   00000094   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000096   002C               CMP      R4,#+0
   \   00000098   59D0               BEQ.N    ??I2C_EE_BufferWrite_2
    201          			{
    202          				I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);
   \   0000009A   2200               MOVS     R2,R4
   \   0000009C   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000009E   2900               MOVS     R1,R5
   \   000000A0   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000A2   3000               MOVS     R0,R6
   \   000000A4   ........           BL       I2C_EE_PageWrite
    203          				I2C_EE_WaitEepromStandbyState();
   \   000000A8   ........           BL       I2C_EE_WaitEepromStandbyState
   \   000000AC   4FE0               B.N      ??I2C_EE_BufferWrite_2
    204          			}
    205          		}
    206          	}
    207          	/* If WriteAddr is not I2C_PageSize aligned  */
    208          	else 
    209          	{
    210          		/* If NumByteToWrite < I2C_PageSize */
    211          		if(NumOfPage== 0) 
   \                     ??I2C_EE_BufferWrite_0:
   \   000000AE   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000B0   002F               CMP      R7,#+0
   \   000000B2   09D1               BNE.N    ??I2C_EE_BufferWrite_4
    212          		{
    213          			I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);
   \   000000B4   2200               MOVS     R2,R4
   \   000000B6   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000B8   2900               MOVS     R1,R5
   \   000000BA   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000BC   3000               MOVS     R0,R6
   \   000000BE   ........           BL       I2C_EE_PageWrite
    214          			I2C_EE_WaitEepromStandbyState();
   \   000000C2   ........           BL       I2C_EE_WaitEepromStandbyState
   \   000000C6   42E0               B.N      ??I2C_EE_BufferWrite_2
    215          		}
    216          		/* If NumByteToWrite > I2C_PageSize */
    217          		else
    218          		{
    219          			NumByteToWrite -= count;
   \                     ??I2C_EE_BufferWrite_4:
   \   000000C8   5FFA8AFA           UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000CC   B8EB0A08           SUBS     R8,R8,R10
    220          			NumOfPage =  NumByteToWrite / I2C_PageSize;
   \   000000D0   1FFA88F8           UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000D4   4020               MOVS     R0,#+64
   \   000000D6   98FBF0F7           SDIV     R7,R8,R0
    221          			NumOfSingle = NumByteToWrite % I2C_PageSize;    
   \   000000DA   1FFA88F8           UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000DE   4020               MOVS     R0,#+64
   \   000000E0   98FBF0F4           SDIV     R4,R8,R0
   \   000000E4   04FB1084           MLS      R4,R4,R0,R8
    222          			
    223          			if(count != 0)
   \   000000E8   5FFA8AFA           UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000EC   BAF1000F           CMP      R10,#+0
   \   000000F0   1CD0               BEQ.N    ??I2C_EE_BufferWrite_5
    224          			{  
    225          				I2C_EE_PageWrite(pBuffer, WriteAddr, count);
   \   000000F2   5246               MOV      R2,R10
   \   000000F4   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000F6   2900               MOVS     R1,R5
   \   000000F8   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000FA   3000               MOVS     R0,R6
   \   000000FC   ........           BL       I2C_EE_PageWrite
    226          				I2C_EE_WaitEepromStandbyState();
   \   00000100   ........           BL       I2C_EE_WaitEepromStandbyState
    227          				WriteAddr += count;
   \   00000104   5FFA8AFA           UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000108   1AEB0505           ADDS     R5,R10,R5
    228          				pBuffer += count;
   \   0000010C   5FFA8AFA           UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000110   1AEB0606           ADDS     R6,R10,R6
   \   00000114   0AE0               B.N      ??I2C_EE_BufferWrite_5
    229          			} 
    230          			
    231          			while(NumOfPage--)
    232          			{
    233          				I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_PageSize);
   \                     ??I2C_EE_BufferWrite_6:
   \   00000116   4022               MOVS     R2,#+64
   \   00000118   2900               MOVS     R1,R5
   \   0000011A   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000011C   3000               MOVS     R0,R6
   \   0000011E   ........           BL       I2C_EE_PageWrite
    234          				I2C_EE_WaitEepromStandbyState();
   \   00000122   ........           BL       I2C_EE_WaitEepromStandbyState
    235          				WriteAddr +=  I2C_PageSize;
   \   00000126   4035               ADDS     R5,R5,#+64
    236          				pBuffer += I2C_PageSize;  
   \   00000128   06F24006           ADDW     R6,R6,#+64
    237          			}
   \                     ??I2C_EE_BufferWrite_5:
   \   0000012C   3800               MOVS     R0,R7
   \   0000012E   471E               SUBS     R7,R0,#+1
   \   00000130   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000132   0028               CMP      R0,#+0
   \   00000134   EFD1               BNE.N    ??I2C_EE_BufferWrite_6
    238          			if(NumOfSingle != 0)
   \   00000136   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000138   002C               CMP      R4,#+0
   \   0000013A   08D0               BEQ.N    ??I2C_EE_BufferWrite_2
    239          			{
    240          				I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle); 
   \   0000013C   2200               MOVS     R2,R4
   \   0000013E   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000140   2900               MOVS     R1,R5
   \   00000142   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000144   3000               MOVS     R0,R6
   \   00000146   ........           BL       I2C_EE_PageWrite
    241          				I2C_EE_WaitEepromStandbyState();
   \   0000014A   ........           BL       I2C_EE_WaitEepromStandbyState
    242          			}
    243          		}
    244          	}  
    245          	Delay(10);
   \                     ??I2C_EE_BufferWrite_2:
   \   0000014E   0A20               MOVS     R0,#+10
   \   00000150   ........           BL       Delay
    246          	EE_DISABLE();
   \   00000154   ........           BL       EE_DISABLE
    247          }
   \   00000158   BDE8F087           POP      {R4-R10,PC}      ;; return
    248          
    249          /*******************************************************************************
    250          * Function Name  : I2C_EE_ByteWrite
    251          * Description    : Writes one byte to the I2C EEPROM.
    252          * Input          : - pBuffer : pointer to the buffer  containing the data to be 
    253          *                    written to the EEPROM.
    254          *                  - WriteAddr : EEPROM's internal address to write to.
    255          * Output         : None
    256          * Return         : None
    257          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    258          void I2C_EE_ByteWrite(u8* pBuffer, u16 WriteAddr)
    259          {
   \                     I2C_EE_ByteWrite:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    260          	
    261          	/* Send STRAT condition */
    262          	I2C_GenerateSTART(I2C2, ENABLE);
   \   00000006   0121               MOVS     R1,#+1
   \   00000008   ........           LDR.W    R0,??DataTable9_3  ;; 0x40005800
   \   0000000C   ........           BL       I2C_GenerateSTART
    263          	
    264          	/* Test on EV5 and clear it */
    265          	while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT));  
   \                     ??I2C_EE_ByteWrite_0:
   \   00000010   ........           LDR.W    R1,??DataTable9_5  ;; 0x30001
   \   00000014   ........           LDR.W    R0,??DataTable9_3  ;; 0x40005800
   \   00000018   ........           BL       I2C_CheckEvent
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   F7D0               BEQ.N    ??I2C_EE_ByteWrite_0
    266          	
    267          	/* Send EEPROM address for write */
    268          	I2C_Send7bitAddress(I2C2, EEPROM_ADDRESS, I2C_Direction_Transmitter);
   \   00000020   0022               MOVS     R2,#+0
   \   00000022   ........           LDR.W    R0,??DataTable9_4
   \   00000026   0188               LDRH     R1,[R0, #+0]
   \   00000028   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002A   ........           LDR.W    R0,??DataTable9_3  ;; 0x40005800
   \   0000002E   ........           BL       I2C_Send7bitAddress
    269          	
    270          	/* Test on EV6 and clear it */
    271          	while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
   \                     ??I2C_EE_ByteWrite_1:
   \   00000032   ........           LDR.W    R1,??DataTable9_6  ;; 0x70082
   \   00000036   ........           LDR.W    R0,??DataTable9_3  ;; 0x40005800
   \   0000003A   ........           BL       I2C_CheckEvent
   \   0000003E   0028               CMP      R0,#+0
   \   00000040   F7D0               BEQ.N    ??I2C_EE_ByteWrite_1
    272          	
    273          	/* Send the EEPROM's internal address to write to */
    274          	I2C_SendData(I2C2, ( WriteAddr >> 8 ) & 0xff);
   \   00000042   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   290A               LSRS     R1,R5,#+8
   \   00000046   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000048   ........           LDR.W    R0,??DataTable9_3  ;; 0x40005800
   \   0000004C   ........           BL       I2C_SendData
    275          	
    276          	/* Test on EV8 and clear it */
    277          	while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTING));
   \                     ??I2C_EE_ByteWrite_2:
   \   00000050   ........           LDR.W    R1,??DataTable9_7  ;; 0x70080
   \   00000054   ........           LDR.W    R0,??DataTable9_3  ;; 0x40005800
   \   00000058   ........           BL       I2C_CheckEvent
   \   0000005C   0028               CMP      R0,#+0
   \   0000005E   F7D0               BEQ.N    ??I2C_EE_ByteWrite_2
    278          	I2C_SendData(I2C2, (WriteAddr & 0xff) );
   \   00000060   2900               MOVS     R1,R5
   \   00000062   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000064   ........           LDR.W    R0,??DataTable9_3  ;; 0x40005800
   \   00000068   ........           BL       I2C_SendData
    279          	
    280          	/* Test on EV8 and clear it */
    281          	while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTING));
   \                     ??I2C_EE_ByteWrite_3:
   \   0000006C   ........           LDR.W    R1,??DataTable9_7  ;; 0x70080
   \   00000070   ........           LDR.W    R0,??DataTable9_3  ;; 0x40005800
   \   00000074   ........           BL       I2C_CheckEvent
   \   00000078   0028               CMP      R0,#+0
   \   0000007A   F7D0               BEQ.N    ??I2C_EE_ByteWrite_3
    282          	/* Send the byte to be written */
    283          	I2C_SendData(I2C2, *pBuffer); 
   \   0000007C   2178               LDRB     R1,[R4, #+0]
   \   0000007E   ........           LDR.W    R0,??DataTable9_3  ;; 0x40005800
   \   00000082   ........           BL       I2C_SendData
    284          	
    285          	/* Test on EV8 and clear it */
    286          	while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
   \                     ??I2C_EE_ByteWrite_4:
   \   00000086   ........           LDR.W    R1,??DataTable9_8  ;; 0x70084
   \   0000008A   ........           LDR.W    R0,??DataTable9_3  ;; 0x40005800
   \   0000008E   ........           BL       I2C_CheckEvent
   \   00000092   0028               CMP      R0,#+0
   \   00000094   F7D0               BEQ.N    ??I2C_EE_ByteWrite_4
    287          	
    288          	/* Send STOP condition */
    289          	I2C_GenerateSTOP(I2C2, ENABLE);
   \   00000096   0121               MOVS     R1,#+1
   \   00000098   ........           LDR.W    R0,??DataTable9_3  ;; 0x40005800
   \   0000009C   ........           BL       I2C_GenerateSTOP
    290          	
    291          }
   \   000000A0   31BD               POP      {R0,R4,R5,PC}    ;; return
    292          
    293          /*******************************************************************************
    294          * Function Name  : I2C_EE_PageWrite
    295          * Description    : Writes more than one byte to the EEPROM with a single WRITE
    296          *                  cycle. The number of byte can't exceed the EEPROM page size.
    297          * Input          : - pBuffer : pointer to the buffer containing the data to be 
    298          *                    written to the EEPROM.
    299          *                  - WriteAddr : EEPROM's internal address to write to.
    300          *                  - NumByteToWrite : number of bytes to write to the EEPROM.
    301          * Output         : None
    302          * Return         : None
    303          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    304          uint32_t I2C_EE_PageWrite(u8* pBuffer, u16 WriteAddr, u8 NumByteToWrite)
    305          {
   \                     I2C_EE_PageWrite:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0E00               MOVS     R6,R1
   \   00000006   1500               MOVS     R5,R2
    306          	
    307          	/* While the bus is busy */
    308          	EETimeout = EE_LONG_TIMEOUT;
   \   00000008   ........           LDR.W    R0,??DataTable9_9
   \   0000000C   5FF41621           MOVS     R1,#+614400
   \   00000010   0160               STR      R1,[R0, #+0]
    309          	while(I2C_GetFlagStatus(I2C2, I2C_FLAG_BUSY))  
   \                     ??I2C_EE_PageWrite_0:
   \   00000012   5FF40031           MOVS     R1,#+131072
   \   00000016   ........           LDR.W    R0,??DataTable9_3  ;; 0x40005800
   \   0000001A   ........           BL       I2C_GetFlagStatus
   \   0000001E   0028               CMP      R0,#+0
   \   00000020   0BD0               BEQ.N    ??I2C_EE_PageWrite_1
    310          	{
    311          		if((EETimeout--) == 0) return EE_TIMEOUT_UserCallback();
   \   00000022   ........           LDR.W    R0,??DataTable9_9
   \   00000026   0068               LDR      R0,[R0, #+0]
   \   00000028   411E               SUBS     R1,R0,#+1
   \   0000002A   ........           LDR.W    R2,??DataTable9_9
   \   0000002E   1160               STR      R1,[R2, #+0]
   \   00000030   0028               CMP      R0,#+0
   \   00000032   EED1               BNE.N    ??I2C_EE_PageWrite_0
   \   00000034   ........           BL       EE_TIMEOUT_UserCallback
   \   00000038   7DE0               B.N      ??I2C_EE_PageWrite_2
    312          	}
    313          	
    314          	/* Send START condition */
    315          	I2C_GenerateSTART(I2C2, ENABLE);
   \                     ??I2C_EE_PageWrite_1:
   \   0000003A   0121               MOVS     R1,#+1
   \   0000003C   ........           LDR.W    R0,??DataTable9_3  ;; 0x40005800
   \   00000040   ........           BL       I2C_GenerateSTART
    316          	
    317          	/* Test on EV5 and clear it */
    318          	EETimeout = EE_FLAG_TIMEOUT;
   \   00000044   ........           LDR.W    R0,??DataTable9_9
   \   00000048   4FF47041           MOV      R1,#+61440
   \   0000004C   0160               STR      R1,[R0, #+0]
    319          	while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT))
   \                     ??I2C_EE_PageWrite_3:
   \   0000004E   ........           LDR.W    R1,??DataTable9_5  ;; 0x30001
   \   00000052   ........           LDR.W    R0,??DataTable9_3  ;; 0x40005800
   \   00000056   ........           BL       I2C_CheckEvent
   \   0000005A   0028               CMP      R0,#+0
   \   0000005C   0BD1               BNE.N    ??I2C_EE_PageWrite_4
    320          	{
    321          		if((EETimeout--) == 0) return EE_TIMEOUT_UserCallback();
   \   0000005E   ........           LDR.W    R0,??DataTable9_9
   \   00000062   0068               LDR      R0,[R0, #+0]
   \   00000064   411E               SUBS     R1,R0,#+1
   \   00000066   ........           LDR.W    R2,??DataTable9_9
   \   0000006A   1160               STR      R1,[R2, #+0]
   \   0000006C   0028               CMP      R0,#+0
   \   0000006E   EED1               BNE.N    ??I2C_EE_PageWrite_3
   \   00000070   ........           BL       EE_TIMEOUT_UserCallback
   \   00000074   5FE0               B.N      ??I2C_EE_PageWrite_2
    322          	}		
    323          	
    324          	/* Send EEPROM address for write */
    325          	I2C_Send7bitAddress(I2C2, EEPROM_ADDRESS, I2C_Direction_Transmitter);
   \                     ??I2C_EE_PageWrite_4:
   \   00000076   0022               MOVS     R2,#+0
   \   00000078   ....               LDR.N    R0,??DataTable9_4
   \   0000007A   0188               LDRH     R1,[R0, #+0]
   \   0000007C   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007E   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   00000080   ........           BL       I2C_Send7bitAddress
    326          	
    327          	/* Test on EV6 and clear it */
    328          	EETimeout = EE_FLAG_TIMEOUT;
   \   00000084   ....               LDR.N    R0,??DataTable9_9
   \   00000086   4FF47041           MOV      R1,#+61440
   \   0000008A   0160               STR      R1,[R0, #+0]
    329          	while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))  
   \                     ??I2C_EE_PageWrite_5:
   \   0000008C   ....               LDR.N    R1,??DataTable9_6  ;; 0x70082
   \   0000008E   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   00000090   ........           BL       I2C_CheckEvent
   \   00000094   0028               CMP      R0,#+0
   \   00000096   09D1               BNE.N    ??I2C_EE_PageWrite_6
    330          	{
    331          		if((EETimeout--) == 0) return EE_TIMEOUT_UserCallback();
   \   00000098   ....               LDR.N    R0,??DataTable9_9
   \   0000009A   0068               LDR      R0,[R0, #+0]
   \   0000009C   411E               SUBS     R1,R0,#+1
   \   0000009E   ....               LDR.N    R2,??DataTable9_9
   \   000000A0   1160               STR      R1,[R2, #+0]
   \   000000A2   0028               CMP      R0,#+0
   \   000000A4   F2D1               BNE.N    ??I2C_EE_PageWrite_5
   \   000000A6   ........           BL       EE_TIMEOUT_UserCallback
   \   000000AA   44E0               B.N      ??I2C_EE_PageWrite_2
    332          	}  
    333          	
    334          	/* Send the EEPROM's internal address to write to */    
    335          	I2C_SendData(I2C2, (WriteAddr >> 8 ) & 0xff);  
   \                     ??I2C_EE_PageWrite_6:
   \   000000AC   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000AE   310A               LSRS     R1,R6,#+8
   \   000000B0   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B2   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   000000B4   ........           BL       I2C_SendData
    336          	
    337          	/* Test on EV8 and clear it */
    338          	EETimeout = EE_FLAG_TIMEOUT;
   \   000000B8   ....               LDR.N    R0,??DataTable9_9
   \   000000BA   4FF47041           MOV      R1,#+61440
   \   000000BE   0160               STR      R1,[R0, #+0]
    339          	while(! I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
   \                     ??I2C_EE_PageWrite_7:
   \   000000C0   ....               LDR.N    R1,??DataTable9_8  ;; 0x70084
   \   000000C2   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   000000C4   ........           BL       I2C_CheckEvent
   \   000000C8   0028               CMP      R0,#+0
   \   000000CA   09D1               BNE.N    ??I2C_EE_PageWrite_8
    340          	{
    341          		if((EETimeout--) == 0) return EE_TIMEOUT_UserCallback();
   \   000000CC   ....               LDR.N    R0,??DataTable9_9
   \   000000CE   0068               LDR      R0,[R0, #+0]
   \   000000D0   411E               SUBS     R1,R0,#+1
   \   000000D2   ....               LDR.N    R2,??DataTable9_9
   \   000000D4   1160               STR      R1,[R2, #+0]
   \   000000D6   0028               CMP      R0,#+0
   \   000000D8   F2D1               BNE.N    ??I2C_EE_PageWrite_7
   \   000000DA   ........           BL       EE_TIMEOUT_UserCallback
   \   000000DE   2AE0               B.N      ??I2C_EE_PageWrite_2
    342          	}  		
    343          	
    344          	I2C_SendData(I2C2, (WriteAddr & 0xff) );  
   \                     ??I2C_EE_PageWrite_8:
   \   000000E0   3100               MOVS     R1,R6
   \   000000E2   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000E4   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   000000E6   ........           BL       I2C_SendData
    345          	
    346          	/* Test on EV8 and clear it */
    347          	EETimeout = EE_FLAG_TIMEOUT;
   \   000000EA   ....               LDR.N    R0,??DataTable9_9
   \   000000EC   4FF47041           MOV      R1,#+61440
   \   000000F0   0160               STR      R1,[R0, #+0]
    348          	while(! I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
   \                     ??I2C_EE_PageWrite_9:
   \   000000F2   ....               LDR.N    R1,??DataTable9_8  ;; 0x70084
   \   000000F4   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   000000F6   ........           BL       I2C_CheckEvent
   \   000000FA   0028               CMP      R0,#+0
   \   000000FC   F9D0               BEQ.N    ??I2C_EE_PageWrite_9
    349          	{
    350          		if((EETimeout--) == 0) return EE_TIMEOUT_UserCallback();
   \   000000FE   ....               LDR.N    R0,??DataTable9_9
   \   00000100   0068               LDR      R0,[R0, #+0]
   \   00000102   411E               SUBS     R1,R0,#+1
   \   00000104   ....               LDR.N    R2,??DataTable9_9
   \   00000106   1160               STR      R1,[R2, #+0]
   \   00000108   0028               CMP      R0,#+0
   \   0000010A   0AD1               BNE.N    ??I2C_EE_PageWrite_10
   \   0000010C   ........           BL       EE_TIMEOUT_UserCallback
   \   00000110   11E0               B.N      ??I2C_EE_PageWrite_2
    351          	}  		
    352          	/* While there is data to be written */
    353          	while(NumByteToWrite--)  
    354          	{
    355          		/* Send the current byte */
    356          		I2C_SendData(I2C2, *pBuffer); 
   \                     ??I2C_EE_PageWrite_11:
   \   00000112   2178               LDRB     R1,[R4, #+0]
   \   00000114   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   00000116   ........           BL       I2C_SendData
    357          		Delay(5);
   \   0000011A   0520               MOVS     R0,#+5
   \   0000011C   ........           BL       Delay
    358          		/* Point to the next byte to be written */
    359          		pBuffer++; 
   \   00000120   641C               ADDS     R4,R4,#+1
    360          		
    361          		/* Test on EV8 and clear it */
    362          		//    while (!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
    363          	}
   \                     ??I2C_EE_PageWrite_10:
   \   00000122   2800               MOVS     R0,R5
   \   00000124   451E               SUBS     R5,R0,#+1
   \   00000126   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000128   0028               CMP      R0,#+0
   \   0000012A   F2D1               BNE.N    ??I2C_EE_PageWrite_11
    364          	
    365          	/* Send STOP condition */
    366          	I2C_GenerateSTOP(I2C2, ENABLE);
   \   0000012C   0121               MOVS     R1,#+1
   \   0000012E   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   00000130   ........           BL       I2C_GenerateSTOP
    367          	return 0;
   \   00000134   0020               MOVS     R0,#+0
   \                     ??I2C_EE_PageWrite_2:
   \   00000136   70BD               POP      {R4-R6,PC}       ;; return
    368          }
    369          
    370          /*******************************************************************************
    371          * Function Name  : I2C_EE_BufferRead
    372          * Description    : Reads a block of data from the EEPROM.
    373          * Input          : - pBuffer : pointer to the buffer that receives the data read 
    374          *                    from the EEPROM.
    375          *                  - ReadAddr : EEPROM's internal address to read from.
    376          *                  - NumByteToRead : number of bytes to read from the EEPROM.
    377          * Output         : None
    378          * Return         : None
    379          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    380          uint32_t I2C_EE_BufferRead(u8* pBuffer, u16 ReadAddr, u16 NumByteToRead)
    381          {  
   \                     I2C_EE_BufferRead:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0E00               MOVS     R6,R1
   \   00000006   1500               MOVS     R5,R2
    382          
    383          //     I2C_GenerateSTOP(I2C2, ENABLE);
    384          //	I2C_GenerateSTART(I2C2, ENABLE);     
    385          	//  EE_ENABLE();
    386          	/* While the bus is busy */
    387          	EETimeout = EE_LONG_TIMEOUT;
   \   00000008   ....               LDR.N    R0,??DataTable9_9
   \   0000000A   5FF41621           MOVS     R1,#+614400
   \   0000000E   0160               STR      R1,[R0, #+0]
    388          	while(I2C_GetFlagStatus(I2C2, I2C_FLAG_BUSY))					// Buzy  
   \                     ??I2C_EE_BufferRead_0:
   \   00000010   5FF40031           MOVS     R1,#+131072
   \   00000014   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   00000016   ........           BL       I2C_GetFlagStatus
   \   0000001A   0028               CMP      R0,#+0
   \   0000001C   09D0               BEQ.N    ??I2C_EE_BufferRead_1
    389          	{
    390          		if((EETimeout--) == 0) return EE_TIMEOUT_UserCallback();
   \   0000001E   ....               LDR.N    R0,??DataTable9_9
   \   00000020   0068               LDR      R0,[R0, #+0]
   \   00000022   411E               SUBS     R1,R0,#+1
   \   00000024   ....               LDR.N    R2,??DataTable9_9
   \   00000026   1160               STR      R1,[R2, #+0]
   \   00000028   0028               CMP      R0,#+0
   \   0000002A   F1D1               BNE.N    ??I2C_EE_BufferRead_0
   \   0000002C   ........           BL       EE_TIMEOUT_UserCallback
   \   00000030   BDE0               B.N      ??I2C_EE_BufferRead_2
    391          	}
    392          	/* Send START condition */
    393          	I2C_GenerateSTART(I2C2, ENABLE);							//  
   \                     ??I2C_EE_BufferRead_1:
   \   00000032   0121               MOVS     R1,#+1
   \   00000034   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   00000036   ........           BL       I2C_GenerateSTART
    394          	EETimeout = EE_FLAG_TIMEOUT;
   \   0000003A   ....               LDR.N    R0,??DataTable9_9
   \   0000003C   4FF47041           MOV      R1,#+61440
   \   00000040   0160               STR      R1,[R0, #+0]
    395          	/* Test on EV5 and clear it */
    396          	while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT))
   \                     ??I2C_EE_BufferRead_3:
   \   00000042   ....               LDR.N    R1,??DataTable9_5  ;; 0x30001
   \   00000044   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   00000046   ........           BL       I2C_CheckEvent
   \   0000004A   0028               CMP      R0,#+0
   \   0000004C   09D1               BNE.N    ??I2C_EE_BufferRead_4
    397          	{
    398          		if((EETimeout--) == 0) return EE_TIMEOUT_UserCallback();
   \   0000004E   ....               LDR.N    R0,??DataTable9_9
   \   00000050   0068               LDR      R0,[R0, #+0]
   \   00000052   411E               SUBS     R1,R0,#+1
   \   00000054   ....               LDR.N    R2,??DataTable9_9
   \   00000056   1160               STR      R1,[R2, #+0]
   \   00000058   0028               CMP      R0,#+0
   \   0000005A   F2D1               BNE.N    ??I2C_EE_BufferRead_3
   \   0000005C   ........           BL       EE_TIMEOUT_UserCallback
   \   00000060   A5E0               B.N      ??I2C_EE_BufferRead_2
    399          	}
    400          	
    401          	/* Send EEPROM address for write */
    402          	I2C_Send7bitAddress(I2C2, EEPROM_ADDRESS, I2C_Direction_Transmitter);			//  
   \                     ??I2C_EE_BufferRead_4:
   \   00000062   0022               MOVS     R2,#+0
   \   00000064   ....               LDR.N    R0,??DataTable9_4
   \   00000066   0188               LDRH     R1,[R0, #+0]
   \   00000068   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006A   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   0000006C   ........           BL       I2C_Send7bitAddress
    403          	
    404          	EETimeout = EE_FLAG_TIMEOUT;
   \   00000070   ....               LDR.N    R0,??DataTable9_9
   \   00000072   4FF47041           MOV      R1,#+61440
   \   00000076   0160               STR      R1,[R0, #+0]
    405          	/* Test on EV6 and clear it */
    406          	while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
   \                     ??I2C_EE_BufferRead_5:
   \   00000078   ....               LDR.N    R1,??DataTable9_6  ;; 0x70082
   \   0000007A   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   0000007C   ........           BL       I2C_CheckEvent
   \   00000080   0028               CMP      R0,#+0
   \   00000082   09D1               BNE.N    ??I2C_EE_BufferRead_6
    407          	{
    408          		if((EETimeout--) == 0) return EE_TIMEOUT_UserCallback();
   \   00000084   ....               LDR.N    R0,??DataTable9_9
   \   00000086   0068               LDR      R0,[R0, #+0]
   \   00000088   411E               SUBS     R1,R0,#+1
   \   0000008A   ....               LDR.N    R2,??DataTable9_9
   \   0000008C   1160               STR      R1,[R2, #+0]
   \   0000008E   0028               CMP      R0,#+0
   \   00000090   F2D1               BNE.N    ??I2C_EE_BufferRead_5
   \   00000092   ........           BL       EE_TIMEOUT_UserCallback
   \   00000096   8AE0               B.N      ??I2C_EE_BufferRead_2
    409          	}
    410          	
    411          	/* Clear EV6 by setting again the PE bit */
    412          	I2C_Cmd(I2C2, ENABLE);										//  
   \                     ??I2C_EE_BufferRead_6:
   \   00000098   0121               MOVS     R1,#+1
   \   0000009A   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   0000009C   ........           BL       I2C_Cmd
    413          	
    414          	/* Send the EEPROM's internal address to write to */
    415          	I2C_SendData(I2C2, ( ReadAddr >> 8 ) & 0xff);  						//  ..
   \   000000A0   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000A2   310A               LSRS     R1,R6,#+8
   \   000000A4   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A6   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   000000A8   ........           BL       I2C_SendData
    416          	EETimeout = EE_FLAG_TIMEOUT;
   \   000000AC   ....               LDR.N    R0,??DataTable9_9
   \   000000AE   4FF47041           MOV      R1,#+61440
   \   000000B2   0160               STR      R1,[R0, #+0]
    417          	/* Test on EV8 and clear it */
    418          	while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
   \                     ??I2C_EE_BufferRead_7:
   \   000000B4   ....               LDR.N    R1,??DataTable9_8  ;; 0x70084
   \   000000B6   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   000000B8   ........           BL       I2C_CheckEvent
   \   000000BC   0028               CMP      R0,#+0
   \   000000BE   09D1               BNE.N    ??I2C_EE_BufferRead_8
    419          	{
    420          		if((EETimeout--) == 0) return EE_TIMEOUT_UserCallback();
   \   000000C0   ....               LDR.N    R0,??DataTable9_9
   \   000000C2   0068               LDR      R0,[R0, #+0]
   \   000000C4   411E               SUBS     R1,R0,#+1
   \   000000C6   ....               LDR.N    R2,??DataTable9_9
   \   000000C8   1160               STR      R1,[R2, #+0]
   \   000000CA   0028               CMP      R0,#+0
   \   000000CC   F2D1               BNE.N    ??I2C_EE_BufferRead_7
   \   000000CE   ........           BL       EE_TIMEOUT_UserCallback
   \   000000D2   6CE0               B.N      ??I2C_EE_BufferRead_2
    421          	}		
    422          	I2C_SendData(I2C2, ( ReadAddr & 0xff ) );  						//  .
   \                     ??I2C_EE_BufferRead_8:
   \   000000D4   3100               MOVS     R1,R6
   \   000000D6   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D8   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   000000DA   ........           BL       I2C_SendData
    423          	
    424          	/* Test on EV8 and clear it */
    425          	EETimeout = EE_FLAG_TIMEOUT;
   \   000000DE   ....               LDR.N    R0,??DataTable9_9
   \   000000E0   4FF47041           MOV      R1,#+61440
   \   000000E4   0160               STR      R1,[R0, #+0]
    426          	while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
   \                     ??I2C_EE_BufferRead_9:
   \   000000E6   ....               LDR.N    R1,??DataTable9_8  ;; 0x70084
   \   000000E8   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   000000EA   ........           BL       I2C_CheckEvent
   \   000000EE   0028               CMP      R0,#+0
   \   000000F0   09D1               BNE.N    ??I2C_EE_BufferRead_10
    427          	{
    428          		if((EETimeout--) == 0) return EE_TIMEOUT_UserCallback();
   \   000000F2   ....               LDR.N    R0,??DataTable9_9
   \   000000F4   0068               LDR      R0,[R0, #+0]
   \   000000F6   411E               SUBS     R1,R0,#+1
   \   000000F8   ....               LDR.N    R2,??DataTable9_9
   \   000000FA   1160               STR      R1,[R2, #+0]
   \   000000FC   0028               CMP      R0,#+0
   \   000000FE   F2D1               BNE.N    ??I2C_EE_BufferRead_9
   \   00000100   ........           BL       EE_TIMEOUT_UserCallback
   \   00000104   53E0               B.N      ??I2C_EE_BufferRead_2
    429          	}		
    430          	/* Send STRAT condition a second time */    
    431          	I2C_GenerateSTART(I2C2, ENABLE);								//   
   \                     ??I2C_EE_BufferRead_10:
   \   00000106   0121               MOVS     R1,#+1
   \   00000108   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   0000010A   ........           BL       I2C_GenerateSTART
    432          	
    433          	/* Test on EV5 and clear it */
    434          	EETimeout = EE_FLAG_TIMEOUT;	
   \   0000010E   ....               LDR.N    R0,??DataTable9_9
   \   00000110   4FF47041           MOV      R1,#+61440
   \   00000114   0160               STR      R1,[R0, #+0]
    435          	while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT))
   \                     ??I2C_EE_BufferRead_11:
   \   00000116   ....               LDR.N    R1,??DataTable9_5  ;; 0x30001
   \   00000118   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   0000011A   ........           BL       I2C_CheckEvent
   \   0000011E   0028               CMP      R0,#+0
   \   00000120   09D1               BNE.N    ??I2C_EE_BufferRead_12
    436          	{
    437          		if((EETimeout--) == 0) return EE_TIMEOUT_UserCallback();
   \   00000122   ....               LDR.N    R0,??DataTable9_9
   \   00000124   0068               LDR      R0,[R0, #+0]
   \   00000126   411E               SUBS     R1,R0,#+1
   \   00000128   ....               LDR.N    R2,??DataTable9_9
   \   0000012A   1160               STR      R1,[R2, #+0]
   \   0000012C   0028               CMP      R0,#+0
   \   0000012E   F2D1               BNE.N    ??I2C_EE_BufferRead_11
   \   00000130   ........           BL       EE_TIMEOUT_UserCallback
   \   00000134   3BE0               B.N      ??I2C_EE_BufferRead_2
    438          	}		
    439          	
    440          	/* Send EEPROM address for read */
    441          	I2C_Send7bitAddress(I2C2, EEPROM_ADDRESS, I2C_Direction_Receiver);			//  
   \                     ??I2C_EE_BufferRead_12:
   \   00000136   0122               MOVS     R2,#+1
   \   00000138   ....               LDR.N    R0,??DataTable9_4
   \   0000013A   0188               LDRH     R1,[R0, #+0]
   \   0000013C   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000013E   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   00000140   ........           BL       I2C_Send7bitAddress
    442          	
    443          	/* Test on EV6 and clear it */
    444          	EETimeout = EE_FLAG_TIMEOUT;	
   \   00000144   ....               LDR.N    R0,??DataTable9_9
   \   00000146   4FF47041           MOV      R1,#+61440
   \   0000014A   0160               STR      R1,[R0, #+0]
    445          	while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
   \                     ??I2C_EE_BufferRead_13:
   \   0000014C   ....               LDR.N    R1,??DataTable9_10  ;; 0x30002
   \   0000014E   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   00000150   ........           BL       I2C_CheckEvent
   \   00000154   0028               CMP      R0,#+0
   \   00000156   20D1               BNE.N    ??I2C_EE_BufferRead_14
    446          	{
    447          		if((EETimeout--) == 0) return EE_TIMEOUT_UserCallback();
   \   00000158   ....               LDR.N    R0,??DataTable9_9
   \   0000015A   0068               LDR      R0,[R0, #+0]
   \   0000015C   411E               SUBS     R1,R0,#+1
   \   0000015E   ....               LDR.N    R2,??DataTable9_9
   \   00000160   1160               STR      R1,[R2, #+0]
   \   00000162   0028               CMP      R0,#+0
   \   00000164   F2D1               BNE.N    ??I2C_EE_BufferRead_13
   \   00000166   ........           BL       EE_TIMEOUT_UserCallback
   \   0000016A   20E0               B.N      ??I2C_EE_BufferRead_2
    448          	}
    449          	/* While there is data to be read */
    450          	while(NumByteToRead)          
    451          	{
    452          		if(NumByteToRead == 1)
   \                     ??I2C_EE_BufferRead_15:
   \   0000016C   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000016E   012D               CMP      R5,#+1
   \   00000170   07D1               BNE.N    ??I2C_EE_BufferRead_16
    453          		{
    454          			/* Disable Acknowledgement */
    455          			I2C_AcknowledgeConfig(I2C2, DISABLE);
   \   00000172   0021               MOVS     R1,#+0
   \   00000174   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   00000176   ........           BL       I2C_AcknowledgeConfig
    456          			
    457          			/* Send STOP Condition */
    458          			I2C_GenerateSTOP(I2C2, ENABLE);
   \   0000017A   0121               MOVS     R1,#+1
   \   0000017C   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   0000017E   ........           BL       I2C_GenerateSTOP
    459          		}
    460          		
    461          		/* Test on EV7 and clear it */
    462          		if(I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_RECEIVED))  //   
   \                     ??I2C_EE_BufferRead_16:
   \   00000182   ....               LDR.N    R1,??DataTable9_11  ;; 0x30040
   \   00000184   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   00000186   ........           BL       I2C_CheckEvent
   \   0000018A   0028               CMP      R0,#+0
   \   0000018C   05D0               BEQ.N    ??I2C_EE_BufferRead_14
    463          		{      
    464          			/* Read a byte from the EEPROM */
    465          			*pBuffer = I2C_ReceiveData(I2C2);
   \   0000018E   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   00000190   ........           BL       I2C_ReceiveData
   \   00000194   2070               STRB     R0,[R4, #+0]
    466          			
    467          			/* Point to the next location where the byte read will be saved */
    468          			pBuffer++; 
   \   00000196   641C               ADDS     R4,R4,#+1
    469          			
    470          			/* Decrement the read bytes counter */
    471          			NumByteToRead--;        
   \   00000198   6D1E               SUBS     R5,R5,#+1
    472          		}   
    473          	}
   \                     ??I2C_EE_BufferRead_14:
   \   0000019A   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000019C   002D               CMP      R5,#+0
   \   0000019E   E5D1               BNE.N    ??I2C_EE_BufferRead_15
    474          	
    475          	/* Enable Acknowledgement to be ready for another reception */
    476          	I2C_AcknowledgeConfig(I2C2, ENABLE);
   \   000001A0   0121               MOVS     R1,#+1
   \   000001A2   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   000001A4   ........           BL       I2C_AcknowledgeConfig
    477          	EE_DISABLE();
   \   000001A8   ........           BL       EE_DISABLE
    478               return 0;
   \   000001AC   0020               MOVS     R0,#+0
   \                     ??I2C_EE_BufferRead_2:
   \   000001AE   70BD               POP      {R4-R6,PC}       ;; return
    479          }
    480          
    481          /*******************************************************************************
    482          * Function Name  : I2C_EE_WaitEepromStandbyState
    483          * Description    : Wait for EEPROM Standby state
    484          * Input          : None
    485          * Output         : None
    486          * Return         : None
    487          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    488          void I2C_EE_WaitEepromStandbyState(void)      
    489          {
   \                     I2C_EE_WaitEepromStandbyState:
   \   00000000   80B5               PUSH     {R7,LR}
    490          	vu16 SR1_Tmp = 0;
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   ADF80000           STRH     R0,[SP, #+0]
    491          	
    492          	do
    493          	{
    494          		/* Send START condition */
    495          		I2C_GenerateSTART(I2C2, ENABLE);
   \                     ??I2C_EE_WaitEepromStandbyState_0:
   \   00000008   0121               MOVS     R1,#+1
   \   0000000A   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   0000000C   ........           BL       I2C_GenerateSTART
    496          		/* Read I2C2 SR1 register */
    497          		SR1_Tmp = I2C_ReadRegister(I2C2, I2C_Register_SR1);
   \   00000010   1421               MOVS     R1,#+20
   \   00000012   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   00000014   ........           BL       I2C_ReadRegister
   \   00000018   ADF80000           STRH     R0,[SP, #+0]
    498          		/* Send EEPROM address for write */
    499          		I2C_Send7bitAddress(I2C2, EEPROM_ADDRESS, I2C_Direction_Transmitter);
   \   0000001C   0022               MOVS     R2,#+0
   \   0000001E   ....               LDR.N    R0,??DataTable9_4
   \   00000020   0188               LDRH     R1,[R0, #+0]
   \   00000022   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   00000026   ........           BL       I2C_Send7bitAddress
    500          	}while(!(I2C_ReadRegister(I2C2, I2C_Register_SR1) & 0x0002));
   \   0000002A   1421               MOVS     R1,#+20
   \   0000002C   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   0000002E   ........           BL       I2C_ReadRegister
   \   00000032   8007               LSLS     R0,R0,#+30
   \   00000034   E8D5               BPL.N    ??I2C_EE_WaitEepromStandbyState_0
    501          	
    502          	/* Clear AF flag */
    503          	I2C_ClearFlag(I2C2, I2C_FLAG_AF);
   \   00000036   ....               LDR.N    R1,??DataTable9_12  ;; 0x10000400
   \   00000038   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   0000003A   ........           BL       I2C_ClearFlag
    504          	
    505          	/* STOP condition */    
    506          	I2C_GenerateSTOP(I2C2, ENABLE);  
   \   0000003E   0121               MOVS     R1,#+1
   \   00000040   ....               LDR.N    R0,??DataTable9_3  ;; 0x40005800
   \   00000042   ........           BL       I2C_GenerateSTOP
    507          	
    508          	
    509          }
   \   00000046   01BD               POP      {R0,PC}          ;; return
    510          
    511          #ifdef USE_DEFAULT_TIMEOUT_CALLBACK
    512          /**
    513          * @brief  Basic management of the timeout situation.
    514          * @param  None.
    515          * @retval None.
    516          */

   \                                 In section .text, align 2, keep-with-next
    517          uint32_t EE_TIMEOUT_UserCallback(void)
    518          {
   \                     EE_TIMEOUT_UserCallback:
   \   00000000   80B5               PUSH     {R7,LR}
    519          	/* Block communication and all processes */
    520          //	while (1)
    521          	{   
    522          		if(LOGWRITE & LOG_EEPROM)                       
   \   00000002   ....               LDR.N    R0,??DataTable9_13
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   C005               LSLS     R0,R0,#+23
   \   00000008   08D5               BPL.N    ??EE_TIMEOUT_UserCallback_0
    523          		{					
    524          			sprintf((char *)Buffer,"EEPROM ERROR TIMEOUT \r\n " );                 
   \   0000000A   ........           ADR.W    R1,`?<Constant "EEPROM ERROR TIMEOUT \\r\\n ">`
   \   0000000E   ....               LDR.N    R0,??DataTable9_14
   \   00000010   ........           BL       sprintf
    525          			Write_Log(Buffer, FAIL_LOG);
   \   00000014   0221               MOVS     R1,#+2
   \   00000016   ....               LDR.N    R0,??DataTable9_14
   \   00000018   ........           BL       Write_Log
    526          		}
    527          	}
    528               return 0;
   \                     ??EE_TIMEOUT_UserCallback_0:
   \   0000001C   0020               MOVS     R0,#+0
   \   0000001E   02BD               POP      {R1,PC}          ;; return
    529          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   00180240           DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   00040240           DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   A0860100           DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   00580040           DC32     0x40005800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   ........           DC32     EEPROM_ADDRESS

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   01000300           DC32     0x30001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   82000700           DC32     0x70082

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   80000700           DC32     0x70080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   84000700           DC32     0x70084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   ........           DC32     EETimeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   02000300           DC32     0x30002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   40000300           DC32     0x30040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   00040010           DC32     0x10000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   ........           DC32     LOGWRITE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   ........           DC32     Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "EEPROM ERROR TIMEOUT \\r\\n ">`:
   \   00000000                      ; Initializer data, 28 bytes
   \   00000000   454550524F4D       DC8 69, 69, 80, 82, 79, 77, 32, 69, 82, 82
   \              20455252    
   \   0000000A   4F522054494D       DC8 79, 82, 32, 84, 73, 77, 69, 79, 85, 84
   \              454F5554    
   \   00000014   200D0A200000       DC8 32, 13, 10, 32, 0, 0, 0, 0
   \              0000        
    530          #endif /* USE_DEFAULT_TIMEOUT_CALLBACK */
    531          
    532          #ifdef USE_DEFAULT_CRITICAL_CALLBACK
    533          /**
    534          * @brief  Start critical section: these callbacks should be typically used
    535          *         to disable interrupts when entering a critical section of I2C communication
    536          *         You may use default callbacks provided into this driver by uncommenting the 
    537          *         define USE_DEFAULT_CRITICAL_CALLBACK.
    538          *         Or you can comment that line and implement these callbacks into your 
    539          *         application.
    540          * @param  None.
    541          * @retval None.
    542          */
    543          void sEE_EnterCriticalSection_UserCallback(void)
    544          {
    545          	__disable_irq();  
    546          }
    547          
    548          /**
    549          * @brief  Start and End of critical section: these callbacks should be typically used
    550          *         to re-enable interrupts when exiting a critical section of I2C communication
    551          *         You may use default callbacks provided into this driver by uncommenting the 
    552          *         define USE_DEFAULT_CRITICAL_CALLBACK.
    553          *         Or you can comment that line and implement these callbacks into your 
    554          *         application.
    555          * @param  None.
    556          * @retval None.
    557          */
    558          void sEE_ExitCriticalSection_UserCallback(void)
    559          {
    560          	__enable_irq();
    561          }
    562          #endif /* USE_DEFAULT_CRITICAL_CALLBACK */
    563          
    564          /**
    565          * @}
    566          */
    567          
    568          /**
    569          * @}
    570          */
    571          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                      .cstack
     --------                      -------
     EE_DISABLE                         8
     EE_ENABLE                          8
     EE_LowLevel_Init                  16
     EE_TIMEOUT_UserCallback            8
     I2C_EE_BufferRead                 16
     I2C_EE_BufferWrite                32
     I2C_EE_ByteWrite                  16
     I2C_EE_Init                       24
     I2C_EE_PageWrite                  16
     I2C_EE_WaitEepromStandbyState      8


   Section sizes:

     Function/Label                           Bytes
     --------------                           -----
     EE_DISABLE                                 16
     EE_ENABLE                                  16
     EEPROM_ADDRESS                              2
     EEAddress                                   2
     EETimeout                                   4
     EEDataReadPointer                           4
     EEDataWritePointer                          4
     EEDataNum                                   1
     EE_LowLevel_Init                          170
     I2C_EE_Init                                86
     I2C_EE_BufferWrite                        348
     I2C_EE_ByteWrite                          162
     I2C_EE_PageWrite                          312
     I2C_EE_BufferRead                         432
     I2C_EE_WaitEepromStandbyState              72
     EE_TIMEOUT_UserCallback                    32
     ??DataTable9                                4
     ??DataTable9_1                              4
     ??DataTable9_2                              4
     ??DataTable9_3                              4
     ??DataTable9_4                              4
     ??DataTable9_5                              4
     ??DataTable9_6                              4
     ??DataTable9_7                              4
     ??DataTable9_8                              4
     ??DataTable9_9                              4
     ??DataTable9_10                             4
     ??DataTable9_11                             4
     ??DataTable9_12                             4
     ??DataTable9_13                             4
     ??DataTable9_14                             4
     ?<Constant "EEPROM ERROR TIMEOUT \r\n ">   28

 
    13 bytes in section .bss
     4 bytes in section .data
 1 734 bytes in section .text
 
 1 734 bytes of CODE memory
    17 bytes of DATA memory

Errors: none
Warnings: none
