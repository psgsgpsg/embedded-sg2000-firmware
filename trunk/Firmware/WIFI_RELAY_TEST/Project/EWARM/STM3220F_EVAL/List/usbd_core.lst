###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     16/May/2011  15:08:16 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4 #
#                    \STM32F2xx_StdPeriph_Lib_V0.0.4\Libraries\STM32_USB_Devi #
#                    ce_Library\Core\src\usbd_core.c                          #
#    Command line =  "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Libraries\STM32_USB_Dev #
#                    ice_Library\Core\src\usbd_core.c" -D                     #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D USE_ULPI_PHY -lC "D:\¹¬ÀÛ¾÷\[       #
#                    NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_S #
#                    tdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template #
#                    \EWARM\STM3220F_EVAL\List\" -lA "D:\¹¬ÀÛ¾÷\[ NewDTG      #
#                    ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    STM3220F_EVAL\List\" -o "D:\¹¬ÀÛ¾÷\[ NewDTG              #
#                    ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    STM3220F_EVAL\Obj\" --no_cse --no_unroll --no_inline     #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "D:\¹¬ÀÛ¾÷\[ NewDTG                              #
#                    ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\" -I "D:\¹¬ÀÛ¾÷\[ NewDTG                              #
#                    ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\..\..\Libraries\CMSIS\CM3\CoreSupport\" -I            #
#                    "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Libraries\CMSIS\CM3\DeviceS #
#                    upport\ST\STM32F2xx\" -I "D:\¹¬ÀÛ¾÷\[ NewDTG             #
#                    ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I   #
#                    "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Utilities\STM32_EVAL\" -I   #
#                    "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Utilities\STM32_EVAL\Common #
#                    \" -I "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib #
#                    _V0.0.4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx #
#                    _StdPeriph_Template\EWARM\..\..\..\Utilities\STM32_EVAL\ #
#                    STM3220F_EVAL\" -I "D:\¹¬ÀÛ¾÷\[ NewDTG                   #
#                    ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I         #
#                    "D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Libraries\STM32_USB_Device_ #
#                    Library\Core\inc\" -I "D:\¹¬ÀÛ¾÷\[ NewDTG                #
#                    ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\..\..\Libraries\STM32_USB_Device_Library\Class\msc\in #
#                    c\" -Ol --use_c++_inline                                 #
#    List file    =  D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4 #
#                    \STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPer #
#                    iph_Template\EWARM\STM3220F_EVAL\List\usbd_core.lst      #
#    Object file  =  D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4 #
#                    \STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPer #
#                    iph_Template\EWARM\STM3220F_EVAL\Obj\usbd_core.o         #
#                                                                             #
#                                                                             #
###############################################################################

D:\¹¬ÀÛ¾÷\[ NewDTG ]\ÀÚ·á\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPeriph_Lib_V0.0.4\Libraries\STM32_USB_Device_Library\Core\src\usbd_core.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbd_core.c
      4            * @author  MCD Application Team
      5            * @version V0.0.1
      6            * @date    11/12/2010
      7            * @brief   This file provides all the USBD core functions.
      8            ******************************************************************************
      9            * @copy
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "usbd_core.h"
     23          #include "usbd_req.h"
     24          #include "usbd_ioreq.h"
     25          #include "usb_dcd_int.h"
     26          /** @addtogroup STM32_USB_OTG_DEVICE_LIBRARY
     27            * @{
     28            */
     29          
     30          
     31          /** @defgroup USBD_CORE 
     32            * @brief usbd core module
     33            * @{
     34            */ 
     35          
     36          /** @defgroup USBD_CORE_Private_TypesDefinitions
     37            * @{
     38            */ 
     39          /**
     40            * @}
     41            */ 
     42          
     43          
     44          /** @defgroup USBD_CORE_Private_Defines
     45            * @{
     46            */ 
     47          
     48          /**
     49            * @}
     50            */ 
     51          
     52          
     53          /** @defgroup USBD_CORE_Private_Macros
     54            * @{
     55            */ 
     56          /**
     57            * @}
     58            */ 
     59          
     60          
     61          
     62          
     63          /** @defgroup USBD_CORE_Private_FunctionPrototypes
     64            * @{
     65            */ 
     66          static uint8_t USBD_SetupStage(USB_OTG_CORE_HANDLE *pdev);
     67          static uint8_t USBD_DataOutStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum);
     68          static uint8_t USBD_DataInStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum);
     69          static uint8_t USBD_SOF(USB_OTG_CORE_HANDLE  *pdev);
     70          static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev);
     71          static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev);
     72          static uint8_t USBD_Resume(USB_OTG_CORE_HANDLE  *pdev);
     73          /**
     74            * @}
     75            */ 
     76          
     77          /** @defgroup USBD_CORE_Private_Variables
     78            * @{
     79            */ 
     80          
     81          
     82          

   \                                 In section .data, align 4
     83          USBD_DCD_INT_cb_TypeDef USBD_DCD_INT_cb = 
   \                     USBD_DCD_INT_cb:
   \   00000000   ............       DC32 USBD_DataOutStage, USBD_DataInStage, USBD_SetupStage, USBD_SOF
   \              ............
   \              ........    
   \   00000010   ............       DC32 USBD_Reset, USBD_Suspend, USBD_Resume
   \              ............
     84          {
     85            USBD_DataOutStage,
     86            USBD_DataInStage,
     87            USBD_SetupStage,
     88            USBD_SOF,
     89            USBD_Reset,
     90            USBD_Suspend,
     91            USBD_Resume,
     92          };
     93          

   \                                 In section .data, align 4
     94          USBD_DCD_INT_cb_TypeDef  *USBD_DCD_INT_fops = &USBD_DCD_INT_cb;
   \                     USBD_DCD_INT_fops:
   \   00000000   ........           DC32 USBD_DCD_INT_cb
     95          /**
     96            * @}
     97            */ 
     98          
     99          /** @defgroup USBD_CORE_Private_Functions
    100            * @{
    101            */ 
    102          
    103          /**
    104          * @brief  USBD_Init
    105          *         Initailizes the device stack and load the class driver
    106          * @param  pdev: device instance
    107          * @param  core_address: USB OTG core ID
    108          * @param  class_cb: Class callback structure address
    109          * @param  usr_cb: User callback structure address
    110          * @retval None
    111          */

   \                                 In section .text, align 2, keep-with-next
    112          void USBD_Init(USB_OTG_CORE_HANDLE *pdev,
    113                         USB_OTG_CORE_ID_TypeDef coreID,
    114                         USBD_Class_cb_TypeDef *class_cb, 
    115                         USBD_Usr_cb_TypeDef *usr_cb)
    116          {
   \                     USBD_Init:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
   \   00000008   1F00               MOVS     R7,R3
    117            
    118            USBD_DeInit(pdev);
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   ........           BL       USBD_DeInit
    119            
    120            /*Register class and user callbacks */
    121            pdev->dev.class_cb = class_cb;
   \   00000010   C4F8E065           STR      R6,[R4, #+1504]
    122            pdev->dev.usr_cb = usr_cb;  
   \   00000014   C4F8E475           STR      R7,[R4, #+1508]
    123            
    124            /* set USB OTG core params */
    125            DCD_Init(pdev , coreID);
   \   00000018   2900               MOVS     R1,R5
   \   0000001A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   2000               MOVS     R0,R4
   \   0000001E   ........           BL       DCD_Init
    126            
    127            /* Upon Init call usr callback */
    128            pdev->dev.usr_cb->Init();
   \   00000022   D4F8E405           LDR      R0,[R4, #+1508]
   \   00000026   0068               LDR      R0,[R0, #+0]
   \   00000028   8047               BLX      R0
    129            
    130            /* Enable Interrupts */
    131            USB_OTG_BSP_EnableInterrupt();
   \   0000002A   ........           BL       USB_OTG_BSP_EnableInterrupt
    132          }
   \   0000002E   F1BD               POP      {R0,R4-R7,PC}    ;; return
    133          
    134          /**
    135          * @brief  USBD_DeInit 
    136          *         Re-Initialize th deviuce library
    137          * @param  pdev: device instance
    138          * @retval status: status
    139          */

   \                                 In section .text, align 2, keep-with-next
    140          USBD_Status USBD_DeInit(USB_OTG_CORE_HANDLE *pdev)
    141          {
    142            /* Software Init */
    143            
    144            return USBD_OK;
   \                     USBD_DeInit:
   \   00000000   0020               MOVS     R0,#+0
   \   00000002   7047               BX       LR               ;; return
    145          }
    146          
    147          /**
    148          * @brief  USBD_SetupStage 
    149          *         Handle the setup stage
    150          * @param  pdev: device instance
    151          * @retval status
    152          */

   \                                 In section .text, align 2, keep-with-next
    153          static uint8_t USBD_SetupStage(USB_OTG_CORE_HANDLE *pdev)
    154          {
   \                     USBD_SetupStage:
   \   00000000   1CB5               PUSH     {R2-R4,LR}
   \   00000002   0400               MOVS     R4,R0
    155            USB_SETUP_REQ req;
    156            
    157            USBD_ParseSetupRequest(pdev , &req);
   \   00000004   00A9               ADD      R1,SP,#+0
   \   00000006   2000               MOVS     R0,R4
   \   00000008   ........           BL       USBD_ParseSetupRequest
    158            
    159            switch (req.bmRequest & 0x1F) 
   \   0000000C   9DF80000           LDRB     R0,[SP, #+0]
   \   00000010   10F01F00           ANDS     R0,R0,#0x1F
   \   00000014   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0028               CMP      R0,#+0
   \   00000018   03D0               BEQ.N    ??USBD_SetupStage_0
   \   0000001A   0228               CMP      R0,#+2
   \   0000001C   0BD0               BEQ.N    ??USBD_SetupStage_1
   \   0000001E   05D3               BCC.N    ??USBD_SetupStage_2
   \   00000020   0EE0               B.N      ??USBD_SetupStage_3
    160            {
    161            case USB_REQ_RECIPIENT_DEVICE:   
    162              USBD_StdDevReq (pdev, &req);
   \                     ??USBD_SetupStage_0:
   \   00000022   00A9               ADD      R1,SP,#+0
   \   00000024   2000               MOVS     R0,R4
   \   00000026   ........           BL       USBD_StdDevReq
    163              break;
   \   0000002A   10E0               B.N      ??USBD_SetupStage_4
    164              
    165            case USB_REQ_RECIPIENT_INTERFACE:     
    166              USBD_StdItfReq(pdev, &req);
   \                     ??USBD_SetupStage_2:
   \   0000002C   00A9               ADD      R1,SP,#+0
   \   0000002E   2000               MOVS     R0,R4
   \   00000030   ........           BL       USBD_StdItfReq
    167              break;
   \   00000034   0BE0               B.N      ??USBD_SetupStage_4
    168              
    169            case USB_REQ_RECIPIENT_ENDPOINT:        
    170              USBD_StdEPReq(pdev, &req);   
   \                     ??USBD_SetupStage_1:
   \   00000036   00A9               ADD      R1,SP,#+0
   \   00000038   2000               MOVS     R0,R4
   \   0000003A   ........           BL       USBD_StdEPReq
    171              break;
   \   0000003E   06E0               B.N      ??USBD_SetupStage_4
    172              
    173            default:           
    174              DCD_EP_Stall(pdev , req.bmRequest & 0x80);
   \                     ??USBD_SetupStage_3:
   \   00000040   9DF80000           LDRB     R0,[SP, #+0]
   \   00000044   10F08001           ANDS     R1,R0,#0x80
   \   00000048   2000               MOVS     R0,R4
   \   0000004A   ........           BL       DCD_EP_Stall
    175              break;
    176            }  
    177            return USBD_OK;
   \                     ??USBD_SetupStage_4:
   \   0000004E   0020               MOVS     R0,#+0
   \   00000050   16BD               POP      {R1,R2,R4,PC}    ;; return
    178          }
    179          
    180          /**
    181          * @brief  USBD_DataOutStage 
    182          *         Handle data out stage
    183          * @param  pdev: device instance
    184          * @param  epnum: endpoint index
    185          * @retval status
    186          */

   \                                 In section .text, align 2, keep-with-next
    187          static uint8_t USBD_DataOutStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
    188          {
   \                     USBD_DataOutStage:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    189            USB_OTG_EP *ep;
    190            
    191            if(epnum == 0) 
   \   00000004   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0029               CMP      R1,#+0
   \   00000008   31D1               BNE.N    ??USBD_DataOutStage_0
    192            {
    193              ep = &pdev->dev.out_ep[0];
   \   0000000A   04F27030           ADDW     R0,R4,#+880
    194              if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
   \   0000000E   94F81111           LDRB     R1,[R4, #+273]
   \   00000012   0329               CMP      R1,#+3
   \   00000014   3AD1               BNE.N    ??USBD_DataOutStage_1
    195              {
    196                if(ep->rem_data_len > ep->maxpacket)
   \   00000016   8168               LDR      R1,[R0, #+8]
   \   00000018   C269               LDR      R2,[R0, #+28]
   \   0000001A   9142               CMP      R1,R2
   \   0000001C   15D2               BCS.N    ??USBD_DataOutStage_2
    197                {
    198                  ep->rem_data_len -=  ep->maxpacket;
   \   0000001E   C169               LDR      R1,[R0, #+28]
   \   00000020   8268               LDR      R2,[R0, #+8]
   \   00000022   891A               SUBS     R1,R1,R2
   \   00000024   C161               STR      R1,[R0, #+28]
    199                  ep->xfer_buff +=  ep->rem_data_len;
   \   00000026   C169               LDR      R1,[R0, #+28]
   \   00000028   C268               LDR      R2,[R0, #+12]
   \   0000002A   8918               ADDS     R1,R1,R2
   \   0000002C   C160               STR      R1,[R0, #+12]
    200                  if(pdev->cfg.dma_enable == 1)
   \   0000002E   E178               LDRB     R1,[R4, #+3]
   \   00000030   0129               CMP      R1,#+1
   \   00000032   03D1               BNE.N    ??USBD_DataOutStage_3
    201                  {
    202                    /* in slave mode this, is handled by the RxSTSQLvl ISR */
    203                    ep->xfer_buff += ep->rem_data_len; 
   \   00000034   C169               LDR      R1,[R0, #+28]
   \   00000036   C268               LDR      R2,[R0, #+12]
   \   00000038   8918               ADDS     R1,R1,R2
   \   0000003A   C160               STR      R1,[R0, #+12]
    204                  }        
    205                  USBD_CtlContinueRx (pdev, 
    206                                      ep->xfer_buff,
    207                                      ep->rem_data_len);
   \                     ??USBD_DataOutStage_3:
   \   0000003C   C269               LDR      R2,[R0, #+28]
   \   0000003E   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000040   C168               LDR      R1,[R0, #+12]
   \   00000042   2000               MOVS     R0,R4
   \   00000044   ........           BL       USBD_CtlContinueRx
   \   00000048   20E0               B.N      ??USBD_DataOutStage_1
    208                }
    209                else
    210                {
    211                  if((pdev->dev.class_cb->EP0_RxReady != NULL)&&
    212                     (pdev->dev.device_status == USB_OTG_CONFIGURED))
   \                     ??USBD_DataOutStage_2:
   \   0000004A   D4F8E005           LDR      R0,[R4, #+1504]
   \   0000004E   0069               LDR      R0,[R0, #+16]
   \   00000050   0028               CMP      R0,#+0
   \   00000052   08D0               BEQ.N    ??USBD_DataOutStage_4
   \   00000054   94F81201           LDRB     R0,[R4, #+274]
   \   00000058   0328               CMP      R0,#+3
   \   0000005A   04D1               BNE.N    ??USBD_DataOutStage_4
    213                  {
    214                    pdev->dev.class_cb->EP0_RxReady(pdev); 
   \   0000005C   2000               MOVS     R0,R4
   \   0000005E   D4F8E015           LDR      R1,[R4, #+1504]
   \   00000062   0969               LDR      R1,[R1, #+16]
   \   00000064   8847               BLX      R1
    215                  }
    216                  USBD_CtlSendStatus(pdev);
   \                     ??USBD_DataOutStage_4:
   \   00000066   2000               MOVS     R0,R4
   \   00000068   ........           BL       USBD_CtlSendStatus
   \   0000006C   0EE0               B.N      ??USBD_DataOutStage_1
    217                }
    218              }
    219            }
    220            else if((pdev->dev.class_cb->DataOut != NULL)&&
    221                    (pdev->dev.device_status == USB_OTG_CONFIGURED))
   \                     ??USBD_DataOutStage_0:
   \   0000006E   D4F8E005           LDR      R0,[R4, #+1504]
   \   00000072   8069               LDR      R0,[R0, #+24]
   \   00000074   0028               CMP      R0,#+0
   \   00000076   09D0               BEQ.N    ??USBD_DataOutStage_1
   \   00000078   94F81201           LDRB     R0,[R4, #+274]
   \   0000007C   0328               CMP      R0,#+3
   \   0000007E   05D1               BNE.N    ??USBD_DataOutStage_1
    222            {
    223              pdev->dev.class_cb->DataOut(pdev, epnum); 
   \   00000080   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000082   2000               MOVS     R0,R4
   \   00000084   D4F8E025           LDR      R2,[R4, #+1504]
   \   00000088   9269               LDR      R2,[R2, #+24]
   \   0000008A   9047               BLX      R2
    224            }  
    225            return USBD_OK;
   \                     ??USBD_DataOutStage_1:
   \   0000008C   0020               MOVS     R0,#+0
   \   0000008E   10BD               POP      {R4,PC}          ;; return
    226          }
    227          
    228          /**
    229          * @brief  USBD_DataInStage 
    230          *         Handle data in stage
    231          * @param  pdev: device instance
    232          * @param  epnum: endpoint index
    233          * @retval status
    234          */

   \                                 In section .text, align 2, keep-with-next
    235          static uint8_t USBD_DataInStage(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
    236          {
   \                     USBD_DataInStage:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
    237            USB_OTG_EP *ep;
    238            
    239            if(epnum == 0) 
   \   00000004   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0029               CMP      R1,#+0
   \   00000008   45D1               BNE.N    ??USBD_DataInStage_0
    240            {
    241              ep = &pdev->dev.in_ep[0];
   \   0000000A   04F21815           ADDW     R5,R4,#+280
    242              if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
   \   0000000E   94F81101           LDRB     R0,[R4, #+273]
   \   00000012   0228               CMP      R0,#+2
   \   00000014   4ED1               BNE.N    ??USBD_DataInStage_1
    243              {
    244                if(ep->rem_data_len > ep->maxpacket)
   \   00000016   A868               LDR      R0,[R5, #+8]
   \   00000018   E969               LDR      R1,[R5, #+28]
   \   0000001A   8842               CMP      R0,R1
   \   0000001C   11D2               BCS.N    ??USBD_DataInStage_2
    245                {
    246                  ep->rem_data_len -=  ep->maxpacket;
   \   0000001E   E869               LDR      R0,[R5, #+28]
   \   00000020   A968               LDR      R1,[R5, #+8]
   \   00000022   401A               SUBS     R0,R0,R1
   \   00000024   E861               STR      R0,[R5, #+28]
    247                  if(pdev->cfg.dma_enable == 1)
   \   00000026   E078               LDRB     R0,[R4, #+3]
   \   00000028   0128               CMP      R0,#+1
   \   0000002A   03D1               BNE.N    ??USBD_DataInStage_3
    248                  {
    249                    /* in slave mode this, is handled by the TxFifoEmpty ISR */
    250                    ep->xfer_buff += ep->maxpacket;
   \   0000002C   A868               LDR      R0,[R5, #+8]
   \   0000002E   E968               LDR      R1,[R5, #+12]
   \   00000030   4018               ADDS     R0,R0,R1
   \   00000032   E860               STR      R0,[R5, #+12]
    251                  }
    252                  USBD_CtlContinueSendData (pdev, 
    253                                            ep->xfer_buff, 
    254                                            ep->rem_data_len);
   \                     ??USBD_DataInStage_3:
   \   00000034   EA69               LDR      R2,[R5, #+28]
   \   00000036   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000038   E968               LDR      R1,[R5, #+12]
   \   0000003A   2000               MOVS     R0,R4
   \   0000003C   ........           BL       USBD_CtlContinueSendData
   \   00000040   38E0               B.N      ??USBD_DataInStage_1
    255                }
    256                else
    257                { /* last packet is MPS multiple, so send ZLP packet */
    258                  if((ep->total_data_len % ep->maxpacket == 0) &&
    259                     (ep->total_data_len > ep->maxpacket) &&
    260                       (ep->total_data_len < ep->ctl_data_len ))
   \                     ??USBD_DataInStage_2:
   \   00000042   286A               LDR      R0,[R5, #+32]
   \   00000044   A968               LDR      R1,[R5, #+8]
   \   00000046   B0FBF1F2           UDIV     R2,R0,R1
   \   0000004A   01FB1200           MLS      R0,R1,R2,R0
   \   0000004E   0028               CMP      R0,#+0
   \   00000050   0FD1               BNE.N    ??USBD_DataInStage_4
   \   00000052   A868               LDR      R0,[R5, #+8]
   \   00000054   296A               LDR      R1,[R5, #+32]
   \   00000056   8842               CMP      R0,R1
   \   00000058   0BD2               BCS.N    ??USBD_DataInStage_4
   \   0000005A   286A               LDR      R0,[R5, #+32]
   \   0000005C   696A               LDR      R1,[R5, #+36]
   \   0000005E   8842               CMP      R0,R1
   \   00000060   07D2               BCS.N    ??USBD_DataInStage_4
    261                  {
    262                    
    263                    USBD_CtlContinueSendData(pdev , NULL, 0);
   \   00000062   0022               MOVS     R2,#+0
   \   00000064   0021               MOVS     R1,#+0
   \   00000066   2000               MOVS     R0,R4
   \   00000068   ........           BL       USBD_CtlContinueSendData
    264                    ep->ctl_data_len = 0;
   \   0000006C   0020               MOVS     R0,#+0
   \   0000006E   6862               STR      R0,[R5, #+36]
   \   00000070   20E0               B.N      ??USBD_DataInStage_1
    265                  }
    266                  else
    267                  {
    268                    if((pdev->dev.class_cb->EP0_TxSent != NULL)&&
    269                       (pdev->dev.device_status == USB_OTG_CONFIGURED))
   \                     ??USBD_DataInStage_4:
   \   00000072   D4F8E005           LDR      R0,[R4, #+1504]
   \   00000076   C068               LDR      R0,[R0, #+12]
   \   00000078   0028               CMP      R0,#+0
   \   0000007A   08D0               BEQ.N    ??USBD_DataInStage_5
   \   0000007C   94F81201           LDRB     R0,[R4, #+274]
   \   00000080   0328               CMP      R0,#+3
   \   00000082   04D1               BNE.N    ??USBD_DataInStage_5
    270                    {
    271                      pdev->dev.class_cb->EP0_TxSent(pdev); 
   \   00000084   2000               MOVS     R0,R4
   \   00000086   D4F8E015           LDR      R1,[R4, #+1504]
   \   0000008A   C968               LDR      R1,[R1, #+12]
   \   0000008C   8847               BLX      R1
    272                    }          
    273                    USBD_CtlReceiveStatus(pdev);
   \                     ??USBD_DataInStage_5:
   \   0000008E   2000               MOVS     R0,R4
   \   00000090   ........           BL       USBD_CtlReceiveStatus
   \   00000094   0EE0               B.N      ??USBD_DataInStage_1
    274                  }
    275                }
    276              }
    277            }
    278            else if((pdev->dev.class_cb->DataIn != NULL)&& 
    279                    (pdev->dev.device_status == USB_OTG_CONFIGURED))
   \                     ??USBD_DataInStage_0:
   \   00000096   D4F8E005           LDR      R0,[R4, #+1504]
   \   0000009A   4069               LDR      R0,[R0, #+20]
   \   0000009C   0028               CMP      R0,#+0
   \   0000009E   09D0               BEQ.N    ??USBD_DataInStage_1
   \   000000A0   94F81201           LDRB     R0,[R4, #+274]
   \   000000A4   0328               CMP      R0,#+3
   \   000000A6   05D1               BNE.N    ??USBD_DataInStage_1
    280            {
    281              pdev->dev.class_cb->DataIn(pdev, epnum); 
   \   000000A8   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000AA   2000               MOVS     R0,R4
   \   000000AC   D4F8E025           LDR      R2,[R4, #+1504]
   \   000000B0   5269               LDR      R2,[R2, #+20]
   \   000000B2   9047               BLX      R2
    282            }  
    283            return USBD_OK;
   \                     ??USBD_DataInStage_1:
   \   000000B4   0020               MOVS     R0,#+0
   \   000000B6   32BD               POP      {R1,R4,R5,PC}    ;; return
    284          }
    285          
    286          /**
    287          * @brief  USBD_Reset 
    288          *         Handle Reset event
    289          * @param  pdev: device instance
    290          * @retval status
    291          */
    292          

   \                                 In section .text, align 2, keep-with-next
    293          static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev)
    294          {
   \                     USBD_Reset:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    295            /* Open EP0 OUT */
    296            DCD_EP_Open(pdev,
    297                        0x00,
    298                        USB_OTG_MAX_EP0_SIZE,
    299                        EP_TYPE_CTRL);
   \   00000004   0023               MOVS     R3,#+0
   \   00000006   4022               MOVS     R2,#+64
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   ........           BL       DCD_EP_Open
    300            
    301            /* Open EP0 IN */
    302            DCD_EP_Open(pdev,
    303                        0x80,
    304                        USB_OTG_MAX_EP0_SIZE,
    305                        EP_TYPE_CTRL);
   \   00000010   0023               MOVS     R3,#+0
   \   00000012   4022               MOVS     R2,#+64
   \   00000014   8021               MOVS     R1,#+128
   \   00000016   2000               MOVS     R0,R4
   \   00000018   ........           BL       DCD_EP_Open
    306            
    307            /* Upon Reset call usr call back */
    308            pdev->dev.device_status = USB_OTG_DEFAULT;
   \   0000001C   0120               MOVS     R0,#+1
   \   0000001E   84F81201           STRB     R0,[R4, #+274]
    309            pdev->dev.usr_cb->DeviceReset(pdev->cfg.speed);
   \   00000022   A078               LDRB     R0,[R4, #+2]
   \   00000024   D4F8E415           LDR      R1,[R4, #+1508]
   \   00000028   4968               LDR      R1,[R1, #+4]
   \   0000002A   8847               BLX      R1
    310            
    311            return USBD_OK;
   \   0000002C   0020               MOVS     R0,#+0
   \   0000002E   10BD               POP      {R4,PC}          ;; return
    312          }
    313          
    314          /**
    315          * @brief  USBD_Resume 
    316          *         Handle Resume event
    317          * @param  pdev: device instance
    318          * @retval status
    319          */
    320          

   \                                 In section .text, align 2, keep-with-next
    321          static uint8_t USBD_Resume(USB_OTG_CORE_HANDLE  *pdev)
    322          {
   \                     USBD_Resume:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    323            /* Upon Resume call usr call back */
    324            pdev->dev.usr_cb->DeviceResumed(); 
   \   00000004   D4F8E405           LDR      R0,[R4, #+1508]
   \   00000008   0069               LDR      R0,[R0, #+16]
   \   0000000A   8047               BLX      R0
    325            pdev->dev.device_status = USB_OTG_ADDRESSED;  
   \   0000000C   0220               MOVS     R0,#+2
   \   0000000E   84F81201           STRB     R0,[R4, #+274]
    326            return USBD_OK;
   \   00000012   0020               MOVS     R0,#+0
   \   00000014   10BD               POP      {R4,PC}          ;; return
    327          }
    328          
    329          
    330          /**
    331          * @brief  USBD_Suspend 
    332          *         Handle Suspend event
    333          * @param  pdev: device instance
    334          * @retval status
    335          */
    336          

   \                                 In section .text, align 2, keep-with-next
    337          static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev)
    338          {
   \                     USBD_Suspend:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    339            /* Upon Resume call usr call back */
    340            pdev->dev.usr_cb->DeviceSuspended(); 
   \   00000004   D4F8E405           LDR      R0,[R4, #+1508]
   \   00000008   C068               LDR      R0,[R0, #+12]
   \   0000000A   8047               BLX      R0
    341            pdev->dev.class_cb->DeInit(pdev, 0);
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   2000               MOVS     R0,R4
   \   00000010   D4F8E025           LDR      R2,[R4, #+1504]
   \   00000014   5268               LDR      R2,[R2, #+4]
   \   00000016   9047               BLX      R2
    342            return USBD_OK;
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   10BD               POP      {R4,PC}          ;; return
    343          }
    344          
    345          
    346          /**
    347          * @brief  USBD_SOF 
    348          *         Handle SOF event
    349          * @param  pdev: device instance
    350          * @retval status
    351          */
    352          

   \                                 In section .text, align 2, keep-with-next
    353          static uint8_t USBD_SOF(USB_OTG_CORE_HANDLE  *pdev)
    354          {
   \                     USBD_SOF:
   \   00000000   80B5               PUSH     {R7,LR}
    355            if(pdev->dev.class_cb->SOF)
   \   00000002   D0F8E015           LDR      R1,[R0, #+1504]
   \   00000006   C969               LDR      R1,[R1, #+28]
   \   00000008   0029               CMP      R1,#+0
   \   0000000A   03D0               BEQ.N    ??USBD_SOF_0
    356            {
    357              pdev->dev.class_cb->SOF(pdev); 
   \   0000000C   D0F8E015           LDR      R1,[R0, #+1504]
   \   00000010   C969               LDR      R1,[R1, #+28]
   \   00000012   8847               BLX      R1
    358            }
    359            return USBD_OK;
   \                     ??USBD_SOF_0:
   \   00000014   0020               MOVS     R0,#+0
   \   00000016   02BD               POP      {R1,PC}          ;; return
    360          }
    361          /**
    362          * @brief  USBD_SetCfg 
    363          *        Configure device and start the interface
    364          * @param  pdev: device instance
    365          * @param  cfgidx: configuration index
    366          * @retval status
    367          */
    368          

   \                                 In section .text, align 2, keep-with-next
    369          USBD_Status USBD_SetCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
    370          {
   \                     USBD_SetCfg:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    371            pdev->dev.class_cb->Init(pdev, cfgidx); 
   \   00000004   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   2000               MOVS     R0,R4
   \   00000008   D4F8E025           LDR      R2,[R4, #+1504]
   \   0000000C   1268               LDR      R2,[R2, #+0]
   \   0000000E   9047               BLX      R2
    372            
    373            /* Upon set config call usr call back */
    374            pdev->dev.usr_cb->DeviceConfigured();
   \   00000010   D4F8E405           LDR      R0,[R4, #+1508]
   \   00000014   8068               LDR      R0,[R0, #+8]
   \   00000016   8047               BLX      R0
    375            return USBD_OK; 
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   10BD               POP      {R4,PC}          ;; return
    376          }
    377          
    378          /**
    379          * @brief  USBD_ClrCfg 
    380          *         Clear current configuration
    381          * @param  pdev: device instance
    382          * @param  cfgidx: configuration index
    383          * @retval status: USBD_Status
    384          */

   \                                 In section .text, align 2, keep-with-next
    385          USBD_Status USBD_ClrCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
    386          {
   \                     USBD_ClrCfg:
   \   00000000   80B5               PUSH     {R7,LR}
    387            pdev->dev.class_cb->DeInit(pdev, cfgidx);   
   \   00000002   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   D0F8E025           LDR      R2,[R0, #+1504]
   \   00000008   5268               LDR      R2,[R2, #+4]
   \   0000000A   9047               BLX      R2
    388            return USBD_OK;
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   02BD               POP      {R1,PC}          ;; return
    389          }
    390          
    391          /**
    392            * @}
    393            */ 
    394          
    395          
    396          /**
    397            * @}
    398            */ 
    399          
    400          
    401          /**
    402            * @}
    403            */ 
    404          
    405          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/
    406          

   Maximum stack usage in bytes:

     Function          .cstack
     --------          -------
     USBD_ClrCfg            8
     USBD_DataInStage      16
     USBD_DataOutStage      8
     USBD_DeInit            0
     USBD_Init             24
     USBD_Reset             8
     USBD_Resume            8
     USBD_SOF               8
     USBD_SetCfg            8
     USBD_SetupStage       16
     USBD_Suspend           8


   Section sizes:

     Function/Label    Bytes
     --------------    -----
     USBD_DCD_INT_cb     28
     USBD_DCD_INT_fops    4
     USBD_Init           48
     USBD_DeInit          4
     USBD_SetupStage     82
     USBD_DataOutStage  144
     USBD_DataInStage   184
     USBD_Reset          48
     USBD_Resume         22
     USBD_Suspend        28
     USBD_SOF            24
     USBD_SetCfg         28
     USBD_ClrCfg         16

 
  32 bytes in section .data
 628 bytes in section .text
 
 628 bytes of CODE memory
  32 bytes of DATA memory

Errors: none
Warnings: none
