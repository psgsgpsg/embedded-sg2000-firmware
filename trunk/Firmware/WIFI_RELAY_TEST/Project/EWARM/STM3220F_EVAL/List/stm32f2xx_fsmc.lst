###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     12/Nov/2011  19:31:24 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Libraries\STM32 #
#                    F2xx_StdPeriph_Driver\src\stm32f2xx_fsmc.c               #
#    Command line =  "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Libraries\STM3 #
#                    2F2xx_StdPeriph_Driver\src\stm32f2xx_fsmc.c" -D          #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D RTC_CLOCK_SOURCE_LSE -lC            #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    STM3220F_EVAL\List\" -lA "F:\¹¬ÀÛ¾÷\[ NewDTG             #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\STM3220F_EVAL\List\" #
#                     -o "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EW #
#                    ARM\STM3220F_EVAL\Obj\" --no_cse --no_unroll             #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                              #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\" -I              #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\CMSIS\CM3\CoreSupport\" -I "F:\¹¬ÀÛ¾÷\[  #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Librari #
#                    es\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\" -I             #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I      #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Utilities\STM32_EVAL\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG      #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\Common\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\STM3220F_EVAL\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_OTG_Driver\inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Core\inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Class\msc\inc\" -I "F:\¹¬ÀÛ¾÷\[     #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\" -I   #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\Usb\Inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                      #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\src\" -I      #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Core\inc\" -I     #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\"   #
#                    -Ol --use_c++_inline                                     #
#    List file    =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\List\stm32f2xx_fsmc.lst                     #
#    Object file  =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\Obj\stm32f2xx_fsmc.o                        #
#                                                                             #
#                                                                             #
###############################################################################

F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_fsmc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_fsmc.c
      4            * @author  MCD Application Team
      5            * @version V0.0.4
      6            * @date    13-January-2011
      7            * @brief   This file provides all the FSMC firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f2xx_fsmc.h"
     24          #include "stm32f2xx_rcc.h"
     25          
     26          /** @addtogroup STM32F2xx_StdPeriph_Driver
     27            * @{
     28            */
     29          
     30          /** @defgroup FSMC 
     31            * @brief FSMC driver modules
     32            * @{
     33            */ 
     34          
     35          /** @defgroup FSMC_Private_TypesDefinitions
     36            * @{
     37            */ 
     38          /**
     39            * @}
     40            */
     41          
     42          /** @defgroup FSMC_Private_Defines
     43            * @{
     44            */
     45          
     46          /* --------------------- FSMC registers bit mask ---------------------------- */
     47          
     48          /* FSMC BCRx Mask */
     49          #define BCR_MBKEN_Set                       ((uint32_t)0x00000001)
     50          #define BCR_MBKEN_Reset                     ((uint32_t)0x000FFFFE)
     51          #define BCR_FACCEN_Set                      ((uint32_t)0x00000040)
     52          
     53          /* FSMC PCRx Mask */
     54          #define PCR_PBKEN_Set                       ((uint32_t)0x00000004)
     55          #define PCR_PBKEN_Reset                     ((uint32_t)0x000FFFFB)
     56          #define PCR_ECCEN_Set                       ((uint32_t)0x00000040)
     57          #define PCR_ECCEN_Reset                     ((uint32_t)0x000FFFBF)
     58          #define PCR_MemoryType_NAND                 ((uint32_t)0x00000008)
     59          /**
     60            * @}
     61            */
     62          
     63          /** @defgroup FSMC_Private_Macros
     64            * @{
     65            */
     66          
     67          /**
     68            * @}
     69            */
     70          
     71          /** @defgroup FSMC_Private_Variables
     72            * @{
     73            */
     74          
     75          /**
     76            * @}
     77            */
     78          
     79          /** @defgroup FSMC_Private_FunctionPrototypes
     80            * @{
     81            */
     82          
     83          /**
     84            * @}
     85            */
     86          
     87          /** @defgroup FSMC_Private_Functions
     88            * @{
     89            */
     90          
     91          /**
     92            * @brief  Deinitializes the FSMC NOR/SRAM Banks registers to their default 
     93            *   reset values.
     94            * @param  FSMC_Bank: specifies the FSMC Bank to be used
     95            *   This parameter can be one of the following values:
     96            *     @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
     97            *     @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
     98            *     @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
     99            *     @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
    100            * @retval None
    101            */

   \                                 In section .text, align 2, keep-with-next
    102          void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
    103          {
    104            /* Check the parameter */
    105            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
    106            
    107            /* FSMC_Bank1_NORSRAM1 */
    108            if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
   \                     FSMC_NORSRAMDeInit:
   \   00000000   0028               CMP      R0,#+0
   \   00000002   06D1               BNE.N    ??FSMC_NORSRAMDeInit_0
    109            {
    110              FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
   \   00000004   8100               LSLS     R1,R0,#+2
   \   00000006   B1F1C041           SUBS     R1,R1,#+1610612736
   \   0000000A   43F2DB02           MOVW     R2,#+12507
   \   0000000E   0A60               STR      R2,[R1, #+0]
   \   00000010   05E0               B.N      ??FSMC_NORSRAMDeInit_1
    111            }
    112            /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
    113            else
    114            {   
    115              FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
   \                     ??FSMC_NORSRAMDeInit_0:
   \   00000012   8100               LSLS     R1,R0,#+2
   \   00000014   B1F1C041           SUBS     R1,R1,#+1610612736
   \   00000018   43F2D202           MOVW     R2,#+12498
   \   0000001C   0A60               STR      R2,[R1, #+0]
    116            }
    117            FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
   \                     ??FSMC_NORSRAMDeInit_1:
   \   0000001E   8100               LSLS     R1,R0,#+2
   \   00000020   B1F1C041           SUBS     R1,R1,#+1610612736
   \   00000024   7FF07042           MVNS     R2,#-268435456
   \   00000028   4A60               STR      R2,[R1, #+4]
    118            FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
   \   0000002A   ........           LDR.W    R1,??DataTable15  ;; 0xa0000104
   \   0000002E   7FF07042           MVNS     R2,#-268435456
   \   00000032   41F82020           STR      R2,[R1, R0, LSL #+2]
    119          }
   \   00000036   7047               BX       LR               ;; return
    120          
    121          /**
    122            * @brief  Deinitializes the FSMC NAND Banks registers to their default reset values.
    123            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    124            *   This parameter can be one of the following values:
    125            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    126            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND 
    127            * @retval None
    128            */

   \                                 In section .text, align 2, keep-with-next
    129          void FSMC_NANDDeInit(uint32_t FSMC_Bank)
    130          {
    131            /* Check the parameter */
    132            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
    133            
    134            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     FSMC_NANDDeInit:
   \   00000000   1028               CMP      R0,#+16
   \   00000002   12D1               BNE.N    ??FSMC_NANDDeInit_0
    135            {
    136              /* Set the FSMC_Bank2 registers to their reset values */
    137              FSMC_Bank2->PCR2 = 0x00000018;
   \   00000004   ........           LDR.W    R0,??DataTable15_1  ;; 0xa0000060
   \   00000008   1821               MOVS     R1,#+24
   \   0000000A   0160               STR      R1,[R0, #+0]
    138              FSMC_Bank2->SR2 = 0x00000040;
   \   0000000C   ........           LDR.W    R0,??DataTable15_2  ;; 0xa0000064
   \   00000010   4021               MOVS     R1,#+64
   \   00000012   0160               STR      R1,[R0, #+0]
    139              FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
   \   00000014   ........           LDR.W    R0,??DataTable15_3  ;; 0xa0000068
   \   00000018   5FF0FC31           MOVS     R1,#-50529028
   \   0000001C   0160               STR      R1,[R0, #+0]
    140              FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
   \   0000001E   ........           LDR.W    R0,??DataTable15_4  ;; 0xa000006c
   \   00000022   5FF0FC31           MOVS     R1,#-50529028
   \   00000026   0160               STR      R1,[R0, #+0]
   \   00000028   11E0               B.N      ??FSMC_NANDDeInit_1
    141            }
    142            /* FSMC_Bank3_NAND */  
    143            else
    144            {
    145              /* Set the FSMC_Bank3 registers to their reset values */
    146              FSMC_Bank3->PCR3 = 0x00000018;
   \                     ??FSMC_NANDDeInit_0:
   \   0000002A   ........           LDR.W    R0,??DataTable15_5  ;; 0xa0000080
   \   0000002E   1821               MOVS     R1,#+24
   \   00000030   0160               STR      R1,[R0, #+0]
    147              FSMC_Bank3->SR3 = 0x00000040;
   \   00000032   ........           LDR.W    R0,??DataTable15_6  ;; 0xa0000084
   \   00000036   4021               MOVS     R1,#+64
   \   00000038   0160               STR      R1,[R0, #+0]
    148              FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
   \   0000003A   ........           LDR.W    R0,??DataTable15_7  ;; 0xa0000088
   \   0000003E   5FF0FC31           MOVS     R1,#-50529028
   \   00000042   0160               STR      R1,[R0, #+0]
    149              FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
   \   00000044   ........           LDR.W    R0,??DataTable15_8  ;; 0xa000008c
   \   00000048   5FF0FC31           MOVS     R1,#-50529028
   \   0000004C   0160               STR      R1,[R0, #+0]
    150            }  
    151          }
   \                     ??FSMC_NANDDeInit_1:
   \   0000004E   7047               BX       LR               ;; return
    152          
    153          /**
    154            * @brief  Deinitializes the FSMC PCCARD Bank registers to their default reset values.
    155            * @param  None                       
    156            * @retval None
    157            */

   \                                 In section .text, align 2, keep-with-next
    158          void FSMC_PCCARDDeInit(void)
    159          {
    160            /* Set the FSMC_Bank4 registers to their reset values */
    161            FSMC_Bank4->PCR4 = 0x00000018; 
   \                     FSMC_PCCARDDeInit:
   \   00000000   ........           LDR.W    R0,??DataTable15_9  ;; 0xa00000a0
   \   00000004   1821               MOVS     R1,#+24
   \   00000006   0160               STR      R1,[R0, #+0]
    162            FSMC_Bank4->SR4 = 0x00000000;	
   \   00000008   ........           LDR.W    R0,??DataTable15_10  ;; 0xa00000a4
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   0160               STR      R1,[R0, #+0]
    163            FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
   \   00000010   ........           LDR.W    R0,??DataTable15_11  ;; 0xa00000a8
   \   00000014   5FF0FC31           MOVS     R1,#-50529028
   \   00000018   0160               STR      R1,[R0, #+0]
    164            FSMC_Bank4->PATT4 = 0xFCFCFCFC;
   \   0000001A   ........           LDR.W    R0,??DataTable15_12  ;; 0xa00000ac
   \   0000001E   5FF0FC31           MOVS     R1,#-50529028
   \   00000022   0160               STR      R1,[R0, #+0]
    165            FSMC_Bank4->PIO4 = 0xFCFCFCFC;
   \   00000024   ........           LDR.W    R0,??DataTable15_13  ;; 0xa00000b0
   \   00000028   5FF0FC31           MOVS     R1,#-50529028
   \   0000002C   0160               STR      R1,[R0, #+0]
    166          }
   \   0000002E   7047               BX       LR               ;; return
    167          
    168          /**
    169            * @brief  Initializes the FSMC NOR/SRAM Banks according to the specified
    170            *   parameters in the FSMC_NORSRAMInitStruct.
    171            * @param  FSMC_NORSRAMInitStruct : pointer to a FSMC_NORSRAMInitTypeDef
    172            *   structure that contains the configuration information for 
    173            *   the FSMC NOR/SRAM specified Banks.                       
    174            * @retval None
    175            */

   \                                 In section .text, align 2, keep-with-next
    176          void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
    177          { 
    178            /* Check the parameters */
    179            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
    180            assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
    181            assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
    182            assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
    183            assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
    184            assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
    185            assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
    186            assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
    187            assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
    188            assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
    189            assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
    190            assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
    191            assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
    192            assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
    193            assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
    194            assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
    195            assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
    196            assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
    197            assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
    198            assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
    199            
    200            /* Bank1 NOR/SRAM control register configuration */ 
    201            FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
    202                      (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
    203                      FSMC_NORSRAMInitStruct->FSMC_MemoryType |
    204                      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
    205                      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
    206                      FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
    207                      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
    208                      FSMC_NORSRAMInitStruct->FSMC_WrapMode |
    209                      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
    210                      FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
    211                      FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
    212                      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
    213                      FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
   \                     FSMC_NORSRAMInit:
   \   00000000   4168               LDR      R1,[R0, #+4]
   \   00000002   8268               LDR      R2,[R0, #+8]
   \   00000004   1143               ORRS     R1,R2,R1
   \   00000006   C268               LDR      R2,[R0, #+12]
   \   00000008   1143               ORRS     R1,R2,R1
   \   0000000A   0269               LDR      R2,[R0, #+16]
   \   0000000C   1143               ORRS     R1,R2,R1
   \   0000000E   4269               LDR      R2,[R0, #+20]
   \   00000010   1143               ORRS     R1,R2,R1
   \   00000012   8269               LDR      R2,[R0, #+24]
   \   00000014   1143               ORRS     R1,R2,R1
   \   00000016   C269               LDR      R2,[R0, #+28]
   \   00000018   1143               ORRS     R1,R2,R1
   \   0000001A   026A               LDR      R2,[R0, #+32]
   \   0000001C   1143               ORRS     R1,R2,R1
   \   0000001E   426A               LDR      R2,[R0, #+36]
   \   00000020   1143               ORRS     R1,R2,R1
   \   00000022   826A               LDR      R2,[R0, #+40]
   \   00000024   1143               ORRS     R1,R2,R1
   \   00000026   C26A               LDR      R2,[R0, #+44]
   \   00000028   1143               ORRS     R1,R2,R1
   \   0000002A   026B               LDR      R2,[R0, #+48]
   \   0000002C   1143               ORRS     R1,R2,R1
   \   0000002E   0268               LDR      R2,[R0, #+0]
   \   00000030   9200               LSLS     R2,R2,#+2
   \   00000032   B2F1C042           SUBS     R2,R2,#+1610612736
   \   00000036   1160               STR      R1,[R2, #+0]
    214            if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
   \   00000038   8168               LDR      R1,[R0, #+8]
   \   0000003A   0829               CMP      R1,#+8
   \   0000003C   0BD1               BNE.N    ??FSMC_NORSRAMInit_0
    215            {
    216              FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_Set;
   \   0000003E   0168               LDR      R1,[R0, #+0]
   \   00000040   8900               LSLS     R1,R1,#+2
   \   00000042   B1F1C041           SUBS     R1,R1,#+1610612736
   \   00000046   0968               LDR      R1,[R1, #+0]
   \   00000048   51F04001           ORRS     R1,R1,#0x40
   \   0000004C   0268               LDR      R2,[R0, #+0]
   \   0000004E   9200               LSLS     R2,R2,#+2
   \   00000050   B2F1C042           SUBS     R2,R2,#+1610612736
   \   00000054   1160               STR      R1,[R2, #+0]
    217            }
    218            /* Bank1 NOR/SRAM timing register configuration */
    219            FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
    220                      (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
    221                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
    222                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
    223                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
    224                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
    225                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
    226                       FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
   \                     ??FSMC_NORSRAMInit_0:
   \   00000056   416B               LDR      R1,[R0, #+52]
   \   00000058   0968               LDR      R1,[R1, #+0]
   \   0000005A   426B               LDR      R2,[R0, #+52]
   \   0000005C   5268               LDR      R2,[R2, #+4]
   \   0000005E   51EA0211           ORRS     R1,R1,R2, LSL #+4
   \   00000062   426B               LDR      R2,[R0, #+52]
   \   00000064   9268               LDR      R2,[R2, #+8]
   \   00000066   51EA0221           ORRS     R1,R1,R2, LSL #+8
   \   0000006A   426B               LDR      R2,[R0, #+52]
   \   0000006C   D268               LDR      R2,[R2, #+12]
   \   0000006E   51EA0241           ORRS     R1,R1,R2, LSL #+16
   \   00000072   426B               LDR      R2,[R0, #+52]
   \   00000074   1269               LDR      R2,[R2, #+16]
   \   00000076   51EA0251           ORRS     R1,R1,R2, LSL #+20
   \   0000007A   426B               LDR      R2,[R0, #+52]
   \   0000007C   5269               LDR      R2,[R2, #+20]
   \   0000007E   51EA0261           ORRS     R1,R1,R2, LSL #+24
   \   00000082   426B               LDR      R2,[R0, #+52]
   \   00000084   9269               LDR      R2,[R2, #+24]
   \   00000086   1143               ORRS     R1,R2,R1
   \   00000088   0268               LDR      R2,[R0, #+0]
   \   0000008A   9200               LSLS     R2,R2,#+2
   \   0000008C   B2F1C042           SUBS     R2,R2,#+1610612736
   \   00000090   5160               STR      R1,[R2, #+4]
    227                      
    228              
    229            /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
    230            if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
   \   00000092   C16A               LDR      R1,[R0, #+44]
   \   00000094   B1F5804F           CMP      R1,#+16384
   \   00000098   1AD1               BNE.N    ??FSMC_NORSRAMInit_1
    231            {
    232              assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
    233              assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
    234              assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
    235              assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
    236              assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
    237              assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
    238              FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
    239                        (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
    240                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
    241                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
    242                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
    243                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
    244                         FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
   \   0000009A   816B               LDR      R1,[R0, #+56]
   \   0000009C   0968               LDR      R1,[R1, #+0]
   \   0000009E   826B               LDR      R2,[R0, #+56]
   \   000000A0   5268               LDR      R2,[R2, #+4]
   \   000000A2   51EA0211           ORRS     R1,R1,R2, LSL #+4
   \   000000A6   826B               LDR      R2,[R0, #+56]
   \   000000A8   9268               LDR      R2,[R2, #+8]
   \   000000AA   51EA0221           ORRS     R1,R1,R2, LSL #+8
   \   000000AE   826B               LDR      R2,[R0, #+56]
   \   000000B0   1269               LDR      R2,[R2, #+16]
   \   000000B2   51EA0251           ORRS     R1,R1,R2, LSL #+20
   \   000000B6   826B               LDR      R2,[R0, #+56]
   \   000000B8   5269               LDR      R2,[R2, #+20]
   \   000000BA   51EA0261           ORRS     R1,R1,R2, LSL #+24
   \   000000BE   826B               LDR      R2,[R0, #+56]
   \   000000C0   9269               LDR      R2,[R2, #+24]
   \   000000C2   1143               ORRS     R1,R2,R1
   \   000000C4   0068               LDR      R0,[R0, #+0]
   \   000000C6   ........           LDR.W    R2,??DataTable15  ;; 0xa0000104
   \   000000CA   42F82010           STR      R1,[R2, R0, LSL #+2]
   \   000000CE   06E0               B.N      ??FSMC_NORSRAMInit_2
    245            }
    246            else
    247            {
    248              FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
   \                     ??FSMC_NORSRAMInit_1:
   \   000000D0   0068               LDR      R0,[R0, #+0]
   \   000000D2   ........           LDR.W    R1,??DataTable15  ;; 0xa0000104
   \   000000D6   7FF07042           MVNS     R2,#-268435456
   \   000000DA   41F82020           STR      R2,[R1, R0, LSL #+2]
    249            }
    250          }
   \                     ??FSMC_NORSRAMInit_2:
   \   000000DE   7047               BX       LR               ;; return
    251          
    252          /**
    253            * @brief  Initializes the FSMC NAND Banks according to the specified 
    254            *   parameters in the FSMC_NANDInitStruct.
    255            * @param  FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef 
    256            *   structure that contains the configuration information for the FSMC NAND specified Banks.                       
    257            * @retval None
    258            */

   \                                 In section .text, align 2, keep-with-next
    259          void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
    260          {
   \                     FSMC_NANDInit:
   \   00000000   30B4               PUSH     {R4,R5}
    261            uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
   \   00000002   0021               MOVS     R1,#+0
   \   00000004   0022               MOVS     R2,#+0
   \   00000006   0023               MOVS     R3,#+0
    262              
    263            /* Check the parameters */
    264            assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
    265            assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
    266            assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
    267            assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
    268            assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
    269            assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
    270            assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
    271            assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
    272            assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
    273            assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
    274            assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
    275            assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
    276            assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
    277            assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
    278            assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
    279            
    280            /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
    281            tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
    282                      PCR_MemoryType_NAND |
    283                      FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
    284                      FSMC_NANDInitStruct->FSMC_ECC |
    285                      FSMC_NANDInitStruct->FSMC_ECCPageSize |
    286                      (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
    287                      (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
   \   00000008   4468               LDR      R4,[R0, #+4]
   \   0000000A   8568               LDR      R5,[R0, #+8]
   \   0000000C   2C43               ORRS     R4,R5,R4
   \   0000000E   C568               LDR      R5,[R0, #+12]
   \   00000010   2C43               ORRS     R4,R5,R4
   \   00000012   0569               LDR      R5,[R0, #+16]
   \   00000014   2C43               ORRS     R4,R5,R4
   \   00000016   4569               LDR      R5,[R0, #+20]
   \   00000018   54EA4524           ORRS     R4,R4,R5, LSL #+9
   \   0000001C   8569               LDR      R5,[R0, #+24]
   \   0000001E   54EA4534           ORRS     R4,R4,R5, LSL #+13
   \   00000022   54F00804           ORRS     R4,R4,#0x8
   \   00000026   2100               MOVS     R1,R4
    288                      
    289            /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
    290            tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
    291                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    292                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    293                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
   \   00000028   C469               LDR      R4,[R0, #+28]
   \   0000002A   2468               LDR      R4,[R4, #+0]
   \   0000002C   C569               LDR      R5,[R0, #+28]
   \   0000002E   6D68               LDR      R5,[R5, #+4]
   \   00000030   54EA0524           ORRS     R4,R4,R5, LSL #+8
   \   00000034   C569               LDR      R5,[R0, #+28]
   \   00000036   AD68               LDR      R5,[R5, #+8]
   \   00000038   54EA0544           ORRS     R4,R4,R5, LSL #+16
   \   0000003C   C569               LDR      R5,[R0, #+28]
   \   0000003E   ED68               LDR      R5,[R5, #+12]
   \   00000040   54EA0564           ORRS     R4,R4,R5, LSL #+24
   \   00000044   2200               MOVS     R2,R4
    294                      
    295            /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
    296            tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
    297                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    298                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    299                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
   \   00000046   046A               LDR      R4,[R0, #+32]
   \   00000048   2468               LDR      R4,[R4, #+0]
   \   0000004A   056A               LDR      R5,[R0, #+32]
   \   0000004C   6D68               LDR      R5,[R5, #+4]
   \   0000004E   54EA0524           ORRS     R4,R4,R5, LSL #+8
   \   00000052   056A               LDR      R5,[R0, #+32]
   \   00000054   AD68               LDR      R5,[R5, #+8]
   \   00000056   54EA0544           ORRS     R4,R4,R5, LSL #+16
   \   0000005A   056A               LDR      R5,[R0, #+32]
   \   0000005C   ED68               LDR      R5,[R5, #+12]
   \   0000005E   54EA0564           ORRS     R4,R4,R5, LSL #+24
   \   00000062   2300               MOVS     R3,R4
    300            
    301            if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
   \   00000064   0068               LDR      R0,[R0, #+0]
   \   00000066   1028               CMP      R0,#+16
   \   00000068   09D1               BNE.N    ??FSMC_NANDInit_0
    302            {
    303              /* FSMC_Bank2_NAND registers configuration */
    304              FSMC_Bank2->PCR2 = tmppcr;
   \   0000006A   ........           LDR.W    R0,??DataTable15_1  ;; 0xa0000060
   \   0000006E   0160               STR      R1,[R0, #+0]
    305              FSMC_Bank2->PMEM2 = tmppmem;
   \   00000070   ........           LDR.W    R0,??DataTable15_3  ;; 0xa0000068
   \   00000074   0260               STR      R2,[R0, #+0]
    306              FSMC_Bank2->PATT2 = tmppatt;
   \   00000076   ........           LDR.W    R0,??DataTable15_4  ;; 0xa000006c
   \   0000007A   0360               STR      R3,[R0, #+0]
   \   0000007C   08E0               B.N      ??FSMC_NANDInit_1
    307            }
    308            else
    309            {
    310              /* FSMC_Bank3_NAND registers configuration */
    311              FSMC_Bank3->PCR3 = tmppcr;
   \                     ??FSMC_NANDInit_0:
   \   0000007E   ........           LDR.W    R0,??DataTable15_5  ;; 0xa0000080
   \   00000082   0160               STR      R1,[R0, #+0]
    312              FSMC_Bank3->PMEM3 = tmppmem;
   \   00000084   ........           LDR.W    R0,??DataTable15_7  ;; 0xa0000088
   \   00000088   0260               STR      R2,[R0, #+0]
    313              FSMC_Bank3->PATT3 = tmppatt;
   \   0000008A   ........           LDR.W    R0,??DataTable15_8  ;; 0xa000008c
   \   0000008E   0360               STR      R3,[R0, #+0]
    314            }
    315          }
   \                     ??FSMC_NANDInit_1:
   \   00000090   30BC               POP      {R4,R5}
   \   00000092   7047               BX       LR               ;; return
    316          
    317          /**
    318            * @brief  Initializes the FSMC PCCARD Bank according to the specified 
    319            *   parameters in the FSMC_PCCARDInitStruct.
    320            * @param  FSMC_PCCARDInitStruct : pointer to a FSMC_PCCARDInitTypeDef
    321            *   structure that contains the configuration information for the FSMC PCCARD Bank.                       
    322            * @retval None
    323            */

   \                                 In section .text, align 2, keep-with-next
    324          void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
    325          {
    326            /* Check the parameters */
    327            assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
    328            assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
    329            assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
    330           
    331            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
    332            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
    333            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
    334            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
    335            
    336            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
    337            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
    338            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
    339            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
    340            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
    341            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
    342            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
    343            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
    344            
    345            /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
    346            FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
    347                               FSMC_MemoryDataWidth_16b |  
    348                               (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
    349                               (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
   \                     FSMC_PCCARDInit:
   \   00000000   0168               LDR      R1,[R0, #+0]
   \   00000002   4268               LDR      R2,[R0, #+4]
   \   00000004   51EA4221           ORRS     R1,R1,R2, LSL #+9
   \   00000008   8268               LDR      R2,[R0, #+8]
   \   0000000A   51EA4231           ORRS     R1,R1,R2, LSL #+13
   \   0000000E   51F01001           ORRS     R1,R1,#0x10
   \   00000012   ........           LDR.W    R2,??DataTable15_9  ;; 0xa00000a0
   \   00000016   1160               STR      R1,[R2, #+0]
    350                      
    351            /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
    352            FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
    353                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    354                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    355                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
   \   00000018   C168               LDR      R1,[R0, #+12]
   \   0000001A   0968               LDR      R1,[R1, #+0]
   \   0000001C   C268               LDR      R2,[R0, #+12]
   \   0000001E   5268               LDR      R2,[R2, #+4]
   \   00000020   51EA0221           ORRS     R1,R1,R2, LSL #+8
   \   00000024   C268               LDR      R2,[R0, #+12]
   \   00000026   9268               LDR      R2,[R2, #+8]
   \   00000028   51EA0241           ORRS     R1,R1,R2, LSL #+16
   \   0000002C   C268               LDR      R2,[R0, #+12]
   \   0000002E   D268               LDR      R2,[R2, #+12]
   \   00000030   51EA0261           ORRS     R1,R1,R2, LSL #+24
   \   00000034   ........           LDR.W    R2,??DataTable15_11  ;; 0xa00000a8
   \   00000038   1160               STR      R1,[R2, #+0]
    356                      
    357            /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
    358            FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
    359                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    360                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    361                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
   \   0000003A   0169               LDR      R1,[R0, #+16]
   \   0000003C   0968               LDR      R1,[R1, #+0]
   \   0000003E   0269               LDR      R2,[R0, #+16]
   \   00000040   5268               LDR      R2,[R2, #+4]
   \   00000042   51EA0221           ORRS     R1,R1,R2, LSL #+8
   \   00000046   0269               LDR      R2,[R0, #+16]
   \   00000048   9268               LDR      R2,[R2, #+8]
   \   0000004A   51EA0241           ORRS     R1,R1,R2, LSL #+16
   \   0000004E   0269               LDR      R2,[R0, #+16]
   \   00000050   D268               LDR      R2,[R2, #+12]
   \   00000052   51EA0261           ORRS     R1,R1,R2, LSL #+24
   \   00000056   ........           LDR.W    R2,??DataTable15_12  ;; 0xa00000ac
   \   0000005A   1160               STR      R1,[R2, #+0]
    362                      
    363            /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
    364            FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
    365                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    366                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    367                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
   \   0000005C   4169               LDR      R1,[R0, #+20]
   \   0000005E   0968               LDR      R1,[R1, #+0]
   \   00000060   4269               LDR      R2,[R0, #+20]
   \   00000062   5268               LDR      R2,[R2, #+4]
   \   00000064   51EA0221           ORRS     R1,R1,R2, LSL #+8
   \   00000068   4269               LDR      R2,[R0, #+20]
   \   0000006A   9268               LDR      R2,[R2, #+8]
   \   0000006C   51EA0241           ORRS     R1,R1,R2, LSL #+16
   \   00000070   4069               LDR      R0,[R0, #+20]
   \   00000072   C068               LDR      R0,[R0, #+12]
   \   00000074   51EA0060           ORRS     R0,R1,R0, LSL #+24
   \   00000078   ........           LDR.W    R1,??DataTable15_13  ;; 0xa00000b0
   \   0000007C   0860               STR      R0,[R1, #+0]
    368          }
   \   0000007E   7047               BX       LR               ;; return
    369          
    370          /**
    371            * @brief  Fills each FSMC_NORSRAMInitStruct member with its default value.
    372            * @param  FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef 
    373            *   structure which will be initialized.
    374            * @retval None
    375            */

   \                                 In section .text, align 2, keep-with-next
    376          void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
    377          {  
    378            /* Reset NOR/SRAM Init structure parameters values */
    379            FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
   \                     FSMC_NORSRAMStructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0160               STR      R1,[R0, #+0]
    380            FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
   \   00000004   0221               MOVS     R1,#+2
   \   00000006   4160               STR      R1,[R0, #+4]
    381            FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   8160               STR      R1,[R0, #+8]
    382            FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   C160               STR      R1,[R0, #+12]
    383            FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   0161               STR      R1,[R0, #+16]
    384            FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   4161               STR      R1,[R0, #+20]
    385            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
   \   00000018   0021               MOVS     R1,#+0
   \   0000001A   8161               STR      R1,[R0, #+24]
    386            FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
   \   0000001C   0021               MOVS     R1,#+0
   \   0000001E   C161               STR      R1,[R0, #+28]
    387            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
   \   00000020   0021               MOVS     R1,#+0
   \   00000022   0162               STR      R1,[R0, #+32]
    388            FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
   \   00000024   4FF48051           MOV      R1,#+4096
   \   00000028   4162               STR      R1,[R0, #+36]
    389            FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
   \   0000002A   4FF40051           MOV      R1,#+8192
   \   0000002E   8162               STR      R1,[R0, #+40]
    390            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
   \   00000030   0021               MOVS     R1,#+0
   \   00000032   C162               STR      R1,[R0, #+44]
    391            FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
   \   00000034   0021               MOVS     R1,#+0
   \   00000036   0163               STR      R1,[R0, #+48]
    392            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
   \   00000038   416B               LDR      R1,[R0, #+52]
   \   0000003A   0F22               MOVS     R2,#+15
   \   0000003C   0A60               STR      R2,[R1, #+0]
    393            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
   \   0000003E   416B               LDR      R1,[R0, #+52]
   \   00000040   0F22               MOVS     R2,#+15
   \   00000042   4A60               STR      R2,[R1, #+4]
    394            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
   \   00000044   416B               LDR      R1,[R0, #+52]
   \   00000046   FF22               MOVS     R2,#+255
   \   00000048   8A60               STR      R2,[R1, #+8]
    395            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
   \   0000004A   416B               LDR      R1,[R0, #+52]
   \   0000004C   0F22               MOVS     R2,#+15
   \   0000004E   CA60               STR      R2,[R1, #+12]
    396            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
   \   00000050   416B               LDR      R1,[R0, #+52]
   \   00000052   0F22               MOVS     R2,#+15
   \   00000054   0A61               STR      R2,[R1, #+16]
    397            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
   \   00000056   416B               LDR      R1,[R0, #+52]
   \   00000058   0F22               MOVS     R2,#+15
   \   0000005A   4A61               STR      R2,[R1, #+20]
    398            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
   \   0000005C   416B               LDR      R1,[R0, #+52]
   \   0000005E   0022               MOVS     R2,#+0
   \   00000060   8A61               STR      R2,[R1, #+24]
    399            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
   \   00000062   816B               LDR      R1,[R0, #+56]
   \   00000064   0F22               MOVS     R2,#+15
   \   00000066   0A60               STR      R2,[R1, #+0]
    400            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
   \   00000068   816B               LDR      R1,[R0, #+56]
   \   0000006A   0F22               MOVS     R2,#+15
   \   0000006C   4A60               STR      R2,[R1, #+4]
    401            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
   \   0000006E   816B               LDR      R1,[R0, #+56]
   \   00000070   FF22               MOVS     R2,#+255
   \   00000072   8A60               STR      R2,[R1, #+8]
    402            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
   \   00000074   816B               LDR      R1,[R0, #+56]
   \   00000076   0F22               MOVS     R2,#+15
   \   00000078   CA60               STR      R2,[R1, #+12]
    403            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
   \   0000007A   816B               LDR      R1,[R0, #+56]
   \   0000007C   0F22               MOVS     R2,#+15
   \   0000007E   0A61               STR      R2,[R1, #+16]
    404            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
   \   00000080   816B               LDR      R1,[R0, #+56]
   \   00000082   0F22               MOVS     R2,#+15
   \   00000084   4A61               STR      R2,[R1, #+20]
    405            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
   \   00000086   806B               LDR      R0,[R0, #+56]
   \   00000088   0021               MOVS     R1,#+0
   \   0000008A   8161               STR      R1,[R0, #+24]
    406          }
   \   0000008C   7047               BX       LR               ;; return
    407          
    408          /**
    409            * @brief  Fills each FSMC_NANDInitStruct member with its default value.
    410            * @param  FSMC_NANDInitStruct: pointer to a FSMC_NANDInitTypeDef 
    411            *   structure which will be initialized.
    412            * @retval None
    413            */

   \                                 In section .text, align 2, keep-with-next
    414          void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
    415          { 
    416            /* Reset NAND Init structure parameters values */
    417            FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
   \                     FSMC_NANDStructInit:
   \   00000000   1021               MOVS     R1,#+16
   \   00000002   0160               STR      R1,[R0, #+0]
    418            FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   4160               STR      R1,[R0, #+4]
    419            FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   8160               STR      R1,[R0, #+8]
    420            FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   C160               STR      R1,[R0, #+12]
    421            FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   0161               STR      R1,[R0, #+16]
    422            FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   4161               STR      R1,[R0, #+20]
    423            FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
   \   00000018   0021               MOVS     R1,#+0
   \   0000001A   8161               STR      R1,[R0, #+24]
    424            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   0000001C   C169               LDR      R1,[R0, #+28]
   \   0000001E   FC22               MOVS     R2,#+252
   \   00000020   0A60               STR      R2,[R1, #+0]
    425            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   00000022   C169               LDR      R1,[R0, #+28]
   \   00000024   FC22               MOVS     R2,#+252
   \   00000026   4A60               STR      R2,[R1, #+4]
    426            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   00000028   C169               LDR      R1,[R0, #+28]
   \   0000002A   FC22               MOVS     R2,#+252
   \   0000002C   8A60               STR      R2,[R1, #+8]
    427            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
   \   0000002E   C169               LDR      R1,[R0, #+28]
   \   00000030   FC22               MOVS     R2,#+252
   \   00000032   CA60               STR      R2,[R1, #+12]
    428            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   00000034   016A               LDR      R1,[R0, #+32]
   \   00000036   FC22               MOVS     R2,#+252
   \   00000038   0A60               STR      R2,[R1, #+0]
    429            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   0000003A   016A               LDR      R1,[R0, #+32]
   \   0000003C   FC22               MOVS     R2,#+252
   \   0000003E   4A60               STR      R2,[R1, #+4]
    430            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   00000040   016A               LDR      R1,[R0, #+32]
   \   00000042   FC22               MOVS     R2,#+252
   \   00000044   8A60               STR      R2,[R1, #+8]
    431            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
   \   00000046   006A               LDR      R0,[R0, #+32]
   \   00000048   FC21               MOVS     R1,#+252
   \   0000004A   C160               STR      R1,[R0, #+12]
    432          }
   \   0000004C   7047               BX       LR               ;; return
    433          
    434          /**
    435            * @brief  Fills each FSMC_PCCARDInitStruct member with its default value.
    436            * @param  FSMC_PCCARDInitStruct: pointer to a FSMC_PCCARDInitTypeDef 
    437            *   structure which will be initialized.
    438            * @retval None
    439            */

   \                                 In section .text, align 2, keep-with-next
    440          void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
    441          {
    442            /* Reset PCCARD Init structure parameters values */
    443            FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
   \                     FSMC_PCCARDStructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0160               STR      R1,[R0, #+0]
    444            FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   4160               STR      R1,[R0, #+4]
    445            FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   8160               STR      R1,[R0, #+8]
    446            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   0000000C   C168               LDR      R1,[R0, #+12]
   \   0000000E   FC22               MOVS     R2,#+252
   \   00000010   0A60               STR      R2,[R1, #+0]
    447            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   00000012   C168               LDR      R1,[R0, #+12]
   \   00000014   FC22               MOVS     R2,#+252
   \   00000016   4A60               STR      R2,[R1, #+4]
    448            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   00000018   C168               LDR      R1,[R0, #+12]
   \   0000001A   FC22               MOVS     R2,#+252
   \   0000001C   8A60               STR      R2,[R1, #+8]
    449            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
   \   0000001E   C168               LDR      R1,[R0, #+12]
   \   00000020   FC22               MOVS     R2,#+252
   \   00000022   CA60               STR      R2,[R1, #+12]
    450            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   00000024   0169               LDR      R1,[R0, #+16]
   \   00000026   FC22               MOVS     R2,#+252
   \   00000028   0A60               STR      R2,[R1, #+0]
    451            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   0000002A   0169               LDR      R1,[R0, #+16]
   \   0000002C   FC22               MOVS     R2,#+252
   \   0000002E   4A60               STR      R2,[R1, #+4]
    452            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   00000030   0169               LDR      R1,[R0, #+16]
   \   00000032   FC22               MOVS     R2,#+252
   \   00000034   8A60               STR      R2,[R1, #+8]
    453            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
   \   00000036   0169               LDR      R1,[R0, #+16]
   \   00000038   FC22               MOVS     R2,#+252
   \   0000003A   CA60               STR      R2,[R1, #+12]
    454            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \   0000003C   4169               LDR      R1,[R0, #+20]
   \   0000003E   FC22               MOVS     R2,#+252
   \   00000040   0A60               STR      R2,[R1, #+0]
    455            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \   00000042   4169               LDR      R1,[R0, #+20]
   \   00000044   FC22               MOVS     R2,#+252
   \   00000046   4A60               STR      R2,[R1, #+4]
    456            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \   00000048   4169               LDR      R1,[R0, #+20]
   \   0000004A   FC22               MOVS     R2,#+252
   \   0000004C   8A60               STR      R2,[R1, #+8]
    457            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
   \   0000004E   4069               LDR      R0,[R0, #+20]
   \   00000050   FC21               MOVS     R1,#+252
   \   00000052   C160               STR      R1,[R0, #+12]
    458          }
   \   00000054   7047               BX       LR               ;; return
    459          
    460          /**
    461            * @brief  Enables or disables the specified NOR/SRAM Memory Bank.
    462            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    463            *   This parameter can be one of the following values:
    464            *     @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
    465            *     @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
    466            *     @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
    467            *     @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
    468            * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
    469            * @retval None
    470            */

   \                                 In section .text, align 2, keep-with-next
    471          void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    472          {
    473            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
    474            assert_param(IS_FUNCTIONAL_STATE(NewState));
    475            
    476            if (NewState != DISABLE)
   \                     FSMC_NORSRAMCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   0AD0               BEQ.N    ??FSMC_NORSRAMCmd_0
    477            {
    478              /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
    479              FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
   \   00000006   8100               LSLS     R1,R0,#+2
   \   00000008   B1F1C041           SUBS     R1,R1,#+1610612736
   \   0000000C   0968               LDR      R1,[R1, #+0]
   \   0000000E   51F00101           ORRS     R1,R1,#0x1
   \   00000012   8000               LSLS     R0,R0,#+2
   \   00000014   B0F1C040           SUBS     R0,R0,#+1610612736
   \   00000018   0160               STR      R1,[R0, #+0]
   \   0000001A   09E0               B.N      ??FSMC_NORSRAMCmd_1
    480            }
    481            else
    482            {
    483              /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
    484              FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_Reset;
   \                     ??FSMC_NORSRAMCmd_0:
   \   0000001C   8100               LSLS     R1,R0,#+2
   \   0000001E   B1F1C041           SUBS     R1,R1,#+1610612736
   \   00000022   0968               LDR      R1,[R1, #+0]
   \   00000024   ....               LDR.N    R2,??DataTable15_14  ;; 0xffffe
   \   00000026   1140               ANDS     R1,R2,R1
   \   00000028   8000               LSLS     R0,R0,#+2
   \   0000002A   B0F1C040           SUBS     R0,R0,#+1610612736
   \   0000002E   0160               STR      R1,[R0, #+0]
    485            }
    486          }
   \                     ??FSMC_NORSRAMCmd_1:
   \   00000030   7047               BX       LR               ;; return
    487          
    488          /**
    489            * @brief  Enables or disables the specified NAND Memory Bank.
    490            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    491            *   This parameter can be one of the following values:
    492            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    493            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    494            * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
    495            * @retval None
    496            */

   \                                 In section .text, align 2, keep-with-next
    497          void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    498          {
    499            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
    500            assert_param(IS_FUNCTIONAL_STATE(NewState));
    501            
    502            if (NewState != DISABLE)
   \                     FSMC_NANDCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   0FD0               BEQ.N    ??FSMC_NANDCmd_0
    503            {
    504              /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
    505              if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000006   1028               CMP      R0,#+16
   \   00000008   06D1               BNE.N    ??FSMC_NANDCmd_1
    506              {
    507                FSMC_Bank2->PCR2 |= PCR_PBKEN_Set;
   \   0000000A   ....               LDR.N    R0,??DataTable15_1  ;; 0xa0000060
   \   0000000C   0068               LDR      R0,[R0, #+0]
   \   0000000E   50F00400           ORRS     R0,R0,#0x4
   \   00000012   ....               LDR.N    R1,??DataTable15_1  ;; 0xa0000060
   \   00000014   0860               STR      R0,[R1, #+0]
   \   00000016   15E0               B.N      ??FSMC_NANDCmd_2
    508              }
    509              else
    510              {
    511                FSMC_Bank3->PCR3 |= PCR_PBKEN_Set;
   \                     ??FSMC_NANDCmd_1:
   \   00000018   ....               LDR.N    R0,??DataTable15_5  ;; 0xa0000080
   \   0000001A   0068               LDR      R0,[R0, #+0]
   \   0000001C   50F00400           ORRS     R0,R0,#0x4
   \   00000020   ....               LDR.N    R1,??DataTable15_5  ;; 0xa0000080
   \   00000022   0860               STR      R0,[R1, #+0]
   \   00000024   0EE0               B.N      ??FSMC_NANDCmd_2
    512              }
    513            }
    514            else
    515            {
    516              /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
    517              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_NANDCmd_0:
   \   00000026   1028               CMP      R0,#+16
   \   00000028   06D1               BNE.N    ??FSMC_NANDCmd_3
    518              {
    519                FSMC_Bank2->PCR2 &= PCR_PBKEN_Reset;
   \   0000002A   ....               LDR.N    R0,??DataTable15_1  ;; 0xa0000060
   \   0000002C   0068               LDR      R0,[R0, #+0]
   \   0000002E   ....               LDR.N    R1,??DataTable15_15  ;; 0xffffb
   \   00000030   0840               ANDS     R0,R1,R0
   \   00000032   ....               LDR.N    R1,??DataTable15_1  ;; 0xa0000060
   \   00000034   0860               STR      R0,[R1, #+0]
   \   00000036   05E0               B.N      ??FSMC_NANDCmd_2
    520              }
    521              else
    522              {
    523                FSMC_Bank3->PCR3 &= PCR_PBKEN_Reset;
   \                     ??FSMC_NANDCmd_3:
   \   00000038   ....               LDR.N    R0,??DataTable15_5  ;; 0xa0000080
   \   0000003A   0068               LDR      R0,[R0, #+0]
   \   0000003C   ....               LDR.N    R1,??DataTable15_15  ;; 0xffffb
   \   0000003E   0840               ANDS     R0,R1,R0
   \   00000040   ....               LDR.N    R1,??DataTable15_5  ;; 0xa0000080
   \   00000042   0860               STR      R0,[R1, #+0]
    524              }
    525            }
    526          }
   \                     ??FSMC_NANDCmd_2:
   \   00000044   7047               BX       LR               ;; return
    527          
    528          /**
    529            * @brief  Enables or disables the PCCARD Memory Bank.
    530            * @param  NewState: new state of the PCCARD Memory Bank.  
    531            *   This parameter can be: ENABLE or DISABLE.
    532            * @retval None
    533            */

   \                                 In section .text, align 2, keep-with-next
    534          void FSMC_PCCARDCmd(FunctionalState NewState)
    535          {
    536            assert_param(IS_FUNCTIONAL_STATE(NewState));
    537            
    538            if (NewState != DISABLE)
   \                     FSMC_PCCARDCmd:
   \   00000000   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0028               CMP      R0,#+0
   \   00000004   06D0               BEQ.N    ??FSMC_PCCARDCmd_0
    539            {
    540              /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
    541              FSMC_Bank4->PCR4 |= PCR_PBKEN_Set;
   \   00000006   ....               LDR.N    R0,??DataTable15_9  ;; 0xa00000a0
   \   00000008   0068               LDR      R0,[R0, #+0]
   \   0000000A   50F00400           ORRS     R0,R0,#0x4
   \   0000000E   ....               LDR.N    R1,??DataTable15_9  ;; 0xa00000a0
   \   00000010   0860               STR      R0,[R1, #+0]
   \   00000012   05E0               B.N      ??FSMC_PCCARDCmd_1
    542            }
    543            else
    544            {
    545              /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
    546              FSMC_Bank4->PCR4 &= PCR_PBKEN_Reset;
   \                     ??FSMC_PCCARDCmd_0:
   \   00000014   ....               LDR.N    R0,??DataTable15_9  ;; 0xa00000a0
   \   00000016   0068               LDR      R0,[R0, #+0]
   \   00000018   ....               LDR.N    R1,??DataTable15_15  ;; 0xffffb
   \   0000001A   0840               ANDS     R0,R1,R0
   \   0000001C   ....               LDR.N    R1,??DataTable15_9  ;; 0xa00000a0
   \   0000001E   0860               STR      R0,[R1, #+0]
    547            }
    548          }
   \                     ??FSMC_PCCARDCmd_1:
   \   00000020   7047               BX       LR               ;; return
    549          
    550          /**
    551            * @brief  Enables or disables the FSMC NAND ECC feature.
    552            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    553            *   This parameter can be one of the following values:
    554            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    555            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    556            * @param  NewState: new state of the FSMC NAND ECC feature.  
    557            *   This parameter can be: ENABLE or DISABLE.
    558            * @retval None
    559            */

   \                                 In section .text, align 2, keep-with-next
    560          void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    561          {
    562            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
    563            assert_param(IS_FUNCTIONAL_STATE(NewState));
    564            
    565            if (NewState != DISABLE)
   \                     FSMC_NANDECCCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   0FD0               BEQ.N    ??FSMC_NANDECCCmd_0
    566            {
    567              /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
    568              if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000006   1028               CMP      R0,#+16
   \   00000008   06D1               BNE.N    ??FSMC_NANDECCCmd_1
    569              {
    570                FSMC_Bank2->PCR2 |= PCR_ECCEN_Set;
   \   0000000A   ....               LDR.N    R0,??DataTable15_1  ;; 0xa0000060
   \   0000000C   0068               LDR      R0,[R0, #+0]
   \   0000000E   50F04000           ORRS     R0,R0,#0x40
   \   00000012   ....               LDR.N    R1,??DataTable15_1  ;; 0xa0000060
   \   00000014   0860               STR      R0,[R1, #+0]
   \   00000016   15E0               B.N      ??FSMC_NANDECCCmd_2
    571              }
    572              else
    573              {
    574                FSMC_Bank3->PCR3 |= PCR_ECCEN_Set;
   \                     ??FSMC_NANDECCCmd_1:
   \   00000018   ....               LDR.N    R0,??DataTable15_5  ;; 0xa0000080
   \   0000001A   0068               LDR      R0,[R0, #+0]
   \   0000001C   50F04000           ORRS     R0,R0,#0x40
   \   00000020   ....               LDR.N    R1,??DataTable15_5  ;; 0xa0000080
   \   00000022   0860               STR      R0,[R1, #+0]
   \   00000024   0EE0               B.N      ??FSMC_NANDECCCmd_2
    575              }
    576            }
    577            else
    578            {
    579              /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
    580              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_NANDECCCmd_0:
   \   00000026   1028               CMP      R0,#+16
   \   00000028   06D1               BNE.N    ??FSMC_NANDECCCmd_3
    581              {
    582                FSMC_Bank2->PCR2 &= PCR_ECCEN_Reset;
   \   0000002A   ....               LDR.N    R0,??DataTable15_1  ;; 0xa0000060
   \   0000002C   0068               LDR      R0,[R0, #+0]
   \   0000002E   ....               LDR.N    R1,??DataTable15_16  ;; 0xfffbf
   \   00000030   0840               ANDS     R0,R1,R0
   \   00000032   ....               LDR.N    R1,??DataTable15_1  ;; 0xa0000060
   \   00000034   0860               STR      R0,[R1, #+0]
   \   00000036   05E0               B.N      ??FSMC_NANDECCCmd_2
    583              }
    584              else
    585              {
    586                FSMC_Bank3->PCR3 &= PCR_ECCEN_Reset;
   \                     ??FSMC_NANDECCCmd_3:
   \   00000038   ....               LDR.N    R0,??DataTable15_5  ;; 0xa0000080
   \   0000003A   0068               LDR      R0,[R0, #+0]
   \   0000003C   ....               LDR.N    R1,??DataTable15_16  ;; 0xfffbf
   \   0000003E   0840               ANDS     R0,R1,R0
   \   00000040   ....               LDR.N    R1,??DataTable15_5  ;; 0xa0000080
   \   00000042   0860               STR      R0,[R1, #+0]
    587              }
    588            }
    589          }
   \                     ??FSMC_NANDECCCmd_2:
   \   00000044   7047               BX       LR               ;; return
    590          
    591          /**
    592            * @brief  Returns the error correction code register value.
    593            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    594            *   This parameter can be one of the following values:
    595            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    596            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    597            * @retval The Error Correction Code (ECC) value.
    598            */

   \                                 In section .text, align 2, keep-with-next
    599          uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
    600          {
    601            uint32_t eccval = 0x00000000;
   \                     FSMC_GetECC:
   \   00000000   0021               MOVS     R1,#+0
    602            
    603            if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000002   1028               CMP      R0,#+16
   \   00000004   02D1               BNE.N    ??FSMC_GetECC_0
    604            {
    605              /* Get the ECCR2 register value */
    606              eccval = FSMC_Bank2->ECCR2;
   \   00000006   ....               LDR.N    R0,??DataTable15_17  ;; 0xa0000074
   \   00000008   0168               LDR      R1,[R0, #+0]
   \   0000000A   01E0               B.N      ??FSMC_GetECC_1
    607            }
    608            else
    609            {
    610              /* Get the ECCR3 register value */
    611              eccval = FSMC_Bank3->ECCR3;
   \                     ??FSMC_GetECC_0:
   \   0000000C   ....               LDR.N    R0,??DataTable15_18  ;; 0xa0000094
   \   0000000E   0168               LDR      R1,[R0, #+0]
    612            }
    613            /* Return the error correction code value */
    614            return(eccval);
   \                     ??FSMC_GetECC_1:
   \   00000010   0800               MOVS     R0,R1
   \   00000012   7047               BX       LR               ;; return
    615          }
    616          
    617          /**
    618            * @brief  Enables or disables the specified FSMC interrupts.
    619            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    620            *   This parameter can be one of the following values:
    621            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    622            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    623            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    624            * @param  FSMC_IT: specifies the FSMC interrupt sources to be enabled or disabled.
    625            *   This parameter can be any combination of the following values:
    626            *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    627            *     @arg FSMC_IT_Level: Level edge detection interrupt.
    628            *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
    629            * @param  NewState: new state of the specified FSMC interrupts.
    630            *   This parameter can be: ENABLE or DISABLE.
    631            * @retval None
    632            */

   \                                 In section .text, align 2, keep-with-next
    633          void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
    634          {
    635            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    636            assert_param(IS_FSMC_IT(FSMC_IT));	
    637            assert_param(IS_FUNCTIONAL_STATE(NewState));
    638            
    639            if (NewState != DISABLE)
   \                     FSMC_ITConfig:
   \   00000000   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   002A               CMP      R2,#+0
   \   00000004   17D0               BEQ.N    ??FSMC_ITConfig_0
    640            {
    641              /* Enable the selected FSMC_Bank2 interrupts */
    642              if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000006   1028               CMP      R0,#+16
   \   00000008   05D1               BNE.N    ??FSMC_ITConfig_1
    643              {
    644                FSMC_Bank2->SR2 |= FSMC_IT;
   \   0000000A   ....               LDR.N    R0,??DataTable15_2  ;; 0xa0000064
   \   0000000C   0068               LDR      R0,[R0, #+0]
   \   0000000E   0843               ORRS     R0,R1,R0
   \   00000010   ....               LDR.N    R1,??DataTable15_2  ;; 0xa0000064
   \   00000012   0860               STR      R0,[R1, #+0]
   \   00000014   26E0               B.N      ??FSMC_ITConfig_2
    645              }
    646              /* Enable the selected FSMC_Bank3 interrupts */
    647              else if (FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ITConfig_1:
   \   00000016   4FF48072           MOV      R2,#+256
   \   0000001A   9042               CMP      R0,R2
   \   0000001C   05D1               BNE.N    ??FSMC_ITConfig_3
    648              {
    649                FSMC_Bank3->SR3 |= FSMC_IT;
   \   0000001E   ....               LDR.N    R0,??DataTable15_6  ;; 0xa0000084
   \   00000020   0068               LDR      R0,[R0, #+0]
   \   00000022   0843               ORRS     R0,R1,R0
   \   00000024   ....               LDR.N    R1,??DataTable15_6  ;; 0xa0000084
   \   00000026   0860               STR      R0,[R1, #+0]
   \   00000028   1CE0               B.N      ??FSMC_ITConfig_2
    650              }
    651              /* Enable the selected FSMC_Bank4 interrupts */
    652              else
    653              {
    654                FSMC_Bank4->SR4 |= FSMC_IT;    
   \                     ??FSMC_ITConfig_3:
   \   0000002A   ....               LDR.N    R0,??DataTable15_10  ;; 0xa00000a4
   \   0000002C   0068               LDR      R0,[R0, #+0]
   \   0000002E   0843               ORRS     R0,R1,R0
   \   00000030   ....               LDR.N    R1,??DataTable15_10  ;; 0xa00000a4
   \   00000032   0860               STR      R0,[R1, #+0]
   \   00000034   16E0               B.N      ??FSMC_ITConfig_2
    655              }
    656            }
    657            else
    658            {
    659              /* Disable the selected FSMC_Bank2 interrupts */
    660              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_ITConfig_0:
   \   00000036   1028               CMP      R0,#+16
   \   00000038   05D1               BNE.N    ??FSMC_ITConfig_4
    661              {
    662                
    663                FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
   \   0000003A   ....               LDR.N    R0,??DataTable15_2  ;; 0xa0000064
   \   0000003C   0068               LDR      R0,[R0, #+0]
   \   0000003E   8843               BICS     R0,R0,R1
   \   00000040   ....               LDR.N    R1,??DataTable15_2  ;; 0xa0000064
   \   00000042   0860               STR      R0,[R1, #+0]
   \   00000044   0EE0               B.N      ??FSMC_ITConfig_2
    664              }
    665              /* Disable the selected FSMC_Bank3 interrupts */
    666              else if (FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ITConfig_4:
   \   00000046   4FF48072           MOV      R2,#+256
   \   0000004A   9042               CMP      R0,R2
   \   0000004C   05D1               BNE.N    ??FSMC_ITConfig_5
    667              {
    668                FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
   \   0000004E   ....               LDR.N    R0,??DataTable15_6  ;; 0xa0000084
   \   00000050   0068               LDR      R0,[R0, #+0]
   \   00000052   8843               BICS     R0,R0,R1
   \   00000054   ....               LDR.N    R1,??DataTable15_6  ;; 0xa0000084
   \   00000056   0860               STR      R0,[R1, #+0]
   \   00000058   04E0               B.N      ??FSMC_ITConfig_2
    669              }
    670              /* Disable the selected FSMC_Bank4 interrupts */
    671              else
    672              {
    673                FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
   \                     ??FSMC_ITConfig_5:
   \   0000005A   ....               LDR.N    R0,??DataTable15_10  ;; 0xa00000a4
   \   0000005C   0068               LDR      R0,[R0, #+0]
   \   0000005E   8843               BICS     R0,R0,R1
   \   00000060   ....               LDR.N    R1,??DataTable15_10  ;; 0xa00000a4
   \   00000062   0860               STR      R0,[R1, #+0]
    674              }
    675            }
    676          }
   \                     ??FSMC_ITConfig_2:
   \   00000064   7047               BX       LR               ;; return
    677          
    678          /**
    679            * @brief  Checks whether the specified FSMC flag is set or not.
    680            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    681            *   This parameter can be one of the following values:
    682            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    683            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    684            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    685            * @param  FSMC_FLAG: specifies the flag to check.
    686            *   This parameter can be one of the following values:
    687            *     @arg FSMC_FLAG_RisingEdge: Rising egde detection Flag.
    688            *     @arg FSMC_FLAG_Level: Level detection Flag.
    689            *     @arg FSMC_FLAG_FallingEdge: Falling egde detection Flag.
    690            *     @arg FSMC_FLAG_FEMPT: Fifo empty Flag. 
    691            * @retval The new state of FSMC_FLAG (SET or RESET).
    692            */

   \                                 In section .text, align 2, keep-with-next
    693          FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
    694          {
    695            FlagStatus bitstatus = RESET;
   \                     FSMC_GetFlagStatus:
   \   00000000   0022               MOVS     R2,#+0
    696            uint32_t tmpsr = 0x00000000;
   \   00000002   0023               MOVS     R3,#+0
    697            
    698            /* Check the parameters */
    699            assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
    700            assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
    701            
    702            if(FSMC_Bank == FSMC_Bank2_NAND)
   \   00000004   1028               CMP      R0,#+16
   \   00000006   02D1               BNE.N    ??FSMC_GetFlagStatus_0
    703            {
    704              tmpsr = FSMC_Bank2->SR2;
   \   00000008   ....               LDR.N    R0,??DataTable15_2  ;; 0xa0000064
   \   0000000A   0368               LDR      R3,[R0, #+0]
   \   0000000C   08E0               B.N      ??FSMC_GetFlagStatus_1
    705            }  
    706            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_GetFlagStatus_0:
   \   0000000E   4FF48072           MOV      R2,#+256
   \   00000012   9042               CMP      R0,R2
   \   00000014   02D1               BNE.N    ??FSMC_GetFlagStatus_2
    707            {
    708              tmpsr = FSMC_Bank3->SR3;
   \   00000016   ....               LDR.N    R0,??DataTable15_6  ;; 0xa0000084
   \   00000018   0368               LDR      R3,[R0, #+0]
   \   0000001A   01E0               B.N      ??FSMC_GetFlagStatus_1
    709            }
    710            /* FSMC_Bank4_PCCARD*/
    711            else
    712            {
    713              tmpsr = FSMC_Bank4->SR4;
   \                     ??FSMC_GetFlagStatus_2:
   \   0000001C   ....               LDR.N    R0,??DataTable15_10  ;; 0xa00000a4
   \   0000001E   0368               LDR      R3,[R0, #+0]
    714            } 
    715            
    716            /* Get the flag status */
    717            if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
   \                     ??FSMC_GetFlagStatus_1:
   \   00000020   0B42               TST      R3,R1
   \   00000022   01D0               BEQ.N    ??FSMC_GetFlagStatus_3
    718            {
    719              bitstatus = SET;
   \   00000024   0122               MOVS     R2,#+1
   \   00000026   00E0               B.N      ??FSMC_GetFlagStatus_4
    720            }
    721            else
    722            {
    723              bitstatus = RESET;
   \                     ??FSMC_GetFlagStatus_3:
   \   00000028   0022               MOVS     R2,#+0
    724            }
    725            /* Return the flag status */
    726            return bitstatus;
   \                     ??FSMC_GetFlagStatus_4:
   \   0000002A   1000               MOVS     R0,R2
   \   0000002C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   7047               BX       LR               ;; return
    727          }
    728          
    729          /**
    730            * @brief  Clears the FSMCs pending flags.
    731            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    732            *   This parameter can be one of the following values:
    733            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    734            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    735            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    736            * @param  FSMC_FLAG: specifies the flag to clear.
    737            *   This parameter can be any combination of the following values:
    738            *     @arg FSMC_FLAG_RisingEdge: Rising egde detection Flag.
    739            *     @arg FSMC_FLAG_Level: Level detection Flag.
    740            *     @arg FSMC_FLAG_FallingEdge: Falling egde detection Flag.
    741            * @retval None
    742            */

   \                                 In section .text, align 2, keep-with-next
    743          void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
    744          {
    745           /* Check the parameters */
    746            assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
    747            assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
    748              
    749            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     FSMC_ClearFlag:
   \   00000000   1028               CMP      R0,#+16
   \   00000002   05D1               BNE.N    ??FSMC_ClearFlag_0
    750            {
    751              FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
   \   00000004   ....               LDR.N    R0,??DataTable15_2  ;; 0xa0000064
   \   00000006   0068               LDR      R0,[R0, #+0]
   \   00000008   8843               BICS     R0,R0,R1
   \   0000000A   ....               LDR.N    R1,??DataTable15_2  ;; 0xa0000064
   \   0000000C   0860               STR      R0,[R1, #+0]
   \   0000000E   0EE0               B.N      ??FSMC_ClearFlag_1
    752            }  
    753            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ClearFlag_0:
   \   00000010   4FF48072           MOV      R2,#+256
   \   00000014   9042               CMP      R0,R2
   \   00000016   05D1               BNE.N    ??FSMC_ClearFlag_2
    754            {
    755              FSMC_Bank3->SR3 &= ~FSMC_FLAG;
   \   00000018   ....               LDR.N    R0,??DataTable15_6  ;; 0xa0000084
   \   0000001A   0068               LDR      R0,[R0, #+0]
   \   0000001C   8843               BICS     R0,R0,R1
   \   0000001E   ....               LDR.N    R1,??DataTable15_6  ;; 0xa0000084
   \   00000020   0860               STR      R0,[R1, #+0]
   \   00000022   04E0               B.N      ??FSMC_ClearFlag_1
    756            }
    757            /* FSMC_Bank4_PCCARD*/
    758            else
    759            {
    760              FSMC_Bank4->SR4 &= ~FSMC_FLAG;
   \                     ??FSMC_ClearFlag_2:
   \   00000024   ....               LDR.N    R0,??DataTable15_10  ;; 0xa00000a4
   \   00000026   0068               LDR      R0,[R0, #+0]
   \   00000028   8843               BICS     R0,R0,R1
   \   0000002A   ....               LDR.N    R1,??DataTable15_10  ;; 0xa00000a4
   \   0000002C   0860               STR      R0,[R1, #+0]
    761            }
    762          }
   \                     ??FSMC_ClearFlag_1:
   \   0000002E   7047               BX       LR               ;; return
    763          
    764          /**
    765            * @brief  Checks whether the specified FSMC interrupt has occurred or not.
    766            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    767            *   This parameter can be one of the following values:
    768            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    769            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    770            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    771            * @param  FSMC_IT: specifies the FSMC interrupt source to check.
    772            *   This parameter can be one of the following values:
    773            *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    774            *     @arg FSMC_IT_Level: Level edge detection interrupt.
    775            *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt. 
    776            * @retval The new state of FSMC_IT (SET or RESET).
    777            */

   \                                 In section .text, align 2, keep-with-next
    778          ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
    779          {
   \                     FSMC_GetITStatus:
   \   00000000   30B4               PUSH     {R4,R5}
    780            ITStatus bitstatus = RESET;
   \   00000002   0022               MOVS     R2,#+0
    781            uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
   \   00000004   0023               MOVS     R3,#+0
   \   00000006   0024               MOVS     R4,#+0
   \   00000008   0025               MOVS     R5,#+0
    782            
    783            /* Check the parameters */
    784            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    785            assert_param(IS_FSMC_GET_IT(FSMC_IT));
    786            
    787            if(FSMC_Bank == FSMC_Bank2_NAND)
   \   0000000A   1028               CMP      R0,#+16
   \   0000000C   02D1               BNE.N    ??FSMC_GetITStatus_0
    788            {
    789              tmpsr = FSMC_Bank2->SR2;
   \   0000000E   ....               LDR.N    R0,??DataTable15_2  ;; 0xa0000064
   \   00000010   0368               LDR      R3,[R0, #+0]
   \   00000012   08E0               B.N      ??FSMC_GetITStatus_1
    790            }  
    791            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_GetITStatus_0:
   \   00000014   4FF48072           MOV      R2,#+256
   \   00000018   9042               CMP      R0,R2
   \   0000001A   02D1               BNE.N    ??FSMC_GetITStatus_2
    792            {
    793              tmpsr = FSMC_Bank3->SR3;
   \   0000001C   ....               LDR.N    R0,??DataTable15_6  ;; 0xa0000084
   \   0000001E   0368               LDR      R3,[R0, #+0]
   \   00000020   01E0               B.N      ??FSMC_GetITStatus_1
    794            }
    795            /* FSMC_Bank4_PCCARD*/
    796            else
    797            {
    798              tmpsr = FSMC_Bank4->SR4;
   \                     ??FSMC_GetITStatus_2:
   \   00000022   ....               LDR.N    R0,??DataTable15_10  ;; 0xa00000a4
   \   00000024   0368               LDR      R3,[R0, #+0]
    799            } 
    800            
    801            itstatus = tmpsr & FSMC_IT;
   \                     ??FSMC_GetITStatus_1:
   \   00000026   11EA0304           ANDS     R4,R1,R3
    802            
    803            itenable = tmpsr & (FSMC_IT >> 3);
   \   0000002A   13EAD105           ANDS     R5,R3,R1, LSR #+3
    804            if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
   \   0000002E   002C               CMP      R4,#+0
   \   00000030   03D0               BEQ.N    ??FSMC_GetITStatus_3
   \   00000032   002D               CMP      R5,#+0
   \   00000034   01D0               BEQ.N    ??FSMC_GetITStatus_3
    805            {
    806              bitstatus = SET;
   \   00000036   0122               MOVS     R2,#+1
   \   00000038   00E0               B.N      ??FSMC_GetITStatus_4
    807            }
    808            else
    809            {
    810              bitstatus = RESET;
   \                     ??FSMC_GetITStatus_3:
   \   0000003A   0022               MOVS     R2,#+0
    811            }
    812            return bitstatus; 
   \                     ??FSMC_GetITStatus_4:
   \   0000003C   1000               MOVS     R0,R2
   \   0000003E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   30BC               POP      {R4,R5}
   \   00000042   7047               BX       LR               ;; return
    813          }
    814          
    815          /**
    816            * @brief  Clears the FSMCs interrupt pending bits.
    817            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    818            *   This parameter can be one of the following values:
    819            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    820            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    821            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    822            * @param  FSMC_IT: specifies the interrupt pending bit to clear.
    823            *   This parameter can be any combination of the following values:
    824            *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    825            *     @arg FSMC_IT_Level: Level edge detection interrupt.
    826            *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
    827            * @retval None
    828            */

   \                                 In section .text, align 2, keep-with-next
    829          void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
    830          {
    831            /* Check the parameters */
    832            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    833            assert_param(IS_FSMC_IT(FSMC_IT));
    834              
    835            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     FSMC_ClearITPendingBit:
   \   00000000   1028               CMP      R0,#+16
   \   00000002   0AD1               BNE.N    ??FSMC_ClearITPendingBit_0
    836            {
    837              FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
   \   00000004   ....               LDR.N    R0,??DataTable15_2  ;; 0xa0000064
   \   00000006   0068               LDR      R0,[R0, #+0]
   \   00000008   C1F3DC01           UBFX     R1,R1,#+3,#+29
   \   0000000C   7FF06042           MVNS     R2,#-536870912
   \   00000010   5140               EORS     R1,R2,R1
   \   00000012   0840               ANDS     R0,R1,R0
   \   00000014   ....               LDR.N    R1,??DataTable15_2  ;; 0xa0000064
   \   00000016   0860               STR      R0,[R1, #+0]
   \   00000018   18E0               B.N      ??FSMC_ClearITPendingBit_1
    838            }  
    839            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ClearITPendingBit_0:
   \   0000001A   4FF48072           MOV      R2,#+256
   \   0000001E   9042               CMP      R0,R2
   \   00000020   0AD1               BNE.N    ??FSMC_ClearITPendingBit_2
    840            {
    841              FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
   \   00000022   ....               LDR.N    R0,??DataTable15_6  ;; 0xa0000084
   \   00000024   0068               LDR      R0,[R0, #+0]
   \   00000026   C1F3DC01           UBFX     R1,R1,#+3,#+29
   \   0000002A   7FF06042           MVNS     R2,#-536870912
   \   0000002E   5140               EORS     R1,R2,R1
   \   00000030   0840               ANDS     R0,R1,R0
   \   00000032   ....               LDR.N    R1,??DataTable15_6  ;; 0xa0000084
   \   00000034   0860               STR      R0,[R1, #+0]
   \   00000036   09E0               B.N      ??FSMC_ClearITPendingBit_1
    842            }
    843            /* FSMC_Bank4_PCCARD*/
    844            else
    845            {
    846              FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
   \                     ??FSMC_ClearITPendingBit_2:
   \   00000038   ....               LDR.N    R0,??DataTable15_10  ;; 0xa00000a4
   \   0000003A   0068               LDR      R0,[R0, #+0]
   \   0000003C   C1F3DC01           UBFX     R1,R1,#+3,#+29
   \   00000040   7FF06042           MVNS     R2,#-536870912
   \   00000044   5140               EORS     R1,R2,R1
   \   00000046   0840               ANDS     R0,R1,R0
   \   00000048   ....               LDR.N    R1,??DataTable15_10  ;; 0xa00000a4
   \   0000004A   0860               STR      R0,[R1, #+0]
    847            }
    848          }
   \                     ??FSMC_ClearITPendingBit_1:
   \   0000004C   7047               BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   040100A0           DC32     0xa0000104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   600000A0           DC32     0xa0000060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   640000A0           DC32     0xa0000064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   680000A0           DC32     0xa0000068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   6C0000A0           DC32     0xa000006c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   800000A0           DC32     0xa0000080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   840000A0           DC32     0xa0000084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   880000A0           DC32     0xa0000088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   8C0000A0           DC32     0xa000008c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   A00000A0           DC32     0xa00000a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \   00000000   A40000A0           DC32     0xa00000a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \   00000000   A80000A0           DC32     0xa00000a8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \   00000000   AC0000A0           DC32     0xa00000ac

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \   00000000   B00000A0           DC32     0xa00000b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \   00000000   FEFF0F00           DC32     0xffffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \   00000000   FBFF0F00           DC32     0xffffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_16:
   \   00000000   BFFF0F00           DC32     0xfffbf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_17:
   \   00000000   740000A0           DC32     0xa0000074

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_18:
   \   00000000   940000A0           DC32     0xa0000094
    849          
    850          /**
    851            * @}
    852            */ 
    853          
    854          /**
    855            * @}
    856            */
    857          
    858          /**
    859            * @}
    860            */
    861          
    862          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function               .cstack
     --------               -------
     FSMC_ClearFlag              0
     FSMC_ClearITPendingBit      0
     FSMC_GetECC                 0
     FSMC_GetFlagStatus          0
     FSMC_GetITStatus            8
     FSMC_ITConfig               0
     FSMC_NANDCmd                0
     FSMC_NANDDeInit             0
     FSMC_NANDECCCmd             0
     FSMC_NANDInit               8
     FSMC_NANDStructInit         0
     FSMC_NORSRAMCmd             0
     FSMC_NORSRAMDeInit          0
     FSMC_NORSRAMInit            0
     FSMC_NORSRAMStructInit      0
     FSMC_PCCARDCmd              0
     FSMC_PCCARDDeInit           0
     FSMC_PCCARDInit             0
     FSMC_PCCARDStructInit       0


   Section sizes:

     Function/Label         Bytes
     --------------         -----
     FSMC_NORSRAMDeInit       56
     FSMC_NANDDeInit          80
     FSMC_PCCARDDeInit        48
     FSMC_NORSRAMInit        224
     FSMC_NANDInit           148
     FSMC_PCCARDInit         128
     FSMC_NORSRAMStructInit  142
     FSMC_NANDStructInit      78
     FSMC_PCCARDStructInit    86
     FSMC_NORSRAMCmd          50
     FSMC_NANDCmd             70
     FSMC_PCCARDCmd           34
     FSMC_NANDECCCmd          70
     FSMC_GetECC              20
     FSMC_ITConfig           102
     FSMC_GetFlagStatus       48
     FSMC_ClearFlag           48
     FSMC_GetITStatus         68
     FSMC_ClearITPendingBit   78
     ??DataTable15             4
     ??DataTable15_1           4
     ??DataTable15_2           4
     ??DataTable15_3           4
     ??DataTable15_4           4
     ??DataTable15_5           4
     ??DataTable15_6           4
     ??DataTable15_7           4
     ??DataTable15_8           4
     ??DataTable15_9           4
     ??DataTable15_10          4
     ??DataTable15_11          4
     ??DataTable15_12          4
     ??DataTable15_13          4
     ??DataTable15_14          4
     ??DataTable15_15          4
     ??DataTable15_16          4
     ??DataTable15_17          4
     ??DataTable15_18          4

 
 1 654 bytes in section .text
 
 1 654 bytes of CODE memory

Errors: none
Warnings: none
