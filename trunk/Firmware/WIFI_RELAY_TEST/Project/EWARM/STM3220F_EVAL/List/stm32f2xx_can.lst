###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     12/Nov/2011  19:31:37 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Libraries\STM32 #
#                    F2xx_StdPeriph_Driver\src\stm32f2xx_can.c                #
#    Command line =  "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Libraries\STM3 #
#                    2F2xx_StdPeriph_Driver\src\stm32f2xx_can.c" -D           #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D RTC_CLOCK_SOURCE_LSE -lC            #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    STM3220F_EVAL\List\" -lA "F:\¹¬ÀÛ¾÷\[ NewDTG             #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\STM3220F_EVAL\List\" #
#                     -o "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EW #
#                    ARM\STM3220F_EVAL\Obj\" --no_cse --no_unroll             #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                              #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\" -I              #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\CMSIS\CM3\CoreSupport\" -I "F:\¹¬ÀÛ¾÷\[  #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Librari #
#                    es\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\" -I             #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I      #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Utilities\STM32_EVAL\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG      #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\Common\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\STM3220F_EVAL\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_OTG_Driver\inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Core\inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Class\msc\inc\" -I "F:\¹¬ÀÛ¾÷\[     #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\" -I   #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\Usb\Inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                      #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\src\" -I      #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Core\inc\" -I     #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\"   #
#                    -Ol --use_c++_inline                                     #
#    List file    =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\List\stm32f2xx_can.lst                      #
#    Object file  =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\Obj\stm32f2xx_can.o                         #
#                                                                             #
#                                                                             #
###############################################################################

F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_can.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_can.c
      4            * @author  MCD Application Team
      5            * @version V0.0.4
      6            * @date    13-January-2011
      7            * @brief   This file provides all the CAN firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f2xx_can.h"
     24          #include "stm32f2xx_rcc.h"
     25          
     26          /** @addtogroup STM32F2xx_StdPeriph_Driver
     27            * @{
     28            */
     29          
     30          /** @defgroup CAN 
     31            * @brief CAN driver modules
     32            * @{
     33            */ 
     34          
     35          /** @defgroup CAN_Private_TypesDefinitions
     36            * @{
     37            */
     38          
     39          /**
     40            * @}
     41            */
     42          
     43          /** @defgroup CAN_Private_Defines
     44            * @{
     45            */
     46          
     47          /* CAN Master Control Register bits */
     48          
     49          #define MCR_DBF      ((uint32_t)0x00010000) /* software master reset */
     50          
     51          /* CAN Mailbox Transmit Request */
     52          #define TMIDxR_TXRQ  ((uint32_t)0x00000001) /* Transmit mailbox request */
     53          
     54          /* CAN Filter Master Register bits */
     55          #define FMR_FINIT    ((uint32_t)0x00000001) /* Filter init mode */
     56          
     57          /* Time out for INAK bit */
     58          #define INAK_TIMEOUT        ((uint32_t)0x0000FFFF)
     59          /* Time out for SLAK bit */
     60          #define SLAK_TIMEOUT        ((uint32_t)0x0000FFFF)
     61          
     62          /* Flags in TSR register */
     63          #define CAN_FLAGS_TSR              ((uint32_t)0x08000000) 
     64          /* Flags in RF1R register */
     65          #define CAN_FLAGS_RF1R             ((uint32_t)0x04000000) 
     66          /* Flags in RF0R register */
     67          #define CAN_FLAGS_RF0R             ((uint32_t)0x02000000) 
     68          /* Flags in MSR register */
     69          #define CAN_FLAGS_MSR              ((uint32_t)0x01000000) 
     70          /* Flags in ESR register */
     71          #define CAN_FLAGS_ESR              ((uint32_t)0x00F00000) 
     72          
     73          
     74          /**
     75            * @}
     76            */
     77          
     78          /** @defgroup CAN_Private_Macros
     79            * @{
     80            */
     81          
     82          /**
     83            * @}
     84            */
     85          
     86          /** @defgroup CAN_Private_Variables
     87            * @{
     88            */
     89          
     90          /**
     91            * @}
     92            */
     93          
     94          /** @defgroup CAN_Private_FunctionPrototypes
     95            * @{
     96            */
     97          
     98          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);
     99          
    100          /**
    101            * @}
    102            */
    103          
    104          /** @defgroup CAN_Private_Functions
    105            * @{
    106            */
    107          
    108          /**
    109            * @brief  Deinitializes the CAN peripheral registers to their default reset values.
    110            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    111            * @retval None.
    112            */

   \                                 In section .text, align 2, keep-with-next
    113          void CAN_DeInit(CAN_TypeDef* CANx)
    114          {
   \                     CAN_DeInit:
   \   00000000   80B5               PUSH     {R7,LR}
    115            /* Check the parameters */
    116            assert_param(IS_CAN_ALL_PERIPH(CANx));
    117           
    118            if (CANx == CAN1)
   \   00000002   ........           LDR.W    R1,??DataTable5  ;; 0x40006400
   \   00000006   8842               CMP      R0,R1
   \   00000008   0AD1               BNE.N    ??CAN_DeInit_0
    119            {
    120              /* Enable CAN1 reset state */
    121              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
   \   0000000A   0121               MOVS     R1,#+1
   \   0000000C   5FF00070           MOVS     R0,#+33554432
   \   00000010   ........           BL       RCC_APB1PeriphResetCmd
    122              /* Release CAN1 from reset state */
    123              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   5FF00070           MOVS     R0,#+33554432
   \   0000001A   ........           BL       RCC_APB1PeriphResetCmd
   \   0000001E   09E0               B.N      ??CAN_DeInit_1
    124            }
    125            else
    126            {  
    127              /* Enable CAN2 reset state */
    128              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
   \                     ??CAN_DeInit_0:
   \   00000020   0121               MOVS     R1,#+1
   \   00000022   5FF08060           MOVS     R0,#+67108864
   \   00000026   ........           BL       RCC_APB1PeriphResetCmd
    129              /* Release CAN2 from reset state */
    130              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
   \   0000002A   0021               MOVS     R1,#+0
   \   0000002C   5FF08060           MOVS     R0,#+67108864
   \   00000030   ........           BL       RCC_APB1PeriphResetCmd
    131            }
    132          }
   \                     ??CAN_DeInit_1:
   \   00000034   01BD               POP      {R0,PC}          ;; return
    133          
    134          /**
    135            * @brief  Initializes the CAN peripheral according to the specified
    136            *   parameters in the CAN_InitStruct.
    137            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    138            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure that
    139            *   contains the configuration information for the CAN peripheral.
    140            * @retval Constant indicates initialization succeed which will be 
    141            *   CANINITFAILED or CANINITOK.
    142            */

   \                                 In section .text, align 2, keep-with-next
    143          uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
    144          {
   \                     CAN_Init:
   \   00000000   10B4               PUSH     {R4}
    145            uint8_t InitStatus = CANINITFAILED;
   \   00000002   0022               MOVS     R2,#+0
    146            uint32_t wait_ack = 0x00000000;
   \   00000004   0023               MOVS     R3,#+0
    147            /* Check the parameters */
    148            assert_param(IS_CAN_ALL_PERIPH(CANx));
    149            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
    150            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
    151            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
    152            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
    153            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
    154            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
    155            assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
    156            assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
    157            assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
    158            assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
    159            assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
    160          
    161            /* exit from sleep mode */
    162            CANx->MCR &= ~CAN_MCR_SLEEP;
   \   00000006   0468               LDR      R4,[R0, #+0]
   \   00000008   34F00204           BICS     R4,R4,#0x2
   \   0000000C   0460               STR      R4,[R0, #+0]
    163          
    164            /* Request initialisation */
    165            CANx->MCR |= CAN_MCR_INRQ ;
   \   0000000E   0468               LDR      R4,[R0, #+0]
   \   00000010   54F00104           ORRS     R4,R4,#0x1
   \   00000014   0460               STR      R4,[R0, #+0]
   \   00000016   00E0               B.N      ??CAN_Init_0
    166          
    167            /* Wait the acknowledge */
    168            while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    169            {
    170              wait_ack++;
   \                     ??CAN_Init_1:
   \   00000018   5B1C               ADDS     R3,R3,#+1
    171            }
   \                     ??CAN_Init_0:
   \   0000001A   4268               LDR      R2,[R0, #+4]
   \   0000001C   D207               LSLS     R2,R2,#+31
   \   0000001E   03D4               BMI.N    ??CAN_Init_2
   \   00000020   4FF6FF72           MOVW     R2,#+65535
   \   00000024   9342               CMP      R3,R2
   \   00000026   F7D1               BNE.N    ??CAN_Init_1
    172          
    173            /* ...and check acknowledged */
    174            if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
   \                     ??CAN_Init_2:
   \   00000028   4268               LDR      R2,[R0, #+4]
   \   0000002A   D207               LSLS     R2,R2,#+31
   \   0000002C   01D4               BMI.N    ??CAN_Init_3
    175            {
    176              InitStatus = CANINITFAILED;
   \   0000002E   0022               MOVS     R2,#+0
   \   00000030   6AE0               B.N      ??CAN_Init_4
    177            }
    178            else 
    179            {
    180              /* Set the time triggered communication mode */
    181              if (CAN_InitStruct->CAN_TTCM == ENABLE)
   \                     ??CAN_Init_3:
   \   00000032   8A79               LDRB     R2,[R1, #+6]
   \   00000034   012A               CMP      R2,#+1
   \   00000036   04D1               BNE.N    ??CAN_Init_5
    182              {
    183                CANx->MCR |= CAN_MCR_TTCM;
   \   00000038   0268               LDR      R2,[R0, #+0]
   \   0000003A   52F08002           ORRS     R2,R2,#0x80
   \   0000003E   0260               STR      R2,[R0, #+0]
   \   00000040   03E0               B.N      ??CAN_Init_6
    184              }
    185              else
    186              {
    187                CANx->MCR &= ~CAN_MCR_TTCM;
   \                     ??CAN_Init_5:
   \   00000042   0268               LDR      R2,[R0, #+0]
   \   00000044   32F08002           BICS     R2,R2,#0x80
   \   00000048   0260               STR      R2,[R0, #+0]
    188              }
    189          
    190              /* Set the automatic bus-off management */
    191              if (CAN_InitStruct->CAN_ABOM == ENABLE)
   \                     ??CAN_Init_6:
   \   0000004A   CA79               LDRB     R2,[R1, #+7]
   \   0000004C   012A               CMP      R2,#+1
   \   0000004E   04D1               BNE.N    ??CAN_Init_7
    192              {
    193                CANx->MCR |= CAN_MCR_ABOM;
   \   00000050   0268               LDR      R2,[R0, #+0]
   \   00000052   52F04002           ORRS     R2,R2,#0x40
   \   00000056   0260               STR      R2,[R0, #+0]
   \   00000058   03E0               B.N      ??CAN_Init_8
    194              }
    195              else
    196              {
    197                CANx->MCR &= ~CAN_MCR_ABOM;
   \                     ??CAN_Init_7:
   \   0000005A   0268               LDR      R2,[R0, #+0]
   \   0000005C   32F04002           BICS     R2,R2,#0x40
   \   00000060   0260               STR      R2,[R0, #+0]
    198              }
    199          
    200              /* Set the automatic wake-up mode */
    201              if (CAN_InitStruct->CAN_AWUM == ENABLE)
   \                     ??CAN_Init_8:
   \   00000062   0A7A               LDRB     R2,[R1, #+8]
   \   00000064   012A               CMP      R2,#+1
   \   00000066   04D1               BNE.N    ??CAN_Init_9
    202              {
    203                CANx->MCR |= CAN_MCR_AWUM;
   \   00000068   0268               LDR      R2,[R0, #+0]
   \   0000006A   52F02002           ORRS     R2,R2,#0x20
   \   0000006E   0260               STR      R2,[R0, #+0]
   \   00000070   03E0               B.N      ??CAN_Init_10
    204              }
    205              else
    206              {
    207                CANx->MCR &= ~CAN_MCR_AWUM;
   \                     ??CAN_Init_9:
   \   00000072   0268               LDR      R2,[R0, #+0]
   \   00000074   32F02002           BICS     R2,R2,#0x20
   \   00000078   0260               STR      R2,[R0, #+0]
    208              }
    209          
    210              /* Set the no automatic retransmission */
    211              if (CAN_InitStruct->CAN_NART == ENABLE)
   \                     ??CAN_Init_10:
   \   0000007A   4A7A               LDRB     R2,[R1, #+9]
   \   0000007C   012A               CMP      R2,#+1
   \   0000007E   04D1               BNE.N    ??CAN_Init_11
    212              {
    213                CANx->MCR |= CAN_MCR_NART;
   \   00000080   0268               LDR      R2,[R0, #+0]
   \   00000082   52F01002           ORRS     R2,R2,#0x10
   \   00000086   0260               STR      R2,[R0, #+0]
   \   00000088   03E0               B.N      ??CAN_Init_12
    214              }
    215              else
    216              {
    217                CANx->MCR &= ~CAN_MCR_NART;
   \                     ??CAN_Init_11:
   \   0000008A   0268               LDR      R2,[R0, #+0]
   \   0000008C   32F01002           BICS     R2,R2,#0x10
   \   00000090   0260               STR      R2,[R0, #+0]
    218              }
    219          
    220              /* Set the receive FIFO locked mode */
    221              if (CAN_InitStruct->CAN_RFLM == ENABLE)
   \                     ??CAN_Init_12:
   \   00000092   8A7A               LDRB     R2,[R1, #+10]
   \   00000094   012A               CMP      R2,#+1
   \   00000096   04D1               BNE.N    ??CAN_Init_13
    222              {
    223                CANx->MCR |= CAN_MCR_RFLM;
   \   00000098   0268               LDR      R2,[R0, #+0]
   \   0000009A   52F00802           ORRS     R2,R2,#0x8
   \   0000009E   0260               STR      R2,[R0, #+0]
   \   000000A0   03E0               B.N      ??CAN_Init_14
    224              }
    225              else
    226              {
    227                CANx->MCR &= ~CAN_MCR_RFLM;
   \                     ??CAN_Init_13:
   \   000000A2   0268               LDR      R2,[R0, #+0]
   \   000000A4   32F00802           BICS     R2,R2,#0x8
   \   000000A8   0260               STR      R2,[R0, #+0]
    228              }
    229          
    230              /* Set the transmit FIFO priority */
    231              if (CAN_InitStruct->CAN_TXFP == ENABLE)
   \                     ??CAN_Init_14:
   \   000000AA   CA7A               LDRB     R2,[R1, #+11]
   \   000000AC   012A               CMP      R2,#+1
   \   000000AE   04D1               BNE.N    ??CAN_Init_15
    232              {
    233                CANx->MCR |= CAN_MCR_TXFP;
   \   000000B0   0268               LDR      R2,[R0, #+0]
   \   000000B2   52F00402           ORRS     R2,R2,#0x4
   \   000000B6   0260               STR      R2,[R0, #+0]
   \   000000B8   03E0               B.N      ??CAN_Init_16
    234              }
    235              else
    236              {
    237                CANx->MCR &= ~CAN_MCR_TXFP;
   \                     ??CAN_Init_15:
   \   000000BA   0268               LDR      R2,[R0, #+0]
   \   000000BC   32F00402           BICS     R2,R2,#0x4
   \   000000C0   0260               STR      R2,[R0, #+0]
    238              }
    239          
    240              /* Set the bit timing register */
    241              CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | ((uint32_t)CAN_InitStruct->CAN_SJW << 24) |
    242                         ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) |
    243                         ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
   \                     ??CAN_Init_16:
   \   000000C2   8A78               LDRB     R2,[R1, #+2]
   \   000000C4   CB78               LDRB     R3,[R1, #+3]
   \   000000C6   1B06               LSLS     R3,R3,#+24
   \   000000C8   53EA8272           ORRS     R2,R3,R2, LSL #+30
   \   000000CC   0B79               LDRB     R3,[R1, #+4]
   \   000000CE   52EA0342           ORRS     R2,R2,R3, LSL #+16
   \   000000D2   4B79               LDRB     R3,[R1, #+5]
   \   000000D4   52EA0352           ORRS     R2,R2,R3, LSL #+20
   \   000000D8   0988               LDRH     R1,[R1, #+0]
   \   000000DA   491E               SUBS     R1,R1,#+1
   \   000000DC   1143               ORRS     R1,R1,R2
   \   000000DE   C161               STR      R1,[R0, #+28]
    244          
    245              /* Request leave initialisation */
    246              CANx->MCR &= ~CAN_MCR_INRQ;
   \   000000E0   0168               LDR      R1,[R0, #+0]
   \   000000E2   4908               LSRS     R1,R1,#+1
   \   000000E4   4900               LSLS     R1,R1,#+1
   \   000000E6   0160               STR      R1,[R0, #+0]
    247          
    248             /* Wait the acknowledge */
    249             wait_ack = 0x00;
   \   000000E8   0023               MOVS     R3,#+0
   \   000000EA   00E0               B.N      ??CAN_Init_17
    250          
    251             while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    252             {
    253               wait_ack++;
   \                     ??CAN_Init_18:
   \   000000EC   5B1C               ADDS     R3,R3,#+1
    254             }
   \                     ??CAN_Init_17:
   \   000000EE   4168               LDR      R1,[R0, #+4]
   \   000000F0   C907               LSLS     R1,R1,#+31
   \   000000F2   03D5               BPL.N    ??CAN_Init_19
   \   000000F4   4FF6FF71           MOVW     R1,#+65535
   \   000000F8   8B42               CMP      R3,R1
   \   000000FA   F7D1               BNE.N    ??CAN_Init_18
    255          
    256              /* ...and check acknowledged */
    257              if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
   \                     ??CAN_Init_19:
   \   000000FC   4068               LDR      R0,[R0, #+4]
   \   000000FE   C007               LSLS     R0,R0,#+31
   \   00000100   01D5               BPL.N    ??CAN_Init_20
    258              {
    259                InitStatus = CANINITFAILED;
   \   00000102   0022               MOVS     R2,#+0
   \   00000104   00E0               B.N      ??CAN_Init_4
    260              }
    261              else
    262              {
    263                InitStatus = CANINITOK ;
   \                     ??CAN_Init_20:
   \   00000106   0122               MOVS     R2,#+1
    264              }
    265            }
    266          
    267            /* At this step, return the status of initialization */
    268            return InitStatus;
   \                     ??CAN_Init_4:
   \   00000108   1000               MOVS     R0,R2
   \   0000010A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010C   10BC               POP      {R4}
   \   0000010E   7047               BX       LR               ;; return
    269          }
    270          
    271          /**
    272            * @brief  Initializes the CAN peripheral according to the specified
    273            *   parameters in the CAN_FilterInitStruct.
    274            * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef
    275            *   structure that contains the configuration information.
    276            * @retval None.
    277            */

   \                                 In section .text, align 2, keep-with-next
    278          void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
    279          {
   \                     CAN_FilterInit:
   \   00000000   10B4               PUSH     {R4}
    280            uint32_t filter_number_bit_pos = 0;
   \   00000002   0021               MOVS     R1,#+0
    281            /* Check the parameters */
    282            assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
    283            assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
    284            assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
    285            assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
    286            assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
    287          
    288            filter_number_bit_pos = ((uint32_t)0x00000001) << CAN_FilterInitStruct->CAN_FilterNumber;
   \   00000004   0122               MOVS     R2,#+1
   \   00000006   837A               LDRB     R3,[R0, #+10]
   \   00000008   9A40               LSLS     R2,R2,R3
   \   0000000A   1100               MOVS     R1,R2
    289          
    290            /* Initialisation mode for the filter */
    291            CAN1->FMR |= FMR_FINIT;
   \   0000000C   ........           LDR.W    R2,??DataTable5_1  ;; 0x40006600
   \   00000010   1268               LDR      R2,[R2, #+0]
   \   00000012   52F00102           ORRS     R2,R2,#0x1
   \   00000016   ........           LDR.W    R3,??DataTable5_1  ;; 0x40006600
   \   0000001A   1A60               STR      R2,[R3, #+0]
    292          
    293            /* Filter Deactivation */
    294            CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
   \   0000001C   ........           LDR.W    R2,??DataTable5_2  ;; 0x4000661c
   \   00000020   1268               LDR      R2,[R2, #+0]
   \   00000022   8A43               BICS     R2,R2,R1
   \   00000024   ........           LDR.W    R3,??DataTable5_2  ;; 0x4000661c
   \   00000028   1A60               STR      R2,[R3, #+0]
    295          
    296            /* Filter Scale */
    297            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
   \   0000002A   027B               LDRB     R2,[R0, #+12]
   \   0000002C   002A               CMP      R2,#+0
   \   0000002E   19D1               BNE.N    ??CAN_FilterInit_0
    298            {
    299              /* 16-bit scale for the filter */
    300              CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
   \   00000030   ........           LDR.W    R2,??DataTable5_3  ;; 0x4000660c
   \   00000034   1268               LDR      R2,[R2, #+0]
   \   00000036   8A43               BICS     R2,R2,R1
   \   00000038   ........           LDR.W    R3,??DataTable5_3  ;; 0x4000660c
   \   0000003C   1A60               STR      R2,[R3, #+0]
    301          
    302              /* First 16-bit identifier and First 16-bit mask */
    303              /* Or First 16-bit identifier and Second 16-bit identifier */
    304              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    305              ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
    306                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
   \   0000003E   C288               LDRH     R2,[R0, #+6]
   \   00000040   4388               LDRH     R3,[R0, #+2]
   \   00000042   53EA0242           ORRS     R2,R3,R2, LSL #+16
   \   00000046   837A               LDRB     R3,[R0, #+10]
   \   00000048   ........           LDR.W    R4,??DataTable5_4  ;; 0x40006640
   \   0000004C   44F83320           STR      R2,[R4, R3, LSL #+3]
    307          
    308              /* Second 16-bit identifier and Second 16-bit mask */
    309              /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    310              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    311              ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    312                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
   \   00000050   827A               LDRB     R2,[R0, #+10]
   \   00000052   ........           LDR.W    R3,??DataTable5_4  ;; 0x40006640
   \   00000056   13EBC202           ADDS     R2,R3,R2, LSL #+3
   \   0000005A   8388               LDRH     R3,[R0, #+4]
   \   0000005C   0488               LDRH     R4,[R0, #+0]
   \   0000005E   54EA0343           ORRS     R3,R4,R3, LSL #+16
   \   00000062   5360               STR      R3,[R2, #+4]
    313            }
    314          
    315            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
   \                     ??CAN_FilterInit_0:
   \   00000064   027B               LDRB     R2,[R0, #+12]
   \   00000066   012A               CMP      R2,#+1
   \   00000068   19D1               BNE.N    ??CAN_FilterInit_1
    316            {
    317              /* 32-bit scale for the filter */
    318              CAN1->FS1R |= filter_number_bit_pos;
   \   0000006A   ........           LDR.W    R2,??DataTable5_3  ;; 0x4000660c
   \   0000006E   1268               LDR      R2,[R2, #+0]
   \   00000070   0A43               ORRS     R2,R1,R2
   \   00000072   ........           LDR.W    R3,??DataTable5_3  ;; 0x4000660c
   \   00000076   1A60               STR      R2,[R3, #+0]
    319              /* 32-bit identifier or First 32-bit identifier */
    320              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    321              ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
    322                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
   \   00000078   0288               LDRH     R2,[R0, #+0]
   \   0000007A   4388               LDRH     R3,[R0, #+2]
   \   0000007C   53EA0242           ORRS     R2,R3,R2, LSL #+16
   \   00000080   837A               LDRB     R3,[R0, #+10]
   \   00000082   ........           LDR.W    R4,??DataTable5_4  ;; 0x40006640
   \   00000086   44F83320           STR      R2,[R4, R3, LSL #+3]
    323              /* 32-bit mask or Second 32-bit identifier */
    324              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    325              ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    326                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
   \   0000008A   827A               LDRB     R2,[R0, #+10]
   \   0000008C   ........           LDR.W    R3,??DataTable5_4  ;; 0x40006640
   \   00000090   13EBC202           ADDS     R2,R3,R2, LSL #+3
   \   00000094   8388               LDRH     R3,[R0, #+4]
   \   00000096   C488               LDRH     R4,[R0, #+6]
   \   00000098   54EA0343           ORRS     R3,R4,R3, LSL #+16
   \   0000009C   5360               STR      R3,[R2, #+4]
    327            }
    328          
    329            /* Filter Mode */
    330            if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
   \                     ??CAN_FilterInit_1:
   \   0000009E   C27A               LDRB     R2,[R0, #+11]
   \   000000A0   002A               CMP      R2,#+0
   \   000000A2   07D1               BNE.N    ??CAN_FilterInit_2
    331            {
    332              /*Id/Mask mode for the filter*/
    333              CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
   \   000000A4   ........           LDR.W    R2,??DataTable5_5  ;; 0x40006604
   \   000000A8   1268               LDR      R2,[R2, #+0]
   \   000000AA   8A43               BICS     R2,R2,R1
   \   000000AC   ........           LDR.W    R3,??DataTable5_5  ;; 0x40006604
   \   000000B0   1A60               STR      R2,[R3, #+0]
   \   000000B2   06E0               B.N      ??CAN_FilterInit_3
    334            }
    335            else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
    336            {
    337              /*Identifier list mode for the filter*/
    338              CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
   \                     ??CAN_FilterInit_2:
   \   000000B4   ........           LDR.W    R2,??DataTable5_5  ;; 0x40006604
   \   000000B8   1268               LDR      R2,[R2, #+0]
   \   000000BA   0A43               ORRS     R2,R1,R2
   \   000000BC   ........           LDR.W    R3,??DataTable5_5  ;; 0x40006604
   \   000000C0   1A60               STR      R2,[R3, #+0]
    339            }
    340          
    341            /* Filter FIFO assignment */
    342            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_FilterFIFO0)
   \                     ??CAN_FilterInit_3:
   \   000000C2   0289               LDRH     R2,[R0, #+8]
   \   000000C4   002A               CMP      R2,#+0
   \   000000C6   06D1               BNE.N    ??CAN_FilterInit_4
    343            {
    344              /* FIFO 0 assignation for the filter */
    345              CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
   \   000000C8   ........           LDR.W    R2,??DataTable5_6  ;; 0x40006614
   \   000000CC   1268               LDR      R2,[R2, #+0]
   \   000000CE   8A43               BICS     R2,R2,R1
   \   000000D0   ........           LDR.W    R3,??DataTable5_6  ;; 0x40006614
   \   000000D4   1A60               STR      R2,[R3, #+0]
    346            }
    347          
    348            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_FilterFIFO1)
   \                     ??CAN_FilterInit_4:
   \   000000D6   0289               LDRH     R2,[R0, #+8]
   \   000000D8   012A               CMP      R2,#+1
   \   000000DA   06D1               BNE.N    ??CAN_FilterInit_5
    349            {
    350              /* FIFO 1 assignation for the filter */
    351              CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
   \   000000DC   ........           LDR.W    R2,??DataTable5_6  ;; 0x40006614
   \   000000E0   1268               LDR      R2,[R2, #+0]
   \   000000E2   0A43               ORRS     R2,R1,R2
   \   000000E4   ........           LDR.W    R3,??DataTable5_6  ;; 0x40006614
   \   000000E8   1A60               STR      R2,[R3, #+0]
    352            }
    353            
    354            /* Filter activation */
    355            if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
   \                     ??CAN_FilterInit_5:
   \   000000EA   407B               LDRB     R0,[R0, #+13]
   \   000000EC   0128               CMP      R0,#+1
   \   000000EE   06D1               BNE.N    ??CAN_FilterInit_6
    356            {
    357              CAN1->FA1R |= filter_number_bit_pos;
   \   000000F0   ........           LDR.W    R0,??DataTable5_2  ;; 0x4000661c
   \   000000F4   0068               LDR      R0,[R0, #+0]
   \   000000F6   0843               ORRS     R0,R1,R0
   \   000000F8   ........           LDR.W    R1,??DataTable5_2  ;; 0x4000661c
   \   000000FC   0860               STR      R0,[R1, #+0]
    358            }
    359          
    360            /* Leave the initialisation mode for the filter */
    361            CAN1->FMR &= ~FMR_FINIT;
   \                     ??CAN_FilterInit_6:
   \   000000FE   ........           LDR.W    R0,??DataTable5_1  ;; 0x40006600
   \   00000102   0068               LDR      R0,[R0, #+0]
   \   00000104   4008               LSRS     R0,R0,#+1
   \   00000106   4000               LSLS     R0,R0,#+1
   \   00000108   ........           LDR.W    R1,??DataTable5_1  ;; 0x40006600
   \   0000010C   0860               STR      R0,[R1, #+0]
    362          }
   \   0000010E   10BC               POP      {R4}
   \   00000110   7047               BX       LR               ;; return
    363          
    364          /**
    365            * @brief  Fills each CAN_InitStruct member with its default value.
    366            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which
    367            *   will be initialized.
    368            * @retval None.
    369            */

   \                                 In section .text, align 2, keep-with-next
    370          void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
    371          {
    372            /* Reset CAN init structure parameters values */
    373            /* Initialize the time triggered communication mode */
    374            CAN_InitStruct->CAN_TTCM = DISABLE;
   \                     CAN_StructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   8171               STRB     R1,[R0, #+6]
    375            /* Initialize the automatic bus-off management */
    376            CAN_InitStruct->CAN_ABOM = DISABLE;
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   C171               STRB     R1,[R0, #+7]
    377            /* Initialize the automatic wake-up mode */
    378            CAN_InitStruct->CAN_AWUM = DISABLE;
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   0172               STRB     R1,[R0, #+8]
    379            /* Initialize the no automatic retransmission */
    380            CAN_InitStruct->CAN_NART = DISABLE;
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   4172               STRB     R1,[R0, #+9]
    381            /* Initialize the receive FIFO locked mode */
    382            CAN_InitStruct->CAN_RFLM = DISABLE;
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   8172               STRB     R1,[R0, #+10]
    383            /* Initialize the transmit FIFO priority */
    384            CAN_InitStruct->CAN_TXFP = DISABLE;
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   C172               STRB     R1,[R0, #+11]
    385            /* Initialize the CAN_Mode member */
    386            CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
   \   00000018   0021               MOVS     R1,#+0
   \   0000001A   8170               STRB     R1,[R0, #+2]
    387            /* Initialize the CAN_SJW member */
    388            CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
   \   0000001C   0021               MOVS     R1,#+0
   \   0000001E   C170               STRB     R1,[R0, #+3]
    389            /* Initialize the CAN_BS1 member */
    390            CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
   \   00000020   0321               MOVS     R1,#+3
   \   00000022   0171               STRB     R1,[R0, #+4]
    391            /* Initialize the CAN_BS2 member */
    392            CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
   \   00000024   0221               MOVS     R1,#+2
   \   00000026   4171               STRB     R1,[R0, #+5]
    393            /* Initialize the CAN_Prescaler member */
    394            CAN_InitStruct->CAN_Prescaler = 1;
   \   00000028   0121               MOVS     R1,#+1
   \   0000002A   0180               STRH     R1,[R0, #+0]
    395          }
   \   0000002C   7047               BX       LR               ;; return
    396          
    397          /**
    398            * @brief  Select the start bank filter for slave CAN.
    399            * @note   This function applies only to STM32 Connectivity line devices.
    400            * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
    401            * @retval None.
    402            */

   \                                 In section .text, align 2, keep-with-next
    403          void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
    404          {
    405            /* Check the parameters */
    406            assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
    407            /* enter Initialisation mode for the filter */
    408            CAN1->FMR |= FMR_FINIT;
   \                     CAN_SlaveStartBank:
   \   00000000   ........           LDR.W    R1,??DataTable5_1  ;; 0x40006600
   \   00000004   0968               LDR      R1,[R1, #+0]
   \   00000006   51F00101           ORRS     R1,R1,#0x1
   \   0000000A   ........           LDR.W    R2,??DataTable5_1  ;; 0x40006600
   \   0000000E   1160               STR      R1,[R2, #+0]
    409            /* Select the start slave bank */
    410            CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
   \   00000010   ........           LDR.W    R1,??DataTable5_1  ;; 0x40006600
   \   00000014   0968               LDR      R1,[R1, #+0]
   \   00000016   ........           LDR.W    R2,??DataTable5_7  ;; 0xffffc0f1
   \   0000001A   1140               ANDS     R1,R2,R1
   \   0000001C   ........           LDR.W    R2,??DataTable5_1  ;; 0x40006600
   \   00000020   1160               STR      R1,[R2, #+0]
    411            CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
   \   00000022   ........           LDR.W    R1,??DataTable5_1  ;; 0x40006600
   \   00000026   0968               LDR      R1,[R1, #+0]
   \   00000028   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   51EA0020           ORRS     R0,R1,R0, LSL #+8
   \   0000002E   ........           LDR.W    R1,??DataTable5_1  ;; 0x40006600
   \   00000032   0860               STR      R0,[R1, #+0]
    412            /* Leave Initialisation mode for the filter */
    413            CAN1->FMR &= ~FMR_FINIT;
   \   00000034   ........           LDR.W    R0,??DataTable5_1  ;; 0x40006600
   \   00000038   0068               LDR      R0,[R0, #+0]
   \   0000003A   4008               LSRS     R0,R0,#+1
   \   0000003C   4000               LSLS     R0,R0,#+1
   \   0000003E   ........           LDR.W    R1,??DataTable5_1  ;; 0x40006600
   \   00000042   0860               STR      R0,[R1, #+0]
    414          }
   \   00000044   7047               BX       LR               ;; return
    415          
    416          /**
    417            * @brief  Enables or disables the specified CANx interrupts.
    418            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    419            * @param  CAN_IT: specifies the CAN interrupt sources to be enabled or disabled.
    420            *   This parameter can be: 
    421            *        -CAN_IT_TME, 
    422            *        -CAN_IT_FMP0, 
    423            *        -CAN_IT_FF0,
    424            *        -CAN_IT_FOV0, 
    425            *        -CAN_IT_FMP1, 
    426            *        -CAN_IT_FF1,
    427            *        -CAN_IT_FOV1, 
    428            *        -CAN_IT_EWG, 
    429            *        -CAN_IT_EPV,
    430            *        -CAN_IT_LEC, 
    431            *        -CAN_IT_ERR, 
    432            *        -CAN_IT_WKU or 
    433            *        -CAN_IT_SLK.
    434            * @param  NewState: new state of the CAN interrupts.
    435            *   This parameter can be: ENABLE or DISABLE.
    436            * @retval None.
    437            */

   \                                 In section .text, align 2, keep-with-next
    438          void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
    439          {
    440            /* Check the parameters */
    441            assert_param(IS_CAN_ALL_PERIPH(CANx));
    442            assert_param(IS_CAN_IT(CAN_IT));
    443            assert_param(IS_FUNCTIONAL_STATE(NewState));
    444          
    445            if (NewState != DISABLE)
   \                     CAN_ITConfig:
   \   00000000   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   002A               CMP      R2,#+0
   \   00000004   03D0               BEQ.N    ??CAN_ITConfig_0
    446            {
    447              /* Enable the selected CANx interrupt */
    448              CANx->IER |= CAN_IT;
   \   00000006   4269               LDR      R2,[R0, #+20]
   \   00000008   1143               ORRS     R1,R1,R2
   \   0000000A   4161               STR      R1,[R0, #+20]
   \   0000000C   03E0               B.N      ??CAN_ITConfig_1
    449            }
    450            else
    451            {
    452              /* Disable the selected CANx interrupt */
    453              CANx->IER &= ~CAN_IT;
   \                     ??CAN_ITConfig_0:
   \   0000000E   4269               LDR      R2,[R0, #+20]
   \   00000010   32EA0101           BICS     R1,R2,R1
   \   00000014   4161               STR      R1,[R0, #+20]
    454            }
    455          }
   \                     ??CAN_ITConfig_1:
   \   00000016   7047               BX       LR               ;; return
    456          
    457          /**
    458            * @brief  Initiates the transmission of a message.
    459            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    460            * @param  TxMessage: pointer to a structure which contains CAN Id, CAN
    461            *   DLC and CAN datas.
    462            * @retval The number of the mailbox that is used for transmission
    463            *   or CAN_NO_MB if there is no empty mailbox.
    464            */

   \                                 In section .text, align 2, keep-with-next
    465          uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
    466          {
   \                     CAN_Transmit:
   \   00000000   30B4               PUSH     {R4,R5}
    467            uint8_t transmit_mailbox = 0;
   \   00000002   0022               MOVS     R2,#+0
    468            /* Check the parameters */
    469            assert_param(IS_CAN_ALL_PERIPH(CANx));
    470            assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
    471            assert_param(IS_CAN_RTR(TxMessage->RTR));
    472            assert_param(IS_CAN_DLC(TxMessage->DLC));
    473          
    474            /* Select one empty transmit mailbox */
    475            if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
   \   00000004   8368               LDR      R3,[R0, #+8]
   \   00000006   5B01               LSLS     R3,R3,#+5
   \   00000008   01D5               BPL.N    ??CAN_Transmit_0
    476            {
    477              transmit_mailbox = 0;
   \   0000000A   0022               MOVS     R2,#+0
   \   0000000C   0AE0               B.N      ??CAN_Transmit_1
    478            }
    479            else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
   \                     ??CAN_Transmit_0:
   \   0000000E   8268               LDR      R2,[R0, #+8]
   \   00000010   1201               LSLS     R2,R2,#+4
   \   00000012   01D5               BPL.N    ??CAN_Transmit_2
    480            {
    481              transmit_mailbox = 1;
   \   00000014   0122               MOVS     R2,#+1
   \   00000016   05E0               B.N      ??CAN_Transmit_1
    482            }
    483            else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
   \                     ??CAN_Transmit_2:
   \   00000018   8268               LDR      R2,[R0, #+8]
   \   0000001A   D200               LSLS     R2,R2,#+3
   \   0000001C   01D5               BPL.N    ??CAN_Transmit_3
    484            {
    485              transmit_mailbox = 2;
   \   0000001E   0222               MOVS     R2,#+2
   \   00000020   00E0               B.N      ??CAN_Transmit_1
    486            }
    487            else
    488            {
    489              transmit_mailbox = CAN_NO_MB;
   \                     ??CAN_Transmit_3:
   \   00000022   0422               MOVS     R2,#+4
    490            }
    491          
    492            if (transmit_mailbox != CAN_NO_MB)
   \                     ??CAN_Transmit_1:
   \   00000024   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000026   042A               CMP      R2,#+4
   \   00000028   75D0               BEQ.N    ??CAN_Transmit_4
    493            {
    494              /* Set up the Id */
    495              CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
   \   0000002A   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002C   10EB0213           ADDS     R3,R0,R2, LSL #+4
   \   00000030   D3F88031           LDR      R3,[R3, #+384]
   \   00000034   13F00103           ANDS     R3,R3,#0x1
   \   00000038   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000003A   10EB0214           ADDS     R4,R0,R2, LSL #+4
   \   0000003E   C4F88031           STR      R3,[R4, #+384]
    496              if (TxMessage->IDE == CAN_ID_STD)
   \   00000042   0B7A               LDRB     R3,[R1, #+8]
   \   00000044   002B               CMP      R3,#+0
   \   00000046   0FD1               BNE.N    ??CAN_Transmit_5
    497              {
    498                assert_param(IS_CAN_STDID(TxMessage->StdId));  
    499                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | TxMessage->RTR);
   \   00000048   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004A   10EB0213           ADDS     R3,R0,R2, LSL #+4
   \   0000004E   D3F88031           LDR      R3,[R3, #+384]
   \   00000052   0C68               LDR      R4,[R1, #+0]
   \   00000054   4D7A               LDRB     R5,[R1, #+9]
   \   00000056   55EA4454           ORRS     R4,R5,R4, LSL #+21
   \   0000005A   2343               ORRS     R3,R4,R3
   \   0000005C   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000005E   10EB0214           ADDS     R4,R0,R2, LSL #+4
   \   00000062   C4F88031           STR      R3,[R4, #+384]
   \   00000066   10E0               B.N      ??CAN_Transmit_6
    500              }
    501              else
    502              {
    503                assert_param(IS_CAN_EXTID(TxMessage->ExtId));
    504                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId<<3) | TxMessage->IDE | 
    505                                                         TxMessage->RTR);
   \                     ??CAN_Transmit_5:
   \   00000068   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000006A   10EB0213           ADDS     R3,R0,R2, LSL #+4
   \   0000006E   D3F88031           LDR      R3,[R3, #+384]
   \   00000072   4C68               LDR      R4,[R1, #+4]
   \   00000074   0D7A               LDRB     R5,[R1, #+8]
   \   00000076   55EAC404           ORRS     R4,R5,R4, LSL #+3
   \   0000007A   4D7A               LDRB     R5,[R1, #+9]
   \   0000007C   2C43               ORRS     R4,R5,R4
   \   0000007E   2343               ORRS     R3,R4,R3
   \   00000080   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000082   10EB0214           ADDS     R4,R0,R2, LSL #+4
   \   00000086   C4F88031           STR      R3,[R4, #+384]
    506              }
    507              
    508          
    509              /* Set up the DLC */
    510              TxMessage->DLC &= (uint8_t)0x0000000F;
   \                     ??CAN_Transmit_6:
   \   0000008A   8B7A               LDRB     R3,[R1, #+10]
   \   0000008C   13F00F03           ANDS     R3,R3,#0xF
   \   00000090   8B72               STRB     R3,[R1, #+10]
    511              CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
   \   00000092   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000094   10EB0213           ADDS     R3,R0,R2, LSL #+4
   \   00000098   D3F88431           LDR      R3,[R3, #+388]
   \   0000009C   1B09               LSRS     R3,R3,#+4
   \   0000009E   1B01               LSLS     R3,R3,#+4
   \   000000A0   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000A2   10EB0214           ADDS     R4,R0,R2, LSL #+4
   \   000000A6   C4F88431           STR      R3,[R4, #+388]
    512              CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
   \   000000AA   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000AC   10EB0213           ADDS     R3,R0,R2, LSL #+4
   \   000000B0   D3F88431           LDR      R3,[R3, #+388]
   \   000000B4   8C7A               LDRB     R4,[R1, #+10]
   \   000000B6   2343               ORRS     R3,R4,R3
   \   000000B8   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000BA   10EB0214           ADDS     R4,R0,R2, LSL #+4
   \   000000BE   C4F88431           STR      R3,[R4, #+388]
    513          
    514              /* Set up the data field */
    515              CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
    516                                                       ((uint32_t)TxMessage->Data[2] << 16) |
    517                                                       ((uint32_t)TxMessage->Data[1] << 8) | 
    518                                                       ((uint32_t)TxMessage->Data[0]));
   \   000000C2   8B7B               LDRB     R3,[R1, #+14]
   \   000000C4   4C7B               LDRB     R4,[R1, #+13]
   \   000000C6   2404               LSLS     R4,R4,#+16
   \   000000C8   54EA0363           ORRS     R3,R4,R3, LSL #+24
   \   000000CC   0C7B               LDRB     R4,[R1, #+12]
   \   000000CE   53EA0423           ORRS     R3,R3,R4, LSL #+8
   \   000000D2   CC7A               LDRB     R4,[R1, #+11]
   \   000000D4   2343               ORRS     R3,R4,R3
   \   000000D6   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000D8   10EB0214           ADDS     R4,R0,R2, LSL #+4
   \   000000DC   C4F88831           STR      R3,[R4, #+392]
    519              CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
    520                                                       ((uint32_t)TxMessage->Data[6] << 16) |
    521                                                       ((uint32_t)TxMessage->Data[5] << 8) |
    522                                                       ((uint32_t)TxMessage->Data[4]));
   \   000000E0   8B7C               LDRB     R3,[R1, #+18]
   \   000000E2   4C7C               LDRB     R4,[R1, #+17]
   \   000000E4   2404               LSLS     R4,R4,#+16
   \   000000E6   54EA0363           ORRS     R3,R4,R3, LSL #+24
   \   000000EA   0C7C               LDRB     R4,[R1, #+16]
   \   000000EC   53EA0423           ORRS     R3,R3,R4, LSL #+8
   \   000000F0   C97B               LDRB     R1,[R1, #+15]
   \   000000F2   1943               ORRS     R1,R1,R3
   \   000000F4   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000F6   10EB0213           ADDS     R3,R0,R2, LSL #+4
   \   000000FA   C3F88C11           STR      R1,[R3, #+396]
    523              /* Request transmission */
    524              CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
   \   000000FE   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000100   10EB0211           ADDS     R1,R0,R2, LSL #+4
   \   00000104   D1F88011           LDR      R1,[R1, #+384]
   \   00000108   51F00101           ORRS     R1,R1,#0x1
   \   0000010C   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000010E   10EB0210           ADDS     R0,R0,R2, LSL #+4
   \   00000112   C0F88011           STR      R1,[R0, #+384]
    525            }
    526            return transmit_mailbox;
   \                     ??CAN_Transmit_4:
   \   00000116   1000               MOVS     R0,R2
   \   00000118   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011A   30BC               POP      {R4,R5}
   \   0000011C   7047               BX       LR               ;; return
    527          }
    528          
    529          /**
    530            * @brief  Checks the transmission of a message.
    531            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    532            * @param  TransmitMailbox: the number of the mailbox that is used for transmission.
    533            * @retval CANTXOK if the CAN driver transmits the message, CANTXFAILED in an other case.
    534            */

   \                                 In section .text, align 2, keep-with-next
    535          uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
    536          {
   \                     CAN_TransmitStatus:
   \   00000000   0A00               MOVS     R2,R1
    537            /* RQCP, TXOK and TME bits */
    538            uint8_t state = 0;
   \   00000002   0021               MOVS     R1,#+0
    539            /* Check the parameters */
    540            assert_param(IS_CAN_ALL_PERIPH(CANx));
    541            assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
    542            switch (TransmitMailbox)
   \   00000004   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000006   002A               CMP      R2,#+0
   \   00000008   03D0               BEQ.N    ??CAN_TransmitStatus_0
   \   0000000A   022A               CMP      R2,#+2
   \   0000000C   20D0               BEQ.N    ??CAN_TransmitStatus_1
   \   0000000E   0FD3               BCC.N    ??CAN_TransmitStatus_2
   \   00000010   2EE0               B.N      ??CAN_TransmitStatus_3
    543            {
    544              case (0): state |= (uint8_t)((CANx->TSR & CAN_TSR_RQCP0) << 2);
   \                     ??CAN_TransmitStatus_0:
   \   00000012   8268               LDR      R2,[R0, #+8]
   \   00000014   12F00102           ANDS     R2,R2,#0x1
   \   00000018   51EA8201           ORRS     R1,R1,R2, LSL #+2
    545                state |= (uint8_t)((CANx->TSR & CAN_TSR_TXOK0) >> 0);
   \   0000001C   8268               LDR      R2,[R0, #+8]
   \   0000001E   12F00202           ANDS     R2,R2,#0x2
   \   00000022   1143               ORRS     R1,R2,R1
    546                state |= (uint8_t)((CANx->TSR & CAN_TSR_TME0) >> 26);
   \   00000024   8068               LDR      R0,[R0, #+8]
   \   00000026   800E               LSRS     R0,R0,#+26
   \   00000028   10F00100           ANDS     R0,R0,#0x1
   \   0000002C   0143               ORRS     R1,R0,R1
    547                break;
   \   0000002E   20E0               B.N      ??CAN_TransmitStatus_4
    548              case (1): state |= (uint8_t)((CANx->TSR & CAN_TSR_RQCP1) >> 6);
   \                     ??CAN_TransmitStatus_2:
   \   00000030   8268               LDR      R2,[R0, #+8]
   \   00000032   9209               LSRS     R2,R2,#+6
   \   00000034   12F00402           ANDS     R2,R2,#0x4
   \   00000038   1143               ORRS     R1,R2,R1
    549                state |= (uint8_t)((CANx->TSR & CAN_TSR_TXOK1) >> 8);
   \   0000003A   8268               LDR      R2,[R0, #+8]
   \   0000003C   120A               LSRS     R2,R2,#+8
   \   0000003E   12F00202           ANDS     R2,R2,#0x2
   \   00000042   1143               ORRS     R1,R2,R1
    550                state |= (uint8_t)((CANx->TSR & CAN_TSR_TME1) >> 27);
   \   00000044   8068               LDR      R0,[R0, #+8]
   \   00000046   C00E               LSRS     R0,R0,#+27
   \   00000048   10F00100           ANDS     R0,R0,#0x1
   \   0000004C   0143               ORRS     R1,R0,R1
    551                break;
   \   0000004E   10E0               B.N      ??CAN_TransmitStatus_4
    552              case (2): state |= (uint8_t)((CANx->TSR & CAN_TSR_RQCP2) >> 14);
   \                     ??CAN_TransmitStatus_1:
   \   00000050   8268               LDR      R2,[R0, #+8]
   \   00000052   920B               LSRS     R2,R2,#+14
   \   00000054   12F00402           ANDS     R2,R2,#0x4
   \   00000058   1143               ORRS     R1,R2,R1
    553                state |= (uint8_t)((CANx->TSR & CAN_TSR_TXOK2) >> 16);
   \   0000005A   8268               LDR      R2,[R0, #+8]
   \   0000005C   120C               LSRS     R2,R2,#+16
   \   0000005E   12F00202           ANDS     R2,R2,#0x2
   \   00000062   1143               ORRS     R1,R2,R1
    554                state |= (uint8_t)((CANx->TSR & CAN_TSR_TME2) >> 28);
   \   00000064   8068               LDR      R0,[R0, #+8]
   \   00000066   000F               LSRS     R0,R0,#+28
   \   00000068   10F00100           ANDS     R0,R0,#0x1
   \   0000006C   0143               ORRS     R1,R0,R1
    555                break;
   \   0000006E   00E0               B.N      ??CAN_TransmitStatus_4
    556              default:
    557                state = CANTXFAILED;
   \                     ??CAN_TransmitStatus_3:
   \   00000070   0021               MOVS     R1,#+0
    558                break;
    559            }
    560            switch (state)
   \                     ??CAN_TransmitStatus_4:
   \   00000072   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000074   0029               CMP      R1,#+0
   \   00000076   04D0               BEQ.N    ??CAN_TransmitStatus_5
   \   00000078   0529               CMP      R1,#+5
   \   0000007A   04D0               BEQ.N    ??CAN_TransmitStatus_6
   \   0000007C   0729               CMP      R1,#+7
   \   0000007E   04D0               BEQ.N    ??CAN_TransmitStatus_7
   \   00000080   05E0               B.N      ??CAN_TransmitStatus_8
    561            {
    562                /* transmit pending  */
    563              case (0x0): state = CANTXPENDING;
   \                     ??CAN_TransmitStatus_5:
   \   00000082   0221               MOVS     R1,#+2
    564                break;
   \   00000084   04E0               B.N      ??CAN_TransmitStatus_9
    565                /* transmit failed  */
    566              case (0x5): state = CANTXFAILED;
   \                     ??CAN_TransmitStatus_6:
   \   00000086   0021               MOVS     R1,#+0
    567                break;
   \   00000088   02E0               B.N      ??CAN_TransmitStatus_9
    568                /* transmit succedeed  */
    569              case (0x7): state = CANTXOK;
   \                     ??CAN_TransmitStatus_7:
   \   0000008A   0121               MOVS     R1,#+1
    570                break;
   \   0000008C   00E0               B.N      ??CAN_TransmitStatus_9
    571              default:
    572                state = CANTXFAILED;
   \                     ??CAN_TransmitStatus_8:
   \   0000008E   0021               MOVS     R1,#+0
    573                break;
    574            }
    575            return state;
   \                     ??CAN_TransmitStatus_9:
   \   00000090   0800               MOVS     R0,R1
   \   00000092   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000094   7047               BX       LR               ;; return
    576          }
    577          
    578          /**
    579            * @brief  Cancels a transmit request.
    580            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral. 
    581            * @param  Mailbox: Mailbox number.
    582            * @retval None.
    583            */

   \                                 In section .text, align 2, keep-with-next
    584          void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
    585          {
    586            /* Check the parameters */
    587            assert_param(IS_CAN_ALL_PERIPH(CANx));
    588            assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
    589            /* abort transmission */
    590            switch (Mailbox)
   \                     CAN_CancelTransmit:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   03D0               BEQ.N    ??CAN_CancelTransmit_0
   \   00000006   0229               CMP      R1,#+2
   \   00000008   0BD0               BEQ.N    ??CAN_CancelTransmit_1
   \   0000000A   05D3               BCC.N    ??CAN_CancelTransmit_2
   \   0000000C   0EE0               B.N      ??CAN_CancelTransmit_3
    591            {
    592              case (0): CANx->TSR |= CAN_TSR_ABRQ0;
   \                     ??CAN_CancelTransmit_0:
   \   0000000E   8168               LDR      R1,[R0, #+8]
   \   00000010   51F08001           ORRS     R1,R1,#0x80
   \   00000014   8160               STR      R1,[R0, #+8]
    593                break;
   \   00000016   09E0               B.N      ??CAN_CancelTransmit_4
    594              case (1): CANx->TSR |= CAN_TSR_ABRQ1;
   \                     ??CAN_CancelTransmit_2:
   \   00000018   8168               LDR      R1,[R0, #+8]
   \   0000001A   51F40041           ORRS     R1,R1,#0x8000
   \   0000001E   8160               STR      R1,[R0, #+8]
    595                break;
   \   00000020   04E0               B.N      ??CAN_CancelTransmit_4
    596              case (2): CANx->TSR |= CAN_TSR_ABRQ2;
   \                     ??CAN_CancelTransmit_1:
   \   00000022   8168               LDR      R1,[R0, #+8]
   \   00000024   51F40001           ORRS     R1,R1,#0x800000
   \   00000028   8160               STR      R1,[R0, #+8]
    597                break;
   \   0000002A   FFE7               B.N      ??CAN_CancelTransmit_4
    598              default:
    599                break;
    600            }
    601          }
   \                     ??CAN_CancelTransmit_3:
   \                     ??CAN_CancelTransmit_4:
   \   0000002C   7047               BX       LR               ;; return
    602          
    603          /**
    604            * @brief  Releases a FIFO.
    605            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral. 
    606            * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
    607            * @retval None.
    608            */

   \                                 In section .text, align 2, keep-with-next
    609          void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
    610          {
    611            /* Check the parameters */
    612            assert_param(IS_CAN_ALL_PERIPH(CANx));
    613            assert_param(IS_CAN_FIFO(FIFONumber));
    614            /* Release FIFO0 */
    615            if (FIFONumber == CAN_FIFO0)
   \                     CAN_FIFORelease:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D1               BNE.N    ??CAN_FIFORelease_0
    616            {
    617              CANx->RF0R |= CAN_RF0R_RFOM0;
   \   00000006   C168               LDR      R1,[R0, #+12]
   \   00000008   51F02001           ORRS     R1,R1,#0x20
   \   0000000C   C160               STR      R1,[R0, #+12]
   \   0000000E   03E0               B.N      ??CAN_FIFORelease_1
    618            }
    619            /* Release FIFO1 */
    620            else /* FIFONumber == CAN_FIFO1 */
    621            {
    622              CANx->RF1R |= CAN_RF1R_RFOM1;
   \                     ??CAN_FIFORelease_0:
   \   00000010   0169               LDR      R1,[R0, #+16]
   \   00000012   51F02001           ORRS     R1,R1,#0x20
   \   00000016   0161               STR      R1,[R0, #+16]
    623            }
    624          }
   \                     ??CAN_FIFORelease_1:
   \   00000018   7047               BX       LR               ;; return
    625          
    626          /**
    627            * @brief  Returns the number of pending messages.
    628            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    629            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    630            * @retval NbMessage which is the number of pending message.
    631            */

   \                                 In section .text, align 2, keep-with-next
    632          uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
    633          {
    634            uint8_t message_pending=0;
   \                     CAN_MessagePending:
   \   00000000   0022               MOVS     R2,#+0
    635            /* Check the parameters */
    636            assert_param(IS_CAN_ALL_PERIPH(CANx));
    637            assert_param(IS_CAN_FIFO(FIFONumber));
    638            if (FIFONumber == CAN_FIFO0)
   \   00000002   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0029               CMP      R1,#+0
   \   00000006   03D1               BNE.N    ??CAN_MessagePending_0
    639            {
    640              message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
   \   00000008   C068               LDR      R0,[R0, #+12]
   \   0000000A   10F00302           ANDS     R2,R0,#0x3
   \   0000000E   07E0               B.N      ??CAN_MessagePending_1
    641            }
    642            else if (FIFONumber == CAN_FIFO1)
   \                     ??CAN_MessagePending_0:
   \   00000010   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0129               CMP      R1,#+1
   \   00000014   03D1               BNE.N    ??CAN_MessagePending_2
    643            {
    644              message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
   \   00000016   0069               LDR      R0,[R0, #+16]
   \   00000018   10F00302           ANDS     R2,R0,#0x3
   \   0000001C   00E0               B.N      ??CAN_MessagePending_1
    645            }
    646            else
    647            {
    648              message_pending = 0;
   \                     ??CAN_MessagePending_2:
   \   0000001E   0022               MOVS     R2,#+0
    649            }
    650            return message_pending;
   \                     ??CAN_MessagePending_1:
   \   00000020   1000               MOVS     R0,R2
   \   00000022   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   7047               BX       LR               ;; return
    651          }
    652          
    653          /**
    654            * @brief  Receives a message.
    655            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    656            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    657            * @param  RxMessage: pointer to a structure receive message which 
    658            *   contains CAN Id, CAN DLC, CAN datas and FMI number.
    659            * @retval None.
    660            */

   \                                 In section .text, align 2, keep-with-next
    661          void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
    662          {
   \                     CAN_Receive:
   \   00000000   80B5               PUSH     {R7,LR}
    663            /* Check the parameters */
    664            assert_param(IS_CAN_ALL_PERIPH(CANx));
    665            assert_param(IS_CAN_FIFO(FIFONumber));
    666            /* Get the Id */
    667            RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
   \   00000002   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   10EB0113           ADDS     R3,R0,R1, LSL #+4
   \   00000008   D3F8B031           LDR      R3,[R3, #+432]
   \   0000000C   13F00403           ANDS     R3,R3,#0x4
   \   00000010   1372               STRB     R3,[R2, #+8]
    668            if (RxMessage->IDE == CAN_ID_STD)
   \   00000012   137A               LDRB     R3,[R2, #+8]
   \   00000014   002B               CMP      R3,#+0
   \   00000016   07D1               BNE.N    ??CAN_Receive_0
    669            {
    670              RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
   \   00000018   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   10EB0113           ADDS     R3,R0,R1, LSL #+4
   \   0000001E   D3F8B031           LDR      R3,[R3, #+432]
   \   00000022   5B0D               LSRS     R3,R3,#+21
   \   00000024   1360               STR      R3,[R2, #+0]
   \   00000026   06E0               B.N      ??CAN_Receive_1
    671            }
    672            else
    673            {
    674              RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
   \                     ??CAN_Receive_0:
   \   00000028   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002A   10EB0113           ADDS     R3,R0,R1, LSL #+4
   \   0000002E   D3F8B031           LDR      R3,[R3, #+432]
   \   00000032   DB08               LSRS     R3,R3,#+3
   \   00000034   5360               STR      R3,[R2, #+4]
    675            }
    676            
    677            RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
   \                     ??CAN_Receive_1:
   \   00000036   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000038   10EB0113           ADDS     R3,R0,R1, LSL #+4
   \   0000003C   D3F8B031           LDR      R3,[R3, #+432]
   \   00000040   13F00203           ANDS     R3,R3,#0x2
   \   00000044   5372               STRB     R3,[R2, #+9]
    678            /* Get the DLC */
    679            RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
   \   00000046   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000048   10EB0113           ADDS     R3,R0,R1, LSL #+4
   \   0000004C   D3F8B431           LDR      R3,[R3, #+436]
   \   00000050   13F00F03           ANDS     R3,R3,#0xF
   \   00000054   9372               STRB     R3,[R2, #+10]
    680            /* Get the FMI */
    681            RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
   \   00000056   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000058   10EB0113           ADDS     R3,R0,R1, LSL #+4
   \   0000005C   D3F8B431           LDR      R3,[R3, #+436]
   \   00000060   1B0A               LSRS     R3,R3,#+8
   \   00000062   D374               STRB     R3,[R2, #+19]
    682            /* Get the data field */
    683            RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
   \   00000064   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000066   10EB0113           ADDS     R3,R0,R1, LSL #+4
   \   0000006A   D3F8B831           LDR      R3,[R3, #+440]
   \   0000006E   D372               STRB     R3,[R2, #+11]
    684            RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
   \   00000070   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000072   10EB0113           ADDS     R3,R0,R1, LSL #+4
   \   00000076   D3F8B831           LDR      R3,[R3, #+440]
   \   0000007A   1B0A               LSRS     R3,R3,#+8
   \   0000007C   1373               STRB     R3,[R2, #+12]
    685            RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
   \   0000007E   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000080   10EB0113           ADDS     R3,R0,R1, LSL #+4
   \   00000084   D3F8B831           LDR      R3,[R3, #+440]
   \   00000088   1B0C               LSRS     R3,R3,#+16
   \   0000008A   5373               STRB     R3,[R2, #+13]
    686            RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
   \   0000008C   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008E   10EB0113           ADDS     R3,R0,R1, LSL #+4
   \   00000092   D3F8B831           LDR      R3,[R3, #+440]
   \   00000096   1B0E               LSRS     R3,R3,#+24
   \   00000098   9373               STRB     R3,[R2, #+14]
    687            RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
   \   0000009A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000009C   10EB0113           ADDS     R3,R0,R1, LSL #+4
   \   000000A0   D3F8BC31           LDR      R3,[R3, #+444]
   \   000000A4   D373               STRB     R3,[R2, #+15]
    688            RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
   \   000000A6   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A8   10EB0113           ADDS     R3,R0,R1, LSL #+4
   \   000000AC   D3F8BC31           LDR      R3,[R3, #+444]
   \   000000B0   1B0A               LSRS     R3,R3,#+8
   \   000000B2   1374               STRB     R3,[R2, #+16]
    689            RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
   \   000000B4   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B6   10EB0113           ADDS     R3,R0,R1, LSL #+4
   \   000000BA   D3F8BC31           LDR      R3,[R3, #+444]
   \   000000BE   1B0C               LSRS     R3,R3,#+16
   \   000000C0   5374               STRB     R3,[R2, #+17]
    690            RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
   \   000000C2   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000C4   10EB0113           ADDS     R3,R0,R1, LSL #+4
   \   000000C8   D3F8BC31           LDR      R3,[R3, #+444]
   \   000000CC   1B0E               LSRS     R3,R3,#+24
   \   000000CE   9374               STRB     R3,[R2, #+18]
    691            /* Release the FIFO */
    692            CAN_FIFORelease(CANx, FIFONumber);
   \   000000D0   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D2   ........           BL       CAN_FIFORelease
    693          }
   \   000000D6   01BD               POP      {R0,PC}          ;; return
    694          
    695          /**
    696            * @brief  Enables or disables the DBG Freeze for CAN.
    697            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    698            * @param  NewState: new state of the CAN peripheral.
    699            *   This parameter can be: ENABLE or DISABLE.
    700            * @retval None.
    701            */

   \                                 In section .text, align 2, keep-with-next
    702          void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
    703          {
    704            /* Check the parameters */
    705            assert_param(IS_CAN_ALL_PERIPH(CANx));
    706            assert_param(IS_FUNCTIONAL_STATE(NewState));
    707            
    708            if (NewState != DISABLE)
   \                     CAN_DBGFreeze:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??CAN_DBGFreeze_0
    709            {
    710              /* Enable Debug Freeze  */
    711              CANx->MCR |= MCR_DBF;
   \   00000006   0168               LDR      R1,[R0, #+0]
   \   00000008   51F48031           ORRS     R1,R1,#0x10000
   \   0000000C   0160               STR      R1,[R0, #+0]
   \   0000000E   03E0               B.N      ??CAN_DBGFreeze_1
    712            }
    713            else
    714            {
    715              /* Disable Debug Freeze */
    716              CANx->MCR &= ~MCR_DBF;
   \                     ??CAN_DBGFreeze_0:
   \   00000010   0168               LDR      R1,[R0, #+0]
   \   00000012   31F48031           BICS     R1,R1,#0x10000
   \   00000016   0160               STR      R1,[R0, #+0]
    717            }
    718          }
   \                     ??CAN_DBGFreeze_1:
   \   00000018   7047               BX       LR               ;; return
    719          
    720          /**
    721            * @brief  Enters the low power mode.
    722            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    723            * @retval CANSLEEPOK if sleep entered, CANSLEEPFAILED in an other case.
    724            */

   \                                 In section .text, align 2, keep-with-next
    725          uint8_t CAN_Sleep(CAN_TypeDef* CANx)
    726          {
    727            uint8_t sleepstatus = CANSLEEPFAILED;
   \                     CAN_Sleep:
   \   00000000   0021               MOVS     R1,#+0
    728            
    729            /* Check the parameters */
    730            assert_param(IS_CAN_ALL_PERIPH(CANx));
    731              
    732            /* Request Sleep mode */
    733             CANx->MCR = (((CANx->MCR) & (uint32_t)(~CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
   \   00000002   0268               LDR      R2,[R0, #+0]
   \   00000004   5208               LSRS     R2,R2,#+1
   \   00000006   5200               LSLS     R2,R2,#+1
   \   00000008   52F00202           ORRS     R2,R2,#0x2
   \   0000000C   0260               STR      R2,[R0, #+0]
    734             
    735            /* Sleep mode status */
    736            if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
   \   0000000E   4068               LDR      R0,[R0, #+4]
   \   00000010   10F00300           ANDS     R0,R0,#0x3
   \   00000014   0228               CMP      R0,#+2
   \   00000016   00D1               BNE.N    ??CAN_Sleep_0
    737            {
    738              /* Sleep mode not entered */
    739              sleepstatus =  CANSLEEPOK;
   \   00000018   0121               MOVS     R1,#+1
    740            }
    741            /* At this step, sleep mode status */
    742             return (uint8_t)sleepstatus;
   \                     ??CAN_Sleep_0:
   \   0000001A   0800               MOVS     R0,R1
   \   0000001C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   7047               BX       LR               ;; return
    743          }
    744          
    745          /**
    746            * @brief  Wakes the CAN up.
    747            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    748            * @retval CANWAKEUPOK if sleep mode left, CANWAKEUPFAILED in an other case.
    749            */

   \                                 In section .text, align 2, keep-with-next
    750          uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
    751          {
    752            uint32_t wait_slak = SLAK_TIMEOUT;
   \                     CAN_WakeUp:
   \   00000000   4FF6FF72           MOVW     R2,#+65535
    753            uint8_t wakeupstatus = CANWAKEUPFAILED;
   \   00000004   0021               MOVS     R1,#+0
    754            
    755            /* Check the parameters */
    756            assert_param(IS_CAN_ALL_PERIPH(CANx));
    757              
    758            /* Wake up request */
    759            CANx->MCR &= ~CAN_MCR_SLEEP;
   \   00000006   0368               LDR      R3,[R0, #+0]
   \   00000008   33F00203           BICS     R3,R3,#0x2
   \   0000000C   0360               STR      R3,[R0, #+0]
   \   0000000E   00E0               B.N      ??CAN_WakeUp_0
    760              
    761            /* Sleep mode status */
    762            while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
    763            {
    764             wait_slak--;
   \                     ??CAN_WakeUp_1:
   \   00000010   521E               SUBS     R2,R2,#+1
    765            }
   \                     ??CAN_WakeUp_0:
   \   00000012   4368               LDR      R3,[R0, #+4]
   \   00000014   9B07               LSLS     R3,R3,#+30
   \   00000016   01D5               BPL.N    ??CAN_WakeUp_2
   \   00000018   002A               CMP      R2,#+0
   \   0000001A   F9D1               BNE.N    ??CAN_WakeUp_1
    766            if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
   \                     ??CAN_WakeUp_2:
   \   0000001C   4068               LDR      R0,[R0, #+4]
   \   0000001E   8007               LSLS     R0,R0,#+30
   \   00000020   00D4               BMI.N    ??CAN_WakeUp_3
    767            {
    768             /* Sleep mode exited */
    769              wakeupstatus = CANWAKEUPOK;
   \   00000022   0121               MOVS     R1,#+1
    770            }
    771            /* At this step, sleep mode status */
    772            return (uint8_t)wakeupstatus;
   \                     ??CAN_WakeUp_3:
   \   00000024   0800               MOVS     R0,R1
   \   00000026   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   7047               BX       LR               ;; return
    773          }
    774          
    775          /**
    776            * @brief  Checks whether the specified CAN flag is set or not.
    777            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    778            * @param  CAN_FLAG: specifies the flag to check.
    779            *   This parameter can be one of the following flags: 
    780            *         - CAN_FLAG_EWG
    781            *         - CAN_FLAG_EPV 
    782            *         - CAN_FLAG_BOF
    783            *         - CAN_FLAG_RQCP0
    784            *         - CAN_FLAG_RQCP1
    785            *         - CAN_FLAG_RQCP2
    786            *         - CAN_FLAG_FMP1   
    787            *         - CAN_FLAG_FF1       
    788            *         - CAN_FLAG_FOV1   
    789            *         - CAN_FLAG_FMP0   
    790            *         - CAN_FLAG_FF0       
    791            *         - CAN_FLAG_FOV0   
    792            *         - CAN_FLAG_WKU 
    793            *         - CAN_FLAG_SLAK  
    794            *         - CAN_FLAG_LEC       
    795            * @retval The new state of CAN_FLAG (SET or RESET).
    796            */

   \                                 In section .text, align 2, keep-with-next
    797          FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
    798          {
    799            FlagStatus bitstatus = RESET;
   \                     CAN_GetFlagStatus:
   \   00000000   0022               MOVS     R2,#+0
    800            
    801            /* Check the parameters */
    802            assert_param(IS_CAN_ALL_PERIPH(CANx));
    803            assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
    804            
    805          
    806            if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
   \   00000002   11F4700F           TST      R1,#0xF00000
   \   00000006   07D0               BEQ.N    ??CAN_GetFlagStatus_0
    807            { 
    808              /* Check the status of the specified CAN flag */
    809              if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   00000008   8069               LDR      R0,[R0, #+24]
   \   0000000A   0840               ANDS     R0,R1,R0
   \   0000000C   0003               LSLS     R0,R0,#+12
   \   0000000E   01D0               BEQ.N    ??CAN_GetFlagStatus_1
    810              { 
    811                /* CAN_FLAG is set */
    812                bitstatus = SET;
   \   00000010   0122               MOVS     R2,#+1
   \   00000012   26E0               B.N      ??CAN_GetFlagStatus_2
    813              }
    814              else
    815              { 
    816                /* CAN_FLAG is reset */
    817                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_1:
   \   00000014   0022               MOVS     R2,#+0
   \   00000016   24E0               B.N      ??CAN_GetFlagStatus_2
    818              }
    819            }
    820            else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_0:
   \   00000018   CA01               LSLS     R2,R1,#+7
   \   0000001A   07D5               BPL.N    ??CAN_GetFlagStatus_3
    821            { 
    822              /* Check the status of the specified CAN flag */
    823              if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   0000001C   4068               LDR      R0,[R0, #+4]
   \   0000001E   0840               ANDS     R0,R1,R0
   \   00000020   0003               LSLS     R0,R0,#+12
   \   00000022   01D0               BEQ.N    ??CAN_GetFlagStatus_4
    824              { 
    825                /* CAN_FLAG is set */
    826                bitstatus = SET;
   \   00000024   0122               MOVS     R2,#+1
   \   00000026   1CE0               B.N      ??CAN_GetFlagStatus_2
    827              }
    828              else
    829              { 
    830                /* CAN_FLAG is reset */
    831                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_4:
   \   00000028   0022               MOVS     R2,#+0
   \   0000002A   1AE0               B.N      ??CAN_GetFlagStatus_2
    832              }
    833            }
    834            else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_3:
   \   0000002C   0A01               LSLS     R2,R1,#+4
   \   0000002E   07D5               BPL.N    ??CAN_GetFlagStatus_5
    835            { 
    836              /* Check the status of the specified CAN flag */
    837              if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   00000030   8068               LDR      R0,[R0, #+8]
   \   00000032   0840               ANDS     R0,R1,R0
   \   00000034   0003               LSLS     R0,R0,#+12
   \   00000036   01D0               BEQ.N    ??CAN_GetFlagStatus_6
    838              { 
    839                /* CAN_FLAG is set */
    840                bitstatus = SET;
   \   00000038   0122               MOVS     R2,#+1
   \   0000003A   12E0               B.N      ??CAN_GetFlagStatus_2
    841              }
    842              else
    843              { 
    844                /* CAN_FLAG is reset */
    845                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_6:
   \   0000003C   0022               MOVS     R2,#+0
   \   0000003E   10E0               B.N      ??CAN_GetFlagStatus_2
    846              }
    847            }
    848            else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_5:
   \   00000040   8A01               LSLS     R2,R1,#+6
   \   00000042   07D5               BPL.N    ??CAN_GetFlagStatus_7
    849            { 
    850              /* Check the status of the specified CAN flag */
    851              if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   00000044   C068               LDR      R0,[R0, #+12]
   \   00000046   0840               ANDS     R0,R1,R0
   \   00000048   0003               LSLS     R0,R0,#+12
   \   0000004A   01D0               BEQ.N    ??CAN_GetFlagStatus_8
    852              { 
    853                /* CAN_FLAG is set */
    854                bitstatus = SET;
   \   0000004C   0122               MOVS     R2,#+1
   \   0000004E   08E0               B.N      ??CAN_GetFlagStatus_2
    855              }
    856              else
    857              { 
    858                /* CAN_FLAG is reset */
    859                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_8:
   \   00000050   0022               MOVS     R2,#+0
   \   00000052   06E0               B.N      ??CAN_GetFlagStatus_2
    860              }
    861            }
    862            else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
    863            { 
    864              /* Check the status of the specified CAN flag */
    865              if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_7:
   \   00000054   0069               LDR      R0,[R0, #+16]
   \   00000056   0840               ANDS     R0,R1,R0
   \   00000058   0003               LSLS     R0,R0,#+12
   \   0000005A   01D0               BEQ.N    ??CAN_GetFlagStatus_9
    866              { 
    867                /* CAN_FLAG is set */
    868                bitstatus = SET;
   \   0000005C   0122               MOVS     R2,#+1
   \   0000005E   00E0               B.N      ??CAN_GetFlagStatus_2
    869              }
    870              else
    871              { 
    872                /* CAN_FLAG is reset */
    873                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_9:
   \   00000060   0022               MOVS     R2,#+0
    874              }
    875            }
    876            /* Return the CAN_FLAG status */
    877            return  bitstatus;
   \                     ??CAN_GetFlagStatus_2:
   \   00000062   1000               MOVS     R0,R2
   \   00000064   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   7047               BX       LR               ;; return
    878          }
    879          
    880          /**
    881            * @brief  Clears the CAN's pending flags.
    882            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    883            * @param  CAN_FLAG: specifies the flag to clear.
    884            *   This parameter can be one of the following flags: 
    885            *         - CAN_FLAG_RQCP0
    886            *         - CAN_FLAG_RQCP1
    887            *         - CAN_FLAG_RQCP2
    888            *         - CAN_FLAG_FF1       
    889            *         - CAN_FLAG_FOV1   
    890            *         - CAN_FLAG_FF0       
    891            *         - CAN_FLAG_FOV0   
    892            *         - CAN_FLAG_WKU   
    893            *         - CAN_FLAG_SLAK    
    894            *         - CAN_FLAG_LEC       
    895            * @retval None.
    896            */

   \                                 In section .text, align 2, keep-with-next
    897          void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
    898          {
    899            uint32_t flagtmp=0;
   \                     CAN_ClearFlag:
   \   00000000   0022               MOVS     R2,#+0
    900            /* Check the parameters */
    901            assert_param(IS_CAN_ALL_PERIPH(CANx));
    902            assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
    903            
    904            if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
   \   00000002   ....               LDR.N    R3,??DataTable5_8  ;; 0x30f00070
   \   00000004   9942               CMP      R1,R3
   \   00000006   02D1               BNE.N    ??CAN_ClearFlag_0
    905            {
    906              /* Clear the selected CAN flags */
    907              CANx->ESR = (uint32_t)RESET;
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   8161               STR      R1,[R0, #+24]
   \   0000000C   0EE0               B.N      ??CAN_ClearFlag_1
    908            }
    909            else /* MSR or TSR or RF0R or RF1R */
    910            {
    911              flagtmp = CAN_FLAG & 0x000FFFFF;
   \                     ??CAN_ClearFlag_0:
   \   0000000E   0A03               LSLS     R2,R1,#+12
   \   00000010   120B               LSRS     R2,R2,#+12
    912          
    913              if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
   \   00000012   8B01               LSLS     R3,R1,#+6
   \   00000014   01D5               BPL.N    ??CAN_ClearFlag_2
    914              {
    915                /* Receive Flags */
    916                CANx->RF0R = (uint32_t)(flagtmp);
   \   00000016   C260               STR      R2,[R0, #+12]
   \   00000018   08E0               B.N      ??CAN_ClearFlag_1
    917              }
    918              else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
   \                     ??CAN_ClearFlag_2:
   \   0000001A   4B01               LSLS     R3,R1,#+5
   \   0000001C   01D5               BPL.N    ??CAN_ClearFlag_3
    919              {
    920                /* Receive Flags */
    921                CANx->RF1R = (uint32_t)(flagtmp);
   \   0000001E   0261               STR      R2,[R0, #+16]
   \   00000020   04E0               B.N      ??CAN_ClearFlag_1
    922              }
    923              else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
   \                     ??CAN_ClearFlag_3:
   \   00000022   0901               LSLS     R1,R1,#+4
   \   00000024   01D5               BPL.N    ??CAN_ClearFlag_4
    924              {
    925                /* Transmit Flags */
    926                CANx->TSR = (uint32_t)(flagtmp);
   \   00000026   8260               STR      R2,[R0, #+8]
   \   00000028   00E0               B.N      ??CAN_ClearFlag_1
    927              }
    928              else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
    929              {
    930                /* Operating mode Flags */
    931                CANx->MSR = (uint32_t)(flagtmp);
   \                     ??CAN_ClearFlag_4:
   \   0000002A   4260               STR      R2,[R0, #+4]
    932              }
    933            }
    934          }
   \                     ??CAN_ClearFlag_1:
   \   0000002C   7047               BX       LR               ;; return
    935          
    936          /**
    937            * @brief  Checks whether the specified CANx interrupt has occurred or not.
    938            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    939            * @param  CAN_IT: specifies the CAN interrupt source to check.
    940            *   This parameter can be one of the following flags: 
    941            *         -  CAN_IT_TME               
    942            *         -  CAN_IT_FMP0              
    943            *         -  CAN_IT_FF0               
    944            *         -  CAN_IT_FOV0              
    945            *         -  CAN_IT_FMP1              
    946            *         -  CAN_IT_FF1               
    947            *         -  CAN_IT_FOV1              
    948            *         -  CAN_IT_WKU  
    949            *         -  CAN_IT_SLK  
    950            *         -  CAN_IT_EWG    
    951            *         -  CAN_IT_EPV    
    952            *         -  CAN_IT_BOF    
    953            *         -  CAN_IT_LEC    
    954            *         -  CAN_IT_ERR 
    955            * @retval The current  state of CAN_IT (SET or RESET).
    956            */

   \                                 In section .text, align 2, keep-with-next
    957          ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
    958          {
   \                     CAN_GetITStatus:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
    959            ITStatus itstatus = RESET;
   \   00000004   0025               MOVS     R5,#+0
    960            /* Check the parameters */
    961            assert_param(IS_CAN_ALL_PERIPH(CANx));
    962            assert_param(IS_CAN_IT(CAN_IT));
    963            
    964            /* check the enable interrupt bit */
    965           if((CANx->IER & CAN_IT) != RESET)
   \   00000006   6069               LDR      R0,[R4, #+20]
   \   00000008   0842               TST      R0,R1
   \   0000000A   00F07F80           BEQ.W    ??CAN_GetITStatus_0
    966           {
    967             /* in case the Interrupt is enabled, .... */
    968              switch (CAN_IT)
   \   0000000E   0129               CMP      R1,#+1
   \   00000010   21D0               BEQ.N    ??CAN_GetITStatus_1
   \   00000012   0229               CMP      R1,#+2
   \   00000014   25D0               BEQ.N    ??CAN_GetITStatus_2
   \   00000016   0429               CMP      R1,#+4
   \   00000018   29D0               BEQ.N    ??CAN_GetITStatus_3
   \   0000001A   0829               CMP      R1,#+8
   \   0000001C   2DD0               BEQ.N    ??CAN_GetITStatus_4
   \   0000001E   1029               CMP      R1,#+16
   \   00000020   31D0               BEQ.N    ??CAN_GetITStatus_5
   \   00000022   2029               CMP      R1,#+32
   \   00000024   35D0               BEQ.N    ??CAN_GetITStatus_6
   \   00000026   4029               CMP      R1,#+64
   \   00000028   39D0               BEQ.N    ??CAN_GetITStatus_7
   \   0000002A   B1F5807F           CMP      R1,#+256
   \   0000002E   48D0               BEQ.N    ??CAN_GetITStatus_8
   \   00000030   B1F5007F           CMP      R1,#+512
   \   00000034   4BD0               BEQ.N    ??CAN_GetITStatus_9
   \   00000036   B1F5806F           CMP      R1,#+1024
   \   0000003A   4ED0               BEQ.N    ??CAN_GetITStatus_10
   \   0000003C   B1F5006F           CMP      R1,#+2048
   \   00000040   51D0               BEQ.N    ??CAN_GetITStatus_11
   \   00000042   B1F5004F           CMP      R1,#+32768
   \   00000046   54D0               BEQ.N    ??CAN_GetITStatus_12
   \   00000048   B1F5803F           CMP      R1,#+65536
   \   0000004C   2DD0               BEQ.N    ??CAN_GetITStatus_13
   \   0000004E   B1F5003F           CMP      R1,#+131072
   \   00000052   30D0               BEQ.N    ??CAN_GetITStatus_14
   \   00000054   58E0               B.N      ??CAN_GetITStatus_15
    969              {
    970                case CAN_IT_TME:
    971                         /* Check CAN_TSR_RQCPx bits */
    972          	      itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
   \                     ??CAN_GetITStatus_1:
   \   00000056   ....               LDR.N    R1,??DataTable5_9  ;; 0x10101
   \   00000058   A068               LDR      R0,[R4, #+8]
   \   0000005A   ........           BL       CheckITStatus
   \   0000005E   0500               MOVS     R5,R0
    973          	      break;
   \   00000060   55E0               B.N      ??CAN_GetITStatus_16
    974                case CAN_IT_FMP0:
    975                         /* Check CAN_RF0R_FMP0 bit */
    976          	      itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
   \                     ??CAN_GetITStatus_2:
   \   00000062   0321               MOVS     R1,#+3
   \   00000064   E068               LDR      R0,[R4, #+12]
   \   00000066   ........           BL       CheckITStatus
   \   0000006A   0500               MOVS     R5,R0
    977          	      break;
   \   0000006C   4FE0               B.N      ??CAN_GetITStatus_16
    978                case CAN_IT_FF0:
    979                         /* Check CAN_RF0R_FULL0 bit */
    980                        itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
   \                     ??CAN_GetITStatus_3:
   \   0000006E   0821               MOVS     R1,#+8
   \   00000070   E068               LDR      R0,[R4, #+12]
   \   00000072   ........           BL       CheckITStatus
   \   00000076   0500               MOVS     R5,R0
    981          	      break;
   \   00000078   49E0               B.N      ??CAN_GetITStatus_16
    982                case CAN_IT_FOV0:
    983                         /* Check CAN_RF0R_FOVR0 bit */
    984                        itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
   \                     ??CAN_GetITStatus_4:
   \   0000007A   1021               MOVS     R1,#+16
   \   0000007C   E068               LDR      R0,[R4, #+12]
   \   0000007E   ........           BL       CheckITStatus
   \   00000082   0500               MOVS     R5,R0
    985          	      break;
   \   00000084   43E0               B.N      ??CAN_GetITStatus_16
    986                case CAN_IT_FMP1:
    987                         /* Check CAN_RF1R_FMP1 bit */
    988                        itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
   \                     ??CAN_GetITStatus_5:
   \   00000086   0321               MOVS     R1,#+3
   \   00000088   2069               LDR      R0,[R4, #+16]
   \   0000008A   ........           BL       CheckITStatus
   \   0000008E   0500               MOVS     R5,R0
    989          	      break;
   \   00000090   3DE0               B.N      ??CAN_GetITStatus_16
    990                case CAN_IT_FF1:
    991                         /* Check CAN_RF1R_FULL1 bit */
    992          	      itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
   \                     ??CAN_GetITStatus_6:
   \   00000092   0821               MOVS     R1,#+8
   \   00000094   2069               LDR      R0,[R4, #+16]
   \   00000096   ........           BL       CheckITStatus
   \   0000009A   0500               MOVS     R5,R0
    993          	      break;
   \   0000009C   37E0               B.N      ??CAN_GetITStatus_16
    994                case CAN_IT_FOV1:
    995                         /* Check CAN_RF1R_FOVR1 bit */
    996          	      itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
   \                     ??CAN_GetITStatus_7:
   \   0000009E   1021               MOVS     R1,#+16
   \   000000A0   2069               LDR      R0,[R4, #+16]
   \   000000A2   ........           BL       CheckITStatus
   \   000000A6   0500               MOVS     R5,R0
    997          	      break;
   \   000000A8   31E0               B.N      ??CAN_GetITStatus_16
    998                case CAN_IT_WKU:
    999                         /* Check CAN_MSR_WKUI bit */
   1000                        itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
   \                     ??CAN_GetITStatus_13:
   \   000000AA   0821               MOVS     R1,#+8
   \   000000AC   6068               LDR      R0,[R4, #+4]
   \   000000AE   ........           BL       CheckITStatus
   \   000000B2   0500               MOVS     R5,R0
   1001          	      break;
   \   000000B4   2BE0               B.N      ??CAN_GetITStatus_16
   1002                case CAN_IT_SLK:
   1003                         /* Check CAN_MSR_SLAKI bit */
   1004          	      itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
   \                     ??CAN_GetITStatus_14:
   \   000000B6   1021               MOVS     R1,#+16
   \   000000B8   6068               LDR      R0,[R4, #+4]
   \   000000BA   ........           BL       CheckITStatus
   \   000000BE   0500               MOVS     R5,R0
   1005          	      break;
   \   000000C0   25E0               B.N      ??CAN_GetITStatus_16
   1006                case CAN_IT_EWG:
   1007                         /* Check CAN_ESR_EWGF bit */
   1008          	      itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
   \                     ??CAN_GetITStatus_8:
   \   000000C2   0121               MOVS     R1,#+1
   \   000000C4   A069               LDR      R0,[R4, #+24]
   \   000000C6   ........           BL       CheckITStatus
   \   000000CA   0500               MOVS     R5,R0
   1009          	      break;
   \   000000CC   1FE0               B.N      ??CAN_GetITStatus_16
   1010                case CAN_IT_EPV:
   1011                         /* Check CAN_ESR_EPVF bit */
   1012          	     itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
   \                     ??CAN_GetITStatus_9:
   \   000000CE   0221               MOVS     R1,#+2
   \   000000D0   A069               LDR      R0,[R4, #+24]
   \   000000D2   ........           BL       CheckITStatus
   \   000000D6   0500               MOVS     R5,R0
   1013          	      break;
   \   000000D8   19E0               B.N      ??CAN_GetITStatus_16
   1014                case CAN_IT_BOF:
   1015                         /* Check CAN_ESR_BOFF bit */
   1016          	     itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
   \                     ??CAN_GetITStatus_10:
   \   000000DA   0421               MOVS     R1,#+4
   \   000000DC   A069               LDR      R0,[R4, #+24]
   \   000000DE   ........           BL       CheckITStatus
   \   000000E2   0500               MOVS     R5,R0
   1017          	      break;
   \   000000E4   13E0               B.N      ??CAN_GetITStatus_16
   1018                case CAN_IT_LEC:
   1019                         /* Check CAN_ESR_LEC bit */
   1020          	     itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
   \                     ??CAN_GetITStatus_11:
   \   000000E6   7021               MOVS     R1,#+112
   \   000000E8   A069               LDR      R0,[R4, #+24]
   \   000000EA   ........           BL       CheckITStatus
   \   000000EE   0500               MOVS     R5,R0
   1021          	      break;
   \   000000F0   0DE0               B.N      ??CAN_GetITStatus_16
   1022                case CAN_IT_ERR:
   1023                         /* Check CAN_MSR_ERRI, CAN_ESR_EWGF, CAN_ESR_EPVF, CAN_ESR_BOFF and CAN_ESR_LEC  bits */
   1024          	      itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF|CAN_ESR_EPVF|CAN_ESR_BOFF|CAN_ESR_LEC); 
   \                     ??CAN_GetITStatus_12:
   \   000000F2   7721               MOVS     R1,#+119
   \   000000F4   A069               LDR      R0,[R4, #+24]
   \   000000F6   ........           BL       CheckITStatus
   \   000000FA   0500               MOVS     R5,R0
   1025                        itstatus |= CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
   \   000000FC   0421               MOVS     R1,#+4
   \   000000FE   6068               LDR      R0,[R4, #+4]
   \   00000100   ........           BL       CheckITStatus
   \   00000104   0543               ORRS     R5,R0,R5
   1026          	      break;
   \   00000106   02E0               B.N      ??CAN_GetITStatus_16
   1027                default :
   1028                         /* in case of error, return RESET */
   1029                        itstatus = RESET;
   \                     ??CAN_GetITStatus_15:
   \   00000108   0025               MOVS     R5,#+0
   1030                        break;
   \   0000010A   00E0               B.N      ??CAN_GetITStatus_16
   1031              }
   1032            }
   1033            else
   1034            {
   1035             /* in case the Interrupt is not enabled, return RESET */
   1036              itstatus  = RESET;
   \                     ??CAN_GetITStatus_0:
   \   0000010C   0025               MOVS     R5,#+0
   1037            }
   1038            
   1039            /* Return the CAN_IT status */
   1040            return  itstatus;
   \                     ??CAN_GetITStatus_16:
   \   0000010E   2800               MOVS     R0,R5
   \   00000110   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000112   32BD               POP      {R1,R4,R5,PC}    ;; return
   1041          }
   1042          
   1043          /**
   1044            * @brief  Clears the CANxs interrupt pending bits.
   1045            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1046            * @param  CAN_IT: specifies the interrupt pending bit to clear.
   1047            *         -  CAN_IT_TME                     
   1048            *         -  CAN_IT_FF0               
   1049            *         -  CAN_IT_FOV0                     
   1050            *         -  CAN_IT_FF1               
   1051            *         -  CAN_IT_FOV1              
   1052            *         -  CAN_IT_WKU  
   1053            *         -  CAN_IT_SLK  
   1054            *         -  CAN_IT_EWG    
   1055            *         -  CAN_IT_EPV    
   1056            *         -  CAN_IT_BOF    
   1057            *         -  CAN_IT_LEC    
   1058            *         -  CAN_IT_ERR 
   1059            * @retval None.
   1060            */

   \                                 In section .text, align 2, keep-with-next
   1061          void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1062          {
   1063            /* Check the parameters */
   1064            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1065            assert_param(IS_CAN_CLEAR_IT(CAN_IT));
   1066          
   1067            switch (CAN_IT)
   \                     CAN_ClearITPendingBit:
   \   00000000   0129               CMP      R1,#+1
   \   00000002   1DD0               BEQ.N    ??CAN_ClearITPendingBit_0
   \   00000004   0429               CMP      R1,#+4
   \   00000006   1ED0               BEQ.N    ??CAN_ClearITPendingBit_1
   \   00000008   0829               CMP      R1,#+8
   \   0000000A   1FD0               BEQ.N    ??CAN_ClearITPendingBit_2
   \   0000000C   2029               CMP      R1,#+32
   \   0000000E   20D0               BEQ.N    ??CAN_ClearITPendingBit_3
   \   00000010   4029               CMP      R1,#+64
   \   00000012   21D0               BEQ.N    ??CAN_ClearITPendingBit_4
   \   00000014   B1F5807F           CMP      R1,#+256
   \   00000018   27D0               BEQ.N    ??CAN_ClearITPendingBit_5
   \   0000001A   B1F5007F           CMP      R1,#+512
   \   0000001E   27D0               BEQ.N    ??CAN_ClearITPendingBit_6
   \   00000020   B1F5806F           CMP      R1,#+1024
   \   00000024   27D0               BEQ.N    ??CAN_ClearITPendingBit_7
   \   00000026   B1F5006F           CMP      R1,#+2048
   \   0000002A   27D0               BEQ.N    ??CAN_ClearITPendingBit_8
   \   0000002C   B1F5004F           CMP      R1,#+32768
   \   00000030   29D0               BEQ.N    ??CAN_ClearITPendingBit_9
   \   00000032   B1F5803F           CMP      R1,#+65536
   \   00000036   12D0               BEQ.N    ??CAN_ClearITPendingBit_10
   \   00000038   B1F5003F           CMP      R1,#+131072
   \   0000003C   12D0               BEQ.N    ??CAN_ClearITPendingBit_11
   \   0000003E   27E0               B.N      ??CAN_ClearITPendingBit_12
   1068            {
   1069                case CAN_IT_TME:
   1070                        /* Clear CAN_TSR_RQCPx (rc_w1)*/
   1071          	      CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
   \                     ??CAN_ClearITPendingBit_0:
   \   00000040   ....               LDR.N    R1,??DataTable5_9  ;; 0x10101
   \   00000042   8160               STR      R1,[R0, #+8]
   1072          	      break;
   \   00000044   24E0               B.N      ??CAN_ClearITPendingBit_13
   1073                case CAN_IT_FF0:
   1074                        /* Clear CAN_RF0R_FULL0 (rc_w1)*/
   1075          	      CANx->RF0R = CAN_RF0R_FULL0; 
   \                     ??CAN_ClearITPendingBit_1:
   \   00000046   0821               MOVS     R1,#+8
   \   00000048   C160               STR      R1,[R0, #+12]
   1076          	      break;
   \   0000004A   21E0               B.N      ??CAN_ClearITPendingBit_13
   1077                case CAN_IT_FOV0:
   1078                        /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
   1079          	      CANx->RF0R = CAN_RF0R_FOVR0; 
   \                     ??CAN_ClearITPendingBit_2:
   \   0000004C   1021               MOVS     R1,#+16
   \   0000004E   C160               STR      R1,[R0, #+12]
   1080          	      break;
   \   00000050   1EE0               B.N      ??CAN_ClearITPendingBit_13
   1081                case CAN_IT_FF1:
   1082                        /* Clear CAN_RF1R_FULL1 (rc_w1)*/
   1083          	      CANx->RF1R = CAN_RF1R_FULL1;  
   \                     ??CAN_ClearITPendingBit_3:
   \   00000052   0821               MOVS     R1,#+8
   \   00000054   0161               STR      R1,[R0, #+16]
   1084          	      break;
   \   00000056   1BE0               B.N      ??CAN_ClearITPendingBit_13
   1085                case CAN_IT_FOV1:
   1086                        /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
   1087          	      CANx->RF1R = CAN_RF1R_FOVR1; 
   \                     ??CAN_ClearITPendingBit_4:
   \   00000058   1021               MOVS     R1,#+16
   \   0000005A   0161               STR      R1,[R0, #+16]
   1088          	      break;
   \   0000005C   18E0               B.N      ??CAN_ClearITPendingBit_13
   1089                case CAN_IT_WKU:
   1090                        /* Clear CAN_MSR_WKUI (rc_w1)*/
   1091          	      CANx->MSR = CAN_MSR_WKUI;  
   \                     ??CAN_ClearITPendingBit_10:
   \   0000005E   0821               MOVS     R1,#+8
   \   00000060   4160               STR      R1,[R0, #+4]
   1092          	      break;
   \   00000062   15E0               B.N      ??CAN_ClearITPendingBit_13
   1093                case CAN_IT_SLK:
   1094                        /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
   1095          	      CANx->MSR = CAN_MSR_SLAKI;   
   \                     ??CAN_ClearITPendingBit_11:
   \   00000064   1021               MOVS     R1,#+16
   \   00000066   4160               STR      R1,[R0, #+4]
   1096          	      break;
   \   00000068   12E0               B.N      ??CAN_ClearITPendingBit_13
   1097                case CAN_IT_EWG:
   1098                        /* Clear CAN_MSR_ERRI (rc_w1) */
   1099          	      CANx->MSR = CAN_MSR_ERRI;
   \                     ??CAN_ClearITPendingBit_5:
   \   0000006A   0421               MOVS     R1,#+4
   \   0000006C   4160               STR      R1,[R0, #+4]
   1100                        /* Note : the corresponding Flag is cleared by hardware depending of the CAN Bus status*/ 
   1101          	      break;
   \   0000006E   0FE0               B.N      ??CAN_ClearITPendingBit_13
   1102                case CAN_IT_EPV:
   1103                        /* Clear CAN_MSR_ERRI (rc_w1) */
   1104          	      CANx->MSR = CAN_MSR_ERRI; 
   \                     ??CAN_ClearITPendingBit_6:
   \   00000070   0421               MOVS     R1,#+4
   \   00000072   4160               STR      R1,[R0, #+4]
   1105                        /* Note : the corresponding Flag is cleared by hardware depending of the CAN Bus status*/
   1106          	      break;
   \   00000074   0CE0               B.N      ??CAN_ClearITPendingBit_13
   1107                case CAN_IT_BOF:
   1108                        /* Clear CAN_MSR_ERRI (rc_w1) */ 
   1109          	      CANx->MSR = CAN_MSR_ERRI; 
   \                     ??CAN_ClearITPendingBit_7:
   \   00000076   0421               MOVS     R1,#+4
   \   00000078   4160               STR      R1,[R0, #+4]
   1110                        /* Note : the corresponding Flag is cleared by hardware depending of the CAN Bus status*/
   1111          	      break;
   \   0000007A   09E0               B.N      ??CAN_ClearITPendingBit_13
   1112                case CAN_IT_LEC:
   1113                        /*  Clear LEC bits */
   1114          	      CANx->ESR = RESET; 
   \                     ??CAN_ClearITPendingBit_8:
   \   0000007C   0021               MOVS     R1,#+0
   \   0000007E   8161               STR      R1,[R0, #+24]
   1115                        /* Clear CAN_MSR_ERRI (rc_w1) */
   1116          	      CANx->MSR = CAN_MSR_ERRI; 
   \   00000080   0421               MOVS     R1,#+4
   \   00000082   4160               STR      R1,[R0, #+4]
   1117          	      break;
   \   00000084   04E0               B.N      ??CAN_ClearITPendingBit_13
   1118                case CAN_IT_ERR:
   1119                        /*Clear LEC bits */
   1120          	      CANx->ESR = RESET; 
   \                     ??CAN_ClearITPendingBit_9:
   \   00000086   0021               MOVS     R1,#+0
   \   00000088   8161               STR      R1,[R0, #+24]
   1121                        /* Clear CAN_MSR_ERRI (rc_w1) */
   1122          	      CANx->MSR = CAN_MSR_ERRI; 
   \   0000008A   0421               MOVS     R1,#+4
   \   0000008C   4160               STR      R1,[R0, #+4]
   1123          	      /* Note : BOFF, EPVF and EWGF Flags are cleared by hardware depending of the CAN Bus status*/
   1124          	      break;
   \   0000008E   FFE7               B.N      ??CAN_ClearITPendingBit_13
   1125                default :
   1126          	      break;
   1127             }
   1128          }
   \                     ??CAN_ClearITPendingBit_12:
   \                     ??CAN_ClearITPendingBit_13:
   \   00000090   7047               BX       LR               ;; return
   1129          
   1130          /**
   1131            * @brief  Checks whether the CAN interrupt has occurred or not.
   1132            * @param  CAN_Reg: specifies the CAN interrupt register to check.
   1133            * @param  It_Bit: specifies the interrupt source bit to check.
   1134            * @retval The new state of the CAN Interrupt (SET or RESET).
   1135            */

   \                                 In section .text, align 2, keep-with-next
   1136          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
   1137          {
   1138            ITStatus pendingbitstatus = RESET;
   \                     CheckITStatus:
   \   00000000   0022               MOVS     R2,#+0
   1139            
   1140            if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
   \   00000002   0842               TST      R0,R1
   \   00000004   01D0               BEQ.N    ??CheckITStatus_0
   1141            {
   1142              /* CAN_IT is set */
   1143              pendingbitstatus = SET;
   \   00000006   0122               MOVS     R2,#+1
   \   00000008   00E0               B.N      ??CheckITStatus_1
   1144            }
   1145            else
   1146            {
   1147              /* CAN_IT is reset */
   1148              pendingbitstatus = RESET;
   \                     ??CheckITStatus_0:
   \   0000000A   0022               MOVS     R2,#+0
   1149            }
   1150            return pendingbitstatus;
   \                     ??CheckITStatus_1:
   \   0000000C   1000               MOVS     R0,R2
   \   0000000E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   7047               BX       LR               ;; return
   1151          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   00640040           DC32     0x40006400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   00660040           DC32     0x40006600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   1C660040           DC32     0x4000661c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0C660040           DC32     0x4000660c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   40660040           DC32     0x40006640

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   04660040           DC32     0x40006604

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   14660040           DC32     0x40006614

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   F1C0FFFF           DC32     0xffffc0f1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   7000F030           DC32     0x30f00070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   01010100           DC32     0x10101
   1152          
   1153          /**
   1154            * @}
   1155            */
   1156          
   1157          /**
   1158            * @}
   1159            */
   1160          
   1161          /**
   1162            * @}
   1163            */
   1164          
   1165          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function              .cstack
     --------              -------
     CAN_CancelTransmit         0
     CAN_ClearFlag              0
     CAN_ClearITPendingBit      0
     CAN_DBGFreeze              0
     CAN_DeInit                 8
     CAN_FIFORelease            0
     CAN_FilterInit             4
     CAN_GetFlagStatus          0
     CAN_GetITStatus           16
     CAN_ITConfig               0
     CAN_Init                   4
     CAN_MessagePending         0
     CAN_Receive                8
     CAN_SlaveStartBank         0
     CAN_Sleep                  0
     CAN_StructInit             0
     CAN_Transmit               8
     CAN_TransmitStatus         0
     CAN_WakeUp                 0
     CheckITStatus              0


   Section sizes:

     Function/Label        Bytes
     --------------        -----
     CAN_DeInit              54
     CAN_Init               272
     CAN_FilterInit         274
     CAN_StructInit          46
     CAN_SlaveStartBank      70
     CAN_ITConfig            24
     CAN_Transmit           286
     CAN_TransmitStatus     150
     CAN_CancelTransmit      46
     CAN_FIFORelease         26
     CAN_MessagePending      38
     CAN_Receive            216
     CAN_DBGFreeze           26
     CAN_Sleep               32
     CAN_WakeUp              42
     CAN_GetFlagStatus      104
     CAN_ClearFlag           46
     CAN_GetITStatus        276
     CAN_ClearITPendingBit  146
     CheckITStatus           18
     ??DataTable5             4
     ??DataTable5_1           4
     ??DataTable5_2           4
     ??DataTable5_3           4
     ??DataTable5_4           4
     ??DataTable5_5           4
     ??DataTable5_6           4
     ??DataTable5_7           4
     ??DataTable5_8           4
     ??DataTable5_9           4

 
 2 232 bytes in section .text
 
 2 232 bytes of CODE memory

Errors: none
Warnings: none
