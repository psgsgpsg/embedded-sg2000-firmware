###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     15/Dec/2011  01:44:40 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\nand_if #
#                    .c                                                       #
#    Command line =  "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\nand_i #
#                    f.c" -D USE_STDPERIPH_DRIVER -D STM32F2XX -D             #
#                    USE_STM3220F_EVAL -D USE_USB_OTG_FS -D                   #
#                    RTC_CLOCK_SOURCE_LSE -lC "F:\¹¬ÀÛ¾÷\[ NewDTG             #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\STM3220F_EVAL\List\" #
#                     -lA "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\E #
#                    WARM\STM3220F_EVAL\List\" -o "F:\¹¬ÀÛ¾÷\[ NewDTG         #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\STM3220F_EVAL\Obj\"  #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0\arm\INC\c\DLib_Config_Full.h" -I           #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                              #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\CMSI #
#                    S\CM3\CoreSupport\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG               #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\CMSI #
#                    S\CM3\DeviceSupport\ST\STM32F2xx\" -I "F:\¹¬ÀÛ¾÷\[       #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Librari #
#                    es\STM32F2xx_StdPeriph_Driver\inc\" -I "F:\¹¬ÀÛ¾÷\[      #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utiliti #
#                    es\STM32_EVAL\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\Common\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\STM3220F_EVAL\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_OTG_Driver\inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Core\inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Class\msc\inc\" -I "F:\¹¬ÀÛ¾÷\[     #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\" -I   #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\Usb\Inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                      #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\src\" -I      #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Core\inc\" -I     #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\"   #
#                    -Ol --use_c++_inline                                     #
#    List file    =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\List\nand_if.lst                            #
#    Object file  =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\Obj\nand_if.o                               #
#                                                                             #
#                                                                             #
###############################################################################

F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\nand_if.c
      1          /******************** (C) COPYRIGHT 2007 STMicroelectronics ********************
      2          * File Name          : NAND_if.c
      3          * Author             : MCD Application Team
      4          * Version            : VX.YZ
      5          * Date               : mm/dd/yyyy
      6          * Description        : specific media access Layer for NAND flash
      7          *                      
      8          ********************************************************************************
      9          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     10          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     11          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     12          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     13          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     14          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     15          *******************************************************************************/
     16          
     17          /* Includes ------------------------------------------------------------------*/
     18          #include "fsmc_nand.h"
     19          #include "nand_if.h"
     20          #include "Eeprom.h"
     21          
     22          //#include "stm32f10x_fsmc.h"
     23          
     24          //extern u8 Test_Buffer[NAND_PAGE_SIZE];
     25          /* Private variables ---------------------------------------------------------*/
     26          //volatile u16 LUT[MAX_PHY_BLOCKS_PER_ZONE]; //Look Up Table Buffer

   \                                 In section .bss, align 4
     27          _LookUpTable LookUpTable;
   \                     LookUpTable:
   \   00000000                      DS8 4156
     28          //WRITE_STATE Write_State;
     29          //BLOCK_STATE Block_State;
     30          

   \                                 In section .bss, align 2
     31          u16  phBlock, LogAddress, Initial_Page, CurrentZone = 0;
   \                     phBlock:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     LogAddress:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     Initial_Page:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     CurrentZone:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     32          u16  Written_Pages = 0;
   \                     Written_Pages:
   \   00000000                      DS8 2
     33          

   \                                 In section .bss, align 4
     34          NAND_ADDRESS wAddress;
   \                     wAddress:
   \   00000000                      DS8 8
     35          
     36          u16 NAND_BuildLUT (u8 ZoneNbr);
     37          
     38          SPARE_AREA ReadSpareArea(u32 address);
     39          static NAND_ADDRESS NAND_ConvertPhyAddress(u32 Address);
     40          static u16 NAND_GetFreeBlock(void);
     41          static u16 NAND_Write_Cleanup (void);

   \                                 In section .bss, align 4
     42               u16 LUT[MAX_PHY_BLOCKS_PER_ZONE]; //Look Up Table Buffer
   \                     LUT:
   \   00000000                      DS8 4152
     43          /* Private typedef -----------------------------------------------------------*/
     44          /* Private define ------------------------------------------------------------*/
     45          /* Private macro -------------------------------------------------------------*/
     46          /* Private variables ---------------------------------------------------------*/
     47          /* Private function prototypes -----------------------------------------------*/
     48          /* Private functions ---------------------------------------------------------*/
     49          NAND_ADDRESS NAND_GetAddress (u32 Address);
     50          /*******************************************************************************
     51          * Function Name  : NAND_If_Init
     52          * Description    : Initializes the Media on the STM32 
     53          * Input          : None
     54          * Output         : None
     55          * Return         : None
     56          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     57          void NAND_If_Init(void)
     58          {
   \                     NAND_If_Init:
   \   00000000   80B5               PUSH     {R7,LR}
     59               NAND_BuildLUT(0);
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   ........           BL       NAND_BuildLUT
     60          }
   \   00000008   01BD               POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
     61          void Set_NAND_PageBADBlock(u16 Index)
     62          {
   \                     Set_NAND_PageBADBlock:
   \   00000000   82B0               SUB      SP,SP,#+8
     63               u16 Temp,Block,Zone;
     64          	
     65               u16 i;
     66               
     67          	NAND_ADDRESS Address;
     68          	
     69          	Temp = Index ;		// ÇØ´õ ºÎºÐ µ¥ÀÌÅÍ ¶ç¿ì°í °è»ê
     70          
     71          	Block = Temp / 128;
   \   00000002   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   8021               MOVS     R1,#+128
   \   00000006   90FBF1F1           SDIV     R1,R0,R1
     72          	
     73          	Address.Page = Temp - ( Block * 128);	
   \   0000000A   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000C   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   8022               MOVS     R2,#+128
   \   00000010   02FB1100           MLS      R0,R2,R1,R0
   \   00000014   ADF80400           STRH     R0,[SP, #+4]
     74          	
     75          	Zone = Block / 2076;          // ÃÑºí·° °¹¼ö »çÀÌÁî
   \   00000018   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001A   40F61C00           MOVW     R0,#+2076
   \   0000001E   91FBF0F0           SDIV     R0,R1,R0
     76          	
     77               Address.Block = Block - ( Zone * 2076 );	
   \   00000022   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000024   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000026   40F61C02           MOVW     R2,#+2076
   \   0000002A   02FB1011           MLS      R1,R2,R0,R1
   \   0000002E   ADF80210           STRH     R1,[SP, #+2]
     78               
     79               for( i = 2075 ; i > Address.Block ; i-- )
   \   00000032   40F61B01           MOVW     R1,#+2075
   \   00000036   0BE0               B.N      ??Set_NAND_PageBADBlock_0
     80               {               
     81                    LookUpTable.LUT[ i + 1 ] = LookUpTable.LUT[i] ;
   \                     ??Set_NAND_PageBADBlock_1:
   \   00000038   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000003A   ........           LDR.W    R2,??DataTable6
   \   0000003E   12EB4102           ADDS     R2,R2,R1, LSL #+1
   \   00000042   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000044   ........           LDR.W    R3,??DataTable6
   \   00000048   33F81130           LDRH     R3,[R3, R1, LSL #+1]
   \   0000004C   5380               STRH     R3,[R2, #+2]
     82               }
   \   0000004E   491E               SUBS     R1,R1,#+1
   \                     ??Set_NAND_PageBADBlock_0:
   \   00000050   BDF80220           LDRH     R2,[SP, #+2]
   \   00000054   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000056   8A42               CMP      R2,R1
   \   00000058   EED3               BCC.N    ??Set_NAND_PageBADBlock_1
     83          
     84               LookUpTable.LUT[Address.Block] = 0; /* Block Index + flags */          
   \   0000005A   BDF80210           LDRH     R1,[SP, #+2]
   \   0000005E   ........           LDR.W    R2,??DataTable6
   \   00000062   0023               MOVS     R3,#+0
   \   00000064   22F81130           STRH     R3,[R2, R1, LSL #+1]
     85               Address.Zone = Zone; 
   \   00000068   ADF80000           STRH     R0,[SP, #+0]
     86          
     87          //	return Address;
     88          }
   \   0000006C   02B0               ADD      SP,SP,#+8
   \   0000006E   7047               BX       LR               ;; return
     89          

   \                                 In section .text, align 2, keep-with-next
     90          NAND_ADDRESS Get_NAND_PageAddress(u16 Index)
     91          {
   \                     Get_NAND_PageAddress:
   \   00000000   C0B5               PUSH     {R6,R7,LR}
     92          	u16 Temp,Block,Zone;
     93          	
     94          	NAND_ADDRESS Address;
     95          	
     96          	Temp = Index ;		// ÇØ´õ ºÎºÐ µ¥ÀÌÅÍ ¶ç¿ì°í °è»ê
     97          #ifdef NAND4G
     98          	Blcok = Temp / 64;
     99          	
    100          	Address.Page = Temp - ( Blcok * 64);	
    101          	
    102          	Zone = Blcok / 4096;          // ÃÑºí·° °¹¼ö »çÀÌÁî
    103          	Address.Block = Blcok - ( Zone * 4096 );	
    104              	Address.Zone = Zone; 
    105          #else
    106          
    107          
    108          	Block = Temp / 128;
   \   00000002   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000004   8022               MOVS     R2,#+128
   \   00000006   91FBF2F2           SDIV     R2,R1,R2
    109          	
    110          	Address.Page = Temp - ( Block * 128);	
   \   0000000A   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000E   8023               MOVS     R3,#+128
   \   00000010   03FB1211           MLS      R1,R3,R2,R1
   \   00000014   ADF80410           STRH     R1,[SP, #+4]
    111          	
    112          	Zone = Block / 2076;          // ÃÑºí·° °¹¼ö »çÀÌÁî
   \   00000018   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001A   40F61C01           MOVW     R1,#+2076
   \   0000001E   92FBF1F1           SDIV     R1,R2,R1
    113          	
    114               Address.Block = Block - ( Zone * 2076 );	
   \   00000022   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000024   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000026   40F61C03           MOVW     R3,#+2076
   \   0000002A   03FB1121           MLS      R1,R3,R1,R2
   \   0000002E   ADF80210           STRH     R1,[SP, #+2]
    115               
    116          //     if(Address.Block != 0 && LookUpTable.LUT[Address.Block] == 0)          
    117          //          Address.Block = 
    118          //     else
    119                    Address.Block = LookUpTable.LUT[Address.Block]; /* Block Index + flags */     
   \   00000032   BDF80210           LDRH     R1,[SP, #+2]
   \   00000036   ....               LDR.N    R2,??DataTable6
   \   00000038   32F81110           LDRH     R1,[R2, R1, LSL #+1]
   \   0000003C   ADF80210           STRH     R1,[SP, #+2]
    120               
    121               Address.Zone = 0;      //Zone;          // 
   \   00000040   0021               MOVS     R1,#+0
   \   00000042   ADF80010           STRH     R1,[SP, #+0]
    122          #endif
    123          	return Address;
   \   00000046   00A9               ADD      R1,SP,#+0
   \   00000048   0622               MOVS     R2,#+6
   \   0000004A   ........           BL       __aeabi_memcpy
   \   0000004E   06BD               POP      {R1,R2,PC}       ;; return
    124          }
    125          
    126          /*******************************************************************************
    127          * Function Name  : NAND_Format
    128          * Description    : Format the entire NAND flash
    129          * Input          : None
    130          * Output         : None
    131          * Return         : Status
    132          *******************************************************************************/

   \                                 In section .bss, align 4
    133          u32 test_length;
   \                     test_length:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    134          u32 test_Addr;
   \                     test_Addr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    135          u32 cal_addr;
   \                     cal_addr:
   \   00000000                      DS8 4

   \                                 In section .text, align 2, keep-with-next
    136          u16 NAND_If_Erase (u32 Address)
    137          {
   \                     NAND_If_Erase:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   83B0               SUB      SP,SP,#+12
    138            u32 Address_t;
    139            NAND_ADDRESS Address_s;
    140          
    141            Address_t = ( Address & 0x3FFFFFFF )/NAND_PAGE_SIZE; 
   \   00000004   C0F35031           UBFX     R1,R0,#+13,#+17
    142            test_Addr=Address;
   \   00000008   ....               LDR.N    R2,??DataTable6_1
   \   0000000A   1060               STR      R0,[R2, #+0]
    143            test_Addr=Address_t;
   \   0000000C   ....               LDR.N    R0,??DataTable6_1
   \   0000000E   0160               STR      R1,[R0, #+0]
    144            
    145            Address_s = NAND_GetAddress (Address_t);
   \   00000010   00A8               ADD      R0,SP,#+0
   \   00000012   ........           BL       NAND_GetAddress
    146          // bad block check ÈÄ Àû¿ë
    147            Address_s.Block = LookUpTable.LUT[Address_s.Block]; /* Block Index + flags */
   \   00000016   BDF80200           LDRH     R0,[SP, #+2]
   \   0000001A   ....               LDR.N    R1,??DataTable6
   \   0000001C   31F81000           LDRH     R0,[R1, R0, LSL #+1]
   \   00000020   ADF80200           STRH     R0,[SP, #+2]
    148            
    149            FSMC_NAND_EraseBlock (Address_s);
   \   00000024   DDE90001           LDRD     R0,R1,[SP, #+0]
   \   00000028   ........           BL       FSMC_NAND_EraseBlock
    150          
    151          //  NAND_BuildLUT(0);
    152            return NAND_OK;
   \   0000002C   0020               MOVS     R0,#+0
   \   0000002E   0EBD               POP      {R1-R3,PC}       ;; return
    153          }
    154          /*******************************************************************************
    155          * Function Name  : NAND_If_Write
    156          * Description    : Read sectors 
    157          * Input          : None
    158          * Output         : None
    159          * Return         : None
    160          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    161          u16 NAND_If_Write (u32 Address, u32 DataLength)
    162          {
   \                     NAND_If_Write:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   83B0               SUB      SP,SP,#+12
    163            u32 Address_t;
    164          
    165          
    166            test_length=DataLength;
   \   00000004   ....               LDR.N    R2,??DataTable6_2
   \   00000006   1160               STR      R1,[R2, #+0]
    167            test_Addr=Address;
   \   00000008   ....               LDR.N    R1,??DataTable6_1
   \   0000000A   0860               STR      R0,[R1, #+0]
    168          // add insem    
    169            Address_t = ( Address & 0x3FFFFFFF )/NAND_PAGE_SIZE; ; 
   \   0000000C   C0F35031           UBFX     R1,R0,#+13,#+17
    170            wAddress = NAND_GetAddress (Address_t);
   \   00000010   00A8               ADD      R0,SP,#+0
   \   00000012   ........           BL       NAND_GetAddress
   \   00000016   ....               LDR.N    R0,??DataTable6_3
   \   00000018   00A9               ADD      R1,SP,#+0
   \   0000001A   0622               MOVS     R2,#+6
   \   0000001C   ........           BL       __aeabi_memcpy
    171          
    172            // bad block check ÈÄ Àû¿ë
    173            wAddress.Block = LookUpTable.LUT[wAddress.Block]; /* Block Index + flags */
   \   00000020   ....               LDR.N    R0,??DataTable6_3
   \   00000022   4088               LDRH     R0,[R0, #+2]
   \   00000024   ....               LDR.N    R1,??DataTable6
   \   00000026   31F81000           LDRH     R0,[R1, R0, LSL #+1]
   \   0000002A   ....               LDR.N    R1,??DataTable6_3
   \   0000002C   4880               STRH     R0,[R1, #+2]
    174          
    175          //  if(DataLength<wTransferSize)  DataLength= wTransferSize;
    176            
    177            /* write Last page  */
    178           // FSMC_NAND_WriteSmallPage(MAL_Buffer , wAddress, DataLength);
    179            
    180            NAND_Write_Cleanup();
   \   0000002E   ........           BL       NAND_Write_Cleanup
    181            
    182            return 0;
   \   00000032   0020               MOVS     R0,#+0
   \   00000034   0EBD               POP      {R1-R3,PC}       ;; return
    183          }
    184          
    185          /*******************************************************************************
    186          * Function Name  : NAND_If_Read
    187          * Description    : Write sectors
    188          * Input          : None
    189          * Output         : None
    190          * Return         : buffer address pointer
    191          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    192          u16 NAND_If_Read(u32 Memory_Offset, u8 *Readbuff, u32 Transfer_Length)
    193          {
   \                     NAND_If_Read:
   \   00000000   7CB5               PUSH     {R2-R6,LR}
   \   00000002   0600               MOVS     R6,R0
   \   00000004   0C00               MOVS     R4,R1
   \   00000006   1500               MOVS     R5,R2
    194           u32 Address_t;
    195            NAND_ADDRESS wAddress;
    196           
    197            Address_t = ( Memory_Offset & 0x3FFFFFFF )/NAND_PAGE_SIZE; 
   \   00000008   C6F35031           UBFX     R1,R6,#+13,#+17
    198            Memory_Offset= Memory_Offset & 0x00000FFF ;
   \   0000000C   3605               LSLS     R6,R6,#+20
   \   0000000E   360D               LSRS     R6,R6,#+20
    199            wAddress = NAND_GetAddress(Address_t);
   \   00000010   00A8               ADD      R0,SP,#+0
   \   00000012   ........           BL       NAND_GetAddress
    200          
    201            if (wAddress.Zone != CurrentZone)
   \   00000016   BDF80000           LDRH     R0,[SP, #+0]
   \   0000001A   ....               LDR.N    R1,??DataTable6_4
   \   0000001C   0988               LDRH     R1,[R1, #+0]
   \   0000001E   8842               CMP      R0,R1
   \   00000020   08D0               BEQ.N    ??NAND_If_Read_0
    202            {
    203              CurrentZone = wAddress.Zone;
   \   00000022   ....               LDR.N    R0,??DataTable6_4
   \   00000024   BDF80010           LDRH     R1,[SP, #+0]
   \   00000028   0180               STRH     R1,[R0, #+0]
    204              NAND_BuildLUT(CurrentZone);
   \   0000002A   ....               LDR.N    R0,??DataTable6_4
   \   0000002C   0088               LDRH     R0,[R0, #+0]
   \   0000002E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   ........           BL       NAND_BuildLUT
    205            }
    206          
    207            if (LookUpTable.LUT [wAddress.Block] & BAD_BLOCK)
   \                     ??NAND_If_Read_0:
   \   00000034   BDF80200           LDRH     R0,[SP, #+2]
   \   00000038   ....               LDR.N    R1,??DataTable6
   \   0000003A   31F81000           LDRH     R0,[R1, R0, LSL #+1]
   \   0000003E   4004               LSLS     R0,R0,#+17
   \   00000040   01D5               BPL.N    ??NAND_If_Read_1
    208            {
    209              return NAND_FAIL;
   \   00000042   0120               MOVS     R0,#+1
   \   00000044   0FE0               B.N      ??NAND_If_Read_2
    210            }
    211            else
    212            {
    213          //    wAddress.Block = LUT [wAddress.Block] & ~ (USED_BLOCK | VALID_BLOCK);
    214          //    wAddress.Block = LUT [wAddress.Block];    
    215                wAddress.Block = LookUpTable.LUT [wAddress.Block] & 0x1fff;
   \                     ??NAND_If_Read_1:
   \   00000046   BDF80200           LDRH     R0,[SP, #+2]
   \   0000004A   ....               LDR.N    R1,??DataTable6
   \   0000004C   31F81000           LDRH     R0,[R1, R0, LSL #+1]
   \   00000050   C004               LSLS     R0,R0,#+19
   \   00000052   C00C               LSRS     R0,R0,#+19
   \   00000054   ADF80200           STRH     R0,[SP, #+2]
    216          
    217          //    FSMC_NAND_ReadSmallPage (Readbuff , wAddress, Transfer_Length, Memory_Offset);
    218              FSMC_NAND_ReadSmallPage (Readbuff , wAddress, Transfer_Length);
   \   00000058   2B00               MOVS     R3,R5
   \   0000005A   DDE90012           LDRD     R1,R2,[SP, #+0]
   \   0000005E   2000               MOVS     R0,R4
   \   00000060   ........           BL       FSMC_NAND_ReadSmallPage
    219            }
    220            return NAND_OK;
   \   00000064   0020               MOVS     R0,#+0
   \                     ??NAND_If_Read_2:
   \   00000066   76BD               POP      {R1,R2,R4-R6,PC}  ;; return
    221          }
    222          /*******************************************************************************
    223          * Function Name  : NAND_Write_Cleanup
    224          * Description    : None
    225          * Input          : None
    226          * Output         : None
    227          * Return         : Status
    228          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    229          static u16 NAND_Write_Cleanup (void)
    230          {
   \                     NAND_Write_Cleanup:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   87B0               SUB      SP,SP,#+28
    231            u16  tempSpareArea [8];
    232          
    233          
    234              /* assign logical address to the new used block */
    235              tempSpareArea [0] = LogAddress | USED_BLOCK ;
   \   00000004   ....               LDR.N    R0,??DataTable6_5
   \   00000006   0088               LDRH     R0,[R0, #+0]
   \   00000008   50F40040           ORRS     R0,R0,#0x8000
   \   0000000C   ADF80800           STRH     R0,[SP, #+8]
    236              tempSpareArea [1] = 0xFFFF;
   \   00000010   4FF6FF70           MOVW     R0,#+65535
   \   00000014   ADF80A00           STRH     R0,[SP, #+10]
    237              tempSpareArea [2] = 0xFFFF;
   \   00000018   4FF6FF70           MOVW     R0,#+65535
   \   0000001C   ADF80C00           STRH     R0,[SP, #+12]
    238          
    239              wAddress.Page     = 0x00;
   \   00000020   ....               LDR.N    R0,??DataTable6_3
   \   00000022   0021               MOVS     R1,#+0
   \   00000024   8180               STRH     R1,[R0, #+4]
   \   00000026   ....               LDR.N    R0,??DataTable6_3
   \   00000028   D0E90023           LDRD     R2,R3,[R0, #+0]
   \   0000002C   CDE90023           STRD     R2,R3,[SP, #+0]
    240              FSMC_NAND_WriteSpareArea((u8 *)tempSpareArea , wAddress, 1);
   \   00000030   0123               MOVS     R3,#+1
   \   00000032   DDE90012           LDRD     R1,R2,[SP, #+0]
   \   00000036   02A8               ADD      R0,SP,#+8
   \   00000038   ........           BL       FSMC_NAND_WriteSpareArea
    241          //    NAND_CleanLUT(wAddress.Zone);
    242          
    243            return NAND_OK;
   \   0000003C   0020               MOVS     R0,#+0
   \   0000003E   07B0               ADD      SP,SP,#+28
   \   00000040   00BD               POP      {PC}             ;; return
    244          }
    245          /*******************************************************************************
    246          * Function Name  : NAND_GetFreeBlock
    247          * Description    : Look for a free block for data exchange
    248          * Input          : None
    249          * Output         : None
    250          * Return         : Status
    251          *******************************************************************************/
    252          static u16 NAND_GetFreeBlock (void)
    253          {;
    254          //  return LUT[MAX_LOG_BLOCKS_PER_ZONE]& ~(USED_BLOCK | VALID_BLOCK);
    255          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "NAND_GetFreeBlock"
    256          /*******************************************************************************
    257          * Function Name  : NAND_GetPhyAddress
    258          * Description    : translate logical address into a phy one
    259          * Input          : None
    260          * Output         : None
    261          * Return         : Status
    262          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    263          NAND_ADDRESS NAND_GetAddress (u32 Address)
    264          {
   \                     NAND_GetAddress:
   \   00000000   C0B5               PUSH     {R6,R7,LR}
    265            NAND_ADDRESS Address_t;
    266          
    267            Address_t.Page  = Address & (NAND_BLOCK_SIZE - 1);
   \   00000002   11F07F02           ANDS     R2,R1,#0x7F
   \   00000006   ADF80420           STRH     R2,[SP, #+4]
    268            Address_t.Block = Address / NAND_BLOCK_SIZE;
   \   0000000A   C909               LSRS     R1,R1,#+7
   \   0000000C   ADF80210           STRH     R1,[SP, #+2]
    269            Address_t.Zone = 0;
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   ADF80010           STRH     R1,[SP, #+0]
   \   00000016   0AE0               B.N      ??NAND_GetAddress_0
    270          
    271            while (Address_t.Block >= MAX_LOG_BLOCKS_PER_ZONE)
    272            {
    273              Address_t.Block -= MAX_LOG_BLOCKS_PER_ZONE;
   \                     ??NAND_GetAddress_1:
   \   00000018   BDF80210           LDRH     R1,[SP, #+2]
   \   0000001C   B1F5FA61           SUBS     R1,R1,#+2000
   \   00000020   ADF80210           STRH     R1,[SP, #+2]
    274              Address_t.Zone++;
   \   00000024   BDF80010           LDRH     R1,[SP, #+0]
   \   00000028   491C               ADDS     R1,R1,#+1
   \   0000002A   ADF80010           STRH     R1,[SP, #+0]
    275            }
   \                     ??NAND_GetAddress_0:
   \   0000002E   BDF80210           LDRH     R1,[SP, #+2]
   \   00000032   B1F5FA6F           CMP      R1,#+2000
   \   00000036   EFD2               BCS.N    ??NAND_GetAddress_1
    276            return Address_t;
   \   00000038   00A9               ADD      R1,SP,#+0
   \   0000003A   0622               MOVS     R2,#+6
   \   0000003C   ........           BL       __aeabi_memcpy
   \   00000040   06BD               POP      {R1,R2,PC}       ;; return
    277          }
    278          /*******************************************************************************
    279          * Function Name  : ReadSpareArea
    280          * Description    : Check used block
    281          * Input          : None
    282          * Output         : None
    283          * Return         : Status
    284          *******************************************************************************/
    285          

   \                                 In section .text, align 2, keep-with-next
    286          SPARE_AREA ReadSpareArea (u32 address)
    287          {
   \                     ReadSpareArea:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   F0B0               SUB      SP,SP,#+448
   \   00000004   0400               MOVS     R4,R0
    288            SPARE_AREA t;
    289            u8 Buffer[NAND_SPARE_AREA_SIZE];
    290            NAND_ADDRESS address_s;
    291            address_s = NAND_ConvertPhyAddress(address);
   \   00000006   00A8               ADD      R0,SP,#+0
   \   00000008   ........           BL       NAND_ConvertPhyAddress
    292            FSMC_NAND_ReadSpareArea(Buffer , address_s, 1) ;
   \   0000000C   0123               MOVS     R3,#+1
   \   0000000E   DDE90012           LDRD     R1,R2,[SP, #+0]
   \   00000012   02A8               ADD      R0,SP,#+8
   \   00000014   ........           BL       FSMC_NAND_ReadSpareArea
    293          
    294            t = *(SPARE_AREA *)Buffer;
   \   00000018   00A8               ADD      R0,SP,#+0
   \   0000001A   02A9               ADD      R1,SP,#+8
   \   0000001C   0622               MOVS     R2,#+6
   \   0000001E   ........           BL       __aeabi_memcpy4
    295          
    296            return t;
   \   00000022   2000               MOVS     R0,R4
   \   00000024   00A9               ADD      R1,SP,#+0
   \   00000026   0622               MOVS     R2,#+6
   \   00000028   ........           BL       __aeabi_memcpy
   \   0000002C   70B0               ADD      SP,SP,#+448
   \   0000002E   10BD               POP      {R4,PC}          ;; return
    297          }
    298          /*******************************************************************************
    299          * Function Name  : NAND_ConvertPhyAddress
    300          * Description    : None
    301          * Input          : physical Address
    302          * Output         : None
    303          * Return         : Status
    304          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    305          static NAND_ADDRESS NAND_ConvertPhyAddress (u32 Address)
    306          {
   \                     NAND_ConvertPhyAddress:
   \   00000000   C0B5               PUSH     {R6,R7,LR}
    307            NAND_ADDRESS Address_t;
    308          
    309            Address_t.Page  = Address & (NAND_BLOCK_SIZE - 1);
   \   00000002   11F07F02           ANDS     R2,R1,#0x7F
   \   00000006   ADF80420           STRH     R2,[SP, #+4]
    310            Address_t.Block = Address / NAND_BLOCK_SIZE;
   \   0000000A   C909               LSRS     R1,R1,#+7
   \   0000000C   ADF80210           STRH     R1,[SP, #+2]
    311            Address_t.Zone = 0;
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   ADF80010           STRH     R1,[SP, #+0]
   \   00000016   0BE0               B.N      ??NAND_ConvertPhyAddress_0
    312          
    313            while (Address_t.Block >= MAX_PHY_BLOCKS_PER_ZONE)
    314            {
    315              Address_t.Block -= MAX_PHY_BLOCKS_PER_ZONE;
   \                     ??NAND_ConvertPhyAddress_1:
   \   00000018   BDF80210           LDRH     R1,[SP, #+2]
   \   0000001C   40F61C02           MOVW     R2,#+2076
   \   00000020   891A               SUBS     R1,R1,R2
   \   00000022   ADF80210           STRH     R1,[SP, #+2]
    316              Address_t.Zone++;
   \   00000026   BDF80010           LDRH     R1,[SP, #+0]
   \   0000002A   491C               ADDS     R1,R1,#+1
   \   0000002C   ADF80010           STRH     R1,[SP, #+0]
    317            }
   \                     ??NAND_ConvertPhyAddress_0:
   \   00000030   BDF80210           LDRH     R1,[SP, #+2]
   \   00000034   40F61C02           MOVW     R2,#+2076
   \   00000038   9142               CMP      R1,R2
   \   0000003A   EDD2               BCS.N    ??NAND_ConvertPhyAddress_1
    318            return Address_t;
   \   0000003C   00A9               ADD      R1,SP,#+0
   \   0000003E   0622               MOVS     R2,#+6
   \   00000040   ........           BL       __aeabi_memcpy
   \   00000044   06BD               POP      {R1,R2,PC}       ;; return
    319          }
    320          /*******************************************************************************
    321          * Function Name  : NAND_BuildLUT
    322          * Description    : Build the look up table
    323          * Input          : None
    324          * Output         : None
    325          * Return         : Status
    326          * !!!! NOTE : THIS ALGORITHM IS A SUBJECT OF PATENT FOR STMICROELECTRONICS !!!!!
    327          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    328          u16 NAND_BuildLUT (u8 ZoneNbr)
    329          {
   \                     NAND_BuildLUT:
   \   00000000   7CB5               PUSH     {R2-R6,LR}
   \   00000002   0500               MOVS     R5,R0
    330          
    331               u16  pBadBlock, pCurrentBlock, pFreeBlock;
    332               SPARE_AREA  SpareArea;
    333               
    334          /*****************************************************************************
    335                                        1st step : Init.
    336          *****************************************************************************/
    337          	/*Init the LUT (assume all blocks free) */
    338          	for (pCurrentBlock = 0 ; pCurrentBlock < MAX_PHY_BLOCKS_PER_ZONE ; pCurrentBlock++)  {
   \   00000004   0024               MOVS     R4,#+0
   \   00000006   06E0               B.N      ??NAND_BuildLUT_0
    339          		LUT[pCurrentBlock] = FREE_BLOCK;  					/* 12th bit is set to 1 */
   \                     ??NAND_BuildLUT_1:
   \   00000008   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000000A   ....               LDR.N    R0,??DataTable6_6
   \   0000000C   4FF40051           MOV      R1,#+8192
   \   00000010   20F81410           STRH     R1,[R0, R4, LSL #+1]
    340          	}
   \   00000014   641C               ADDS     R4,R4,#+1
   \                     ??NAND_BuildLUT_0:
   \   00000016   40F61C00           MOVW     R0,#+2076
   \   0000001A   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001C   8442               CMP      R4,R0
   \   0000001E   F3D3               BCC.N    ??NAND_BuildLUT_1
    341          
    342          	/* Init Pointers */
    343          	pBadBlock    = MAX_PHY_BLOCKS_PER_ZONE - 1;
   \   00000020   40F61B06           MOVW     R6,#+2075
    344          	pCurrentBlock = 0;
   \   00000024   0024               MOVS     R4,#+0
   \   00000026   22E0               B.N      ??NAND_BuildLUT_2
    345          
    346          
    347          /*****************************************************************************
    348                               2nd step : locate used and bad blocks
    349          *****************************************************************************/
    350          
    351          	while (pCurrentBlock < MAX_PHY_BLOCKS_PER_ZONE) {
    352          		SpareArea = ReadSpareArea(pCurrentBlock * NAND_BLOCK_SIZE + (ZoneNbr * NAND_BLOCK_SIZE * MAX_PHY_BLOCKS_PER_ZONE));
    353          
    354          		if ((SpareArea.DataStatus == 0) || (SpareArea.BlockStatus == 0)) {
    355          			LUT[pBadBlock--] |= pCurrentBlock | (u16)BAD_BLOCK ;
    356          			LUT[pCurrentBlock] &= (u16)~FREE_BLOCK;
    357          
    358          //			sprintf(xdebug, "bad block = %d        \r\n", pCurrentBlock); mm;
    359          			
    360          			if (pBadBlock == MAX_LOG_BLOCKS_PER_ZONE) {			
    361          				return NAND_FAIL;
    362          			}
    363          		}
    364          		else if (SpareArea.LogicalIndex != 0xFFFF) {
   \                     ??NAND_BuildLUT_3:
   \   00000028   BDF80000           LDRH     R0,[SP, #+0]
   \   0000002C   4FF6FF71           MOVW     R1,#+65535
   \   00000030   8842               CMP      R0,R1
   \   00000032   1BD0               BEQ.N    ??NAND_BuildLUT_4
    365          			LUT[SpareArea.LogicalIndex & 0x1fff] |= pCurrentBlock | USED_BLOCK;
   \   00000034   BDF80000           LDRH     R0,[SP, #+0]
   \   00000038   C004               LSLS     R0,R0,#+19
   \   0000003A   C00C               LSRS     R0,R0,#+19
   \   0000003C   ....               LDR.N    R1,??DataTable6_6
   \   0000003E   31F81000           LDRH     R0,[R1, R0, LSL #+1]
   \   00000042   54F40041           ORRS     R1,R4,#0x8000
   \   00000046   0843               ORRS     R0,R1,R0
   \   00000048   BDF80010           LDRH     R1,[SP, #+0]
   \   0000004C   C904               LSLS     R1,R1,#+19
   \   0000004E   C90C               LSRS     R1,R1,#+19
   \   00000050   ....               LDR.N    R2,??DataTable6_6
   \   00000052   22F81100           STRH     R0,[R2, R1, LSL #+1]
    366          			LUT[pCurrentBlock] &= (u16)( ~FREE_BLOCK);
   \   00000056   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000058   ....               LDR.N    R0,??DataTable6_6
   \   0000005A   30F81400           LDRH     R0,[R0, R4, LSL #+1]
   \   0000005E   4DF6FF71           MOVW     R1,#+57343
   \   00000062   0840               ANDS     R0,R1,R0
   \   00000064   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000066   ....               LDR.N    R1,??DataTable6_6
   \   00000068   21F81400           STRH     R0,[R1, R4, LSL #+1]
    367          
    368          //			sprintf(xdebug, "used block = %d\r\n", pCurrentBlock); mm;
    369          		}
    370          		pCurrentBlock++ ;
   \                     ??NAND_BuildLUT_4:
   \   0000006C   641C               ADDS     R4,R4,#+1
   \                     ??NAND_BuildLUT_2:
   \   0000006E   40F61C00           MOVW     R0,#+2076
   \   00000072   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000074   8442               CMP      R4,R0
   \   00000076   30D2               BCS.N    ??NAND_BuildLUT_5
   \   00000078   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000007A   8020               MOVS     R0,#+128
   \   0000007C   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007E   ....               LDR.N    R1,??DataTable6_7  ;; 0x40e00
   \   00000080   01FB05F1           MUL      R1,R1,R5
   \   00000084   00FB0411           MLA      R1,R0,R4,R1
   \   00000088   00A8               ADD      R0,SP,#+0
   \   0000008A   ........           BL       ReadSpareArea
   \   0000008E   BDF80200           LDRH     R0,[SP, #+2]
   \   00000092   0028               CMP      R0,#+0
   \   00000094   03D0               BEQ.N    ??NAND_BuildLUT_6
   \   00000096   BDF80400           LDRH     R0,[SP, #+4]
   \   0000009A   0028               CMP      R0,#+0
   \   0000009C   C4D1               BNE.N    ??NAND_BuildLUT_3
   \                     ??NAND_BuildLUT_6:
   \   0000009E   3000               MOVS     R0,R6
   \   000000A0   461E               SUBS     R6,R0,#+1
   \   000000A2   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A4   ....               LDR.N    R1,??DataTable6_6
   \   000000A6   31F81010           LDRH     R1,[R1, R0, LSL #+1]
   \   000000AA   54F48042           ORRS     R2,R4,#0x4000
   \   000000AE   1143               ORRS     R1,R2,R1
   \   000000B0   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B2   ....               LDR.N    R2,??DataTable6_6
   \   000000B4   22F81010           STRH     R1,[R2, R0, LSL #+1]
   \   000000B8   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000BA   ....               LDR.N    R0,??DataTable6_6
   \   000000BC   30F81400           LDRH     R0,[R0, R4, LSL #+1]
   \   000000C0   4DF6FF71           MOVW     R1,#+57343
   \   000000C4   0840               ANDS     R0,R1,R0
   \   000000C6   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000C8   ....               LDR.N    R1,??DataTable6_6
   \   000000CA   21F81400           STRH     R0,[R1, R4, LSL #+1]
   \   000000CE   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000D0   B6F5FA6F           CMP      R6,#+2000
   \   000000D4   CAD1               BNE.N    ??NAND_BuildLUT_4
   \   000000D6   0120               MOVS     R0,#+1
   \   000000D8   36E0               B.N      ??NAND_BuildLUT_7
    371          	}
    372          
    373          /*****************************************************************************
    374           3rd step : locate Free Blocks by scanning the LUT already built partially
    375          *****************************************************************************/
    376          	pFreeBlock = 0;
   \                     ??NAND_BuildLUT_5:
   \   000000DA   0020               MOVS     R0,#+0
    377          	for(pCurrentBlock = 0 ; pCurrentBlock < MAX_PHY_BLOCKS_PER_ZONE ; pCurrentBlock++ ) {
   \   000000DC   0024               MOVS     R4,#+0
   \   000000DE   06E0               B.N      ??NAND_BuildLUT_8
    378          		if(!(LUT[pCurrentBlock]& USED_BLOCK)) {
    379          			do {
    380          				if(LUT[pFreeBlock] & FREE_BLOCK) {
    381          					LUT [pCurrentBlock] |= pFreeBlock;
    382          					LUT [pFreeBlock]   &= ~FREE_BLOCK;
    383              				break;
    384          				}
    385          				pFreeBlock++;
   \                     ??NAND_BuildLUT_9:
   \   000000E0   401C               ADDS     R0,R0,#+1
    386          			}
    387          			while ( pFreeBlock < MAX_PHY_BLOCKS_PER_ZONE );
   \   000000E2   40F61C01           MOVW     R1,#+2076
   \   000000E6   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000E8   8842               CMP      R0,R1
   \   000000EA   0BD3               BCC.N    ??NAND_BuildLUT_10
   \                     ??NAND_BuildLUT_11:
   \   000000EC   641C               ADDS     R4,R4,#+1
   \                     ??NAND_BuildLUT_8:
   \   000000EE   40F61C01           MOVW     R1,#+2076
   \   000000F2   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000F4   8C42               CMP      R4,R1
   \   000000F6   20D2               BCS.N    ??NAND_BuildLUT_12
   \   000000F8   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000FA   ....               LDR.N    R1,??DataTable6_6
   \   000000FC   31F81410           LDRH     R1,[R1, R4, LSL #+1]
   \   00000100   0904               LSLS     R1,R1,#+16
   \   00000102   F3D4               BMI.N    ??NAND_BuildLUT_11
   \                     ??NAND_BuildLUT_10:
   \   00000104   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000106   ....               LDR.N    R1,??DataTable6_6
   \   00000108   31F81010           LDRH     R1,[R1, R0, LSL #+1]
   \   0000010C   8904               LSLS     R1,R1,#+18
   \   0000010E   E7D5               BPL.N    ??NAND_BuildLUT_9
   \   00000110   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000112   ....               LDR.N    R1,??DataTable6_6
   \   00000114   31F81410           LDRH     R1,[R1, R4, LSL #+1]
   \   00000118   0143               ORRS     R1,R0,R1
   \   0000011A   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000011C   ....               LDR.N    R2,??DataTable6_6
   \   0000011E   22F81410           STRH     R1,[R2, R4, LSL #+1]
   \   00000122   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000124   ....               LDR.N    R1,??DataTable6_6
   \   00000126   31F81010           LDRH     R1,[R1, R0, LSL #+1]
   \   0000012A   4DF6FF72           MOVW     R2,#+57343
   \   0000012E   1140               ANDS     R1,R2,R1
   \   00000130   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000132   ....               LDR.N    R2,??DataTable6_6
   \   00000134   22F81010           STRH     R1,[R2, R0, LSL #+1]
   \   00000138   D8E7               B.N      ??NAND_BuildLUT_11
    388          		}
    389          	}
    390          
    391               memcpy(&LookUpTable.LUT,LUT,sizeof(LUT));
                      ^
Warning[Pe223]: function "memcpy" declared implicitly

  static u16 NAND_GetFreeBlock (void)
             ^
"F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\nand_if.c",252  Warning[Pe177]: 
          function "NAND_GetFreeBlock" was declared but never referenced
   \                     ??NAND_BuildLUT_12:
   \   0000013A   41F23802           MOVW     R2,#+4152
   \   0000013E   ....               LDR.N    R1,??DataTable6_6
   \   00000140   ....               LDR.N    R0,??DataTable6
   \   00000142   ........           BL       memcpy
    392          	return NAND_OK;
   \   00000146   0020               MOVS     R0,#+0
   \                     ??NAND_BuildLUT_7:
   \   00000148   76BD               POP      {R1,R2,R4-R6,PC}  ;; return
    393          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     LookUpTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   ........           DC32     test_Addr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   ........           DC32     test_length

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   ........           DC32     wAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   ........           DC32     CurrentZone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   ........           DC32     LogAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   ........           DC32     LUT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   000E0400           DC32     0x40e00
    394          
    395          /******************* (C) COPYRIGHT 2007 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function               .cstack
     --------               -------
     Get_NAND_PageAddress       12
     NAND_BuildLUT              24
     NAND_ConvertPhyAddress     12
     NAND_GetAddress            12
     NAND_If_Erase              16
     NAND_If_Init                8
     NAND_If_Read               24
     NAND_If_Write              16
     NAND_Write_Cleanup         32
     ReadSpareArea             456
     Set_NAND_PageBADBlock       8


   Section sizes:

     Function/Label         Bytes
     --------------         -----
     LookUpTable            4156
     phBlock                   2
     LogAddress                2
     Initial_Page              2
     CurrentZone               2
     Written_Pages             2
     wAddress                  8
     LUT                    4152
     NAND_If_Init             10
     Set_NAND_PageBADBlock   112
     Get_NAND_PageAddress     80
     test_length               4
     test_Addr                 4
     cal_addr                  4
     NAND_If_Erase            48
     NAND_If_Write            54
     NAND_If_Read            104
     NAND_Write_Cleanup       66
     NAND_GetAddress          66
     ReadSpareArea            48
     NAND_ConvertPhyAddress   70
     NAND_BuildLUT           330
     ??DataTable6              4
     ??DataTable6_1            4
     ??DataTable6_2            4
     ??DataTable6_3            4
     ??DataTable6_4            4
     ??DataTable6_5            4
     ??DataTable6_6            4
     ??DataTable6_7            4

 
 8 338 bytes in section .bss
 1 020 bytes in section .text
 
 1 020 bytes of CODE memory
 8 338 bytes of DATA memory

Errors: none
Warnings: 3
