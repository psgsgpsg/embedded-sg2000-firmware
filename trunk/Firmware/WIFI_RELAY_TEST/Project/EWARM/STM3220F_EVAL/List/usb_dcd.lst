###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     16/May/2011  15:08:15 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\묵작업\[ NewDTG ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4 #
#                    \STM32F2xx_StdPeriph_Lib_V0.0.4\Libraries\STM32_USB_OTG_ #
#                    Driver\src\usb_dcd.c                                     #
#    Command line =  "D:\묵작업\[ NewDTG ]\자료\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Libraries\STM32_USB_OTG #
#                    _Driver\src\usb_dcd.c" -D USE_STDPERIPH_DRIVER -D        #
#                    STM32F2XX -D USE_STM3220F_EVAL -D USE_USB_OTG_FS -D      #
#                    USE_ULPI_PHY -lC "D:\묵작업\[ NewDTG                     #
#                    ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    STM3220F_EVAL\List\" -lA "D:\묵작업\[ NewDTG             #
#                    ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    STM3220F_EVAL\List\" -o "D:\묵작업\[ NewDTG              #
#                    ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    STM3220F_EVAL\Obj\" --no_cse --no_unroll --no_inline     #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "D:\묵작업\[ NewDTG                              #
#                    ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\" -I "D:\묵작업\[ NewDTG                              #
#                    ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\..\..\Libraries\CMSIS\CM3\CoreSupport\" -I            #
#                    "D:\묵작업\[ NewDTG ]\자료\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Libraries\CMSIS\CM3\DeviceS #
#                    upport\ST\STM32F2xx\" -I "D:\묵작업\[ NewDTG             #
#                    ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I   #
#                    "D:\묵작업\[ NewDTG ]\자료\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Utilities\STM32_EVAL\" -I   #
#                    "D:\묵작업\[ NewDTG ]\자료\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Utilities\STM32_EVAL\Common #
#                    \" -I "D:\묵작업\[ NewDTG ]\자료\STM32F2xx_StdPeriph_Lib #
#                    _V0.0.4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx #
#                    _StdPeriph_Template\EWARM\..\..\..\Utilities\STM32_EVAL\ #
#                    STM3220F_EVAL\" -I "D:\묵작업\[ NewDTG                   #
#                    ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I         #
#                    "D:\묵작업\[ NewDTG ]\자료\STM32F2xx_StdPeriph_Lib_V0.0. #
#                    4\STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPe #
#                    riph_Template\EWARM\..\..\..\Libraries\STM32_USB_Device_ #
#                    Library\Core\inc\" -I "D:\묵작업\[ NewDTG                #
#                    ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPerip #
#                    h_Lib_V0.0.4\Project\STM32F2xx_StdPeriph_Template\EWARM\ #
#                    ..\..\..\Libraries\STM32_USB_Device_Library\Class\msc\in #
#                    c\" -Ol --use_c++_inline                                 #
#    List file    =  D:\묵작업\[ NewDTG ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4 #
#                    \STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPer #
#                    iph_Template\EWARM\STM3220F_EVAL\List\usb_dcd.lst        #
#    Object file  =  D:\묵작업\[ NewDTG ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4 #
#                    \STM32F2xx_StdPeriph_Lib_V0.0.4\Project\STM32F2xx_StdPer #
#                    iph_Template\EWARM\STM3220F_EVAL\Obj\usb_dcd.o           #
#                                                                             #
#                                                                             #
###############################################################################

D:\묵작업\[ NewDTG ]\자료\STM32F2xx_StdPeriph_Lib_V0.0.4\STM32F2xx_StdPeriph_Lib_V0.0.4\Libraries\STM32_USB_OTG_Driver\src\usb_dcd.c
      1          /**
      2            ******************************************************************************
      3            * @file    usb_dcd.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    11/12/2010
      7            * @brief   Peripheral Device Interface Layer
      8            ******************************************************************************
      9            * @copy 
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     19            */
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "usb_dcd.h"
     23          
     24          
     25          /** @addtogroup USB_OTG_DRIVER
     26          * @{
     27          */
     28          
     29          /** @defgroup USB_DCD 
     30          * @brief This file is the interface between EFSL ans Host mass-storage class
     31          * @{
     32          */
     33          
     34          
     35          /** @defgroup USB_DCD_Private_Defines
     36          * @{
     37          */ 
     38          /**
     39          * @}
     40          */ 
     41          
     42          
     43          /** @defgroup USB_DCD_Private_TypesDefinitions
     44          * @{
     45          */ 
     46          /**
     47          * @}
     48          */ 
     49          
     50          
     51          
     52          /** @defgroup USB_DCD_Private_Macros
     53          * @{
     54          */ 
     55          /**
     56          * @}
     57          */ 
     58          
     59          
     60          /** @defgroup USB_DCD_Private_Variables
     61          * @{
     62          */ 
     63          /**
     64          * @}
     65          */ 
     66          
     67          
     68          /** @defgroup USB_DCD_Private_FunctionPrototypes
     69          * @{
     70          */ 
     71          
     72          /**
     73          * @}
     74          */ 
     75          
     76          
     77          /** @defgroup USB_DCD_Private_Functions
     78          * @{
     79          */ 
     80          
     81          
     82          

   \                                 In section .text, align 2, keep-with-next
     83          void DCD_Init(USB_OTG_CORE_HANDLE *pdev , 
     84                        USB_OTG_CORE_ID_TypeDef coreID)
     85          {
   \                     DCD_Init:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
     86            uint32_t i;
     87            USB_OTG_EP *ep;
     88            
     89            USB_OTG_SelectCore (pdev , coreID);
   \   00000004   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   2000               MOVS     R0,R4
   \   00000008   ........           BL       USB_OTG_SelectCore
     90            
     91            pdev->dev.device_status = USB_OTG_DEFAULT;
   \   0000000C   0120               MOVS     R0,#+1
   \   0000000E   84F81201           STRB     R0,[R4, #+274]
     92            pdev->dev.device_address = 0;
   \   00000012   0020               MOVS     R0,#+0
   \   00000014   84F81301           STRB     R0,[R4, #+275]
     93            
     94            /* Init ep structure */
     95            for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   11E0               B.N      ??DCD_Init_0
     96            {
     97              ep = &pdev->dev.in_ep[i];
   \                     ??DCD_Init_1:
   \   0000001C   2821               MOVS     R1,#+40
   \   0000001E   01FB0041           MLA      R1,R1,R0,R4
   \   00000022   01F21811           ADDW     R1,R1,#+280
     98              /* Init ep structure */
     99              ep->is_in = 1;
   \   00000026   0122               MOVS     R2,#+1
   \   00000028   4A70               STRB     R2,[R1, #+1]
    100              ep->num = i;
   \   0000002A   0870               STRB     R0,[R1, #+0]
    101              ep->tx_fifo_num = i;
   \   0000002C   C880               STRH     R0,[R1, #+6]
    102              /* Control until ep is actvated */
    103              ep->type = EP_TYPE_CTRL;
   \   0000002E   0022               MOVS     R2,#+0
   \   00000030   CA70               STRB     R2,[R1, #+3]
    104              ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
   \   00000032   4022               MOVS     R2,#+64
   \   00000034   8A60               STR      R2,[R1, #+8]
    105              ep->xfer_buff = 0;
   \   00000036   0022               MOVS     R2,#+0
   \   00000038   CA60               STR      R2,[R1, #+12]
    106              ep->xfer_len = 0;
   \   0000003A   0022               MOVS     R2,#+0
   \   0000003C   4A61               STR      R2,[R1, #+20]
    107            }
   \   0000003E   401C               ADDS     R0,R0,#+1
   \                     ??DCD_Init_0:
   \   00000040   6178               LDRB     R1,[R4, #+1]
   \   00000042   8842               CMP      R0,R1
   \   00000044   EAD3               BCC.N    ??DCD_Init_1
    108            
    109            for (i = 0; i < pdev->cfg.dev_endpoints; i++)
   \   00000046   0020               MOVS     R0,#+0
   \   00000048   11E0               B.N      ??DCD_Init_2
    110            {
    111              ep = &pdev->dev.out_ep[i];
   \                     ??DCD_Init_3:
   \   0000004A   2821               MOVS     R1,#+40
   \   0000004C   01FB0041           MLA      R1,R1,R0,R4
   \   00000050   01F27031           ADDW     R1,R1,#+880
    112              /* Init ep structure */
    113              ep->is_in = 0;
   \   00000054   0022               MOVS     R2,#+0
   \   00000056   4A70               STRB     R2,[R1, #+1]
    114              ep->num = i;
   \   00000058   0870               STRB     R0,[R1, #+0]
    115              ep->tx_fifo_num = i;
   \   0000005A   C880               STRH     R0,[R1, #+6]
    116              /* Control until ep is activated */
    117              ep->type = EP_TYPE_CTRL;
   \   0000005C   0022               MOVS     R2,#+0
   \   0000005E   CA70               STRB     R2,[R1, #+3]
    118              ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
   \   00000060   4022               MOVS     R2,#+64
   \   00000062   8A60               STR      R2,[R1, #+8]
    119              ep->xfer_buff = 0;
   \   00000064   0022               MOVS     R2,#+0
   \   00000066   CA60               STR      R2,[R1, #+12]
    120              ep->xfer_len = 0;
   \   00000068   0022               MOVS     R2,#+0
   \   0000006A   4A61               STR      R2,[R1, #+20]
    121            }
   \   0000006C   401C               ADDS     R0,R0,#+1
   \                     ??DCD_Init_2:
   \   0000006E   6178               LDRB     R1,[R4, #+1]
   \   00000070   8842               CMP      R0,R1
   \   00000072   EAD3               BCC.N    ??DCD_Init_3
    122            
    123            USB_OTG_DisableGlobalInt(pdev);
   \   00000074   2000               MOVS     R0,R4
   \   00000076   ........           BL       USB_OTG_DisableGlobalInt
    124            
    125            /*Init low level hardware */
    126            USB_OTG_BSP_Init();
   \   0000007A   ........           BL       USB_OTG_BSP_Init
    127            
    128            /*Init the Core (common init.) */
    129            USB_OTG_CoreInit(pdev);
   \   0000007E   2000               MOVS     R0,R4
   \   00000080   ........           BL       USB_OTG_CoreInit
    130            
    131            /* Init Device */
    132            USB_OTG_CoreInitDev(pdev);
   \   00000084   2000               MOVS     R0,R4
   \   00000086   ........           BL       USB_OTG_CoreInitDev
    133            
    134            /* Force Device Mode*/
    135            USB_OTG_SetCurrentMode(pdev, DEVICE_MODE);
   \   0000008A   0021               MOVS     R1,#+0
   \   0000008C   2000               MOVS     R0,R4
   \   0000008E   ........           BL       USB_OTG_SetCurrentMode
    136            
    137            /* Enable USB Global interrupt */
    138            USB_OTG_EnableGlobalInt(pdev);
   \   00000092   2000               MOVS     R0,R4
   \   00000094   ........           BL       USB_OTG_EnableGlobalInt
    139          }
   \   00000098   10BD               POP      {R4,PC}          ;; return
    140          
    141          
    142          /**
    143          * @brief  Configure an EP
    144          * @param pdev : Device instance
    145          * @param epdesc : Endpoint Descriptor
    146          * @retval : status
    147          */

   \                                 In section .text, align 2, keep-with-next
    148          uint32_t DCD_EP_Open(USB_OTG_CORE_HANDLE *pdev , 
    149                               uint8_t ep_addr,
    150                               uint16_t ep_mps,
    151                               uint8_t ep_type)
    152          {
   \                     DCD_EP_Open:
   \   00000000   38B5               PUSH     {R3-R5,LR}
    153            USB_OTG_EP *ep;
    154            
    155            if ((ep_addr & 0x80) == 0x80)
   \   00000002   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0C06               LSLS     R4,R1,#+24
   \   00000006   08D5               BPL.N    ??DCD_EP_Open_0
    156            {
    157              ep = &pdev->dev.in_ep[ep_addr & 0x7F];
   \   00000008   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   11F07F04           ANDS     R4,R1,#0x7F
   \   0000000E   2825               MOVS     R5,#+40
   \   00000010   05FB0404           MLA      R4,R5,R4,R0
   \   00000014   04F21814           ADDW     R4,R4,#+280
   \   00000018   07E0               B.N      ??DCD_EP_Open_1
    158            }
    159            else
    160            {
    161              ep = &pdev->dev.out_ep[ep_addr & 0x7F];
   \                     ??DCD_EP_Open_0:
   \   0000001A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   11F07F04           ANDS     R4,R1,#0x7F
   \   00000020   2825               MOVS     R5,#+40
   \   00000022   05FB0404           MLA      R4,R5,R4,R0
   \   00000026   04F27034           ADDW     R4,R4,#+880
    162            }
    163            ep->num   = ep_addr & 0x7F;
   \                     ??DCD_EP_Open_1:
   \   0000002A   11F07F05           ANDS     R5,R1,#0x7F
   \   0000002E   2570               STRB     R5,[R4, #+0]
    164            
    165            ep->is_in = (0x80 & ep_addr) != 0;
   \   00000030   C1F3C011           UBFX     R1,R1,#+7,#+1
   \   00000034   11F00101           ANDS     R1,R1,#0x1
   \   00000038   6170               STRB     R1,[R4, #+1]
    166            ep->maxpacket = ep_mps;
   \   0000003A   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000003C   A260               STR      R2,[R4, #+8]
    167            ep->type = ep_type;
   \   0000003E   E370               STRB     R3,[R4, #+3]
    168            if (ep->is_in)
   \   00000040   6178               LDRB     R1,[R4, #+1]
   \   00000042   0029               CMP      R1,#+0
   \   00000044   01D0               BEQ.N    ??DCD_EP_Open_2
    169            {
    170              /* Assign a Tx FIFO */
    171              ep->tx_fifo_num = ep->num;
   \   00000046   2178               LDRB     R1,[R4, #+0]
   \   00000048   E180               STRH     R1,[R4, #+6]
    172            }
    173            /* Set initial data PID. */
    174            if (ep_type == USB_OTG_EP_BULK )
   \                     ??DCD_EP_Open_2:
   \   0000004A   DBB2               UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000004C   022B               CMP      R3,#+2
   \   0000004E   01D1               BNE.N    ??DCD_EP_Open_3
    175            {
    176              ep->data_pid_start = 0;
   \   00000050   0021               MOVS     R1,#+0
   \   00000052   2171               STRB     R1,[R4, #+4]
    177            }
    178            USB_OTG_EPActivate(pdev , ep );
   \                     ??DCD_EP_Open_3:
   \   00000054   2100               MOVS     R1,R4
   \   00000056   ........           BL       USB_OTG_EPActivate
    179            return 0;
   \   0000005A   0020               MOVS     R0,#+0
   \   0000005C   32BD               POP      {R1,R4,R5,PC}    ;; return
    180          }
    181          /**
    182          * @brief  called when an EP is disabled
    183          * @param pdev: device instance
    184          * @param ep_addr: endpoint address
    185          * @retval : status
    186          */

   \                                 In section .text, align 2, keep-with-next
    187          uint32_t DCD_EP_Close(USB_OTG_CORE_HANDLE *pdev , uint8_t  ep_addr)
    188          {
   \                     DCD_EP_Close:
   \   00000000   80B5               PUSH     {R7,LR}
    189            USB_OTG_EP *ep;
    190            
    191            if ((ep_addr&0x80) == 0x80)
   \   00000002   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0A06               LSLS     R2,R1,#+24
   \   00000006   08D5               BPL.N    ??DCD_EP_Close_0
    192            {
    193              ep = &pdev->dev.in_ep[ep_addr & 0x7F];
   \   00000008   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   11F07F02           ANDS     R2,R1,#0x7F
   \   0000000E   2823               MOVS     R3,#+40
   \   00000010   03FB0202           MLA      R2,R3,R2,R0
   \   00000014   02F21812           ADDW     R2,R2,#+280
   \   00000018   07E0               B.N      ??DCD_EP_Close_1
    194            }
    195            else
    196            {
    197              ep = &pdev->dev.out_ep[ep_addr & 0x7F];
   \                     ??DCD_EP_Close_0:
   \   0000001A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   11F07F02           ANDS     R2,R1,#0x7F
   \   00000020   2823               MOVS     R3,#+40
   \   00000022   03FB0202           MLA      R2,R3,R2,R0
   \   00000026   02F27032           ADDW     R2,R2,#+880
    198            }
    199            ep->num   = ep_addr & 0x7F;
   \                     ??DCD_EP_Close_1:
   \   0000002A   11F07F03           ANDS     R3,R1,#0x7F
   \   0000002E   1370               STRB     R3,[R2, #+0]
    200            ep->is_in = (0x80 & ep_addr) != 0;
   \   00000030   C1F3C011           UBFX     R1,R1,#+7,#+1
   \   00000034   11F00101           ANDS     R1,R1,#0x1
   \   00000038   5170               STRB     R1,[R2, #+1]
    201            USB_OTG_EPDeactivate(pdev , ep );
   \   0000003A   1100               MOVS     R1,R2
   \   0000003C   ........           BL       USB_OTG_EPDeactivate
    202            return 0;
   \   00000040   0020               MOVS     R0,#+0
   \   00000042   02BD               POP      {R1,PC}          ;; return
    203          }
    204          
    205          
    206          /**
    207          * @brief  DCD_EP_PrepareRx
    208          * @param pdev: device instance
    209          * @param ep_addr: endpoint address
    210          * @param pbuf: pointer to Rx buffer
    211          * @param buf_len: data length
    212          * @retval : status
    213          */

   \                                 In section .text, align 2, keep-with-next
    214          uint32_t   DCD_EP_PrepareRx( USB_OTG_CORE_HANDLE *pdev,
    215                                      uint8_t   ep_addr,
    216                                      uint8_t *pbuf,                        
    217                                      uint16_t  buf_len)
    218          {
   \                     DCD_EP_PrepareRx:
   \   00000000   38B5               PUSH     {R3-R5,LR}
    219            USB_OTG_EP *ep;
    220            
    221            ep = &pdev->dev.out_ep[ep_addr & 0x7F];
   \   00000002   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   11F07F04           ANDS     R4,R1,#0x7F
   \   00000008   2825               MOVS     R5,#+40
   \   0000000A   05FB0404           MLA      R4,R5,R4,R0
   \   0000000E   04F27034           ADDW     R4,R4,#+880
    222            
    223            /*setup and start the Xfer */
    224            ep->xfer_buff = pbuf;  
   \   00000012   E260               STR      R2,[R4, #+12]
    225            ep->xfer_len = buf_len;
   \   00000014   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000016   6361               STR      R3,[R4, #+20]
    226            ep->xfer_count = 0;
   \   00000018   0023               MOVS     R3,#+0
   \   0000001A   A361               STR      R3,[R4, #+24]
    227            ep->is_in = 0;
   \   0000001C   0023               MOVS     R3,#+0
   \   0000001E   6370               STRB     R3,[R4, #+1]
    228            ep->num = ep_addr & 0x7F;
   \   00000020   11F07F01           ANDS     R1,R1,#0x7F
   \   00000024   2170               STRB     R1,[R4, #+0]
    229            
    230            if (pdev->cfg.dma_enable == 1)
   \   00000026   C178               LDRB     R1,[R0, #+3]
   \   00000028   0129               CMP      R1,#+1
   \   0000002A   00D1               BNE.N    ??DCD_EP_PrepareRx_0
    231            {
    232              ep->dma_addr = (uint32_t)pbuf;  
   \   0000002C   2261               STR      R2,[R4, #+16]
    233            }
    234            
    235            if ( ep->num == 0 )
   \                     ??DCD_EP_PrepareRx_0:
   \   0000002E   2178               LDRB     R1,[R4, #+0]
   \   00000030   0029               CMP      R1,#+0
   \   00000032   03D1               BNE.N    ??DCD_EP_PrepareRx_1
    236            {
    237              USB_OTG_EP0StartXfer(pdev , ep);
   \   00000034   2100               MOVS     R1,R4
   \   00000036   ........           BL       USB_OTG_EP0StartXfer
   \   0000003A   02E0               B.N      ??DCD_EP_PrepareRx_2
    238            }
    239            else
    240            {
    241              USB_OTG_EPStartXfer(pdev, ep );
   \                     ??DCD_EP_PrepareRx_1:
   \   0000003C   2100               MOVS     R1,R4
   \   0000003E   ........           BL       USB_OTG_EPStartXfer
    242            }
    243            return 0;
   \                     ??DCD_EP_PrepareRx_2:
   \   00000042   0020               MOVS     R0,#+0
   \   00000044   32BD               POP      {R1,R4,R5,PC}    ;; return
    244          }
    245          
    246          /**
    247          * @brief  Transmit data over USB
    248          * @param pdev: device instance
    249          * @param ep_addr: endpoint address
    250          * @param pbuf: pointer to Tx buffer
    251          * @param buf_len: data length
    252          * @retval : status
    253          */

   \                                 In section .text, align 2, keep-with-next
    254          uint32_t  DCD_EP_Tx ( USB_OTG_CORE_HANDLE *pdev,
    255                               uint8_t   ep_addr,
    256                               uint8_t   *pbuf,
    257                               uint32_t   buf_len)
    258          {
   \                     DCD_EP_Tx:
   \   00000000   38B5               PUSH     {R3-R5,LR}
    259            USB_OTG_EP *ep;
    260            
    261            ep = &pdev->dev.in_ep[ep_addr & 0x7F];
   \   00000002   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   11F07F04           ANDS     R4,R1,#0x7F
   \   00000008   2825               MOVS     R5,#+40
   \   0000000A   05FB0404           MLA      R4,R5,R4,R0
   \   0000000E   04F21814           ADDW     R4,R4,#+280
    262            
    263            /* Setup and start the Transfer */
    264            ep->is_in = 1;
   \   00000012   0125               MOVS     R5,#+1
   \   00000014   6570               STRB     R5,[R4, #+1]
    265            ep->num = ep_addr & 0x7F;  
   \   00000016   11F07F01           ANDS     R1,R1,#0x7F
   \   0000001A   2170               STRB     R1,[R4, #+0]
    266            ep->xfer_buff = pbuf;
   \   0000001C   E260               STR      R2,[R4, #+12]
    267            ep->dma_addr = (uint32_t)pbuf;  
   \   0000001E   2261               STR      R2,[R4, #+16]
    268            ep->xfer_count = 0;
   \   00000020   0021               MOVS     R1,#+0
   \   00000022   A161               STR      R1,[R4, #+24]
    269            ep->xfer_len  = buf_len;
   \   00000024   6361               STR      R3,[R4, #+20]
    270            
    271            if ( ep->num == 0 )
   \   00000026   2178               LDRB     R1,[R4, #+0]
   \   00000028   0029               CMP      R1,#+0
   \   0000002A   03D1               BNE.N    ??DCD_EP_Tx_0
    272            {
    273              USB_OTG_EP0StartXfer(pdev , ep);
   \   0000002C   2100               MOVS     R1,R4
   \   0000002E   ........           BL       USB_OTG_EP0StartXfer
   \   00000032   02E0               B.N      ??DCD_EP_Tx_1
    274            }
    275            else
    276            {
    277              USB_OTG_EPStartXfer(pdev, ep );
   \                     ??DCD_EP_Tx_0:
   \   00000034   2100               MOVS     R1,R4
   \   00000036   ........           BL       USB_OTG_EPStartXfer
    278            }
    279            return 0;
   \                     ??DCD_EP_Tx_1:
   \   0000003A   0020               MOVS     R0,#+0
   \   0000003C   32BD               POP      {R1,R4,R5,PC}    ;; return
    280          }
    281          
    282          
    283          /**
    284          * @brief  Stall an endpoint.
    285          * @param pdev: device instance
    286          * @param epnum: endpoint address
    287          * @retval : status
    288          */

   \                                 In section .text, align 2, keep-with-next
    289          uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
    290          {
   \                     DCD_EP_Stall:
   \   00000000   80B5               PUSH     {R7,LR}
    291            USB_OTG_EP *ep;
    292            if ((0x80 & epnum) == 0x80)
   \   00000002   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0A06               LSLS     R2,R1,#+24
   \   00000006   08D5               BPL.N    ??DCD_EP_Stall_0
    293            {
    294              ep = &pdev->dev.in_ep[epnum & 0x7F];
   \   00000008   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   11F07F02           ANDS     R2,R1,#0x7F
   \   0000000E   2823               MOVS     R3,#+40
   \   00000010   03FB0202           MLA      R2,R3,R2,R0
   \   00000014   02F21812           ADDW     R2,R2,#+280
   \   00000018   05E0               B.N      ??DCD_EP_Stall_1
    295            }
    296            else
    297            {
    298              ep = &pdev->dev.out_ep[epnum];
   \                     ??DCD_EP_Stall_0:
   \   0000001A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   2822               MOVS     R2,#+40
   \   0000001E   02FB0102           MLA      R2,R2,R1,R0
   \   00000022   02F27032           ADDW     R2,R2,#+880
    299            }
    300          
    301            ep->is_stall = 1;
   \                     ??DCD_EP_Stall_1:
   \   00000026   0123               MOVS     R3,#+1
   \   00000028   9370               STRB     R3,[R2, #+2]
    302            ep->num   = epnum & 0x7F;
   \   0000002A   11F07F03           ANDS     R3,R1,#0x7F
   \   0000002E   1370               STRB     R3,[R2, #+0]
    303            ep->is_in = ((epnum & 0x80) == 0x80);
   \   00000030   C1F3C011           UBFX     R1,R1,#+7,#+1
   \   00000034   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   11F00101           ANDS     R1,R1,#0x1
   \   0000003A   5170               STRB     R1,[R2, #+1]
    304            
    305            USB_OTG_EPSetStall(pdev , ep);
   \   0000003C   1100               MOVS     R1,R2
   \   0000003E   ........           BL       USB_OTG_EPSetStall
    306            return (0);
   \   00000042   0020               MOVS     R0,#+0
   \   00000044   02BD               POP      {R1,PC}          ;; return
    307          }
    308          
    309          
    310          /**
    311          * @brief  Clear stall condition on endpoints.
    312          * @param pdev: device instance
    313          * @param epnum: endpoint address
    314          * @retval : status
    315          */

   \                                 In section .text, align 2, keep-with-next
    316          uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
    317          {
   \                     DCD_EP_ClrStall:
   \   00000000   80B5               PUSH     {R7,LR}
    318            USB_OTG_EP *ep;
    319            if ((0x80 & epnum) == 0x80)
   \   00000002   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0A06               LSLS     R2,R1,#+24
   \   00000006   08D5               BPL.N    ??DCD_EP_ClrStall_0
    320            {
    321              ep = &pdev->dev.in_ep[epnum & 0x7F];    
   \   00000008   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   11F07F02           ANDS     R2,R1,#0x7F
   \   0000000E   2823               MOVS     R3,#+40
   \   00000010   03FB0202           MLA      R2,R3,R2,R0
   \   00000014   02F21812           ADDW     R2,R2,#+280
   \   00000018   05E0               B.N      ??DCD_EP_ClrStall_1
    322            }
    323            else
    324            {
    325              ep = &pdev->dev.out_ep[epnum];
   \                     ??DCD_EP_ClrStall_0:
   \   0000001A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   2822               MOVS     R2,#+40
   \   0000001E   02FB0102           MLA      R2,R2,R1,R0
   \   00000022   02F27032           ADDW     R2,R2,#+880
    326            }
    327            
    328            ep->is_stall = 0;  
   \                     ??DCD_EP_ClrStall_1:
   \   00000026   0023               MOVS     R3,#+0
   \   00000028   9370               STRB     R3,[R2, #+2]
    329            ep->num   = epnum & 0x7F;
   \   0000002A   11F07F03           ANDS     R3,R1,#0x7F
   \   0000002E   1370               STRB     R3,[R2, #+0]
    330            ep->is_in = ((epnum & 0x80) == 0x80);
   \   00000030   C1F3C011           UBFX     R1,R1,#+7,#+1
   \   00000034   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   11F00101           ANDS     R1,R1,#0x1
   \   0000003A   5170               STRB     R1,[R2, #+1]
    331            
    332            USB_OTG_EPClearStall(pdev , ep);
   \   0000003C   1100               MOVS     R1,R2
   \   0000003E   ........           BL       USB_OTG_EPClearStall
    333            return (0);
   \   00000042   0020               MOVS     R0,#+0
   \   00000044   02BD               POP      {R1,PC}          ;; return
    334          }
    335          
    336          
    337          /**
    338          * @brief  This Function flushes the FIFOs.
    339          * @param pdev: device instance
    340          * @param epnum: endpoint address
    341          * @retval : status
    342          */

   \                                 In section .text, align 2, keep-with-next
    343          uint32_t  DCD_EP_Flush (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
    344          {
   \                     DCD_EP_Flush:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    345          
    346            if ((epnum & 0x80) == 0x80)
   \   00000006   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   2806               LSLS     R0,R5,#+24
   \   0000000A   06D5               BPL.N    ??DCD_EP_Flush_0
    347            {
    348              USB_OTG_FlushTxFifo(pdev, epnum & 0x7F);
   \   0000000C   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   15F07F01           ANDS     R1,R5,#0x7F
   \   00000012   2000               MOVS     R0,R4
   \   00000014   ........           BL       USB_OTG_FlushTxFifo
   \   00000018   02E0               B.N      ??DCD_EP_Flush_1
    349            }
    350            else
    351            {
    352              USB_OTG_FlushRxFifo(pdev);
   \                     ??DCD_EP_Flush_0:
   \   0000001A   2000               MOVS     R0,R4
   \   0000001C   ........           BL       USB_OTG_FlushRxFifo
    353            }
    354            
    355            DCD_EP_ClrStall(pdev, epnum);
   \                     ??DCD_EP_Flush_1:
   \   00000020   2900               MOVS     R1,R5
   \   00000022   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   2000               MOVS     R0,R4
   \   00000026   ........           BL       DCD_EP_ClrStall
    356            return (0);
   \   0000002A   0020               MOVS     R0,#+0
   \   0000002C   32BD               POP      {R1,R4,R5,PC}    ;; return
    357          }
    358          
    359          
    360          /**
    361          * @brief  This Function set USB device address
    362          * @param pdev: device instance
    363          * @param address: new device address
    364          * @retval : status
    365          */

   \                                 In section .text, align 2, keep-with-next
    366          void  DCD_EP_SetAddress (USB_OTG_CORE_HANDLE *pdev, uint8_t address)
    367          {
    368            USB_OTG_DCFG_TypeDef  dcfg;
    369            dcfg.d32 = 0;
   \                     DCD_EP_SetAddress:
   \   00000000   0022               MOVS     R2,#+0
    370            dcfg.b.devaddr = address;
   \   00000002   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   61F30A12           BFI      R2,R1,#+4,#+7
    371            USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
   \   00000008   0169               LDR      R1,[R0, #+16]
   \   0000000A   0968               LDR      R1,[R1, #+0]
   \   0000000C   1143               ORRS     R1,R2,R1
   \   0000000E   0069               LDR      R0,[R0, #+16]
   \   00000010   0160               STR      R1,[R0, #+0]
    372          }
   \   00000012   7047               BX       LR               ;; return
    373          
    374          /**
    375          * @brief  Connect device (enable internal pull-up)
    376          * @param pdev: device instance
    377          * @retval : None
    378          */

   \                                 In section .text, align 2, keep-with-next
    379          void  DCD_DevConnect (USB_OTG_CORE_HANDLE *pdev)
    380          {
   \                     DCD_DevConnect:
   \   00000000   80B5               PUSH     {R7,LR}
    381          #ifndef USE_OTG_MODE
    382            USB_OTG_DCTL_TypeDef  dctl;
    383            dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
   \   00000002   0169               LDR      R1,[R0, #+16]
   \   00000004   4968               LDR      R1,[R1, #+4]
    384            /* Connect device */
    385            dctl.b.sftdiscon  = 0;
   \   00000006   31F00201           BICS     R1,R1,#0x2
    386            USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
   \   0000000A   0069               LDR      R0,[R0, #+16]
   \   0000000C   4160               STR      R1,[R0, #+4]
    387            USB_OTG_BSP_mDelay(3);
   \   0000000E   0320               MOVS     R0,#+3
   \   00000010   ........           BL       USB_OTG_BSP_mDelay
    388          #endif
    389          }
   \   00000014   01BD               POP      {R0,PC}          ;; return
    390          
    391          
    392          /**
    393          * @brief  Disconnect device (disable internal pull-up)
    394          * @param pdev: device instance
    395          * @retval : None
    396          */

   \                                 In section .text, align 2, keep-with-next
    397          void  DCD_DevDisconnect (USB_OTG_CORE_HANDLE *pdev)
    398          {
   \                     DCD_DevDisconnect:
   \   00000000   80B5               PUSH     {R7,LR}
    399          #ifndef USE_OTG_MODE
    400            USB_OTG_DCTL_TypeDef  dctl;
    401            dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
   \   00000002   0169               LDR      R1,[R0, #+16]
   \   00000004   4968               LDR      R1,[R1, #+4]
    402            /* Disconnect device for 3ms */
    403            dctl.b.sftdiscon  = 1;
   \   00000006   51F00201           ORRS     R1,R1,#0x2
    404            USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
   \   0000000A   0069               LDR      R0,[R0, #+16]
   \   0000000C   4160               STR      R1,[R0, #+4]
    405            USB_OTG_BSP_mDelay(3);
   \   0000000E   0320               MOVS     R0,#+3
   \   00000010   ........           BL       USB_OTG_BSP_mDelay
    406          #endif
    407          }
   \   00000014   01BD               POP      {R0,PC}          ;; return
    408          
    409          /**
    410          * @}
    411          */ 
    412          
    413          /**
    414          * @}
    415          */ 
    416          
    417          /**
    418          * @}
    419          */
    420          
    421          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function          .cstack
     --------          -------
     DCD_DevConnect         8
     DCD_DevDisconnect      8
     DCD_EP_Close           8
     DCD_EP_ClrStall        8
     DCD_EP_Flush          16
     DCD_EP_Open           16
     DCD_EP_PrepareRx      16
     DCD_EP_SetAddress      0
     DCD_EP_Stall           8
     DCD_EP_Tx             16
     DCD_Init               8


   Section sizes:

     Function/Label    Bytes
     --------------    -----
     DCD_Init           154
     DCD_EP_Open         94
     DCD_EP_Close        68
     DCD_EP_PrepareRx    70
     DCD_EP_Tx           62
     DCD_EP_Stall        70
     DCD_EP_ClrStall     70
     DCD_EP_Flush        46
     DCD_EP_SetAddress   20
     DCD_DevConnect      22
     DCD_DevDisconnect   22

 
 698 bytes in section .text
 
 698 bytes of CODE memory

Errors: none
Warnings: none
