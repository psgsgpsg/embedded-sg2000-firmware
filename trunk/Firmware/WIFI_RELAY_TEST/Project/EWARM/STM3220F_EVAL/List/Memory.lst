###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     19/Dec/2011  16:18:49 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\Memory.c     #
#    Command line =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\Memory.c -D  #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D RTC_CLOCK_SOURCE_LSE -lC            #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\List\ -lA E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Pr #
#                    oject\EWARM\STM3220F_EVAL\List\ -o                       #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\Obj\ --no_cse --no_unroll --no_inline            #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWAR #
#                    M\..\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWA #
#                    RM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I             #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I       #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I             #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Utilities\STM32_EVAL\ -I E:\Work\Firmware\DTG\DTG_EMS_SY #
#                    STEM\Project\EWARM\..\..\Utilities\STM32_EVAL\Common\    #
#                    -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\ #
#                    ..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I                #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_OTG_Driver\inc\ -I                   #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_Device_Library\Core\inc\ -I          #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_Device_Library\Class\msc\inc\ -I     #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\Usb #
#                    \ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\. #
#                    .\Usb\Inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Projec #
#                    t\EWARM\..\Usb\src\ -I E:\Work\Firmware\DTG\DTG_EMS_SYST #
#                    EM\Project\EWARM\..\..\Libraries\STM32_USB_HOST_Library\ #
#                    Core\inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project #
#                    \EWARM\..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\ #
#                    inc\ -Ol --use_c++_inline                                #
#    List file    =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\List\Memory.lst                                  #
#    Object file  =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\Obj\Memory.o                                     #
#                                                                             #
#                                                                             #
###############################################################################

E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\Memory.c
      1          #include <stdio.h>
      2          #include "Memory.h"
      3          #include "fsmc_nand.h"
      4          #include "main.h"

   \                                 In section .text, align 2
   \   __intrinsic __interwork __softfp void *memcpy(void *, void const *, size_t)
   \                     memcpy:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           BL       __aeabi_memcpy
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   10BD               POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __intrinsic __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   1000               MOVS     R0,R2
   \   00000006   0A00               MOVS     R2,R1
   \   00000008   0100               MOVS     R1,R0
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   ........           BL       __aeabi_memset
   \   00000010   2000               MOVS     R0,R4
   \   00000012   10BD               POP      {R4,PC}          ;; return
      5          #include "Eeprom.h"
      6          #include "i2c_ee.h"
      7          #ifdef DEBUG_LOG 
      8               #include "Log.h"
      9          #endif
     10          #include "rtc.h"
     11          #include "usbh_usr.h"
     12          #include "nand_if.h"
     13          

   \                                 In section .bss, align 4
     14          struct __ViewHeader VIEW_Header;              // 읽어올때 해더를 가르킨다.              // 읽어올때 해더를 가르킨다.
   \                     VIEW_Header:
   \   00000000                      DS8 24
     15          

   \                                 In section .bss, align 4
     16          HEADER_EMS_ACCRUE I2C_Ems_Accure;
   \                     I2C_Ems_Accure:
   \   00000000                      DS8 16

   \                                 In section .bss, align 4
     17          HEADER_Info NAND_Header_Info;				// PAGE에 저장하기 위한 변수
   \                     NAND_Header_Info:
   \   00000000                      DS8 16

   \                                 In section .bss, align 4
     18          HEADER_Index NAND_Header_Index;
   \                     NAND_Header_Index:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
     19          DATA_Transmit NAND_Data_Transmit;
   \                     NAND_Data_Transmit:
   \   00000000                      DS8 12
     20          
     21          //struct __BIN_AVERAGE_BUFFER Average_Memory[10];		// 1초간 10개의 평균 내기위한 변수
     22          

   \                                 In section .text, align 2, keep-with-next
     23          u16 GetHeader_Index(u16 PageNum, s16 Add)        // 페이지의 
     24          {
     25               int Page;
     26               Page = PageNum;     
   \                     GetHeader_Index:
   \   00000000   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
     27               
     28               if( Page + Add < 0 )
   \   00000002   09B2               SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   00000004   0A18               ADDS     R2,R1,R0
   \   00000006   002A               CMP      R2,#+0
   \   00000008   03D5               BPL.N    ??GetHeader_Index_0
     29               {
     30                    Page = MAX_HEADER_PAGE + Page + Add;
   \   0000000A   09B2               SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   0000000C   D231               ADDS     R1,R1,#+210
   \   0000000E   0818               ADDS     R0,R1,R0
   \   00000010   09E0               B.N      ??GetHeader_Index_1
     31               }else if ( Page + Add > MAX_HEADER_PAGE )    // 210 을 넘었다면
   \                     ??GetHeader_Index_0:
   \   00000012   09B2               SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   00000014   0A18               ADDS     R2,R1,R0
   \   00000016   D32A               CMP      R2,#+211
   \   00000018   03DB               BLT.N    ??GetHeader_Index_2
     32               {
     33                    Page = Add  - ( MAX_HEADER_PAGE - Page + 1);
   \   0000001A   09B2               SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   0000001C   D339               SUBS     R1,R1,#+211
   \   0000001E   0818               ADDS     R0,R1,R0
   \   00000020   01E0               B.N      ??GetHeader_Index_1
     34               }else
     35                    Page += Add;
   \                     ??GetHeader_Index_2:
   \   00000022   09B2               SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   00000024   0818               ADDS     R0,R1,R0
     36               
     37               return Page;
   \                     ??GetHeader_Index_1:
   \   00000026   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000028   7047               BX       LR               ;; return
     38          }
     39          

   \                                 In section .bss, align 4
     40          struct _BIN_NAND_DTG_DATA DTG_NAND_Binary[DATA_IN_PAGE_SIZE];
   \                     DTG_NAND_Binary:
   \   00000000                      DS8 6392
     41          
     42          //////////////////////////////////////////////////////////////////////////////////
     43          // 
     44          // 검색 날짜와 종료 날짜를 입력 받아서 
     45          // VIEW_Header.Start_Index, VIEW_Header.End_Index 로 반환해준다.
     46          //

   \                                 In section .text, align 2, keep-with-next
     47          void Search_Header( u32 StartTime ,u32 Time)
     48          {
     49          //     
     50          //     HEADER_Info Tmp_Info;
     51          //
     52          //     VIEW_Header.End_Index = StartTime;       // 시작하는 오늘 카운터                 
     53          //     for( i = Time ; i > Time ; i-- )
     54          //     {
     55          //          Tmp_Info = Read_Header_Information( i );   // 순서대로 저장되어있는 해더 데이터를 읽어온다.
     56          //          if( Tmp_Info.Verify == I2C_EEPROM_VERIFY3 )
     57          //          {
     58          //               VIEW_Header.Start_Index = i;               
     59          //          } 
     60          //          if( i == 0 )
     61          //          {
     62          //               
     63          //          }
     64          //     }     
     65          }
   \                     Search_Header:
   \   00000000   7047               BX       LR               ;; return
     66          

   \                                 In section .text, align 2, keep-with-next
     67          void Setting_Header_Information(void)
     68          {	   
   \                     Setting_Header_Information:
   \   00000000   80B5               PUSH     {R7,LR}
     69          	//  ----- 신규 해더를 세팅한다. -----------------------------------------
     70               memset(&NAND_Header_Info,0,sizeof(NAND_Header_Info));
   \   00000002   1022               MOVS     R2,#+16
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   ........           LDR.W    R0,??DataTable15
   \   0000000A   ........           BL       memset
     71          	NAND_Header_Info.Date[0] = SYSTEM_TIME.tm_year - 2000;
   \   0000000E   ........           LDR.W    R0,??DataTable15_1
   \   00000012   4069               LDR      R0,[R0, #+20]
   \   00000014   3030               ADDS     R0,R0,#+48
   \   00000016   ........           LDR.W    R1,??DataTable15
   \   0000001A   0870               STRB     R0,[R1, #+0]
     72          	NAND_Header_Info.Date[1] = SYSTEM_TIME.tm_mon;
   \   0000001C   ........           LDR.W    R0,??DataTable15
   \   00000020   ........           LDR.W    R1,??DataTable15_1
   \   00000024   0969               LDR      R1,[R1, #+16]
   \   00000026   4170               STRB     R1,[R0, #+1]
     73          	NAND_Header_Info.Date[2] = SYSTEM_TIME.tm_mday;	//현재 날짜와 마지막 페이지 주소를 기록
   \   00000028   ........           LDR.W    R0,??DataTable15
   \   0000002C   ........           LDR.W    R1,??DataTable15_1
   \   00000030   C968               LDR      R1,[R1, #+12]
   \   00000032   8170               STRB     R1,[R0, #+2]
     74          	NAND_Header_Info.Start_Page = NAND_Header_Index.Page_Count;	// 지난 마지막 해더의 페이지 번호를 읽어 온다.
   \   00000034   ........           LDR.W    R0,??DataTable15
   \   00000038   ........           LDR.W    R1,??DataTable15_2
   \   0000003C   4968               LDR      R1,[R1, #+4]
   \   0000003E   4160               STR      R1,[R0, #+4]
     75          	NAND_Header_Info.End_Page = NAND_Header_Index.Page_Count;	
   \   00000040   ........           LDR.W    R0,??DataTable15
   \   00000044   ........           LDR.W    R1,??DataTable15_2
   \   00000048   4968               LDR      R1,[R1, #+4]
   \   0000004A   8160               STR      R1,[R0, #+8]
     76               NAND_Header_Info.Verify = I2C_EEPROM_VERIFY3;
   \   0000004C   ........           LDR.W    R0,??DataTable15
   \   00000050   4EF60661           MOVW     R1,#+60934
   \   00000054   8181               STRH     R1,[R0, #+12]
     77          }
   \   00000056   01BD               POP      {R0,PC}          ;; return
     78          

   \                                 In section .text, align 2, keep-with-next
     79          HEADER_Info Read_Header_Information(u16 Header_Index)
     80          {
   \                     Read_Header_Information:
   \   00000000   1FB5               PUSH     {R0-R4,LR}
   \   00000002   0400               MOVS     R4,R0
     81          	HEADER_Info TempHeader;
     82          
     83          	// ----- EEPROM 에 해더의 위치를 찾아 기록 한다.
     84          
     85          	I2C_EE_BufferRead(Buffer, I2C_EEPROM_WriteAddress3 + ( Header_Index * HEADER_INFO_SIZE ) , HEADER_INFO_SIZE ); 	
   \   00000004   1022               MOVS     R2,#+16
   \   00000006   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000008   0801               LSLS     R0,R1,#+4
   \   0000000A   10F18001           ADDS     R1,R0,#+128
   \   0000000E   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000010   ........           LDR.W    R0,??DataTable15_3
   \   00000014   ........           BL       I2C_EE_BufferRead
     86          	memcpy(&TempHeader, Buffer, HEADER_INFO_SIZE );	
   \   00000018   1022               MOVS     R2,#+16
   \   0000001A   ........           LDR.W    R1,??DataTable15_3
   \   0000001E   00A8               ADD      R0,SP,#+0
   \   00000020   ........           BL       memcpy
     87               if( TempHeader.Verify != I2C_EEPROM_VERIFY3 )
   \   00000024   BDF80C00           LDRH     R0,[SP, #+12]
   \   00000028   4EF60661           MOVW     R1,#+60934
   \   0000002C   8842               CMP      R0,R1
   \   0000002E   04D0               BEQ.N    ??Read_Header_Information_0
     88               {
     89                    memset(&TempHeader,0,HEADER_INFO_SIZE);          
   \   00000030   1022               MOVS     R2,#+16
   \   00000032   0021               MOVS     R1,#+0
   \   00000034   00A8               ADD      R0,SP,#+0
   \   00000036   ........           BL       memset
     90               }
     91          #ifdef DEBUG_LOG 
     92          	if(LOGWRITE & LOG_MEMORY)
     93          	{
     94          		sprintf((char *)Buffer,"READ HEADER_INFORMATION %d\r\n", Header_Index);
     95          		Write_Log(Buffer, NORMAL_LOG);
     96          	}	
     97          #endif
     98          	return TempHeader;     
   \                     ??Read_Header_Information_0:
   \   0000003A   2000               MOVS     R0,R4
   \   0000003C   00A9               ADD      R1,SP,#+0
   \   0000003E   1022               MOVS     R2,#+16
   \   00000040   ........           BL       __aeabi_memcpy4
   \   00000044   04B0               ADD      SP,SP,#+16
   \   00000046   10BD               POP      {R4,PC}          ;; return
     99          }
    100          

   \                                 In section .text, align 2, keep-with-next
    101          void Memory_Config(void)
    102          {	
   \                     Memory_Config:
   \   00000000   1FB5               PUSH     {R0-R4,LR}
    103          	// ----- EEPROM 에서 헤더위치를 찾어서 읽어온다.
    104               u32 DataSize;
    105               u32 PageNum;
    106               u32 BlockNum;
                          ^
Warning[Pe177]: variable "BlockNum" was declared but never referenced
    107          
    108               NAND_ADDRESS NAND_PAGE;
                                   ^
Warning[Pe177]: variable "NAND_PAGE" was declared but never referenced
    109               
    110          	I2C_EE_BufferRead(Buffer, I2C_EEPROM_WriteAddress1 , sizeof(HEADER_Index) ); 	
   \   00000002   0A22               MOVS     R2,#+10
   \   00000004   4021               MOVS     R1,#+64
   \   00000006   ........           LDR.W    R0,??DataTable15_3
   \   0000000A   ........           BL       I2C_EE_BufferRead
    111          	memcpy(&NAND_Header_Index,Buffer,sizeof(HEADER_Index));	
   \   0000000E   0A22               MOVS     R2,#+10
   \   00000010   ........           LDR.W    R1,??DataTable15_3
   \   00000014   ........           LDR.W    R0,??DataTable15_2
   \   00000018   ........           BL       memcpy
    112               
    113               if(NAND_Header_Index.Verify != I2C_EEPROM_VERIFY1)            // 처음라면 리셋 시켜준다.ㄴ
   \   0000001C   ........           LDR.W    R0,??DataTable15_2
   \   00000020   0089               LDRH     R0,[R0, #+8]
   \   00000022   4EF60361           MOVW     R1,#+60931
   \   00000026   8842               CMP      R0,R1
   \   00000028   20D0               BEQ.N    ??Memory_Config_0
    114               {
    115                    NAND_Header_Index.Write_Point = 0;
   \   0000002A   ........           LDR.W    R0,??DataTable15_2
   \   0000002E   0021               MOVS     R1,#+0
   \   00000030   4180               STRH     R1,[R0, #+2]
    116                    NAND_Header_Index.Page_Count = 0;
   \   00000032   ........           LDR.W    R0,??DataTable15_2
   \   00000036   0021               MOVS     R1,#+0
   \   00000038   4160               STR      R1,[R0, #+4]
    117                    NAND_Header_Index.Verify = I2C_EEPROM_VERIFY1;
   \   0000003A   ........           LDR.W    R0,??DataTable15_2
   \   0000003E   4EF60361           MOVW     R1,#+60931
   \   00000042   0181               STRH     R1,[R0, #+8]
    118                    
    119                    memcpy(Buffer,&NAND_Header_Index, sizeof(HEADER_Index));	
   \   00000044   0A22               MOVS     R2,#+10
   \   00000046   ........           LDR.W    R1,??DataTable15_2
   \   0000004A   ........           LDR.W    R0,??DataTable15_3
   \   0000004E   ........           BL       memcpy
    120                    I2C_EE_BufferWrite(Buffer, I2C_EEPROM_WriteAddress1 , sizeof(HEADER_Index) ); 	
   \   00000052   0A22               MOVS     R2,#+10
   \   00000054   4021               MOVS     R1,#+64
   \   00000056   ........           LDR.W    R0,??DataTable15_3
   \   0000005A   ........           BL       I2C_EE_BufferWrite
    121                    
    122                    memset(&NAND_Header_Info,0,sizeof(NAND_Header_Info));
   \   0000005E   1022               MOVS     R2,#+16
   \   00000060   0021               MOVS     R1,#+0
   \   00000062   ........           LDR.W    R0,??DataTable15
   \   00000066   ........           BL       memset
   \   0000006A   0BE0               B.N      ??Memory_Config_1
    123                    
    124               }else
    125               {
    126               // -----------------------------------------------------------------------
    127               // 
    128               // - 정보 읽기
    129               // - 현재 인포의 정보를 읽어온다.
    130               //
    131               // -----------------------------------------------------------------------
    132          
    133                    NAND_Header_Info = Read_Header_Information(NAND_Header_Index.Write_Point);
   \                     ??Memory_Config_0:
   \   0000006C   ........           LDR.W    R0,??DataTable15_2
   \   00000070   4188               LDRH     R1,[R0, #+2]
   \   00000072   00A8               ADD      R0,SP,#+0
   \   00000074   ........           BL       Read_Header_Information
   \   00000078   ........           LDR.W    R0,??DataTable15
   \   0000007C   00A9               ADD      R1,SP,#+0
   \   0000007E   1022               MOVS     R2,#+16
   \   00000080   ........           BL       __aeabi_memcpy4
    134               }
    135               //------------------------------------------------------------------------
    136               //
    137               //   전송 데이터 위치 저장
    138               //
    139               //------------------------------------------------------------------------
    140          
    141          	I2C_EE_BufferRead(Buffer, I2C_EEPROM_WriteAddress2 , sizeof(DATA_Transmit) ); 	
   \                     ??Memory_Config_1:
   \   00000084   0A22               MOVS     R2,#+10
   \   00000086   6021               MOVS     R1,#+96
   \   00000088   ........           LDR.W    R0,??DataTable15_3
   \   0000008C   ........           BL       I2C_EE_BufferRead
    142          	memcpy(&NAND_Data_Transmit,Buffer,sizeof(DATA_Transmit));	
   \   00000090   0A22               MOVS     R2,#+10
   \   00000092   ........           LDR.W    R1,??DataTable15_3
   \   00000096   ........           LDR.W    R0,??DataTable15_4
   \   0000009A   ........           BL       memcpy
    143               
    144               if(NAND_Data_Transmit.Verify != I2C_EEPROM_VERIFY2)            // 처음라면 리셋 시켜준다.
   \   0000009E   ........           LDR.W    R0,??DataTable15_4
   \   000000A2   0089               LDRH     R0,[R0, #+8]
   \   000000A4   4EF60461           MOVW     R1,#+60932
   \   000000A8   8842               CMP      R0,R1
   \   000000AA   19D0               BEQ.N    ??Memory_Config_2
    145               {
    146                    NAND_Data_Transmit.Start_Page = 0;
   \   000000AC   ........           LDR.W    R0,??DataTable15_4
   \   000000B0   0021               MOVS     R1,#+0
   \   000000B2   0160               STR      R1,[R0, #+0]
    147                    NAND_Data_Transmit.End_Page = 0;
   \   000000B4   ........           LDR.W    R0,??DataTable15_4
   \   000000B8   0021               MOVS     R1,#+0
   \   000000BA   4160               STR      R1,[R0, #+4]
    148                    NAND_Data_Transmit.Verify = I2C_EEPROM_VERIFY2;
   \   000000BC   ........           LDR.W    R0,??DataTable15_4
   \   000000C0   4EF60461           MOVW     R1,#+60932
   \   000000C4   0181               STRH     R1,[R0, #+8]
    149                    
    150                    memcpy(Buffer,&NAND_Data_Transmit, sizeof(DATA_Transmit));	
   \   000000C6   0A22               MOVS     R2,#+10
   \   000000C8   ........           LDR.W    R1,??DataTable15_4
   \   000000CC   ........           LDR.W    R0,??DataTable15_3
   \   000000D0   ........           BL       memcpy
    151                    I2C_EE_BufferWrite(Buffer, I2C_EEPROM_WriteAddress2 , sizeof(DATA_Transmit) ); 	
   \   000000D4   0A22               MOVS     R2,#+10
   \   000000D6   6021               MOVS     R1,#+96
   \   000000D8   ........           LDR.W    R0,??DataTable15_3
   \   000000DC   ........           BL       I2C_EE_BufferWrite
    152               }
    153               if(NAND_Header_Index.Page_Count != 0)
   \                     ??Memory_Config_2:
   \   000000E0   ........           LDR.W    R0,??DataTable15_2
   \   000000E4   4068               LDR      R0,[R0, #+4]
   \   000000E6   0028               CMP      R0,#+0
   \   000000E8   4CD0               BEQ.N    ??Memory_Config_3
    154               {          
    155          //          DataSize = sizeof(DTG_NAND_Binary[0]);                                 
    156          //          DTG_EMS_DataLoad(NAND_Header_Index.Page_Count - 1 );   // 마지막 페이지를 읽어온다.
    157                    
    158                    DataSize = sizeof(EMS_Drive_Value);          
   \   000000EA   2424               MOVS     R4,#+36
    159          //          memcpy( &EMS_Drive_Value, NAND_Buffer, DataSize );
    160                    
    161               	I2C_EE_BufferRead(Buffer, I2C_EEPROM_WriteAddress0 , sizeof(I2C_Ems_Accure) + DataSize); 	
   \   000000EC   14F10F02           ADDS     R2,R4,#+15
   \   000000F0   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000F2   0021               MOVS     R1,#+0
   \   000000F4   ........           LDR.W    R0,??DataTable15_3
   \   000000F8   ........           BL       I2C_EE_BufferRead
    162                  	memcpy(&EMS_Drive_Value,Buffer, DataSize);	          
   \   000000FC   2200               MOVS     R2,R4
   \   000000FE   ........           LDR.W    R1,??DataTable15_3
   \   00000102   ........           LDR.W    R0,??DataTable15_5
   \   00000106   ........           BL       memcpy
    163               	memcpy(&I2C_Ems_Accure,&Buffer[DataSize],sizeof(I2C_Ems_Accure));	
   \   0000010A   0F22               MOVS     R2,#+15
   \   0000010C   ........           LDR.W    R0,??DataTable15_3
   \   00000110   2118               ADDS     R1,R4,R0
   \   00000112   ........           LDR.W    R0,??DataTable15_6
   \   00000116   ........           BL       memcpy
    164                    Info.EcoStatus = I2C_Ems_Accure.ECO_Drive;
   \   0000011A   ........           LDR.W    R0,??DataTable15_7
   \   0000011E   ........           LDR.W    R1,??DataTable15_6
   \   00000122   897A               LDRB     R1,[R1, #+10]
   \   00000124   0176               STRB     R1,[R0, #+24]
    165                    if(I2C_Ems_Accure.Verify != I2C_EEPROM_VERIFY0)
   \   00000126   ........           LDR.W    R0,??DataTable15_6
   \   0000012A   B0F80D00           LDRH     R0,[R0, #+13]
   \   0000012E   4EF60261           MOVW     R1,#+60930
   \   00000132   8842               CMP      R0,R1
   \   00000134   48D0               BEQ.N    ??Memory_Config_4
    166                    {
    167                         memset(&EMS_Drive_Value,0,DataSize);
   \   00000136   2200               MOVS     R2,R4
   \   00000138   0021               MOVS     R1,#+0
   \   0000013A   ........           LDR.W    R0,??DataTable15_5
   \   0000013E   ........           BL       memset
    168                         memset(&I2C_Ems_Accure,0,sizeof(I2C_Ems_Accure));     
   \   00000142   0F22               MOVS     R2,#+15
   \   00000144   0021               MOVS     R1,#+0
   \   00000146   ........           LDR.W    R0,??DataTable15_6
   \   0000014A   ........           BL       memset
    169               	     memcpy(&Buffer[DataSize],&I2C_Ems_Accure,sizeof(I2C_Ems_Accure));                           
   \   0000014E   0F22               MOVS     R2,#+15
   \   00000150   ........           LDR.W    R1,??DataTable15_6
   \   00000154   ........           LDR.W    R0,??DataTable15_3
   \   00000158   2018               ADDS     R0,R4,R0
   \   0000015A   ........           BL       memcpy
    170                        	Info.EcoStatus = 0;                                    // 기존 에코상태
   \   0000015E   ........           LDR.W    R0,??DataTable15_7
   \   00000162   0021               MOVS     R1,#+0
   \   00000164   0176               STRB     R1,[R0, #+24]
    171                         I2C_Ems_Accure.Verify = I2C_EEPROM_VERIFY0;
   \   00000166   ........           LDR.W    R0,??DataTable15_6
   \   0000016A   4EF60261           MOVW     R1,#+60930
   \   0000016E   A0F80D10           STRH     R1,[R0, #+13]
    172                         I2C_EE_BufferWrite(Buffer, I2C_EEPROM_WriteAddress0 , sizeof(I2C_Ems_Accure) + DataSize ); 	                              
   \   00000172   14F10F02           ADDS     R2,R4,#+15
   \   00000176   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000178   0021               MOVS     R1,#+0
   \   0000017A   ........           LDR.W    R0,??DataTable15_3
   \   0000017E   ........           BL       I2C_EE_BufferWrite
   \   00000182   21E0               B.N      ??Memory_Config_4
    173                    }
    174          
    175               }else          // 처음 데이터를 불러오는 것이라면
    176               {
    177                      
    178                    memset(Buffer,0,sizeof(Buffer));            
   \                     ??Memory_Config_3:
   \   00000184   4FF40072           MOV      R2,#+512
   \   00000188   0021               MOVS     R1,#+0
   \   0000018A   ........           LDR.W    R0,??DataTable15_3
   \   0000018E   ........           BL       memset
    179                    I2C_Ems_Accure.Verify = I2C_EEPROM_VERIFY0;          
   \   00000192   ........           LDR.W    R0,??DataTable15_6
   \   00000196   4EF60261           MOVW     R1,#+60930
   \   0000019A   A0F80D10           STRH     R1,[R0, #+13]
    180          	     memcpy(&Buffer[DataSize],&I2C_Ems_Accure,sizeof(I2C_Ems_Accure));     
   \   0000019E   0F22               MOVS     R2,#+15
   \   000001A0   ........           LDR.W    R1,??DataTable15_6
   \   000001A4   ........           LDR.W    R0,??DataTable15_3
   \   000001A8   2018               ADDS     R0,R4,R0
   \   000001AA   ........           BL       memcpy
    181                    DataSize = sizeof(EMS_Drive_Value);           
   \   000001AE   2424               MOVS     R4,#+36
    182                    DataSize += sizeof(I2C_Ems_Accure);
   \   000001B0   0F34               ADDS     R4,R4,#+15
    183                    Info.EcoStatus  = 0;                   // 기존 에코상태
   \   000001B2   ........           LDR.W    R0,??DataTable15_7
   \   000001B6   0021               MOVS     R1,#+0
   \   000001B8   0176               STRB     R1,[R0, #+24]
    184                    I2C_EE_BufferWrite(Buffer, I2C_EEPROM_WriteAddress0 , DataSize  ); 	          
   \   000001BA   2200               MOVS     R2,R4
   \   000001BC   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000001BE   0021               MOVS     R1,#+0
   \   000001C0   ........           LDR.W    R0,??DataTable15_3
   \   000001C4   ........           BL       I2C_EE_BufferWrite
    185                    
    186               }
    187               Info.Total_StartCount = I2C_Ems_Accure.Total_StartMoter;
   \                     ??Memory_Config_4:
   \   000001C8   ........           LDR.W    R0,??DataTable15_7
   \   000001CC   ........           LDR.W    R1,??DataTable15_6
   \   000001D0   0968               LDR      R1,[R1, #+0]
   \   000001D2   C0F82610           STR      R1,[R0, #+38]
    188               Info.Total_Drive_PulsCount1 = I2C_Ems_Accure.Total_Drive_PulsCount1;
   \   000001D6   ........           LDR.W    R0,??DataTable15_7
   \   000001DA   ........           LDR.W    R1,??DataTable15_6
   \   000001DE   4968               LDR      R1,[R1, #+4]
   \   000001E0   C0F82A10           STR      R1,[R0, #+42]
    189               Info.Total_Drive_PulsCount2 = I2C_Ems_Accure.Total_Drive_PulsCount2;     
   \   000001E4   ........           LDR.W    R0,??DataTable15_7
   \   000001E8   ........           LDR.W    R1,??DataTable15_6
   \   000001EC   0989               LDRH     R1,[R1, #+8]
   \   000001EE   C185               STRH     R1,[R0, #+46]
    190               Info.AccidentCount = I2C_Ems_Accure.AccidentCount;
   \   000001F0   ........           LDR.W    R0,??DataTable15_7
   \   000001F4   ........           LDR.W    R1,??DataTable15_6
   \   000001F8   B1F80B10           LDRH     R1,[R1, #+11]
   \   000001FC   8184               STRH     R1,[R0, #+36]
    191               
    192               DTG_EMS_DataLoad( NAND_Header_Index.Page_Count );  
   \   000001FE   ........           LDR.W    R0,??DataTable15_2
   \   00000202   4068               LDR      R0,[R0, #+4]
   \   00000204   ........           BL       DTG_EMS_DataLoad
    193               
    194               if(NAND_Buffer[8189] == 0xAA && NAND_Buffer[8190] == 0xAA  && NAND_Buffer[8191] == 0xAA )
   \   00000208   ........           LDR.W    R0,??DataTable15_8
   \   0000020C   0078               LDRB     R0,[R0, #+0]
   \   0000020E   AA28               CMP      R0,#+170
   \   00000210   32D1               BNE.N    ??Memory_Config_5
   \   00000212   ........           LDR.W    R0,??DataTable15_9
   \   00000216   0078               LDRB     R0,[R0, #+0]
   \   00000218   AA28               CMP      R0,#+170
   \   0000021A   2DD1               BNE.N    ??Memory_Config_5
   \   0000021C   ........           LDR.W    R0,??DataTable15_10
   \   00000220   0078               LDRB     R0,[R0, #+0]
   \   00000222   AA28               CMP      R0,#+170
   \   00000224   28D1               BNE.N    ??Memory_Config_5
    195               {
    196                    // 시작하는 처음 블럭부터 다시 쓴다.
    197                    PageNum = (( NAND_Header_Index.Page_Count / 128 ) *128);
   \   00000226   ........           LDR.W    R0,??DataTable15_2
   \   0000022A   4068               LDR      R0,[R0, #+4]
   \   0000022C   C009               LSRS     R0,R0,#+7
   \   0000022E   8021               MOVS     R1,#+128
   \   00000230   01FB00F4           MUL      R4,R1,R0
    198          
    199                    NAND_ERASE_PAGE(PageNum);          
   \   00000234   2000               MOVS     R0,R4
   \   00000236   ........           BL       NAND_ERASE_PAGE
    200                                  
    201                    NAND_Header_Info.End_Page = PageNum;           // 초기화시 마지막 페이지가 더작으면
   \   0000023A   ........           LDR.W    R0,??DataTable15
   \   0000023E   8460               STR      R4,[R0, #+8]
    202                    if(NAND_Header_Info.End_Page < NAND_Header_Info.Start_Page)          
   \   00000240   ........           LDR.W    R0,??DataTable15
   \   00000244   8068               LDR      R0,[R0, #+8]
   \   00000246   ........           LDR.W    R1,??DataTable15
   \   0000024A   4968               LDR      R1,[R1, #+4]
   \   0000024C   8842               CMP      R0,R1
   \   0000024E   02D2               BCS.N    ??Memory_Config_6
    203                         NAND_Header_Info.Start_Page = PageNum;
   \   00000250   ........           LDR.W    R0,??DataTable15
   \   00000254   4460               STR      R4,[R0, #+4]
    204                    // 총페이지 수만 그대로 남김
    205                    NAND_Header_Index.Page_Count = PageNum;     
   \                     ??Memory_Config_6:
   \   00000256   ........           LDR.W    R0,??DataTable15_2
   \   0000025A   4460               STR      R4,[R0, #+4]
    206                    // 초기화
    207                    
    208                    NAND_Data_Transmit.End_Page = PageNum;       // 초기화시 마지막 페이지가 더작으면
   \   0000025C   ........           LDR.W    R0,??DataTable15_4
   \   00000260   4460               STR      R4,[R0, #+4]
    209                    if(NAND_Data_Transmit.End_Page < NAND_Data_Transmit.Start_Page )
   \   00000262   ........           LDR.W    R0,??DataTable15_4
   \   00000266   4068               LDR      R0,[R0, #+4]
   \   00000268   ........           LDR.W    R1,??DataTable15_4
   \   0000026C   0968               LDR      R1,[R1, #+0]
   \   0000026E   8842               CMP      R0,R1
   \   00000270   02D2               BCS.N    ??Memory_Config_5
    210                         NAND_Data_Transmit.Start_Page = PageNum; 
   \   00000272   ........           LDR.W    R0,??DataTable15_4
   \   00000276   0460               STR      R4,[R0, #+0]
    211               }
    212          }
   \                     ??Memory_Config_5:
   \   00000278   1FBD               POP      {R0-R4,PC}       ;; return
    213          

   \                                 In section .text, align 2, keep-with-next
    214          void Write_Header_EMS(void)           // 인덱스를 저장한다.
    215          {
   \                     Write_Header_EMS:
   \   00000000   10B5               PUSH     {R4,LR}
    216               u16 DataSize;
    217               DataSize = sizeof( EMS_Drive_Value );
   \   00000002   2424               MOVS     R4,#+36
    218               memcpy(&Buffer,&EMS_Drive_Value, DataSize);        // 일일 운행거리와      
   \   00000004   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000006   2200               MOVS     R2,R4
   \   00000008   ........           LDR.W    R1,??DataTable15_5
   \   0000000C   ........           LDR.W    R0,??DataTable15_3
   \   00000010   ........           BL       memcpy
    219               
    220               I2C_Ems_Accure.Total_StartMoter = Info.Total_StartCount;
   \   00000014   ........           LDR.W    R0,??DataTable15_7
   \   00000018   D0F82600           LDR      R0,[R0, #+38]
   \   0000001C   ........           LDR.W    R1,??DataTable15_6
   \   00000020   0860               STR      R0,[R1, #+0]
    221               I2C_Ems_Accure.Total_Drive_PulsCount1 = Info.Total_Drive_PulsCount1;
   \   00000022   ........           LDR.W    R0,??DataTable15_6
   \   00000026   ........           LDR.W    R1,??DataTable15_7
   \   0000002A   D1F82A10           LDR      R1,[R1, #+42]
   \   0000002E   4160               STR      R1,[R0, #+4]
    222               
    223               I2C_Ems_Accure.Total_Drive_PulsCount2 = Info.Total_Drive_PulsCount2;     
   \   00000030   ........           LDR.W    R0,??DataTable15_6
   \   00000034   ........           LDR.W    R1,??DataTable15_7
   \   00000038   C98D               LDRH     R1,[R1, #+46]
   \   0000003A   0181               STRH     R1,[R0, #+8]
    224               
    225               I2C_Ems_Accure.ECO_Drive = Info.EcoStatus ;                   // 기존 에코상태
   \   0000003C   ........           LDR.W    R0,??DataTable15_6
   \   00000040   ........           LDR.W    R1,??DataTable15_7
   \   00000044   097E               LDRB     R1,[R1, #+24]
   \   00000046   8172               STRB     R1,[R0, #+10]
    226               
    227               I2C_Ems_Accure.AccidentCount = Info.AccidentCount ;                   // 사고 이벤트 카운트
   \   00000048   ........           LDR.W    R0,??DataTable15_6
   \   0000004C   ........           LDR.W    R1,??DataTable15_7
   \   00000050   898C               LDRH     R1,[R1, #+36]
   \   00000052   A0F80B10           STRH     R1,[R0, #+11]
    228               
    229               I2C_Ems_Accure.Verify = I2C_EEPROM_VERIFY0;                           // 누적 운행거리 저장한다.
   \   00000056   ........           LDR.W    R0,??DataTable15_6
   \   0000005A   4EF60261           MOVW     R1,#+60930
   \   0000005E   A0F80D10           STRH     R1,[R0, #+13]
    230               memcpy(&Buffer[DataSize],&I2C_Ems_Accure,sizeof(I2C_Ems_Accure));	     
   \   00000062   0F22               MOVS     R2,#+15
   \   00000064   ........           LDR.W    R1,??DataTable15_6
   \   00000068   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000006A   ........           LDR.W    R0,??DataTable15_3
   \   0000006E   2018               ADDS     R0,R4,R0
   \   00000070   ........           BL       memcpy
    231               I2C_EE_BufferWrite(Buffer, I2C_EEPROM_WriteAddress0 , DataSize + sizeof(I2C_Ems_Accure) ); 	      
   \   00000074   14F10F02           ADDS     R2,R4,#+15
   \   00000078   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000007A   0021               MOVS     R1,#+0
   \   0000007C   ........           LDR.W    R0,??DataTable15_3
   \   00000080   ........           BL       I2C_EE_BufferWrite
    232          }
   \   00000084   10BD               POP      {R4,PC}          ;; return
    233          

   \                                 In section .text, align 2, keep-with-next
    234          void Write_Header_Index(void)      // NAND 인덱스를 저장
    235          {
   \                     Write_Header_Index:
   \   00000000   80B5               PUSH     {R7,LR}
    236          
    237               NAND_Header_Index.Verify = I2C_EEPROM_VERIFY1;
   \   00000002   ........           LDR.W    R0,??DataTable15_2
   \   00000006   4EF60361           MOVW     R1,#+60931
   \   0000000A   0181               STRH     R1,[R0, #+8]
    238          	memcpy(Buffer,&NAND_Header_Index,sizeof(HEADER_Index));	     
   \   0000000C   0A22               MOVS     R2,#+10
   \   0000000E   ........           LDR.W    R1,??DataTable15_2
   \   00000012   ........           LDR.W    R0,??DataTable15_3
   \   00000016   ........           BL       memcpy
    239          	I2C_EE_BufferWrite(Buffer, I2C_EEPROM_WriteAddress1 , sizeof(HEADER_Index) ); 	    
   \   0000001A   0A22               MOVS     R2,#+10
   \   0000001C   4021               MOVS     R1,#+64
   \   0000001E   ........           LDR.W    R0,??DataTable15_3
   \   00000022   ........           BL       I2C_EE_BufferWrite
    240          }
   \   00000026   01BD               POP      {R0,PC}          ;; return
    241          

   \                                 In section .text, align 2, keep-with-next
    242          void Write_Transmit_Header(void)        // 정송 시작과 끝을 저장한다.
    243          {
   \                     Write_Transmit_Header:
   \   00000000   80B5               PUSH     {R7,LR}
    244               NAND_Data_Transmit.Verify = I2C_EEPROM_VERIFY2;
   \   00000002   ........           LDR.W    R0,??DataTable15_4
   \   00000006   4EF60461           MOVW     R1,#+60932
   \   0000000A   0181               STRH     R1,[R0, #+8]
    245          	memcpy(Buffer,&NAND_Data_Transmit,sizeof(DATA_Transmit));	     
   \   0000000C   0A22               MOVS     R2,#+10
   \   0000000E   ........           LDR.W    R1,??DataTable15_4
   \   00000012   ........           LDR.W    R0,??DataTable15_3
   \   00000016   ........           BL       memcpy
    246          	I2C_EE_BufferWrite(Buffer, I2C_EEPROM_WriteAddress2 , sizeof(DATA_Transmit) ); 	     
   \   0000001A   0A22               MOVS     R2,#+10
   \   0000001C   6021               MOVS     R1,#+96
   \   0000001E   ........           LDR.W    R0,??DataTable15_3
   \   00000022   ........           BL       I2C_EE_BufferWrite
    247          }
   \   00000026   01BD               POP      {R0,PC}          ;; return
    248          

   \                                 In section .text, align 2, keep-with-next
    249          void Write_Header_Information(void)          // 실제 NAND 데이터를 저장하고 기록 한다.
    250          {
   \                     Write_Header_Information:
   \   00000000   80B5               PUSH     {R7,LR}
    251               memset(&Buffer , 0 , sizeof(Buffer) );     
   \   00000002   4FF40072           MOV      R2,#+512
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   ........           LDR.W    R0,??DataTable15_3
   \   0000000C   ........           BL       memset
    252               memcpy(Buffer, &NAND_Header_Info, HEADER_INFO_SIZE ) ;            
   \   00000010   1022               MOVS     R2,#+16
   \   00000012   ........           LDR.W    R1,??DataTable15
   \   00000016   ........           LDR.W    R0,??DataTable15_3
   \   0000001A   ........           BL       memcpy
    253               I2C_EE_BufferWrite( Buffer, I2C_EEPROM_WriteAddress3 + ( NAND_Header_Index.Write_Point * HEADER_INFO_SIZE ), HEADER_INFO_SIZE  ) ;
   \   0000001E   1022               MOVS     R2,#+16
   \   00000020   ........           LDR.W    R0,??DataTable15_2
   \   00000024   4088               LDRH     R0,[R0, #+2]
   \   00000026   0001               LSLS     R0,R0,#+4
   \   00000028   10F18001           ADDS     R1,R0,#+128
   \   0000002C   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000002E   ........           LDR.W    R0,??DataTable15_3
   \   00000032   ........           BL       I2C_EE_BufferWrite
    254          
    255               // 다음 위치 인덱스 클리어 시키기
    256          //     memset(&Buffer , 0 , sizeof(Buffer) );
    257          //     I2C_EE_BufferWrite( Buffer, I2C_EEPROM_WriteAddress3 + ( ( NAND_Header_Index.Write_Point + 1 ) * HEADER_INFO_SIZE ) , HEADER_INFO_SIZE  ) ;            
    258          }
   \   00000036   01BD               POP      {R0,PC}          ;; return
    259          
    260          

   \                                 In section .text, align 2, keep-with-next
    261          void Accident_DataSave( u16 Count )     // 충돌이벤트 저장
    262          {
   \                     Accident_DataSave:
   \   00000000   1CB5               PUSH     {R2-R4,LR}
    263          
    264               NAND_ADDRESS NAND_PAGE;
    265               u32 DataSize = 0;
   \   00000002   0024               MOVS     R4,#+0
    266               NAND_PAGE = Get_NAND_PageAddress( ( MAX_NAND_PAGE + 1 ) + Count );
   \   00000004   B0F5C051           SUBS     R1,R0,#+6144
   \   00000008   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000A   00A8               ADD      R0,SP,#+0
   \   0000000C   ........           BL       Get_NAND_PageAddress
    267          
    268               //printf("%d %d %d %d \r\n",Page_Num, NAND_PAGE.Zone,NAND_PAGE.Block,NAND_PAGE.Page);	
    269          	if( NAND_PAGE.Page == 0 )
   \   00000010   BDF80400           LDRH     R0,[SP, #+4]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   03D1               BNE.N    ??Accident_DataSave_0
    270          	{
    271                    // 페이지가 첫번째 페이지를 기록하기 전에 블럭을 삭제한다.
    272                 //   printf("NAND ERASE!!!!!!!!!!!\r\n");
    273                  FSMC_NAND_EraseBlock(NAND_PAGE);
   \   00000018   DDE90001           LDRD     R0,R1,[SP, #+0]
   \   0000001C   ........           BL       FSMC_NAND_EraseBlock
    274          	}
    275          
    276               DataSize = sizeof(DTG_NAND_Binary[0]);     
   \                     ??Accident_DataSave_0:
   \   00000020   4724               MOVS     R4,#+71
    277               
    278               memset(NAND_Buffer, 0, sizeof( NAND_Buffer ) );
   \   00000022   42F20102           MOVW     R2,#+8193
   \   00000026   0021               MOVS     R1,#+0
   \   00000028   ........           LDR.W    R0,??DataTable15_11
   \   0000002C   ........           BL       memset
    279               
    280               //----- EMS 데이터 저장 ---------------------------------------------------    
    281          
    282               DataSize = sizeof(Accident_Time);
   \   00000030   0D20               MOVS     R0,#+13
   \   00000032   0400               MOVS     R4,R0
    283               // 0.01초 데이터 저장
    284               memcpy( &NAND_Buffer , &Accident_Time , DataSize );
   \   00000034   2200               MOVS     R2,R4
   \   00000036   ........           LDR.W    R1,??DataTable15_12
   \   0000003A   ........           LDR.W    R0,??DataTable15_11
   \   0000003E   ........           BL       memcpy
    285               memcpy( &NAND_Buffer[ DataSize ] ,Accident_SaveBuffer, sizeof(Accident_SaveBuffer));
   \   00000042   4FF4FA52           MOV      R2,#+8000
   \   00000046   ........           LDR.W    R1,??DataTable15_13
   \   0000004A   ........           LDR.W    R0,??DataTable15_11
   \   0000004E   2018               ADDS     R0,R4,R0
   \   00000050   ........           BL       memcpy
    286               // 1 초 데이터 저장
    287               DataSize += sizeof(Accident_SaveBuffer);
   \   00000054   14F5FA54           ADDS     R4,R4,#+8000
    288               memcpy( &NAND_Buffer[ DataSize ] ,Accident2_SaveBuffer, sizeof(Accident2_SaveBuffer));          
   \   00000058   AA22               MOVS     R2,#+170
   \   0000005A   ........           LDR.W    R1,??DataTable15_14
   \   0000005E   ........           LDR.W    R0,??DataTable15_11
   \   00000062   2018               ADDS     R0,R4,R0
   \   00000064   ........           BL       memcpy
    289          
    290               // 저장 하기
    291               FSMC_NAND_WriteSmallPage(NAND_Buffer,NAND_PAGE,1);		// 데이터를 기록 한다.
   \   00000068   0123               MOVS     R3,#+1
   \   0000006A   DDE90012           LDRD     R1,R2,[SP, #+0]
   \   0000006E   ........           LDR.W    R0,??DataTable15_11
   \   00000072   ........           BL       FSMC_NAND_WriteSmallPage
    292               
    293          }
   \   00000076   13BD               POP      {R0,R1,R4,PC}    ;; return
    294          

   \                                 In section .text, align 2, keep-with-next
    295          u8 NAND_ERASE_PAGE(u32 Page_Num)
    296          {
   \                     NAND_ERASE_PAGE:
   \   00000000   1CB5               PUSH     {R2-R4,LR}
   \   00000002   0400               MOVS     R4,R0
    297               u16 i;
    298               NAND_ADDRESS NAND_PAGE;
    299             
    300          
    301               NAND_PAGE = Get_NAND_PageAddress(Page_Num);     
   \   00000004   2100               MOVS     R1,R4
   \   00000006   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000008   00A8               ADD      R0,SP,#+0
   \   0000000A   ........           BL       Get_NAND_PageAddress
   \   0000000E   12E0               B.N      ??NAND_ERASE_PAGE_0
    302               
    303               while(1)
    304               {
    305                    // 블럭 오류 확인
    306                    //
    307                    if( FSMC_NAND_EraseBlock(NAND_PAGE) == NAND_TIMEOUT_ERROR )
    308                    {
    309                         //                    LUT[Address.Block] = Page_Num ;
    310                         // 배드블럭이라고 한다면 
    311                         Page_Num+=128;
    312                         NAND_PAGE = Get_NAND_PageAddress(Page_Num);      
    313                         
    314                         for( i = ( Page_Num / 128 )  ; i < 2075 ; i++ )
    315                              LookUpTable.LUT[i] = LookUpTable.LUT[i +1] ;
   \                     ??NAND_ERASE_PAGE_1:
   \   00000010   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000012   ........           LDR.W    R1,??DataTable15_15
   \   00000016   11EB4001           ADDS     R1,R1,R0, LSL #+1
   \   0000001A   4988               LDRH     R1,[R1, #+2]
   \   0000001C   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001E   ........           LDR.W    R2,??DataTable15_15
   \   00000022   22F81010           STRH     R1,[R2, R0, LSL #+1]
   \   00000026   401C               ADDS     R0,R0,#+1
   \                     ??NAND_ERASE_PAGE_2:
   \   00000028   40F61B01           MOVW     R1,#+2075
   \   0000002C   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002E   8842               CMP      R0,R1
   \   00000030   EED3               BCC.N    ??NAND_ERASE_PAGE_1
    316                         
    317                         Save_LookupTable();
   \   00000032   ........           BL       Save_LookupTable
   \                     ??NAND_ERASE_PAGE_0:
   \   00000036   DDE90001           LDRD     R0,R1,[SP, #+0]
   \   0000003A   ........           BL       FSMC_NAND_EraseBlock
   \   0000003E   B0F5806F           CMP      R0,#+1024
   \   00000042   07D1               BNE.N    ??NAND_ERASE_PAGE_3
   \   00000044   8034               ADDS     R4,R4,#+128
   \   00000046   2100               MOVS     R1,R4
   \   00000048   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000004A   00A8               ADD      R0,SP,#+0
   \   0000004C   ........           BL       Get_NAND_PageAddress
   \   00000050   E009               LSRS     R0,R4,#+7
   \   00000052   E9E7               B.N      ??NAND_ERASE_PAGE_2
    318                    }else
    319                    {
    320                         break;
    321                    }
    322               }     
    323               
    324          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "NAND_ERASE_PAGE"
   \                     ??NAND_ERASE_PAGE_3:
   \   00000054   16BD               POP      {R1,R2,R4,PC}    ;; return
    325          

   \                                 In section .text, align 2, keep-with-next
    326          void DTG_EMS_DataSave(u32 Page_Num , u16 DataCount)
    327          {
   \                     DTG_EMS_DataSave:
   \   00000000   7CB5               PUSH     {R2-R6,LR}
   \   00000002   0500               MOVS     R5,R0
   \   00000004   0C00               MOVS     R4,R1
    328          
    329               u16 DataSize ;
    330               u16 i;
    331               NAND_ADDRESS NAND_PAGE;
    332               
    333          //     if(!CheckTimeOver(10,MemoryTime))     // 1초마다 한번씩만 동작하도록한다.
    334          //		return ;     
    335          //     MemoryTime = MS_TIMER;     
    336          
    337               NAND_PAGE = Get_NAND_PageAddress(Page_Num);
   \   00000006   2900               MOVS     R1,R5
   \   00000008   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000A   00A8               ADD      R0,SP,#+0
   \   0000000C   ........           BL       Get_NAND_PageAddress
    338          
    339               //printf("%d %d %d %d \r\n",Page_Num, NAND_PAGE.Zone,NAND_PAGE.Block,NAND_PAGE.Page);	
    340          	if( NAND_PAGE.Page == 0 )
   \   00000010   BDF80400           LDRH     R0,[SP, #+4]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   02D1               BNE.N    ??DTG_EMS_DataSave_0
    341          	{
    342                    // 페이지가 첫번째 페이지를 기록하기 전에 블럭을 삭제한다.
    343                 //   printf("NAND ERASE!!!!!!!!!!!\r\n");
    344                       NAND_ERASE_PAGE(Page_Num);
   \   00000018   2800               MOVS     R0,R5
   \   0000001A   ........           BL       NAND_ERASE_PAGE
    345          	}
    346          
    347               DataSize = sizeof(DTG_NAND_Binary[0]);     
   \                     ??DTG_EMS_DataSave_0:
   \   0000001E   4725               MOVS     R5,#+71
    348               
    349               memset(NAND_Buffer,0, sizeof( NAND_Buffer ) );
   \   00000020   42F20102           MOVW     R2,#+8193
   \   00000024   0021               MOVS     R1,#+0
   \   00000026   ........           LDR.W    R0,??DataTable15_11
   \   0000002A   ........           BL       memset
    350               
    351               //----- EMS 데이터 저장 ---------------------------------------------------    
    352               
    353               memcpy( &NAND_Buffer , &EMS_Drive_Value , EMS_SIZE );
   \   0000002E   2422               MOVS     R2,#+36
   \   00000030   ........           LDR.W    R1,??DataTable15_5
   \   00000034   ........           LDR.W    R0,??DataTable15_11
   \   00000038   ........           BL       memcpy
    354               
    355               //-------------------------------------------------------------------------
    356               for ( i = 0 ; i < DataCount ; i++)
   \   0000003C   0026               MOVS     R6,#+0
   \   0000003E   11E0               B.N      ??DTG_EMS_DataSave_1
    357               {
    358          	     memcpy( &NAND_Buffer[ ( EMS_SIZE + ( i * DataSize ) ) ], &DTG_NAND_Binary[i], DataSize );
   \                     ??DTG_EMS_DataSave_2:
   \   00000040   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000042   2A00               MOVS     R2,R5
   \   00000044   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000046   4720               MOVS     R0,#+71
   \   00000048   ........           LDR.W    R1,??DataTable15_16
   \   0000004C   00FB0611           MLA      R1,R0,R6,R1
   \   00000050   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000052   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000054   ........           LDR.W    R0,??DataTable15_11
   \   00000058   05FB0600           MLA      R0,R5,R6,R0
   \   0000005C   2430               ADDS     R0,R0,#+36
   \   0000005E   ........           BL       memcpy
    359               }
   \   00000062   761C               ADDS     R6,R6,#+1
   \                     ??DTG_EMS_DataSave_1:
   \   00000064   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000066   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000068   A642               CMP      R6,R4
   \   0000006A   E9D3               BCC.N    ??DTG_EMS_DataSave_2
    360               NAND_Buffer[8189] = 0xAA;
   \   0000006C   ........           LDR.W    R0,??DataTable15_8
   \   00000070   AA21               MOVS     R1,#+170
   \   00000072   0170               STRB     R1,[R0, #+0]
    361               NAND_Buffer[8190] = 0xAA;
   \   00000074   ........           LDR.W    R0,??DataTable15_9
   \   00000078   AA21               MOVS     R1,#+170
   \   0000007A   0170               STRB     R1,[R0, #+0]
    362               NAND_Buffer[8191] = 0xAA;     
   \   0000007C   ........           LDR.W    R0,??DataTable15_10
   \   00000080   AA21               MOVS     R1,#+170
   \   00000082   0170               STRB     R1,[R0, #+0]
    363               FSMC_NAND_WriteSmallPage(NAND_Buffer,NAND_PAGE,1);		// 데이터를 기록 한다.
   \   00000084   0123               MOVS     R3,#+1
   \   00000086   DDE90012           LDRD     R1,R2,[SP, #+0]
   \   0000008A   ........           LDR.W    R0,??DataTable15_11
   \   0000008E   ........           BL       FSMC_NAND_WriteSmallPage
    364             	#ifdef DEBUG_LOG 
    365          	//--------------------- 로그 기록 --------------------------------------
    366          	if(LOGWRITE & LOG_MEMORY)
    367          	{
    368          		sprintf((char *)Buffer,"NAND_FLASH WRITTEND Z=%d B=%d P=%d \r\n",NAND_PAGE.Zone,NAND_PAGE.Block,NAND_PAGE.Page);
    369          		Write_Log(Buffer, NORMAL_LOG);
    370          	}	
    371          #endif
    372          }
   \   00000092   73BD               POP      {R0,R1,R4-R6,PC}  ;; return
    373          

   \                                 In section .text, align 2, keep-with-next
    374          void DTG_EMS_DataLoad(u32 Page_Num)
    375          {
   \                     DTG_EMS_DataLoad:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   83B0               SUB      SP,SP,#+12
    376          //     u16 DataSize ;
    377          
    378               NAND_ADDRESS NAND_PAGE;
    379                    
    380          //     DataSize = sizeof(DTG_NAND_Binary[0]);     
    381          	
    382               NAND_PAGE = Get_NAND_PageAddress(Page_Num);
   \   00000004   0100               MOVS     R1,R0
   \   00000006   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000008   00A8               ADD      R0,SP,#+0
   \   0000000A   ........           BL       Get_NAND_PageAddress
    383          	memset(NAND_Buffer, 0 ,sizeof(NAND_Buffer) );
   \   0000000E   42F20102           MOVW     R2,#+8193
   \   00000012   0021               MOVS     R1,#+0
   \   00000014   ........           LDR.W    R0,??DataTable15_11
   \   00000018   ........           BL       memset
    384               FSMC_NAND_ReadSmallPage( NAND_Buffer, NAND_PAGE, 1);		// 데이터를 기록을 읽는다.
   \   0000001C   0123               MOVS     R3,#+1
   \   0000001E   DDE90012           LDRD     R1,R2,[SP, #+0]
   \   00000022   ........           LDR.W    R0,??DataTable15_11
   \   00000026   ........           BL       FSMC_NAND_ReadSmallPage
    385          	
    386          //     memcpy( &EMS_Drive_Value, &NAND_Buffer, EMS_SIZE );
    387          #ifdef DEBUG_LOG 
    388          	//--------------------- 로그 기록 --------------------------------------
    389          	if(LOGWRITE & LOG_MEMORY)
    390          	{
    391          		sprintf((char *)Buffer,"NAND_FLASH READ Z=%d B=%d P=%d \r\n",NAND_PAGE.Zone,NAND_PAGE.Block,NAND_PAGE.Page);
    392          		Write_Log(Buffer, NORMAL_LOG);
    393          	}
    394          #endif
    395          }
   \   0000002A   07BD               POP      {R0-R2,PC}       ;; return
    396          

   \                                 In section .text, align 2, keep-with-next
    397          void Convert_Binary(char *Str, u32 Num)
    398          {	
    399          	Str[0] = (Num >> 24)&0xff;
   \                     Convert_Binary:
   \   00000000   0A0E               LSRS     R2,R1,#+24
   \   00000002   0270               STRB     R2,[R0, #+0]
    400          	Str[1] = (Num >> 16)&0xff;
   \   00000004   0A0C               LSRS     R2,R1,#+16
   \   00000006   4270               STRB     R2,[R0, #+1]
    401          	Str[2] = (Num >> 8)&0xff;
   \   00000008   0A0A               LSRS     R2,R1,#+8
   \   0000000A   8270               STRB     R2,[R0, #+2]
    402          	Str[3] = Num &0xff;
   \   0000000C   C170               STRB     R1,[R0, #+3]
    403          }
   \   0000000E   7047               BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    404          void Convert_Data(void)
    405          {
    406          //	u16 Index NAND_Index.Index;
    407          	
    408          //	DTG_Raw_Memory.DayDriveLength = 0;
    409          	
    410          //	memcpy(DTG_NAND_Binary[Index], DTG_Raw_Memory, sizeof( DTG_Raw_Memory ) );
    411          //	memcpy(DTG_NAND_Binary[Index], DTG_Raw_Memory, sizeof( DTG_Raw_Memory ) );
    412          }
   \                     Convert_Data:
   \   00000000   7047               BX       LR               ;; return
    413          
    414          //
    415          // 1초 마다 메모리 처리 
    416          //

   \                                 In section .text, align 2, keep-with-next
    417          void Page_Stack(void)
    418          {
    419          	
    420          }
   \                     Page_Stack:
   \   00000000   7047               BX       LR               ;; return
    421          

   \                                 In section .text, align 2, keep-with-next
    422          void Memory_Process(void)		
    423          {	
   \                     Memory_Process:
   \   00000000   38B5               PUSH     {R3-R5,LR}
    424          //	static u16 MemoryTimer = 0;
    425          // 	static u16 MSec_Count = 0;
    426          // 	static u16 Sec_Count = 0;
    427               
    428               static u8 OldSec;
    429          //     static u32 TimerCount = 0;
    430               u32 TimerData;
    431            
    432               if(OldSec != SYSTEM_TIME.tm_sec)
   \   00000002   ........           LDR.W    R0,??DataTable15_17
   \   00000006   0078               LDRB     R0,[R0, #+0]
   \   00000008   ........           LDR.W    R1,??DataTable15_1
   \   0000000C   0968               LDR      R1,[R1, #+0]
   \   0000000E   8842               CMP      R0,R1
   \   00000010   00F03781           BEQ.W    ??Memory_Process_0
    433               {
    434                     TimerData = RTC_DateToBinary(&SYSTEM_TIME);
   \   00000014   ........           LDR.W    R0,??DataTable15_1
   \   00000018   ........           BL       RTC_DateToBinary
   \   0000001C   0400               MOVS     R4,R0
    435                     // printf("%d %d \r\n",Sec_Count,SYSTEM_TIME.tm_sec);
    436          
    437                     // 거리 계산 공식 임시 적용 0.0196247
    438                     memcpy(DTG_NAND_Binary[Info.DTG_DataCount].Driver_Num, Info.Driver_Num, DRIVER_NUM_SIZE);
   \   0000001E   1222               MOVS     R2,#+18
   \   00000020   ........           LDR.W    R1,??DataTable15_18
   \   00000024   ........           LDR.W    R0,??DataTable15_7
   \   00000028   90F86200           LDRB     R0,[R0, #+98]
   \   0000002C   4723               MOVS     R3,#+71
   \   0000002E   ........           LDR.W    R5,??DataTable15_16
   \   00000032   03FB0050           MLA      R0,R3,R0,R5
   \   00000036   ........           BL       memcpy
    439                     DTG_NAND_Binary[Info.DTG_DataCount].DayDriveLength = Info.DayDriveLength;//SYSTEM_TIME.tm_sec;      // 일일 거리
   \   0000003A   ........           LDR.W    R0,??DataTable15_7
   \   0000003E   90F86200           LDRB     R0,[R0, #+98]
   \   00000042   4721               MOVS     R1,#+71
   \   00000044   ........           LDR.W    R2,??DataTable15_16
   \   00000048   01FB0020           MLA      R0,R1,R0,R2
   \   0000004C   ........           LDR.W    R1,??DataTable15_7
   \   00000050   498B               LDRH     R1,[R1, #+26]
   \   00000052   A0F81310           STRH     R1,[R0, #+19]
    440                     // 거리계산이 필요한가?
    441                     DTG_NAND_Binary[Info.DTG_DataCount].TotalDriveLength = Info.TotalDriveLength;                       // 총운행거리
   \   00000056   ........           LDR.W    R0,??DataTable15_7
   \   0000005A   90F86200           LDRB     R0,[R0, #+98]
   \   0000005E   4721               MOVS     R1,#+71
   \   00000060   ........           LDR.W    R2,??DataTable15_16
   \   00000064   01FB0020           MLA      R0,R1,R0,R2
   \   00000068   ........           LDR.W    R1,??DataTable15_7
   \   0000006C   C969               LDR      R1,[R1, #+28]
   \   0000006E   C0F81510           STR      R1,[R0, #+21]
    442                     
    443                     //          DTG_NAND_Binary[Info.DTG_DataCount].Total_Drive_PulsCount1 = Info.Total_Drive_PulsCount1;           // 
    444                     //		DTG_NAND_Binary[Info.DTG_DataCount].Total_Drive_PulsCount2 = Info.Total_Drive_PulsCount2;
    445                     
    446                     DTG_NAND_Binary[Info.DTG_DataCount].Datetime = TimerData;
   \   00000072   ........           LDR.W    R0,??DataTable15_7
   \   00000076   90F86200           LDRB     R0,[R0, #+98]
   \   0000007A   4721               MOVS     R1,#+71
   \   0000007C   ........           LDR.W    R2,??DataTable15_16
   \   00000080   01FB0020           MLA      R0,R1,R0,R2
   \   00000084   C0F81940           STR      R4,[R0, #+25]
    447                     DTG_NAND_Binary[Info.DTG_DataCount].Speed = Info.SPEED_Value;//AvrageTemp1;
   \   00000088   ........           LDR.W    R0,??DataTable15_7
   \   0000008C   90F86200           LDRB     R0,[R0, #+98]
   \   00000090   4721               MOVS     R1,#+71
   \   00000092   ........           LDR.W    R2,??DataTable15_16
   \   00000096   01FB0020           MLA      R0,R1,R0,R2
   \   0000009A   ........           LDR.W    R1,??DataTable15_7
   \   0000009E   91F83410           LDRB     R1,[R1, #+52]
   \   000000A2   4177               STRB     R1,[R0, #+29]
    448                     DTG_NAND_Binary[Info.DTG_DataCount].RPM = Info.RPM_Value;//AvrageTemp2;
   \   000000A4   ........           LDR.W    R0,??DataTable15_7
   \   000000A8   90F86200           LDRB     R0,[R0, #+98]
   \   000000AC   4721               MOVS     R1,#+71
   \   000000AE   ........           LDR.W    R2,??DataTable15_16
   \   000000B2   01FB0020           MLA      R0,R1,R0,R2
   \   000000B6   ........           LDR.W    R1,??DataTable15_7
   \   000000BA   B1F83510           LDRH     R1,[R1, #+53]
   \   000000BE   C183               STRH     R1,[R0, #+30]
    449          		
    450          		DTG_NAND_Binary[Info.DTG_DataCount].Sign_Break =  Info.Sign_Break ;    				// 브레이크를 밟고 있는가?
   \   000000C0   ........           LDR.W    R0,??DataTable15_7
   \   000000C4   90F86200           LDRB     R0,[R0, #+98]
   \   000000C8   4721               MOVS     R1,#+71
   \   000000CA   ........           LDR.W    R2,??DataTable15_16
   \   000000CE   01FB0020           MLA      R0,R1,R0,R2
   \   000000D2   ........           LDR.W    R1,??DataTable15_7
   \   000000D6   91F83710           LDRB     R1,[R1, #+55]
   \   000000DA   80F82010           STRB     R1,[R0, #+32]
    451          		
    452          		DTG_NAND_Binary[Info.DTG_DataCount].GPSX = Info.GPSX ;
   \   000000DE   ........           LDR.W    R0,??DataTable15_7
   \   000000E2   90F86200           LDRB     R0,[R0, #+98]
   \   000000E6   4721               MOVS     R1,#+71
   \   000000E8   ........           LDR.W    R2,??DataTable15_16
   \   000000EC   01FB0020           MLA      R0,R1,R0,R2
   \   000000F0   ........           LDR.W    R1,??DataTable15_7
   \   000000F4   896B               LDR      R1,[R1, #+56]
   \   000000F6   C0F82110           STR      R1,[R0, #+33]
    453          		DTG_NAND_Binary[Info.DTG_DataCount].GPSY = Info.GPSY ;	
   \   000000FA   ........           LDR.W    R0,??DataTable15_7
   \   000000FE   90F86200           LDRB     R0,[R0, #+98]
   \   00000102   4721               MOVS     R1,#+71
   \   00000104   ........           LDR.W    R2,??DataTable15_16
   \   00000108   01FB0020           MLA      R0,R1,R0,R2
   \   0000010C   ........           LDR.W    R1,??DataTable15_7
   \   00000110   C96B               LDR      R1,[R1, #+60]
   \   00000112   C0F82510           STR      R1,[R0, #+37]
    454          		DTG_NAND_Binary[Info.DTG_DataCount].Azimuth = Info.Azimuth ;
   \   00000116   ........           LDR.W    R0,??DataTable15_7
   \   0000011A   90F86200           LDRB     R0,[R0, #+98]
   \   0000011E   4721               MOVS     R1,#+71
   \   00000120   ........           LDR.W    R2,??DataTable15_16
   \   00000124   01FB0020           MLA      R0,R1,R0,R2
   \   00000128   ........           LDR.W    R1,??DataTable15_7
   \   0000012C   B1F84010           LDRH     R1,[R1, #+64]
   \   00000130   A0F82910           STRH     R1,[R0, #+41]
    455          		
    456          		DTG_NAND_Binary[Info.DTG_DataCount].AccelX = Info.AccelX; //(int)( AvrageTemp3 /9.8 );
   \   00000134   ........           LDR.W    R0,??DataTable15_7
   \   00000138   90F86200           LDRB     R0,[R0, #+98]
   \   0000013C   4721               MOVS     R1,#+71
   \   0000013E   ........           LDR.W    R2,??DataTable15_16
   \   00000142   01FB0020           MLA      R0,R1,R0,R2
   \   00000146   ........           LDR.W    R1,??DataTable15_7
   \   0000014A   B1F84210           LDRH     R1,[R1, #+66]
   \   0000014E   A0F82B10           STRH     R1,[R0, #+43]
    457          		DTG_NAND_Binary[Info.DTG_DataCount].AccelY = Info.AccelY; //(int)( AvrageTemp4 /9.8 );		
   \   00000152   ........           LDR.W    R0,??DataTable15_7
   \   00000156   90F86200           LDRB     R0,[R0, #+98]
   \   0000015A   4721               MOVS     R1,#+71
   \   0000015C   ........           LDR.W    R2,??DataTable15_16
   \   00000160   01FB0020           MLA      R0,R1,R0,R2
   \   00000164   ........           LDR.W    R1,??DataTable15_7
   \   00000168   B1F84410           LDRH     R1,[R1, #+68]
   \   0000016C   A0F82D10           STRH     R1,[R0, #+45]
    458          		
    459          		DTG_NAND_Binary[Info.DTG_DataCount].MachineStatus = Info.MachineStatus ;
   \   00000170   ........           LDR.W    R0,??DataTable15_7
   \   00000174   90F86200           LDRB     R0,[R0, #+98]
   \   00000178   4721               MOVS     R1,#+71
   \   0000017A   ........           LDR.W    R2,??DataTable15_16
   \   0000017E   01FB0020           MLA      R0,R1,R0,R2
   \   00000182   ........           LDR.W    R1,??DataTable15_7
   \   00000186   91F84610           LDRB     R1,[R1, #+70]
   \   0000018A   80F82F10           STRB     R1,[R0, #+47]
    460          		//////  EMS   /////////////////////////////////////////////////////
    461          		
    462                      memcpy(&DTG_NAND_Binary[Info.DTG_DataCount].Ems_Data,&Info.EMS_Data,sizeof(EMS_VALUE));
   \   0000018E   1622               MOVS     R2,#+22
   \   00000190   ........           LDR.W    R1,??DataTable15_19
   \   00000194   ........           LDR.W    R0,??DataTable15_7
   \   00000198   90F86200           LDRB     R0,[R0, #+98]
   \   0000019C   4723               MOVS     R3,#+71
   \   0000019E   ........           LDR.W    R4,??DataTable15_16
   \   000001A2   03FB0040           MLA      R0,R3,R0,R4
   \   000001A6   3030               ADDS     R0,R0,#+48
   \   000001A8   ........           BL       memcpy
    463                      
    464                      //memcpy(&DTG_NAND_Binary[Info.DTG_DataCount].EMS_Drive_Value,&EMS_Drive_Value,sizeof(EMS_Drive_Value));
    465                      
    466                      ////////////////////////////////////////////////////////////////////////////////
    467                      
    468          		DTG_NAND_Binary[Info.DTG_DataCount].DataValid = 1;		// NAND에 들어갔을때 데이터의 유효성을확인
   \   000001AC   ........           LDR.W    R0,??DataTable15_7
   \   000001B0   90F86200           LDRB     R0,[R0, #+98]
   \   000001B4   4721               MOVS     R1,#+71
   \   000001B6   ........           LDR.W    R2,??DataTable15_16
   \   000001BA   01FB0020           MLA      R0,R1,R0,R2
   \   000001BE   0121               MOVS     R1,#+1
   \   000001C0   80F84610           STRB     R1,[R0, #+70]
    469          		
    470                      //		EMS_Drive_Value.Drive_Time ++ ;                             // 일일 운행시간
    471                      
    472                      // --------- 1 초 USB에 데이터 기록  ------------------------------------------------
    473                    
    474                    if(USBH_USR_ApplicationState == USH_USR_FS_IDLE && USBH_USR_ActionFlag == USH_USR_FS_IDLE)
   \   000001C4   ........           LDR.W    R0,??DataTable15_20
   \   000001C8   0078               LDRB     R0,[R0, #+0]
   \   000001CA   0128               CMP      R0,#+1
   \   000001CC   0DD1               BNE.N    ??Memory_Process_1
   \   000001CE   ........           LDR.W    R0,??DataTable15_21
   \   000001D2   0078               LDRB     R0,[R0, #+0]
   \   000001D4   0128               CMP      R0,#+1
   \   000001D6   08D1               BNE.N    ??Memory_Process_1
    475                    {
    476                         USBH_USR_ActionFlag = USH_USR_FS_WRITEFILE;      // 1초데이터 기록                         
   \   000001D8   ........           LDR.W    R0,??DataTable15_21
   \   000001DC   0321               MOVS     R1,#+3
   \   000001DE   0170               STRB     R1,[R0, #+0]
    477                         Convert_DTG_Data(Info.DTG_DataCount);
   \   000001E0   ....               LDR.N    R0,??DataTable15_7
   \   000001E2   90F86200           LDRB     R0,[R0, #+98]
   \   000001E6   ........           BL       Convert_DTG_Data
    478                    }
    479          
    480                    // -----------------------------------------------------------------------------
    481                    
    482                    Info.DTG_DataCount++;		// 중간에 저장하기 위해서 데이터 갯수를 센다.
   \                     ??Memory_Process_1:
   \   000001EA   ....               LDR.N    R0,??DataTable15_7
   \   000001EC   90F86200           LDRB     R0,[R0, #+98]
   \   000001F0   401C               ADDS     R0,R0,#+1
   \   000001F2   ....               LDR.N    R1,??DataTable15_7
   \   000001F4   81F86200           STRB     R0,[R1, #+98]
    483                    
    484                    /////////////////////////////////////////////////////////////////////
    485                    // 한 페이지가 모두 찼다면 		
    486                    // 30개의 데이터를 수집 하면 저장한다.		
    487                    //
    488                    
    489                    if(Info.DTG_DataCount >= 3)//DATA_IN_PAGE_SIZE)
   \   000001F8   ....               LDR.N    R0,??DataTable15_7
   \   000001FA   90F86200           LDRB     R0,[R0, #+98]
   \   000001FE   0328               CMP      R0,#+3
   \   00000200   3FD3               BCC.N    ??Memory_Process_0
    490                    {
    491                         Flag.EMS_Data_Save = 1;
   \   00000202   ........           LDR.W    R0,??DataTable15_22
   \   00000206   0121               MOVS     R1,#+1
   \   00000208   4174               STRB     R1,[R0, #+17]
    492                         // NAND FLASH 데이터 저장
    493                         
    494                         DTG_EMS_DataSave(NAND_Header_Index.Page_Count, Info.DTG_DataCount);
   \   0000020A   ....               LDR.N    R0,??DataTable15_7
   \   0000020C   90F86210           LDRB     R1,[R0, #+98]
   \   00000210   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000212   ....               LDR.N    R0,??DataTable15_2
   \   00000214   4068               LDR      R0,[R0, #+4]
   \   00000216   ........           BL       DTG_EMS_DataSave
    495                         // 헤더 저장
    496                         if(NAND_Data_Transmit.End_Page >= MAX_NAND_PAGE)
   \   0000021A   ....               LDR.N    R0,??DataTable15_4
   \   0000021C   4068               LDR      R0,[R0, #+4]
   \   0000021E   ....               LDR.N    R1,??DataTable15_23  ;; 0x3e7ff
   \   00000220   8842               CMP      R0,R1
   \   00000222   03D3               BCC.N    ??Memory_Process_2
    497                              NAND_Data_Transmit.End_Page = 0;
   \   00000224   ....               LDR.N    R0,??DataTable15_4
   \   00000226   0021               MOVS     R1,#+0
   \   00000228   4160               STR      R1,[R0, #+4]
   \   0000022A   04E0               B.N      ??Memory_Process_3
    498                         else
    499                              NAND_Data_Transmit.End_Page ++;         // 데이터 전송 페이지 저장
   \                     ??Memory_Process_2:
   \   0000022C   ....               LDR.N    R0,??DataTable15_4
   \   0000022E   4068               LDR      R0,[R0, #+4]
   \   00000230   401C               ADDS     R0,R0,#+1
   \   00000232   ....               LDR.N    R1,??DataTable15_4
   \   00000234   4860               STR      R0,[R1, #+4]
    500                         if(NAND_Header_Index.Page_Count >= MAX_NAND_PAGE)
   \                     ??Memory_Process_3:
   \   00000236   ....               LDR.N    R0,??DataTable15_2
   \   00000238   4068               LDR      R0,[R0, #+4]
   \   0000023A   ....               LDR.N    R1,??DataTable15_23  ;; 0x3e7ff
   \   0000023C   8842               CMP      R0,R1
   \   0000023E   03D3               BCC.N    ??Memory_Process_4
    501                              NAND_Header_Index.Page_Count = 0;
   \   00000240   ....               LDR.N    R0,??DataTable15_2
   \   00000242   0021               MOVS     R1,#+0
   \   00000244   4160               STR      R1,[R0, #+4]
   \   00000246   04E0               B.N      ??Memory_Process_5
    502                         else
    503                              NAND_Header_Index.Page_Count ++;
   \                     ??Memory_Process_4:
   \   00000248   ....               LDR.N    R0,??DataTable15_2
   \   0000024A   4068               LDR      R0,[R0, #+4]
   \   0000024C   401C               ADDS     R0,R0,#+1
   \   0000024E   ....               LDR.N    R1,??DataTable15_2
   \   00000250   4860               STR      R0,[R1, #+4]
    504                         if(NAND_Header_Info.End_Page >= MAX_NAND_PAGE)        
   \                     ??Memory_Process_5:
   \   00000252   ....               LDR.N    R0,??DataTable15
   \   00000254   8068               LDR      R0,[R0, #+8]
   \   00000256   ....               LDR.N    R1,??DataTable15_23  ;; 0x3e7ff
   \   00000258   8842               CMP      R0,R1
   \   0000025A   03D3               BCC.N    ??Memory_Process_6
    505                              NAND_Header_Info.End_Page = 0;
   \   0000025C   ....               LDR.N    R0,??DataTable15
   \   0000025E   0021               MOVS     R1,#+0
   \   00000260   8160               STR      R1,[R0, #+8]
   \   00000262   04E0               B.N      ??Memory_Process_7
    506                         else
    507                              NAND_Header_Info.End_Page++;
   \                     ??Memory_Process_6:
   \   00000264   ....               LDR.N    R0,??DataTable15
   \   00000266   8068               LDR      R0,[R0, #+8]
   \   00000268   401C               ADDS     R0,R0,#+1
   \   0000026A   ....               LDR.N    R1,??DataTable15
   \   0000026C   8860               STR      R0,[R1, #+8]
    508                         
    509                         // 초기화
    510                         Info.DTG_DataCount = 0;
   \                     ??Memory_Process_7:
   \   0000026E   ....               LDR.N    R0,??DataTable15_7
   \   00000270   0021               MOVS     R1,#+0
   \   00000272   80F86210           STRB     R1,[R0, #+98]
    511                         memset(DTG_NAND_Binary,0, sizeof(DTG_NAND_Binary));
   \   00000276   41F6F602           MOVW     R2,#+6390
   \   0000027A   0021               MOVS     R1,#+0
   \   0000027C   ....               LDR.N    R0,??DataTable15_16
   \   0000027E   ........           BL       memset
    512                         
    513                    }
    514               }
    515               OldSec = SYSTEM_TIME.tm_sec;
   \                     ??Memory_Process_0:
   \   00000282   ....               LDR.N    R0,??DataTable15_17
   \   00000284   ....               LDR.N    R1,??DataTable15_1
   \   00000286   0968               LDR      R1,[R1, #+0]
   \   00000288   0170               STRB     R1,[R0, #+0]
    516          }
   \   0000028A   31BD               POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .bss, align 1
   \                     ??OldSec:
   \   00000000                      DS8 1

   \                                 In section .text, align 2, keep-with-next
    517          void Convert_DTG_Data(unsigned char Index)
    518          {
   \                     Convert_DTG_Data:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   AAB0               SUB      SP,SP,#+168
   \   00000004   0400               MOVS     R4,R0
    519               TM_Struct Timer;
    520               // -- 초기화 
    521               memset(USBH_USR_DTG_Buffer,0,sizeof(USBH_USR_DTG_Buffer));
   \   00000006   4FF48072           MOV      R2,#+256
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   ....               LDR.N    R0,??DataTable15_24
   \   0000000E   ........           BL       memset
    522               // -- 메인 루트     
    523               RTC_BinaryToDate( DTG_NAND_Binary[Index].Datetime , &Timer );		// 시간저장된 데이터 변환    
   \   00000012   21A9               ADD      R1,SP,#+132
   \   00000014   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   4720               MOVS     R0,#+71
   \   00000018   ....               LDR.N    R2,??DataTable15_16
   \   0000001A   00FB0420           MLA      R0,R0,R4,R2
   \   0000001E   D0F81900           LDR      R0,[R0, #+25]
   \   00000022   ........           BL       RTC_BinaryToDate
    524          
    525               sprintf((char*)USBH_USR_DTG_Buffer,
    526                       "%02d/%02d/%02d-%02d:%02d:%02d,%018s,"
    527                       "%04d,%07d,"
    528                       "%03d,%04d,%d,"
    529                       "%03d.%06d,%03d.%06d,%03d,%0+4d,"
    530                       "%0+4d,%02d,"
    531                       "%04d,%04d,%04d,%04d,%04d,%04d,%+03d,%+03d,%03d,%03d,"
    532                       "%08x,%08x,%04x,"
    533                       "%02x,%02x\r\n",
    534                                 Timer.tm_year,Timer.tm_mon,Timer.tm_mday,
    535                                 Timer.tm_hour,Timer.tm_min,Timer.tm_sec,             
    536                                 Info.Driver_Num,                       
    537          
    538                                 DTG_NAND_Binary[Index].Speed,
    539                                 DTG_NAND_Binary[Index].RPM,
    540                                 DTG_NAND_Binary[Index].Sign_Break,
    541                                 
    542                                 DTG_NAND_Binary[Index].GPSX/ 1000000,
    543                                 DTG_NAND_Binary[Index].GPSX% 1000000,
    544                                 DTG_NAND_Binary[Index].GPSY/ 1000000,
    545                                 DTG_NAND_Binary[Index].GPSY% 1000000,
    546                                 
    547                                 DTG_NAND_Binary[Index].Azimuth,
    548                                 DTG_NAND_Binary[Index].AccelX,
    549                                 DTG_NAND_Binary[Index].AccelY,
    550          
    551                                 DTG_NAND_Binary[Index].DayDriveLength,
    552                                 DTG_NAND_Binary[Index].TotalDriveLength,                       
    553                                 
    554                                 DTG_NAND_Binary[Index].MachineStatus,
    555                                 DTG_NAND_Binary[Index].Ems_Data.Fuel_Volt,
    556                                 DTG_NAND_Binary[Index].Ems_Data.Battery_Volt,
    557                                 DTG_NAND_Binary[Index].Ems_Data.AirPressure_Volt,
    558                                 DTG_NAND_Binary[Index].Ems_Data.CoolWaterTemp_Volt,
    559                                 DTG_NAND_Binary[Index].Ems_Data.Acceller_Volt,	
    560                                 DTG_NAND_Binary[Index].Ems_Data.LPG_PWM_Value,
    561                                 DTG_NAND_Binary[Index].Ems_Data.Tilt_X,
    562                                 DTG_NAND_Binary[Index].Ems_Data.Tilt_Y,
    563                                 DTG_NAND_Binary[Index].Ems_Data.Gps_HDOP,
    564                                 DTG_NAND_Binary[Index].Ems_Data.GPS_Speed,
    565                                 Info.Total_StartCount,
    566                                 Info.Total_Drive_PulsCount1,
    567                                 Info.Total_Drive_PulsCount2,
    568                                 DTG_NAND_Binary[Index].Ems_Data.Input_Status,
    569                                 DTG_NAND_Binary[Index].Ems_Data.Out_Status
    570                                 );
   \   00000026   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000028   4720               MOVS     R0,#+71
   \   0000002A   ....               LDR.N    R1,??DataTable15_16
   \   0000002C   00FB0410           MLA      R0,R0,R4,R1
   \   00000030   D0F82500           LDR      R0,[R0, #+37]
   \   00000034   ....               LDR.N    R1,??DataTable15_25  ;; 0xf4240
   \   00000036   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   4722               MOVS     R2,#+71
   \   0000003A   ....               LDR.N    R3,??DataTable15_16
   \   0000003C   02FB0432           MLA      R2,R2,R4,R3
   \   00000040   D2F82120           LDR      R2,[R2, #+33]
   \   00000044   ....               LDR.N    R3,??DataTable15_25  ;; 0xf4240
   \   00000046   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000048   4725               MOVS     R5,#+71
   \   0000004A   ....               LDR.N    R6,??DataTable15_16
   \   0000004C   05FB0465           MLA      R5,R5,R4,R6
   \   00000050   B5F84450           LDRH     R5,[R5, #+68]
   \   00000054   2095               STR      R5,[SP, #+128]
   \   00000056   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000058   4725               MOVS     R5,#+71
   \   0000005A   ....               LDR.N    R6,??DataTable15_16
   \   0000005C   05FB0465           MLA      R5,R5,R4,R6
   \   00000060   B5F84250           LDRH     R5,[R5, #+66]
   \   00000064   1F95               STR      R5,[SP, #+124]
   \   00000066   ....               LDR.N    R5,??DataTable15_7
   \   00000068   ED8D               LDRH     R5,[R5, #+46]
   \   0000006A   1E95               STR      R5,[SP, #+120]
   \   0000006C   ....               LDR.N    R5,??DataTable15_7
   \   0000006E   D5F82A50           LDR      R5,[R5, #+42]
   \   00000072   1D95               STR      R5,[SP, #+116]
   \   00000074   ....               LDR.N    R5,??DataTable15_7
   \   00000076   D5F82650           LDR      R5,[R5, #+38]
   \   0000007A   1C95               STR      R5,[SP, #+112]
   \   0000007C   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007E   4725               MOVS     R5,#+71
   \   00000080   ....               LDR.N    R6,??DataTable15_16
   \   00000082   05FB0465           MLA      R5,R5,R4,R6
   \   00000086   ED8F               LDRH     R5,[R5, #+62]
   \   00000088   1B95               STR      R5,[SP, #+108]
   \   0000008A   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008C   4725               MOVS     R5,#+71
   \   0000008E   ....               LDR.N    R6,??DataTable15_16
   \   00000090   05FB0465           MLA      R5,R5,R4,R6
   \   00000094   B5F84050           LDRH     R5,[R5, #+64]
   \   00000098   1A95               STR      R5,[SP, #+104]
   \   0000009A   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009C   4725               MOVS     R5,#+71
   \   0000009E   ....               LDR.N    R6,??DataTable15_16
   \   000000A0   05FB0465           MLA      R5,R5,R4,R6
   \   000000A4   95F93D50           LDRSB    R5,[R5, #+61]
   \   000000A8   1995               STR      R5,[SP, #+100]
   \   000000AA   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AC   4725               MOVS     R5,#+71
   \   000000AE   ....               LDR.N    R6,??DataTable15_16
   \   000000B0   05FB0465           MLA      R5,R5,R4,R6
   \   000000B4   95F93C50           LDRSB    R5,[R5, #+60]
   \   000000B8   1895               STR      R5,[SP, #+96]
   \   000000BA   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BC   4725               MOVS     R5,#+71
   \   000000BE   ....               LDR.N    R6,??DataTable15_16
   \   000000C0   05FB0465           MLA      R5,R5,R4,R6
   \   000000C4   6D8F               LDRH     R5,[R5, #+58]
   \   000000C6   1795               STR      R5,[SP, #+92]
   \   000000C8   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CA   4725               MOVS     R5,#+71
   \   000000CC   ....               LDR.N    R6,??DataTable15_16
   \   000000CE   05FB0465           MLA      R5,R5,R4,R6
   \   000000D2   2D8F               LDRH     R5,[R5, #+56]
   \   000000D4   1695               STR      R5,[SP, #+88]
   \   000000D6   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D8   4725               MOVS     R5,#+71
   \   000000DA   ....               LDR.N    R6,??DataTable15_16
   \   000000DC   05FB0465           MLA      R5,R5,R4,R6
   \   000000E0   ED8E               LDRH     R5,[R5, #+54]
   \   000000E2   1595               STR      R5,[SP, #+84]
   \   000000E4   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000E6   4725               MOVS     R5,#+71
   \   000000E8   ....               LDR.N    R6,??DataTable15_16
   \   000000EA   05FB0465           MLA      R5,R5,R4,R6
   \   000000EE   AD8E               LDRH     R5,[R5, #+52]
   \   000000F0   1495               STR      R5,[SP, #+80]
   \   000000F2   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F4   4725               MOVS     R5,#+71
   \   000000F6   ....               LDR.N    R6,??DataTable15_16
   \   000000F8   05FB0465           MLA      R5,R5,R4,R6
   \   000000FC   6D8E               LDRH     R5,[R5, #+50]
   \   000000FE   1395               STR      R5,[SP, #+76]
   \   00000100   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000102   4725               MOVS     R5,#+71
   \   00000104   ....               LDR.N    R6,??DataTable15_16
   \   00000106   05FB0465           MLA      R5,R5,R4,R6
   \   0000010A   2D8E               LDRH     R5,[R5, #+48]
   \   0000010C   1295               STR      R5,[SP, #+72]
   \   0000010E   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000110   4725               MOVS     R5,#+71
   \   00000112   ....               LDR.N    R6,??DataTable15_16
   \   00000114   05FB0465           MLA      R5,R5,R4,R6
   \   00000118   95F82F50           LDRB     R5,[R5, #+47]
   \   0000011C   1195               STR      R5,[SP, #+68]
   \   0000011E   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000120   4725               MOVS     R5,#+71
   \   00000122   ....               LDR.N    R6,??DataTable15_16
   \   00000124   05FB0465           MLA      R5,R5,R4,R6
   \   00000128   D5F81550           LDR      R5,[R5, #+21]
   \   0000012C   1095               STR      R5,[SP, #+64]
   \   0000012E   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000130   4725               MOVS     R5,#+71
   \   00000132   ....               LDR.N    R6,??DataTable15_16
   \   00000134   05FB0465           MLA      R5,R5,R4,R6
   \   00000138   B5F81350           LDRH     R5,[R5, #+19]
   \   0000013C   0F95               STR      R5,[SP, #+60]
   \   0000013E   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000140   4725               MOVS     R5,#+71
   \   00000142   ....               LDR.N    R6,??DataTable15_16
   \   00000144   05FB0465           MLA      R5,R5,R4,R6
   \   00000148   B5F92D50           LDRSH    R5,[R5, #+45]
   \   0000014C   0E95               STR      R5,[SP, #+56]
   \   0000014E   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000150   4725               MOVS     R5,#+71
   \   00000152   ....               LDR.N    R6,??DataTable15_16
   \   00000154   05FB0465           MLA      R5,R5,R4,R6
   \   00000158   B5F92B50           LDRSH    R5,[R5, #+43]
   \   0000015C   0D95               STR      R5,[SP, #+52]
   \   0000015E   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000160   4725               MOVS     R5,#+71
   \   00000162   ....               LDR.N    R6,??DataTable15_16
   \   00000164   05FB0465           MLA      R5,R5,R4,R6
   \   00000168   B5F82950           LDRH     R5,[R5, #+41]
   \   0000016C   0C95               STR      R5,[SP, #+48]
   \   0000016E   B0FBF1F5           UDIV     R5,R0,R1
   \   00000172   01FB1500           MLS      R0,R1,R5,R0
   \   00000176   0B90               STR      R0,[SP, #+44]
   \   00000178   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000017A   4720               MOVS     R0,#+71
   \   0000017C   ....               LDR.N    R1,??DataTable15_16
   \   0000017E   00FB0410           MLA      R0,R0,R4,R1
   \   00000182   D0F82500           LDR      R0,[R0, #+37]
   \   00000186   ....               LDR.N    R1,??DataTable15_25  ;; 0xf4240
   \   00000188   B0FBF1F0           UDIV     R0,R0,R1
   \   0000018C   0A90               STR      R0,[SP, #+40]
   \   0000018E   B2FBF3F0           UDIV     R0,R2,R3
   \   00000192   03FB1020           MLS      R0,R3,R0,R2
   \   00000196   0990               STR      R0,[SP, #+36]
   \   00000198   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000019A   4720               MOVS     R0,#+71
   \   0000019C   ....               LDR.N    R1,??DataTable15_16
   \   0000019E   00FB0410           MLA      R0,R0,R4,R1
   \   000001A2   D0F82100           LDR      R0,[R0, #+33]
   \   000001A6   ....               LDR.N    R1,??DataTable15_25  ;; 0xf4240
   \   000001A8   B0FBF1F0           UDIV     R0,R0,R1
   \   000001AC   0890               STR      R0,[SP, #+32]
   \   000001AE   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001B0   4720               MOVS     R0,#+71
   \   000001B2   ....               LDR.N    R1,??DataTable15_16
   \   000001B4   00FB0410           MLA      R0,R0,R4,R1
   \   000001B8   90F82000           LDRB     R0,[R0, #+32]
   \   000001BC   0790               STR      R0,[SP, #+28]
   \   000001BE   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001C0   4720               MOVS     R0,#+71
   \   000001C2   ....               LDR.N    R1,??DataTable15_16
   \   000001C4   00FB0410           MLA      R0,R0,R4,R1
   \   000001C8   C08B               LDRH     R0,[R0, #+30]
   \   000001CA   0690               STR      R0,[SP, #+24]
   \   000001CC   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001CE   4720               MOVS     R0,#+71
   \   000001D0   ....               LDR.N    R1,??DataTable15_16
   \   000001D2   00FB0410           MLA      R0,R0,R4,R1
   \   000001D6   407F               LDRB     R0,[R0, #+29]
   \   000001D8   0590               STR      R0,[SP, #+20]
   \   000001DA   ....               LDR.N    R0,??DataTable15_18
   \   000001DC   0490               STR      R0,[SP, #+16]
   \   000001DE   2198               LDR      R0,[SP, #+132]
   \   000001E0   0390               STR      R0,[SP, #+12]
   \   000001E2   2298               LDR      R0,[SP, #+136]
   \   000001E4   0290               STR      R0,[SP, #+8]
   \   000001E6   2398               LDR      R0,[SP, #+140]
   \   000001E8   0190               STR      R0,[SP, #+4]
   \   000001EA   2498               LDR      R0,[SP, #+144]
   \   000001EC   0090               STR      R0,[SP, #+0]
   \   000001EE   259B               LDR      R3,[SP, #+148]
   \   000001F0   269A               LDR      R2,[SP, #+152]
   \   000001F2   ........           ADR.W    R1,`?<Constant "%02d/%02d/%02d-%02d:%...">`
   \   000001F6   ....               LDR.N    R0,??DataTable15_24
   \   000001F8   ........           BL       sprintf
    571          
    572          }
   \   000001FC   2AB0               ADD      SP,SP,#+168
   \   000001FE   70BD               POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
    573          void Conver_EMS_Data(void)
    574          {
   \                     Conver_EMS_Data:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   99B0               SUB      SP,SP,#+100
    575               TM_Struct Timer;
    576               // -- 초기화 
    577               memset(USBH_USR_DTG_Buffer,0,sizeof(USBH_USR_DTG_Buffer));
   \   00000004   4FF48072           MOV      R2,#+256
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   ....               LDR.N    R0,??DataTable15_24
   \   0000000C   ........           BL       memset
    578               // -- 메인 루트     
    579               RTC_BinaryToDate( RTC_DateToBinary(&SYSTEM_TIME) , &Timer );		// 시간저장된 데이터 변환    
   \   00000010   ....               LDR.N    R0,??DataTable15_1
   \   00000012   ........           BL       RTC_DateToBinary
   \   00000016   0FA9               ADD      R1,SP,#+60
   \   00000018   ........           BL       RTC_BinaryToDate
    580          
    581               sprintf((char*)USBH_USR_DTG_Buffer,"%02d/%02d/%02d-%02d:%02d:%02d,"
    582                       "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\r\n",     
    583                       Timer.tm_year,Timer.tm_mon,Timer.tm_mday,
    584                       Timer.tm_hour,Timer.tm_min,Timer.tm_sec,             
    585                                 EMS_Drive_Value.Today_Speed_PulsCount,
    586                                 EMS_Drive_Value.Drive_Time,
    587                                 EMS_Drive_Value.DriveStop_Time,
    588                                 EMS_Drive_Value.EngineStop_Time,
    589                                 EMS_Drive_Value.EcoUse_Time,                       
    590                                 EMS_Drive_Value.Day_StarterMotor,
    591                                 EMS_Drive_Value.QuickAccel_Count,
    592                                 EMS_Drive_Value.QuickStart_Count,
    593                                 EMS_Drive_Value.QuickStop_Count,
    594                                 EMS_Drive_Value.HighRPM_Count,
    595                                 EMS_Drive_Value.Break_Count);
   \   0000001C   ....               LDR.N    R0,??DataTable15_5
   \   0000001E   408C               LDRH     R0,[R0, #+34]
   \   00000020   0E90               STR      R0,[SP, #+56]
   \   00000022   ....               LDR.N    R0,??DataTable15_5
   \   00000024   008C               LDRH     R0,[R0, #+32]
   \   00000026   0D90               STR      R0,[SP, #+52]
   \   00000028   ....               LDR.N    R0,??DataTable15_5
   \   0000002A   C08B               LDRH     R0,[R0, #+30]
   \   0000002C   0C90               STR      R0,[SP, #+48]
   \   0000002E   ....               LDR.N    R0,??DataTable15_5
   \   00000030   808B               LDRH     R0,[R0, #+28]
   \   00000032   0B90               STR      R0,[SP, #+44]
   \   00000034   ....               LDR.N    R0,??DataTable15_5
   \   00000036   408B               LDRH     R0,[R0, #+26]
   \   00000038   0A90               STR      R0,[SP, #+40]
   \   0000003A   ....               LDR.N    R0,??DataTable15_5
   \   0000003C   008B               LDRH     R0,[R0, #+24]
   \   0000003E   0990               STR      R0,[SP, #+36]
   \   00000040   ....               LDR.N    R0,??DataTable15_5
   \   00000042   4069               LDR      R0,[R0, #+20]
   \   00000044   0890               STR      R0,[SP, #+32]
   \   00000046   ....               LDR.N    R0,??DataTable15_5
   \   00000048   0069               LDR      R0,[R0, #+16]
   \   0000004A   0790               STR      R0,[SP, #+28]
   \   0000004C   ....               LDR.N    R0,??DataTable15_5
   \   0000004E   C068               LDR      R0,[R0, #+12]
   \   00000050   0690               STR      R0,[SP, #+24]
   \   00000052   ....               LDR.N    R0,??DataTable15_5
   \   00000054   4068               LDR      R0,[R0, #+4]
   \   00000056   0590               STR      R0,[SP, #+20]
   \   00000058   ....               LDR.N    R0,??DataTable15_5
   \   0000005A   8068               LDR      R0,[R0, #+8]
   \   0000005C   0490               STR      R0,[SP, #+16]
   \   0000005E   0F98               LDR      R0,[SP, #+60]
   \   00000060   0390               STR      R0,[SP, #+12]
   \   00000062   1098               LDR      R0,[SP, #+64]
   \   00000064   0290               STR      R0,[SP, #+8]
   \   00000066   1198               LDR      R0,[SP, #+68]
   \   00000068   0190               STR      R0,[SP, #+4]
   \   0000006A   1298               LDR      R0,[SP, #+72]
   \   0000006C   0090               STR      R0,[SP, #+0]
   \   0000006E   139B               LDR      R3,[SP, #+76]
   \   00000070   149A               LDR      R2,[SP, #+80]
   \   00000072   ........           ADR.W    R1,`?<Constant "%02d/%02d/%02d-%02d:%...">_1`
   \   00000076   ....               LDR.N    R0,??DataTable15_24
   \   00000078   ........           BL       sprintf
    596          }
   \   0000007C   19B0               ADD      SP,SP,#+100
   \   0000007E   00BD               POP      {PC}             ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   ........           DC32     NAND_Header_Info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   ........           DC32     SYSTEM_TIME

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   ........           DC32     NAND_Header_Index

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   ........           DC32     Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   ........           DC32     NAND_Data_Transmit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   ........           DC32     EMS_Drive_Value

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   ........           DC32     I2C_Ems_Accure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   ........           DC32     Info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   ........           DC32     NAND_Buffer+0x1FFD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   ........           DC32     NAND_Buffer+0x1FFE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \   00000000   ........           DC32     NAND_Buffer+0x1FFF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \   00000000   ........           DC32     NAND_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \   00000000   ........           DC32     Accident_Time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \   00000000   ........           DC32     Accident_SaveBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \   00000000   ........           DC32     Accident2_SaveBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \   00000000   ........           DC32     LookUpTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_16:
   \   00000000   ........           DC32     DTG_NAND_Binary

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_17:
   \   00000000   ........           DC32     ??OldSec

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_18:
   \   00000000   ........           DC32     Info+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_19:
   \   00000000   ........           DC32     Info+0x47

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_20:
   \   00000000   ........           DC32     USBH_USR_ApplicationState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_21:
   \   00000000   ........           DC32     USBH_USR_ActionFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_22:
   \   00000000   ........           DC32     Flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_23:
   \   00000000   FFE70300           DC32     0x3e7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_24:
   \   00000000   ........           DC32     USBH_USR_DTG_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_25:
   \   00000000   40420F00           DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%02d/%02d/%02d-%02d:%...">`:
   \   00000000                      ; Initializer data, 180 bytes
   \   00000000   253032642F25       DC8 37, 48, 50, 100, 47, 37, 48, 50, 100, 47
   \              3032642F    
   \   0000000A   253032642D25       DC8 37, 48, 50, 100, 45, 37, 48, 50, 100, 58
   \              3032643A    
   \   00000014   253032643A25       DC8 37, 48, 50, 100, 58, 37, 48, 50, 100, 44
   \              3032642C    
   \   0000001E   25303138732C       DC8 37, 48, 49, 56, 115, 44, 37, 48, 52, 100
   \              25303464    
   \   00000028   2C253037642C       DC8 44, 37, 48, 55, 100, 44, 37, 48, 51, 100
   \              25303364    
   \   00000032   2C253034642C       DC8 44, 37, 48, 52, 100, 44, 37, 100, 44, 37
   \              25642C25    
   \   0000003C   3033642E2530       DC8 48, 51, 100, 46, 37, 48, 54, 100, 44, 37
   \              36642C25    
   \   00000046   3033642E2530       DC8 48, 51, 100, 46, 37, 48, 54, 100, 44, 37
   \              36642C25    
   \   00000050   3033642C2530       DC8 48, 51, 100, 44, 37, 48, 43, 52, 100, 44
   \              2B34642C    
   \   0000005A   25302B34642C       DC8 37, 48, 43, 52, 100, 44, 37, 48, 50, 100
   \              25303264    
   \   00000064   2C253034642C       DC8 44, 37, 48, 52, 100, 44, 37, 48, 52, 100
   \              25303464    
   \   0000006E   2C253034642C       DC8 44, 37, 48, 52, 100, 44, 37, 48, 52, 100
   \              25303464    
   \   00000078   2C253034642C       DC8 44, 37, 48, 52, 100, 44, 37, 48, 52, 100
   \              25303464    
   \   00000082   2C252B303364       DC8 44, 37, 43, 48, 51, 100, 44, 37, 43, 48
   \              2C252B30    
   \   0000008C   33642C253033       DC8 51, 100, 44, 37, 48, 51, 100, 44, 37, 48
   \              642C2530    
   \   00000096   33642C253038       DC8 51, 100, 44, 37, 48, 56, 120, 44, 37, 48
   \              782C2530    
   \   000000A0   38782C253034       DC8 56, 120, 44, 37, 48, 52, 120, 44, 37, 48
   \              782C2530    
   \   000000AA   32782C253032       DC8 50, 120, 44, 37, 48, 50, 120, 13, 10, 0
   \              780D0A00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%02d/%02d/%02d-%02d:%...">_1`:
   \   00000000                      ; Initializer data, 68 bytes
   \   00000000   253032642F25       DC8 37, 48, 50, 100, 47, 37, 48, 50, 100, 47
   \              3032642F    
   \   0000000A   253032642D25       DC8 37, 48, 50, 100, 45, 37, 48, 50, 100, 58
   \              3032643A    
   \   00000014   253032643A25       DC8 37, 48, 50, 100, 58, 37, 48, 50, 100, 44
   \              3032642C    
   \   0000001E   25642C25642C       DC8 37, 100, 44, 37, 100, 44, 37, 100, 44, 37
   \              25642C25    
   \   00000028   642C25642C25       DC8 100, 44, 37, 100, 44, 37, 100, 44, 37, 100
   \              642C2564    
   \   00000032   2C25642C2564       DC8 44, 37, 100, 44, 37, 100, 44, 37, 100, 44
   \              2C25642C    
   \   0000003C   25640D0A0000       DC8 37, 100, 13, 10, 0, 0, 0, 0
   \              0000        

   Maximum stack usage in bytes:

     Function                   .cstack
     --------                   -------
     Accident_DataSave              16
     Conver_EMS_Data               104
     Convert_Binary                  0
     Convert_DTG_Data              184
     Convert_Data                    0
     DTG_EMS_DataLoad               16
     DTG_EMS_DataSave               24
     GetHeader_Index                 0
     Memory_Config                  24
     Memory_Process                 16
     NAND_ERASE_PAGE                16
     Page_Stack                      0
     Read_Header_Information        24
     Search_Header                   0
     Setting_Header_Information      8
     Write_Header_EMS                8
     Write_Header_Index              8
     Write_Header_Information        8
     Write_Transmit_Header           8
     memcpy                          8
     memset                          8


   Section sizes:

     Function/Label                           Bytes
     --------------                           -----
     memcpy                                     14
     memset                                     20
     VIEW_Header                                24
     I2C_Ems_Accure                             16
     NAND_Header_Info                           16
     NAND_Header_Index                          12
     NAND_Data_Transmit                         12
     GetHeader_Index                            42
     DTG_NAND_Binary                          6392
     Search_Header                               2
     Setting_Header_Information                 88
     Read_Header_Information                    72
     Memory_Config                             634
     Write_Header_EMS                          134
     Write_Header_Index                         40
     Write_Transmit_Header                      40
     Write_Header_Information                   56
     Accident_DataSave                         120
     NAND_ERASE_PAGE                            86
     DTG_EMS_DataSave                          148
     DTG_EMS_DataLoad                           44
     Convert_Binary                             16
     Convert_Data                                2
     Page_Stack                                  2
     Memory_Process                            652
     OldSec                                      1
     Convert_DTG_Data                          512
     Conver_EMS_Data                           128
     ??DataTable15                               4
     ??DataTable15_1                             4
     ??DataTable15_2                             4
     ??DataTable15_3                             4
     ??DataTable15_4                             4
     ??DataTable15_5                             4
     ??DataTable15_6                             4
     ??DataTable15_7                             4
     ??DataTable15_8                             4
     ??DataTable15_9                             4
     ??DataTable15_10                            4
     ??DataTable15_11                            4
     ??DataTable15_12                            4
     ??DataTable15_13                            4
     ??DataTable15_14                            4
     ??DataTable15_15                            4
     ??DataTable15_16                            4
     ??DataTable15_17                            4
     ??DataTable15_18                            4
     ??DataTable15_19                            4
     ??DataTable15_20                            4
     ??DataTable15_21                            4
     ??DataTable15_22                            4
     ??DataTable15_23                            4
     ??DataTable15_24                            4
     ??DataTable15_25                            4
     ?<Constant "%02d/%02d/%02d-%02d:%...">    180
     ?<Constant "%02d/%02d/%02d-%02d:%...">_1   68

 
 6 473 bytes in section .bss
 3 204 bytes in section .text
 
 3 170 bytes of CODE memory (+ 34 bytes shared)
 6 473 bytes of DATA memory

Errors: none
Warnings: 3
