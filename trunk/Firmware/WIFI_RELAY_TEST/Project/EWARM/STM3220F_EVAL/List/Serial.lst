###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     19/Dec/2011  16:18:50 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\Serial.c     #
#    Command line =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\Serial.c -D  #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D RTC_CLOCK_SOURCE_LSE -lC            #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\List\ -lA E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Pr #
#                    oject\EWARM\STM3220F_EVAL\List\ -o                       #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\Obj\ --no_cse --no_unroll --no_inline            #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWAR #
#                    M\..\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWA #
#                    RM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I             #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I       #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I             #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Utilities\STM32_EVAL\ -I E:\Work\Firmware\DTG\DTG_EMS_SY #
#                    STEM\Project\EWARM\..\..\Utilities\STM32_EVAL\Common\    #
#                    -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\ #
#                    ..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I                #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_OTG_Driver\inc\ -I                   #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_Device_Library\Core\inc\ -I          #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_Device_Library\Class\msc\inc\ -I     #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\Usb #
#                    \ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\. #
#                    .\Usb\Inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Projec #
#                    t\EWARM\..\Usb\src\ -I E:\Work\Firmware\DTG\DTG_EMS_SYST #
#                    EM\Project\EWARM\..\..\Libraries\STM32_USB_HOST_Library\ #
#                    Core\inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project #
#                    \EWARM\..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\ #
#                    inc\ -Ol --use_c++_inline                                #
#    List file    =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\List\Serial.lst                                  #
#    Object file  =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\Obj\Serial.o                                     #
#                                                                             #
#                                                                             #
###############################################################################

E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\Serial.c
      1          #include "Serial.h"
      2          #include "main.h"

   \                                 In section .text, align 2
   \   __intrinsic __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   1000               MOVS     R0,R2
   \   00000006   0A00               MOVS     R2,R1
   \   00000008   0100               MOVS     R1,R0
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   ........           BL       __aeabi_memset
   \   00000010   2000               MOVS     R0,R4
   \   00000012   10BD               POP      {R4,PC}          ;; return
      3          

   \                                 In section .bss, align 4
      4          struct _Serial RTX_GPS;
   \                     RTX_GPS:
   \   00000000                      DS8 2068

   \                                 In section .bss, align 4
      5          struct _Serial PC_Comm;
   \                     PC_Comm:
   \   00000000                      DS8 2068

   \                                 In section .bss, align 4
      6          struct _Serial RF_Module;
   \                     RF_Module:
   \   00000000                      DS8 2068
      7          

   \                                 In section .bss, align 4
      8          u32 KMap_Transmit_Count;
   \                     KMap_Transmit_Count:
   \   00000000                      DS8 4
      9          

   \                                 In section .text, align 2, keep-with-next
     10          void Serial_Config(void)		// Serial 초기화
     11          {
   \                     Serial_Config:
   \   00000000   80B5               PUSH     {R7,LR}
     12          	memset(&RTX_GPS  , 0x00, sizeof( RTX_GPS ) );
   \   00000002   40F61202           MOVW     R2,#+2066
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   ........           LDR.W    R0,??DataTable10
   \   0000000C   ........           BL       memset
     13          	memset(&PC_Comm  , 0x00, sizeof( PC_Comm ) );
   \   00000010   40F61202           MOVW     R2,#+2066
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   ........           LDR.W    R0,??DataTable10_1
   \   0000001A   ........           BL       memset
     14          	memset(&RF_Module  , 0x00, sizeof( RF_Module ) );     
   \   0000001E   40F61202           MOVW     R2,#+2066
   \   00000022   0021               MOVS     R1,#+0
   \   00000024   ........           LDR.W    R0,??DataTable10_2
   \   00000028   ........           BL       memset
     15               
     16          	USART1_Init(); 	//외부장치 컴퓨터와 통신
   \   0000002C   ........           BL       USART1_Init
     17          	USART2_Init();		// RF 모듈
   \   00000030   ........           BL       USART2_Init
     18          	USART4_Init();		// GPS
   \   00000034   ........           BL       USART4_Init
     19          	
     20               NVIC_Config();       
   \   00000038   ........           BL       NVIC_Config
     21          }
   \   0000003C   01BD               POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
     22          void Clear_Serial1(void)
     23          {
   \                     Clear_Serial1:
   \   00000000   80B5               PUSH     {R7,LR}
     24          	memset(&PC_Comm  , 0x00, sizeof( RF_Module ) );          
   \   00000002   40F61202           MOVW     R2,#+2066
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   ........           LDR.W    R0,??DataTable10_1
   \   0000000C   ........           BL       memset
     25          }
   \   00000010   01BD               POP      {R0,PC}          ;; return
     26          

   \                                 In section .text, align 2, keep-with-next
     27          void Clear_Serial2()
     28          {
   \                     Clear_Serial2:
   \   00000000   80B5               PUSH     {R7,LR}
     29          	memset(&RF_Module ,0,sizeof(struct _Serial));
   \   00000002   40F61202           MOVW     R2,#+2066
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   ........           LDR.W    R0,??DataTable10_2
   \   0000000C   ........           BL       memset
     30          }
   \   00000010   01BD               POP      {R0,PC}          ;; return
     31          

   \                                 In section .text, align 2, keep-with-next
     32          void Clear_Serial4(void)
     33          {
   \                     Clear_Serial4:
   \   00000000   80B5               PUSH     {R7,LR}
     34          	memset(&RTX_GPS  , 0x00, sizeof( RTX_GPS ) );     
   \   00000002   40F61202           MOVW     R2,#+2066
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   ........           LDR.W    R0,??DataTable10
   \   0000000C   ........           BL       memset
     35          }
   \   00000010   01BD               POP      {R0,PC}          ;; return
     36          
     37          /**********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     38          void NVIC_Config(void)
     39          {
   \                     NVIC_Config:
   \   00000000   80B5               PUSH     {R7,LR}
     40          	NVIC_InitTypeDef NVIC_InitStructure;
     41          	
     42          	/* Enable the USARTx Interrupt */
     43          	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
   \   00000002   2520               MOVS     R0,#+37
   \   00000004   8DF80000           STRB     R0,[SP, #+0]
     44          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   8DF80100           STRB     R0,[SP, #+1]
     45          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   0000000E   0020               MOVS     R0,#+0
   \   00000010   8DF80200           STRB     R0,[SP, #+2]
     46          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000014   0120               MOVS     R0,#+1
   \   00000016   8DF80300           STRB     R0,[SP, #+3]
     47          	NVIC_Init(&NVIC_InitStructure);
   \   0000001A   00A8               ADD      R0,SP,#+0
   \   0000001C   ........           BL       NVIC_Init
     48               	
     49          	/* Enable the USARTx Interrupt */
     50          	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
   \   00000020   2620               MOVS     R0,#+38
   \   00000022   8DF80000           STRB     R0,[SP, #+0]
     51          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
   \   00000026   0020               MOVS     R0,#+0
   \   00000028   8DF80100           STRB     R0,[SP, #+1]
     52          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   0000002C   0020               MOVS     R0,#+0
   \   0000002E   8DF80200           STRB     R0,[SP, #+2]
     53          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000032   0120               MOVS     R0,#+1
   \   00000034   8DF80300           STRB     R0,[SP, #+3]
     54          	NVIC_Init(&NVIC_InitStructure);
   \   00000038   00A8               ADD      R0,SP,#+0
   \   0000003A   ........           BL       NVIC_Init
     55               
     56          	/* Enable the USARTx Interrupt */
     57          	NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
   \   0000003E   3420               MOVS     R0,#+52
   \   00000040   8DF80000           STRB     R0,[SP, #+0]
     58          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
   \   00000044   0020               MOVS     R0,#+0
   \   00000046   8DF80100           STRB     R0,[SP, #+1]
     59          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   0000004A   0020               MOVS     R0,#+0
   \   0000004C   8DF80200           STRB     R0,[SP, #+2]
     60          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000050   0120               MOVS     R0,#+1
   \   00000052   8DF80300           STRB     R0,[SP, #+3]
     61          	NVIC_Init(&NVIC_InitStructure);
   \   00000056   00A8               ADD      R0,SP,#+0
   \   00000058   ........           BL       NVIC_Init
     62          	
     63          }        
   \   0000005C   01BD               POP      {R0,PC}          ;; return
     64          /*******************************************************************************
     65          GPS을 위한 통신초트를 초기화 한다. (UART1)
     66          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     67          void USART1_Init(void)
     68          {
   \                     USART1_Init:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   87B0               SUB      SP,SP,#+28
     69               /* 
     70               USARTx configured as follow:
     71               - BaudRate = 115200 baud  
     72               - Word Length = 8 Bits
     73               - One Stop Bit
     74               - No parity
     75               - Hardware flow control disabled (RTS and CTS signals)
     76               - Receive and transmit enabled
     77               */
     78               USART_InitTypeDef USART_InitStructure;
     79          	GPIO_InitTypeDef GPIO_InitStructure;
     80          	
     81               RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   0120               MOVS     R0,#+1
   \   00000008   ........           BL       RCC_AHB1PeriphClockCmd
     82               RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   1020               MOVS     R0,#+16
   \   00000010   ........           BL       RCC_APB2PeriphClockCmd
     83               /* Connect PXx to USARTx_Tx*/
     84               GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_USART1);
   \   00000014   0722               MOVS     R2,#+7
   \   00000016   0A21               MOVS     R1,#+10
   \   00000018   ........           LDR.W    R0,??DataTable10_3  ;; 0x40020000
   \   0000001C   ........           BL       GPIO_PinAFConfig
     85               
     86               /* Connect PXx to USARTx_Rx*/
     87               GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_USART1);
   \   00000020   0722               MOVS     R2,#+7
   \   00000022   0921               MOVS     R1,#+9
   \   00000024   ........           LDR.W    R0,??DataTable10_3  ;; 0x40020000
   \   00000028   ........           BL       GPIO_PinAFConfig
     88               
     89          	// Configure USART2 Tx (PA.2) as alternate function push-pull 
     90          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
   \   0000002C   4FF40070           MOV      R0,#+512
   \   00000030   0090               STR      R0,[SP, #+0]
     91          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000032   0220               MOVS     R0,#+2
   \   00000034   8DF80500           STRB     R0,[SP, #+5]
     92          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000038   0020               MOVS     R0,#+0
   \   0000003A   8DF80600           STRB     R0,[SP, #+6]
     93               GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   0000003E   0120               MOVS     R0,#+1
   \   00000040   8DF80700           STRB     R0,[SP, #+7]
     94               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   00000044   0220               MOVS     R0,#+2
   \   00000046   8DF80400           STRB     R0,[SP, #+4]
     95          	GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000004A   00A9               ADD      R1,SP,#+0
   \   0000004C   ........           LDR.W    R0,??DataTable10_3  ;; 0x40020000
   \   00000050   ........           BL       GPIO_Init
     96          	
     97          	// Configure USART2 Rx (PA.3) as input floating 
     98          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   00000054   4FF48060           MOV      R0,#+1024
   \   00000058   0090               STR      R0,[SP, #+0]
     99               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   0000005A   0220               MOVS     R0,#+2
   \   0000005C   8DF80400           STRB     R0,[SP, #+4]
    100          	GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000060   00A9               ADD      R1,SP,#+0
   \   00000062   ........           LDR.W    R0,??DataTable10_3  ;; 0x40020000
   \   00000066   ........           BL       GPIO_Init
    101               
    102               USART_InitStructure.USART_BaudRate = 115200;
   \   0000006A   5FF4E130           MOVS     R0,#+115200
   \   0000006E   0290               STR      R0,[SP, #+8]
    103               USART_InitStructure.USART_WordLength = USART_WordLength_8b;
   \   00000070   0020               MOVS     R0,#+0
   \   00000072   ADF80C00           STRH     R0,[SP, #+12]
    104               USART_InitStructure.USART_StopBits = USART_StopBits_1;
   \   00000076   0020               MOVS     R0,#+0
   \   00000078   ADF80E00           STRH     R0,[SP, #+14]
    105               USART_InitStructure.USART_Parity = USART_Parity_No;
   \   0000007C   0020               MOVS     R0,#+0
   \   0000007E   ADF81000           STRH     R0,[SP, #+16]
    106               USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   00000082   0020               MOVS     R0,#+0
   \   00000084   ADF81400           STRH     R0,[SP, #+20]
    107               USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   00000088   0C20               MOVS     R0,#+12
   \   0000008A   ADF81200           STRH     R0,[SP, #+18]
    108          	
    109               USART_Init(USART1, &USART_InitStructure);
   \   0000008E   02A9               ADD      R1,SP,#+8
   \   00000090   ........           LDR.W    R0,??DataTable10_4  ;; 0x40011000
   \   00000094   ........           BL       USART_Init
    110               USART_Cmd(USART1, ENABLE);
   \   00000098   0121               MOVS     R1,#+1
   \   0000009A   ........           LDR.W    R0,??DataTable10_4  ;; 0x40011000
   \   0000009E   ........           BL       USART_Cmd
    111               USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	         
   \   000000A2   0122               MOVS     R2,#+1
   \   000000A4   40F22551           MOVW     R1,#+1317
   \   000000A8   ........           LDR.W    R0,??DataTable10_4  ;; 0x40011000
   \   000000AC   ........           BL       USART_ITConfig
    112               
    113          }
   \   000000B0   07B0               ADD      SP,SP,#+28
   \   000000B2   00BD               POP      {PC}             ;; return
    114          /*******************************************************************************
    115          외부 통신을 위한 통신초트를 초기화 한다. (UART2)
    116          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    117          void USART2_Init(void)
    118          {
   \                     USART2_Init:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   87B0               SUB      SP,SP,#+28
    119               /* USARTx configured as follow:
    120               - BaudRate = 115200 baud  
    121               - Word Length = 8 Bits
    122               - One Stop Bit
    123               - No parity
    124               - Hardware flow control disabled (RTS and CTS signals)
    125               - Receive and transmit enabled
    126               */
    127               USART_InitTypeDef USART_InitStructure;
    128          	GPIO_InitTypeDef GPIO_InitStructure;
    129          	
    130               RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   0120               MOVS     R0,#+1
   \   00000008   ........           BL       RCC_AHB1PeriphClockCmd
    131               RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   5FF40030           MOVS     R0,#+131072
   \   00000012   ........           BL       RCC_APB1PeriphClockCmd
    132               /* Connect PXx to USARTx_Tx*/
    133          //     GPIO_PinAFConfig(GPIOA, GPIO_PinSource0, GPIO_AF_USART2);     
    134          //     GPIO_PinAFConfig(GPIOA, GPIO_PinSource1, GPIO_AF_USART2);        
    135               GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);
   \   00000016   0722               MOVS     R2,#+7
   \   00000018   0221               MOVS     R1,#+2
   \   0000001A   ........           LDR.W    R0,??DataTable10_3  ;; 0x40020000
   \   0000001E   ........           BL       GPIO_PinAFConfig
    136            
    137               /* Connect PXx to USARTx_Rx*/
    138               GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_USART2);
   \   00000022   0722               MOVS     R2,#+7
   \   00000024   0321               MOVS     R1,#+3
   \   00000026   ........           LDR.W    R0,??DataTable10_3  ;; 0x40020000
   \   0000002A   ........           BL       GPIO_PinAFConfig
    139          
    140               
    141               // Configure USART2 Tx (PA.2) as alternate function push-pull 
    142               GPIO_InitStructure.GPIO_Pin = /*GPIO_Pin_0 | GPIO_Pin_1 |*/ GPIO_Pin_2;
   \   0000002E   0420               MOVS     R0,#+4
   \   00000030   0090               STR      R0,[SP, #+0]
    143               GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000032   0220               MOVS     R0,#+2
   \   00000034   8DF80500           STRB     R0,[SP, #+5]
    144               GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;        
   \   00000038   0020               MOVS     R0,#+0
   \   0000003A   8DF80600           STRB     R0,[SP, #+6]
    145               GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   0000003E   0120               MOVS     R0,#+1
   \   00000040   8DF80700           STRB     R0,[SP, #+7]
    146               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;        
   \   00000044   0220               MOVS     R0,#+2
   \   00000046   8DF80400           STRB     R0,[SP, #+4]
    147               GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000004A   00A9               ADD      R1,SP,#+0
   \   0000004C   ........           LDR.W    R0,??DataTable10_3  ;; 0x40020000
   \   00000050   ........           BL       GPIO_Init
    148          	
    149               // Configure USART2 Rx (PA.3) as input floating 
    150               GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
   \   00000054   0820               MOVS     R0,#+8
   \   00000056   0090               STR      R0,[SP, #+0]
    151               
    152               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   00000058   0220               MOVS     R0,#+2
   \   0000005A   8DF80400           STRB     R0,[SP, #+4]
    153               GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000005E   00A9               ADD      R1,SP,#+0
   \   00000060   ........           LDR.W    R0,??DataTable10_3  ;; 0x40020000
   \   00000064   ........           BL       GPIO_Init
    154               
    155               USART_InitStructure.USART_BaudRate = 115200;
   \   00000068   5FF4E130           MOVS     R0,#+115200
   \   0000006C   0290               STR      R0,[SP, #+8]
    156               USART_InitStructure.USART_WordLength = USART_WordLength_8b;
   \   0000006E   0020               MOVS     R0,#+0
   \   00000070   ADF80C00           STRH     R0,[SP, #+12]
    157               USART_InitStructure.USART_StopBits = USART_StopBits_1;
   \   00000074   0020               MOVS     R0,#+0
   \   00000076   ADF80E00           STRH     R0,[SP, #+14]
    158               USART_InitStructure.USART_Parity = USART_Parity_No;
   \   0000007A   0020               MOVS     R0,#+0
   \   0000007C   ADF81000           STRH     R0,[SP, #+16]
    159               USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   00000080   0020               MOVS     R0,#+0
   \   00000082   ADF81400           STRH     R0,[SP, #+20]
    160               USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   00000086   0C20               MOVS     R0,#+12
   \   00000088   ADF81200           STRH     R0,[SP, #+18]
    161          	
    162               USART_Init(USART2, &USART_InitStructure);
   \   0000008C   02A9               ADD      R1,SP,#+8
   \   0000008E   ........           LDR.W    R0,??DataTable10_5  ;; 0x40004400
   \   00000092   ........           BL       USART_Init
    163               USART_Cmd(USART2, ENABLE);
   \   00000096   0121               MOVS     R1,#+1
   \   00000098   ........           LDR.W    R0,??DataTable10_5  ;; 0x40004400
   \   0000009C   ........           BL       USART_Cmd
    164               USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);	        
   \   000000A0   0122               MOVS     R2,#+1
   \   000000A2   40F22551           MOVW     R1,#+1317
   \   000000A6   ........           LDR.W    R0,??DataTable10_5  ;; 0x40004400
   \   000000AA   ........           BL       USART_ITConfig
    165               
    166          }
   \   000000AE   07B0               ADD      SP,SP,#+28
   \   000000B0   00BD               POP      {PC}             ;; return
    167          
    168          /*******************************************************************************
    169          GPS을 위한 통신초트를 초기화 한다. (UART4)
    170          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    171          void USART4_Init(void)
    172          {
   \                     USART4_Init:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   87B0               SUB      SP,SP,#+28
    173               /* USARTx configured as follow:
    174               - BaudRate = 9600 baud  
    175               - Word Length = 8 Bits
    176               - One Stop Bit
    177               - No parity
    178               - Hardware flow control disabled (RTS and CTS signals)
    179               - Receive and transmit enabled
    180               */
    181               USART_InitTypeDef USART_InitStructure;
    182          	GPIO_InitTypeDef GPIO_InitStructure;
    183          	
    184               RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   0420               MOVS     R0,#+4
   \   00000008   ........           BL       RCC_AHB1PeriphClockCmd
    185               RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   5FF40020           MOVS     R0,#+524288
   \   00000012   ........           BL       RCC_APB1PeriphClockCmd
    186               /* Connect PXx to USARTx_Tx*/
    187               GPIO_PinAFConfig(GPIOC, GPIO_PinSource11, GPIO_AF_UART4);
   \   00000016   0822               MOVS     R2,#+8
   \   00000018   0B21               MOVS     R1,#+11
   \   0000001A   ........           LDR.W    R0,??DataTable10_6  ;; 0x40020800
   \   0000001E   ........           BL       GPIO_PinAFConfig
    188               
    189               /* Connect PXx to USARTx_Rx*/
    190               GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_UART4);
   \   00000022   0822               MOVS     R2,#+8
   \   00000024   0A21               MOVS     R1,#+10
   \   00000026   ........           LDR.W    R0,??DataTable10_6  ;; 0x40020800
   \   0000002A   ........           BL       GPIO_PinAFConfig
    191               
    192          	// Configure USART2 Tx (PA.2) as alternate function push-pull 
    193          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   0000002E   4FF48060           MOV      R0,#+1024
   \   00000032   0090               STR      R0,[SP, #+0]
    194          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000034   0220               MOVS     R0,#+2
   \   00000036   8DF80500           STRB     R0,[SP, #+5]
    195               GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   0000003A   0020               MOVS     R0,#+0
   \   0000003C   8DF80600           STRB     R0,[SP, #+6]
    196               GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   00000040   0120               MOVS     R0,#+1
   \   00000042   8DF80700           STRB     R0,[SP, #+7]
    197               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;        
   \   00000046   0220               MOVS     R0,#+2
   \   00000048   8DF80400           STRB     R0,[SP, #+4]
    198          	GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   0000004C   00A9               ADD      R1,SP,#+0
   \   0000004E   ....               LDR.N    R0,??DataTable10_6  ;; 0x40020800
   \   00000050   ........           BL       GPIO_Init
    199          	
    200          	// Configure USART2 Rx (PA.3) as input floating 
    201          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
   \   00000054   4FF40060           MOV      R0,#+2048
   \   00000058   0090               STR      R0,[SP, #+0]
    202               GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   0000005A   0220               MOVS     R0,#+2
   \   0000005C   8DF80400           STRB     R0,[SP, #+4]
    203          	GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   00000060   00A9               ADD      R1,SP,#+0
   \   00000062   ....               LDR.N    R0,??DataTable10_6  ;; 0x40020800
   \   00000064   ........           BL       GPIO_Init
    204               
    205               USART_InitStructure.USART_BaudRate = 9600;
   \   00000068   4FF41650           MOV      R0,#+9600
   \   0000006C   0290               STR      R0,[SP, #+8]
    206               USART_InitStructure.USART_WordLength = USART_WordLength_8b;
   \   0000006E   0020               MOVS     R0,#+0
   \   00000070   ADF80C00           STRH     R0,[SP, #+12]
    207               USART_InitStructure.USART_StopBits = USART_StopBits_1;
   \   00000074   0020               MOVS     R0,#+0
   \   00000076   ADF80E00           STRH     R0,[SP, #+14]
    208               USART_InitStructure.USART_Parity = USART_Parity_No;
   \   0000007A   0020               MOVS     R0,#+0
   \   0000007C   ADF81000           STRH     R0,[SP, #+16]
    209               USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   00000080   0020               MOVS     R0,#+0
   \   00000082   ADF81400           STRH     R0,[SP, #+20]
    210               USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   00000086   0C20               MOVS     R0,#+12
   \   00000088   ADF81200           STRH     R0,[SP, #+18]
    211               
    212               USART_Init(UART4, &USART_InitStructure);
   \   0000008C   02A9               ADD      R1,SP,#+8
   \   0000008E   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   00000090   ........           BL       USART_Init
    213               USART_Cmd(UART4, ENABLE);
   \   00000094   0121               MOVS     R1,#+1
   \   00000096   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   00000098   ........           BL       USART_Cmd
    214               USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);
   \   0000009C   0122               MOVS     R2,#+1
   \   0000009E   40F22551           MOVW     R1,#+1317
   \   000000A2   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   000000A4   ........           BL       USART_ITConfig
    215          }
   \   000000A8   07B0               ADD      SP,SP,#+28
   \   000000AA   00BD               POP      {PC}             ;; return
    216          

   \                                 In section .text, align 2, keep-with-next
    217          void USART1_IRQHandler(void)		// RF 데이터를 받는다.
    218          {
   \                     USART1_IRQHandler:
   \   00000000   10B5               PUSH     {R4,LR}
    219          	static unsigned char data;
    220          	struct _Serial *serial;
    221          	
    222          	//   u16   ErrorFlag = 0;
    223          	
    224          	serial = &PC_Comm;
   \   00000002   ....               LDR.N    R4,??DataTable10_1
    225          	
    226          	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
   \   00000004   40F22551           MOVW     R1,#+1317
   \   00000008   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   0000000A   ........           BL       USART_GetITStatus
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   47D0               BEQ.N    ??USART1_IRQHandler_0
    227          	{
    228          		if (USART_GetFlagStatus(USART1, USART_FLAG_ORE) != RESET) {
   \   00000012   0821               MOVS     R1,#+8
   \   00000014   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   00000016   ........           BL       USART_GetFlagStatus
   \   0000001A   0028               CMP      R0,#+0
   \   0000001C   03D0               BEQ.N    ??USART1_IRQHandler_1
    229          			USART_ClearITPendingBit(USART1, USART_FLAG_ORE);
   \   0000001E   0821               MOVS     R1,#+8
   \   00000020   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   00000022   ........           BL       USART_ClearITPendingBit
    230                         //			ErrorFlag = 1;
    231          		}
    232          		if (USART_GetFlagStatus(USART1, USART_FLAG_NE) != RESET) {
   \                     ??USART1_IRQHandler_1:
   \   00000026   0421               MOVS     R1,#+4
   \   00000028   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   0000002A   ........           BL       USART_GetFlagStatus
   \   0000002E   0028               CMP      R0,#+0
   \   00000030   03D0               BEQ.N    ??USART1_IRQHandler_2
    233          			USART_ClearITPendingBit(USART1, USART_FLAG_NE);
   \   00000032   0421               MOVS     R1,#+4
   \   00000034   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   00000036   ........           BL       USART_ClearITPendingBit
    234                         //			ErrorFlag = 1;
    235          		}
    236          		if (USART_GetFlagStatus(USART1, USART_FLAG_FE) != RESET) {
   \                     ??USART1_IRQHandler_2:
   \   0000003A   0221               MOVS     R1,#+2
   \   0000003C   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   0000003E   ........           BL       USART_GetFlagStatus
   \   00000042   0028               CMP      R0,#+0
   \   00000044   03D0               BEQ.N    ??USART1_IRQHandler_3
    237          			USART_ClearITPendingBit(USART1, USART_FLAG_FE);
   \   00000046   0221               MOVS     R1,#+2
   \   00000048   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   0000004A   ........           BL       USART_ClearITPendingBit
    238                         //			ErrorFlag = 1;
    239          		}
    240          		if (USART_GetFlagStatus(USART1, USART_FLAG_PE) != RESET) {
   \                     ??USART1_IRQHandler_3:
   \   0000004E   0121               MOVS     R1,#+1
   \   00000050   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   00000052   ........           BL       USART_GetFlagStatus
   \   00000056   0028               CMP      R0,#+0
   \   00000058   03D0               BEQ.N    ??USART1_IRQHandler_4
    241          			USART_ClearITPendingBit(USART1, USART_FLAG_PE);
   \   0000005A   0121               MOVS     R1,#+1
   \   0000005C   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   0000005E   ........           BL       USART_ClearITPendingBit
    242                         //			ErrorFlag = 1;
    243          		}
    244                    
    245          		// 수신된 데이타를 버퍼에 넣음
    246          		data = (USART_ReceiveData(USART1) & 0xFF);
   \                     ??USART1_IRQHandler_4:
   \   00000062   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   00000064   ........           BL       USART_ReceiveData
   \   00000068   ....               LDR.N    R1,??DataTable10_8
   \   0000006A   0870               STRB     R0,[R1, #+0]
    247          		serial->rxbuf[serial->rxep] = data;
   \   0000006C   B4F80204           LDRH     R0,[R4, #+1026]
   \   00000070   ....               LDR.N    R1,??DataTable10_8
   \   00000072   0978               LDRB     R1,[R1, #+0]
   \   00000074   0155               STRB     R1,[R0, R4]
    248          		serial->rxep ++;
   \   00000076   B4F80204           LDRH     R0,[R4, #+1026]
   \   0000007A   401C               ADDS     R0,R0,#+1
   \   0000007C   A4F80204           STRH     R0,[R4, #+1026]
    249          //          serial->RxBuf_Count++;         //  메시지 버퍼큐
    250          		// 수신 버퍼를 초과하는 경우 버림
    251          		if (serial->rxep >= sizeof(serial->rxbuf)) serial->rxep = 0;
   \   00000080   B4F80204           LDRH     R0,[R4, #+1026]
   \   00000084   B0F5806F           CMP      R0,#+1024
   \   00000088   02D3               BCC.N    ??USART1_IRQHandler_5
   \   0000008A   0020               MOVS     R0,#+0
   \   0000008C   A4F80204           STRH     R0,[R4, #+1026]
    252                    
    253          		// 다음 문자는 무조건 0으로 
    254          		serial->rxbuf[serial->rxep] = 0;	
   \                     ??USART1_IRQHandler_5:
   \   00000090   B4F80204           LDRH     R0,[R4, #+1026]
   \   00000094   0021               MOVS     R1,#+0
   \   00000096   0155               STRB     R1,[R0, R4]
    255          		
    256          		/*		
    257          		data = (USART_ReceiveData(UART4) & 0xFF);			// 수신된 데이타를 버퍼에 넣음
    258          		
    259                    Buffer[BuffCnt++ ] = data;
    260          		*/
    261                    
    262          		// Clear the USART2 Receive interrupt 
    263          		USART_ClearITPendingBit(USART1, USART_IT_RXNE | USART_IT_TXE | USART_IT_ERR);
   \   00000098   40F26771           MOVW     R1,#+1895
   \   0000009C   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   0000009E   ........           BL       USART_ClearITPendingBit
    264          	} 
    265          }
   \                     ??USART1_IRQHandler_0:
   \   000000A2   10BD               POP      {R4,PC}          ;; return

   \                                 In section .bss, align 1
   \                     ??data:
   \   00000000                      DS8 1

   \                                 In section .text, align 2, keep-with-next
    266          void USART2_IRQHandler(void)		// RF 데이터를 받는다.
    267          {
   \                     USART2_IRQHandler:
   \   00000000   10B5               PUSH     {R4,LR}
    268          	static unsigned char data;
    269          	struct _Serial *serial;
    270          	
    271          	//   u16   ErrorFlag = 0;
    272          	
    273          	serial = &RF_Module;
   \   00000002   ....               LDR.N    R4,??DataTable10_2
    274          	
    275          	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
   \   00000004   40F22551           MOVW     R1,#+1317
   \   00000008   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   0000000A   ........           BL       USART_GetITStatus
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   47D0               BEQ.N    ??USART2_IRQHandler_0
    276          	{
    277          		if (USART_GetFlagStatus(USART2, USART_FLAG_ORE) != RESET) {
   \   00000012   0821               MOVS     R1,#+8
   \   00000014   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   00000016   ........           BL       USART_GetFlagStatus
   \   0000001A   0028               CMP      R0,#+0
   \   0000001C   03D0               BEQ.N    ??USART2_IRQHandler_1
    278          			USART_ClearITPendingBit(USART2, USART_FLAG_ORE);
   \   0000001E   0821               MOVS     R1,#+8
   \   00000020   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   00000022   ........           BL       USART_ClearITPendingBit
    279                         //			ErrorFlag = 1;
    280          		}
    281          		if (USART_GetFlagStatus(USART2, USART_FLAG_NE) != RESET) {
   \                     ??USART2_IRQHandler_1:
   \   00000026   0421               MOVS     R1,#+4
   \   00000028   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   0000002A   ........           BL       USART_GetFlagStatus
   \   0000002E   0028               CMP      R0,#+0
   \   00000030   03D0               BEQ.N    ??USART2_IRQHandler_2
    282          			USART_ClearITPendingBit(USART2, USART_FLAG_NE);
   \   00000032   0421               MOVS     R1,#+4
   \   00000034   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   00000036   ........           BL       USART_ClearITPendingBit
    283                         //			ErrorFlag = 1;
    284          		}
    285          		if (USART_GetFlagStatus(USART2, USART_FLAG_FE) != RESET) {
   \                     ??USART2_IRQHandler_2:
   \   0000003A   0221               MOVS     R1,#+2
   \   0000003C   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   0000003E   ........           BL       USART_GetFlagStatus
   \   00000042   0028               CMP      R0,#+0
   \   00000044   03D0               BEQ.N    ??USART2_IRQHandler_3
    286          			USART_ClearITPendingBit(USART2, USART_FLAG_FE);
   \   00000046   0221               MOVS     R1,#+2
   \   00000048   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   0000004A   ........           BL       USART_ClearITPendingBit
    287                         //			ErrorFlag = 1;
    288          		}
    289          		if (USART_GetFlagStatus(USART2, USART_FLAG_PE) != RESET) {
   \                     ??USART2_IRQHandler_3:
   \   0000004E   0121               MOVS     R1,#+1
   \   00000050   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   00000052   ........           BL       USART_GetFlagStatus
   \   00000056   0028               CMP      R0,#+0
   \   00000058   03D0               BEQ.N    ??USART2_IRQHandler_4
    290          			USART_ClearITPendingBit(USART2, USART_FLAG_PE);
   \   0000005A   0121               MOVS     R1,#+1
   \   0000005C   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   0000005E   ........           BL       USART_ClearITPendingBit
    291                         //			ErrorFlag = 1;
    292          		}
    293                    
    294          		// 수신된 데이타를 버퍼에 넣음
    295          //          if(serial->RxBuf_Count < MAX_SERIAL_BUF)
    296          //          {
    297                    data = (USART_ReceiveData(USART2) & 0xFF);
   \                     ??USART2_IRQHandler_4:
   \   00000062   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   00000064   ........           BL       USART_ReceiveData
   \   00000068   ....               LDR.N    R1,??DataTable10_9
   \   0000006A   0870               STRB     R0,[R1, #+0]
    298                    serial->rxbuf[serial->rxep] = data;
   \   0000006C   B4F80204           LDRH     R0,[R4, #+1026]
   \   00000070   ....               LDR.N    R1,??DataTable10_9
   \   00000072   0978               LDRB     R1,[R1, #+0]
   \   00000074   0155               STRB     R1,[R0, R4]
    299                    serial->rxep ++;
   \   00000076   B4F80204           LDRH     R0,[R4, #+1026]
   \   0000007A   401C               ADDS     R0,R0,#+1
   \   0000007C   A4F80204           STRH     R0,[R4, #+1026]
    300          //          serial->RxBuf_Count++;
    301                    // 수신 버퍼를 초과하는 경우 버림
    302                    if (serial->rxep >= sizeof(serial->rxbuf)) serial->rxep = 0;
   \   00000080   B4F80204           LDRH     R0,[R4, #+1026]
   \   00000084   B0F5806F           CMP      R0,#+1024
   \   00000088   02D3               BCC.N    ??USART2_IRQHandler_5
   \   0000008A   0020               MOVS     R0,#+0
   \   0000008C   A4F80204           STRH     R0,[R4, #+1026]
    303                    
    304                    // 다음 문자는 무조건 0으로 
    305                    serial->rxbuf[serial->rxep] = 0;	
   \                     ??USART2_IRQHandler_5:
   \   00000090   B4F80204           LDRH     R0,[R4, #+1026]
   \   00000094   0021               MOVS     R1,#+0
   \   00000096   0155               STRB     R1,[R0, R4]
    306          //		}
    307          		/*		
    308          		data = (USART_ReceiveData(UART4) & 0xFF);			// 수신된 데이타를 버퍼에 넣음
    309          		
    310                    Buffer[BuffCnt++ ] = data;
    311          		*/
    312                    
    313          		// Clear the USART2 Receive interrupt 
    314          		USART_ClearITPendingBit(USART2, USART_IT_RXNE | USART_IT_TXE | USART_IT_ERR);
   \   00000098   40F26771           MOVW     R1,#+1895
   \   0000009C   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   0000009E   ........           BL       USART_ClearITPendingBit
    315          	} 
    316          }
   \                     ??USART2_IRQHandler_0:
   \   000000A2   10BD               POP      {R4,PC}          ;; return

   \                                 In section .bss, align 1
   \                     ??data_1:
   \   00000000                      DS8 1
    317          

   \                                 In section .text, align 2, keep-with-next
    318          void UART4_IRQHandler(void)		// GPS 데이터를 받는다.
    319          {
   \                     UART4_IRQHandler:
   \   00000000   10B5               PUSH     {R4,LR}
    320          	static unsigned char data;
    321          	struct _Serial *serial;
    322          	
    323          	//   u16   ErrorFlag = 0;
    324          	
    325          	serial = &RTX_GPS;
   \   00000002   ....               LDR.N    R4,??DataTable10
    326          	
    327          	if(USART_GetITStatus(UART4, USART_IT_RXNE) != RESET)
   \   00000004   40F22551           MOVW     R1,#+1317
   \   00000008   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   0000000A   ........           BL       USART_GetITStatus
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   47D0               BEQ.N    ??UART4_IRQHandler_0
    328          	{
    329          		if (USART_GetFlagStatus(UART4, USART_FLAG_ORE) != RESET) {
   \   00000012   0821               MOVS     R1,#+8
   \   00000014   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   00000016   ........           BL       USART_GetFlagStatus
   \   0000001A   0028               CMP      R0,#+0
   \   0000001C   03D0               BEQ.N    ??UART4_IRQHandler_1
    330          			USART_ClearITPendingBit(UART4, USART_FLAG_ORE);
   \   0000001E   0821               MOVS     R1,#+8
   \   00000020   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   00000022   ........           BL       USART_ClearITPendingBit
    331                         //			ErrorFlag = 1;
    332          		}
    333          		if (USART_GetFlagStatus(UART4, USART_FLAG_NE) != RESET) {
   \                     ??UART4_IRQHandler_1:
   \   00000026   0421               MOVS     R1,#+4
   \   00000028   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   0000002A   ........           BL       USART_GetFlagStatus
   \   0000002E   0028               CMP      R0,#+0
   \   00000030   03D0               BEQ.N    ??UART4_IRQHandler_2
    334          			USART_ClearITPendingBit(UART4, USART_FLAG_NE);
   \   00000032   0421               MOVS     R1,#+4
   \   00000034   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   00000036   ........           BL       USART_ClearITPendingBit
    335                         //			ErrorFlag = 1;
    336          		}
    337          		if (USART_GetFlagStatus(UART4, USART_FLAG_FE) != RESET) {
   \                     ??UART4_IRQHandler_2:
   \   0000003A   0221               MOVS     R1,#+2
   \   0000003C   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   0000003E   ........           BL       USART_GetFlagStatus
   \   00000042   0028               CMP      R0,#+0
   \   00000044   03D0               BEQ.N    ??UART4_IRQHandler_3
    338          			USART_ClearITPendingBit(UART4, USART_FLAG_FE);
   \   00000046   0221               MOVS     R1,#+2
   \   00000048   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   0000004A   ........           BL       USART_ClearITPendingBit
    339                         //			ErrorFlag = 1;
    340          		}
    341          		if (USART_GetFlagStatus(UART4, USART_FLAG_PE) != RESET) {
   \                     ??UART4_IRQHandler_3:
   \   0000004E   0121               MOVS     R1,#+1
   \   00000050   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   00000052   ........           BL       USART_GetFlagStatus
   \   00000056   0028               CMP      R0,#+0
   \   00000058   03D0               BEQ.N    ??UART4_IRQHandler_4
    342          			USART_ClearITPendingBit(UART4, USART_FLAG_PE);
   \   0000005A   0121               MOVS     R1,#+1
   \   0000005C   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   0000005E   ........           BL       USART_ClearITPendingBit
    343                         //			ErrorFlag = 1;
    344          		}
    345                    
    346          		// 수신된 데이타를 버퍼에 넣음
    347          		data = (USART_ReceiveData(UART4) & 0xFF);
   \                     ??UART4_IRQHandler_4:
   \   00000062   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   00000064   ........           BL       USART_ReceiveData
   \   00000068   ....               LDR.N    R1,??DataTable10_10
   \   0000006A   0870               STRB     R0,[R1, #+0]
    348          		serial->rxbuf[serial->rxep] = data;
   \   0000006C   B4F80204           LDRH     R0,[R4, #+1026]
   \   00000070   ....               LDR.N    R1,??DataTable10_10
   \   00000072   0978               LDRB     R1,[R1, #+0]
   \   00000074   0155               STRB     R1,[R0, R4]
    349          		serial->rxep ++;
   \   00000076   B4F80204           LDRH     R0,[R4, #+1026]
   \   0000007A   401C               ADDS     R0,R0,#+1
   \   0000007C   A4F80204           STRH     R0,[R4, #+1026]
    350                    
    351          		// 수신 버퍼를 초과하는 경우 버림
    352          		if (serial->rxep >= sizeof(serial->rxbuf)) serial->rxep = 0;
   \   00000080   B4F80204           LDRH     R0,[R4, #+1026]
   \   00000084   B0F5806F           CMP      R0,#+1024
   \   00000088   02D3               BCC.N    ??UART4_IRQHandler_5
   \   0000008A   0020               MOVS     R0,#+0
   \   0000008C   A4F80204           STRH     R0,[R4, #+1026]
    353                    
    354          		// 다음 문자는 무조건 0으로 
    355          		serial->rxbuf[serial->rxep] = 0;	
   \                     ??UART4_IRQHandler_5:
   \   00000090   B4F80204           LDRH     R0,[R4, #+1026]
   \   00000094   0021               MOVS     R1,#+0
   \   00000096   0155               STRB     R1,[R0, R4]
    356          		
    357          		/*		
    358          		data = (USART_ReceiveData(UART4) & 0xFF);			// 수신된 데이타를 버퍼에 넣음
    359          		
    360                    Buffer[BuffCnt++ ] = data;
    361          		*/
    362                    
    363          		// Clear the USART2 Receive interrupt 
    364          		USART_ClearITPendingBit(UART4, USART_IT_RXNE | USART_IT_TXE | USART_IT_ERR);
   \   00000098   40F26771           MOVW     R1,#+1895
   \   0000009C   ....               LDR.N    R0,??DataTable10_7  ;; 0x40004c00
   \   0000009E   ........           BL       USART_ClearITPendingBit
    365          	} 
    366          }
   \                     ??UART4_IRQHandler_0:
   \   000000A2   10BD               POP      {R4,PC}          ;; return

   \                                 In section .bss, align 1
   \                     ??data_2:
   \   00000000                      DS8 1
    367          

   \                                 In section .text, align 2, keep-with-next
    368          void puts_data(struct _Serial *serial, char *str,u32 Length)
    369          {
   \                     puts_data:
   \   00000000   30B4               PUSH     {R4,R5}
    370               u32 i;
    371               for( i = 0 ; i < Length ; i++)
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   13E0               B.N      ??puts_data_0
    372               {
    373                    serial->txbuf[serial->txep++] = *str;
   \                     ??puts_data_1:
   \   00000006   B0F80E48           LDRH     R4,[R0, #+2062]
   \   0000000A   651C               ADDS     R5,R4,#+1
   \   0000000C   A0F80E58           STRH     R5,[R0, #+2062]
   \   00000010   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000012   2418               ADDS     R4,R4,R0
   \   00000014   0D78               LDRB     R5,[R1, #+0]
   \   00000016   84F80B54           STRB     R5,[R4, #+1035]
    374                    str++;
   \   0000001A   491C               ADDS     R1,R1,#+1
    375                    
    376                    if (serial->txep >= MAX_SERIAL_BUF) serial->txep = 0;
   \   0000001C   B0F80E48           LDRH     R4,[R0, #+2062]
   \   00000020   B4F5806F           CMP      R4,#+1024
   \   00000024   02D3               BCC.N    ??puts_data_2
   \   00000026   0024               MOVS     R4,#+0
   \   00000028   A0F80E48           STRH     R4,[R0, #+2062]
    377               }
   \                     ??puts_data_2:
   \   0000002C   5B1C               ADDS     R3,R3,#+1
   \                     ??puts_data_0:
   \   0000002E   9342               CMP      R3,R2
   \   00000030   E9D3               BCC.N    ??puts_data_1
    378          }
   \   00000032   30BC               POP      {R4,R5}
   \   00000034   7047               BX       LR               ;; return
    379          

   \                                 In section .text, align 2, keep-with-next
    380          void puts_string(struct _Serial *serial, char *str)
    381          {
   \                     puts_string:
   \   00000000   12E0               B.N      ??puts_string_0
    382               while(*str) {
    383                    serial->txbuf[serial->txep++] = *str;
   \                     ??puts_string_1:
   \   00000002   B0F80E28           LDRH     R2,[R0, #+2062]
   \   00000006   531C               ADDS     R3,R2,#+1
   \   00000008   A0F80E38           STRH     R3,[R0, #+2062]
   \   0000000C   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000E   1218               ADDS     R2,R2,R0
   \   00000010   0B78               LDRB     R3,[R1, #+0]
   \   00000012   82F80B34           STRB     R3,[R2, #+1035]
    384                    str++;
   \   00000016   491C               ADDS     R1,R1,#+1
    385                    
    386                    if (serial->txep >= MAX_SERIAL_BUF) serial->txep = 0;
   \   00000018   B0F80E28           LDRH     R2,[R0, #+2062]
   \   0000001C   B2F5806F           CMP      R2,#+1024
   \   00000020   02D3               BCC.N    ??puts_string_0
   \   00000022   0022               MOVS     R2,#+0
   \   00000024   A0F80E28           STRH     R2,[R0, #+2062]
    387               }
   \                     ??puts_string_0:
   \   00000028   0A78               LDRB     R2,[R1, #+0]
   \   0000002A   002A               CMP      R2,#+0
   \   0000002C   E9D1               BNE.N    ??puts_string_1
    388          }
   \   0000002E   7047               BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    389          void puts_char(struct _Serial *serial, char str)
    390          {
    391               serial->txbuf[serial->txep++] = str;    
   \                     puts_char:
   \   00000000   B0F80E28           LDRH     R2,[R0, #+2062]
   \   00000004   531C               ADDS     R3,R2,#+1
   \   00000006   A0F80E38           STRH     R3,[R0, #+2062]
   \   0000000A   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000C   1218               ADDS     R2,R2,R0
   \   0000000E   82F80B14           STRB     R1,[R2, #+1035]
    392               if (serial->txep >= MAX_SERIAL_BUF) serial->txep = 0;
   \   00000012   B0F80E18           LDRH     R1,[R0, #+2062]
   \   00000016   B1F5806F           CMP      R1,#+1024
   \   0000001A   02D3               BCC.N    ??puts_char_0
   \   0000001C   0021               MOVS     R1,#+0
   \   0000001E   A0F80E18           STRH     R1,[R0, #+2062]
    393          }
   \                     ??puts_char_0:
   \   00000022   7047               BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    394          void SendSerial(USART_TypeDef* USARTx, struct _Serial *serial)
    395          {
   \                     SendSerial:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0500               MOVS     R5,R0
   \   00000004   0C00               MOVS     R4,R1
    396               
    397          	if (serial->txsp != serial->txep) 
   \   00000006   B4F80C08           LDRH     R0,[R4, #+2060]
   \   0000000A   B4F80E18           LDRH     R1,[R4, #+2062]
   \   0000000E   8842               CMP      R0,R1
   \   00000010   17D0               BEQ.N    ??SendSerial_0
    398               {
    399          		if (USART_GetFlagStatus(USARTx, USART_FLAG_TXE) == SET) 
   \   00000012   8021               MOVS     R1,#+128
   \   00000014   2800               MOVS     R0,R5
   \   00000016   ........           BL       USART_GetFlagStatus
   \   0000001A   0128               CMP      R0,#+1
   \   0000001C   11D1               BNE.N    ??SendSerial_0
    400                    {
    401                         USARTx->DR = (serial->txbuf[serial->txsp++] & (u16)0x01FF);
   \   0000001E   B4F80C08           LDRH     R0,[R4, #+2060]
   \   00000022   411C               ADDS     R1,R0,#+1
   \   00000024   A4F80C18           STRH     R1,[R4, #+2060]
   \   00000028   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002A   0019               ADDS     R0,R0,R4
   \   0000002C   90F80B04           LDRB     R0,[R0, #+1035]
   \   00000030   A880               STRH     R0,[R5, #+4]
    402          			if (serial->txsp >= MAX_SERIAL_BUF) 	
   \   00000032   B4F80C08           LDRH     R0,[R4, #+2060]
   \   00000036   B0F5806F           CMP      R0,#+1024
   \   0000003A   02D3               BCC.N    ??SendSerial_0
    403                              serial->txsp = 0;
   \   0000003C   0020               MOVS     R0,#+0
   \   0000003E   A4F80C08           STRH     R0,[R4, #+2060]
    404          		}
    405          	}
    406          }
   \                     ??SendSerial_0:
   \   00000042   31BD               POP      {R0,R4,R5,PC}    ;; return
    407          

   \                                 In section .text, align 2, keep-with-next
    408          void SendMessage(void)
    409          {
   \                     SendMessage:
   \   00000000   80B5               PUSH     {R7,LR}
    410               SendSerial(USART1, &PC_Comm);
   \   00000002   ....               LDR.N    R1,??DataTable10_1
   \   00000004   ....               LDR.N    R0,??DataTable10_4  ;; 0x40011000
   \   00000006   ........           BL       SendSerial
    411               SendSerial(USART2, &RF_Module);
   \   0000000A   ....               LDR.N    R1,??DataTable10_2
   \   0000000C   ....               LDR.N    R0,??DataTable10_5  ;; 0x40004400
   \   0000000E   ........           BL       SendSerial
    412          }
   \   00000012   01BD               POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   ........           DC32     RTX_GPS

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   ........           DC32     PC_Comm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   ........           DC32     RF_Module

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   00000240           DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   00100140           DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   00440040           DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   00080240           DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   004C0040           DC32     0x40004c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   ........           DC32     ??data

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   ........           DC32     ??data_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   ........           DC32     ??data_2

   Maximum stack usage in bytes:

     Function          .cstack
     --------          -------
     Clear_Serial1          8
     Clear_Serial2          8
     Clear_Serial4          8
     NVIC_Config            8
     SendMessage            8
     SendSerial            16
     Serial_Config          8
     UART4_IRQHandler       8
     USART1_IRQHandler      8
     USART1_Init           32
     USART2_IRQHandler      8
     USART2_Init           32
     USART4_Init           32
     memset                 8
     puts_char              0
     puts_data              8
     puts_string            0


   Section sizes:

     Function/Label      Bytes
     --------------      -----
     memset                20
     RTX_GPS             2068
     PC_Comm             2068
     RF_Module           2068
     KMap_Transmit_Count    4
     Serial_Config         62
     Clear_Serial1         18
     Clear_Serial2         18
     Clear_Serial4         18
     NVIC_Config           94
     USART1_Init          180
     USART2_Init          178
     USART4_Init          172
     USART1_IRQHandler    164
     data                   1
     USART2_IRQHandler    164
     data                   1
     UART4_IRQHandler     164
     data                   1
     puts_data             54
     puts_string           48
     puts_char             36
     SendSerial            68
     SendMessage           20
     ??DataTable10          4
     ??DataTable10_1        4
     ??DataTable10_2        4
     ??DataTable10_3        4
     ??DataTable10_4        4
     ??DataTable10_5        4
     ??DataTable10_6        4
     ??DataTable10_7        4
     ??DataTable10_8        4
     ??DataTable10_9        4
     ??DataTable10_10       4

 
 6 211 bytes in section .bss
 1 522 bytes in section .text
 
 1 502 bytes of CODE memory (+ 20 bytes shared)
 6 211 bytes of DATA memory

Errors: none
Warnings: none
