###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     12/Nov/2011  19:31:43 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Libraries\STM32 #
#                    _USB_HOST_Library\Core\src\usbh_stdreq.c                 #
#    Command line =  "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Libraries\STM3 #
#                    2_USB_HOST_Library\Core\src\usbh_stdreq.c" -D            #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D RTC_CLOCK_SOURCE_LSE -lC            #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    STM3220F_EVAL\List\" -lA "F:\¹¬ÀÛ¾÷\[ NewDTG             #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\STM3220F_EVAL\List\" #
#                     -o "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EW #
#                    ARM\STM3220F_EVAL\Obj\" --no_cse --no_unroll             #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                              #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\" -I              #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\CMSIS\CM3\CoreSupport\" -I "F:\¹¬ÀÛ¾÷\[  #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Librari #
#                    es\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\" -I             #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I      #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Utilities\STM32_EVAL\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG      #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\Common\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\STM3220F_EVAL\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_OTG_Driver\inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Core\inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Class\msc\inc\" -I "F:\¹¬ÀÛ¾÷\[     #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\" -I   #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\Usb\Inc\" -I "F:\¹¬ÀÛ¾÷\[ NewDTG                      #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\src\" -I      #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Core\inc\" -I     #
#                    "F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\"   #
#                    -Ol --use_c++_inline                                     #
#    List file    =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\List\usbh_stdreq.lst                        #
#    Object file  =  F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\Obj\usbh_stdreq.o                           #
#                                                                             #
#                                                                             #
###############################################################################

F:\¹¬ÀÛ¾÷\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Libraries\STM32_USB_HOST_Library\Core\src\usbh_stdreq.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbh_stdreq.c 
      4            * @author  MCD Application Team
      5            * @version V2.0.0RC1
      6            * @date    18-March-2011
      7            * @brief   This file implements the standard requests for device enumeration
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */ 
     21          /* Includes ------------------------------------------------------------------*/
     22          
     23          #include "usbh_ioreq.h"
     24          #include "usbh_stdreq.h"
     25          
     26          /** @addtogroup USBH_LIB
     27          * @{
     28          */
     29          
     30          /** @addtogroup USBH_LIB_CORE
     31          * @{
     32          */
     33          
     34          /** @defgroup USBH_STDREQ 
     35          * @brief This file implements the standard requests for device enumeration
     36          * @{
     37          */
     38          
     39          
     40          /** @defgroup USBH_STDREQ_Private_Defines
     41          * @{
     42          */ 
     43          /**
     44          * @}
     45          */ 
     46          
     47          
     48          /** @defgroup USBH_STDREQ_Private_TypesDefinitions
     49          * @{
     50          */ 
     51          /**
     52          * @}
     53          */ 
     54          
     55          
     56          
     57          /** @defgroup USBH_STDREQ_Private_Macros
     58          * @{
     59          */ 
     60          /**
     61          * @}
     62          */ 
     63          
     64          
     65          /** @defgroup USBH_STDREQ_Private_Variables
     66          * @{
     67          */
     68          /**
     69          * @}
     70          */ 
     71          
     72          
     73          /** @defgroup USBH_STDREQ_Private_FunctionPrototypes
     74          * @{
     75          */
     76          static void USBH_ParseDevDesc (USBH_DevDesc_TypeDef* , uint8_t *buf, uint16_t length);
     77          
     78          static void USBH_ParseCfgDesc (USBH_CfgDesc_TypeDef* cfg_desc,
     79                                         USBH_InterfaceDesc_TypeDef* itf_desc,
     80                                         USBH_EpDesc_TypeDef*  ep_desc,                                                           
     81                                         uint8_t *buf, 
     82                                         uint16_t length);
     83          static  USBH_DescHeader_t      *USBH_GetNextDesc (uint8_t   *pbuf, 
     84                                                            uint16_t  *ptr);
     85          
     86          static void USBH_ParseInterfaceDesc (USBH_InterfaceDesc_TypeDef  *if_descriptor, uint8_t *buf);
     87          static void USBH_ParseEPDesc (USBH_EpDesc_TypeDef  *ep_descriptor, uint8_t *buf);
     88          
     89          static void USBH_ParseStringDesc (uint8_t* psrc, uint8_t* pdest, uint16_t length);
     90          /**
     91          * @}
     92          */ 
     93          
     94          
     95          /** @defgroup USBH_STDREQ_Private_Functions
     96          * @{
     97          */ 
     98          
     99          
    100          /**
    101          * @brief  USBH_Get_DevDesc
    102          *         Issue Get Device Descriptor command to the device. Once the response 
    103          *         received, it parses the device descriptor and updates the status.
    104          * @param  pdev: Selected device
    105          * @param  dev_desc: Device Descriptor buffer address
    106          * @param  pdev->host.Rx_Buffer: Receive Buffer address
    107          * @param  length: Length of the descriptor
    108          * @retval Status
    109          */

   \                                 In section .text, align 2, keep-with-next
    110          USBH_Status USBH_Get_DevDesc(USB_OTG_CORE_HANDLE *pdev,
    111                                       USBH_HOST *phost,
    112                                       uint8_t length)
    113          {
   \                     USBH_Get_DevDesc:
   \   00000000   F0B5               PUSH     {R4-R7,LR}
   \   00000002   83B0               SUB      SP,SP,#+12
   \   00000004   0400               MOVS     R4,R0
   \   00000006   0D00               MOVS     R5,R1
   \   00000008   1600               MOVS     R6,R2
    114            
    115            USBH_Status status;
    116            
    117            if((status = USBH_GetDescriptor(pdev, 
    118                                            phost,
    119                                            USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,                          
    120                                            USB_DESC_DEVICE, 
    121                                            pdev->host.Rx_Buffer,
    122                                            length)) == USBH_OK)
   \   0000000A   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000000C   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000000E   0196               STR      R6,[SP, #+4]
   \   00000010   04F21010           ADDW     R0,R4,#+272
   \   00000014   0090               STR      R0,[SP, #+0]
   \   00000016   4FF48073           MOV      R3,#+256
   \   0000001A   0022               MOVS     R2,#+0
   \   0000001C   2900               MOVS     R1,R5
   \   0000001E   2000               MOVS     R0,R4
   \   00000020   ........           BL       USBH_GetDescriptor
   \   00000024   0700               MOVS     R7,R0
   \   00000026   3800               MOVS     R0,R7
   \   00000028   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0028               CMP      R0,#+0
   \   0000002C   08D1               BNE.N    ??USBH_Get_DevDesc_0
    123            {
    124              /* Commands successfully sent and Response Received */       
    125              USBH_ParseDevDesc(&phost->device_prop.Dev_Desc, pdev->host.Rx_Buffer, length);
   \   0000002E   F6B2               UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   3200               MOVS     R2,R6
   \   00000032   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000034   04F21011           ADDW     R1,R4,#+272
   \   00000038   15F12200           ADDS     R0,R5,#+34
   \   0000003C   ........           BL       USBH_ParseDevDesc
    126            }
    127            return status;      
   \                     ??USBH_Get_DevDesc_0:
   \   00000040   3800               MOVS     R0,R7
   \   00000042   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   FEBD               POP      {R1-R7,PC}       ;; return
    128          }
    129          
    130          /**
    131          * @brief  USBH_Get_CfgDesc
    132          *         Issues Configuration Descriptor to the device. Once the response 
    133          *         received, it parses the configuartion descriptor and updates the 
    134          *         status.
    135          * @param  pdev: Selected device
    136          * @param  cfg_desc: Configuration Descriptor address
    137          * @param  itf_desc: Interface Descriptor address
    138          * @param  ep_desc: Endpoint Descriptor address
    139          * @param  length: Length of the descriptor
    140          * @retval Status
    141          */

   \                                 In section .text, align 2, keep-with-next
    142          USBH_Status USBH_Get_CfgDesc(USB_OTG_CORE_HANDLE *pdev, 
    143                                       USBH_HOST           *phost,                      
    144                                       uint16_t length)
    145          
    146          {
   \                     USBH_Get_CfgDesc:
   \   00000000   F0B5               PUSH     {R4-R7,LR}
   \   00000002   83B0               SUB      SP,SP,#+12
   \   00000004   0400               MOVS     R4,R0
   \   00000006   0D00               MOVS     R5,R1
   \   00000008   1600               MOVS     R6,R2
    147            USBH_Status status;
    148            
    149            if((status = USBH_GetDescriptor(pdev,
    150                                            phost,
    151                                            USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,                          
    152                                            USB_DESC_CONFIGURATION, 
    153                                            pdev->host.Rx_Buffer,
    154                                            length)) == USBH_OK)
   \   0000000A   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000000C   0196               STR      R6,[SP, #+4]
   \   0000000E   04F21010           ADDW     R0,R4,#+272
   \   00000012   0090               STR      R0,[SP, #+0]
   \   00000014   4FF40073           MOV      R3,#+512
   \   00000018   0022               MOVS     R2,#+0
   \   0000001A   2900               MOVS     R1,R5
   \   0000001C   2000               MOVS     R0,R4
   \   0000001E   ........           BL       USBH_GetDescriptor
   \   00000022   0700               MOVS     R7,R0
   \   00000024   3800               MOVS     R0,R7
   \   00000026   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0028               CMP      R0,#+0
   \   0000002A   0BD1               BNE.N    ??USBH_Get_CfgDesc_0
    155            {
    156              /* Commands successfully sent and Response Received  */       
    157              USBH_ParseCfgDesc (&phost->device_prop.Cfg_Desc,
    158                                 phost->device_prop.Itf_Desc,
    159                                 phost->device_prop.Ep_Desc[0], 
    160                                 pdev->host.Rx_Buffer,
    161                                 length); 
   \   0000002C   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000002E   0096               STR      R6,[SP, #+0]
   \   00000030   04F21013           ADDW     R3,R4,#+272
   \   00000034   15F15002           ADDS     R2,R5,#+80
   \   00000038   15F13E01           ADDS     R1,R5,#+62
   \   0000003C   15F13400           ADDS     R0,R5,#+52
   \   00000040   ........           BL       USBH_ParseCfgDesc
    162              
    163            }
    164            return status;
   \                     ??USBH_Get_CfgDesc_0:
   \   00000044   3800               MOVS     R0,R7
   \   00000046   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   FEBD               POP      {R1-R7,PC}       ;; return
    165          }
    166          
    167          
    168          /**
    169          * @brief  USBH_Get_StringDesc
    170          *         Issues string Descriptor command to the device. Once the response 
    171          *         received, it parses the string descriptor and updates the status.
    172          * @param  pdev: Selected device
    173          * @param  string_index: String index for the descriptor
    174          * @param  buff: Buffer address for the descriptor
    175          * @param  length: Length of the descriptor
    176          * @retval Status
    177          */

   \                                 In section .text, align 2, keep-with-next
    178          USBH_Status USBH_Get_StringDesc(USB_OTG_CORE_HANDLE *pdev,
    179                                          USBH_HOST *phost,
    180                                          uint8_t string_index, 
    181                                          uint8_t *buff, 
    182                                          uint16_t length)
    183          {
   \                     USBH_Get_StringDesc:
   \   00000000   F0B5               PUSH     {R4-R7,LR}
   \   00000002   83B0               SUB      SP,SP,#+12
   \   00000004   0500               MOVS     R5,R0
   \   00000006   1E00               MOVS     R6,R3
   \   00000008   089C               LDR      R4,[SP, #+32]
    184            USBH_Status status;
    185            
    186            if((status = USBH_GetDescriptor(pdev,
    187                                            phost,
    188                                            USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,                                    
    189                                            USB_DESC_STRING | string_index, 
    190                                            pdev->host.Rx_Buffer,
    191                                            length)) == USBH_OK)
   \   0000000A   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000000C   0194               STR      R4,[SP, #+4]
   \   0000000E   05F21010           ADDW     R0,R5,#+272
   \   00000012   0090               STR      R0,[SP, #+0]
   \   00000014   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000016   4FF44070           MOV      R0,#+768
   \   0000001A   50EA0203           ORRS     R3,R0,R2
   \   0000001E   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000020   0022               MOVS     R2,#+0
   \   00000022   2800               MOVS     R0,R5
   \   00000024   ........           BL       USBH_GetDescriptor
   \   00000028   0700               MOVS     R7,R0
   \   0000002A   3800               MOVS     R0,R7
   \   0000002C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0028               CMP      R0,#+0
   \   00000030   06D1               BNE.N    ??USBH_Get_StringDesc_0
    192            {
    193              /* Commands successfully sent and Response Received  */       
    194              USBH_ParseStringDesc(pdev->host.Rx_Buffer,buff, length);    
   \   00000032   2200               MOVS     R2,R4
   \   00000034   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000036   3100               MOVS     R1,R6
   \   00000038   05F21010           ADDW     R0,R5,#+272
   \   0000003C   ........           BL       USBH_ParseStringDesc
    195            }
    196            return status;
   \                     ??USBH_Get_StringDesc_0:
   \   00000040   3800               MOVS     R0,R7
   \   00000042   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   FEBD               POP      {R1-R7,PC}       ;; return
    197          }
    198          
    199          /**
    200          * @brief  USBH_GetDescriptor
    201          *         Issues Descriptor command to the device. Once the response received,
    202          *         it parses the descriptor and updates the status.
    203          * @param  pdev: Selected device
    204          * @param  req_type: Descriptor type
    205          * @param  value_idx: wValue for the GetDescriptr request
    206          * @param  buff: Buffer to store the descriptor
    207          * @param  length: Length of the descriptor
    208          * @retval Status
    209          */

   \                                 In section .text, align 2, keep-with-next
    210          USBH_Status USBH_GetDescriptor(USB_OTG_CORE_HANDLE *pdev,
    211                                         USBH_HOST           *phost,                                
    212                                         uint8_t  req_type,
    213                                         uint16_t value_idx, 
    214                                         uint8_t* buff, 
    215                                         uint16_t length )
    216          { 
   \                     USBH_GetDescriptor:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   049D               LDR      R5,[SP, #+16]
   \   00000004   059C               LDR      R4,[SP, #+20]
    217            phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
   \   00000006   52F08002           ORRS     R2,R2,#0x80
   \   0000000A   0A75               STRB     R2,[R1, #+20]
    218            phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
   \   0000000C   0622               MOVS     R2,#+6
   \   0000000E   4A75               STRB     R2,[R1, #+21]
    219            phost->Control.setup.b.wValue.w = value_idx;
   \   00000010   CB82               STRH     R3,[R1, #+22]
    220            
    221            if ((value_idx & 0xff00) == USB_DESC_STRING)
   \   00000012   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000014   13F47F42           ANDS     R2,R3,#0xFF00
   \   00000018   4FF44073           MOV      R3,#+768
   \   0000001C   9A42               CMP      R2,R3
   \   0000001E   03D1               BNE.N    ??USBH_GetDescriptor_0
    222            {
    223              phost->Control.setup.b.wIndex.w = 0x0409;
   \   00000020   40F20942           MOVW     R2,#+1033
   \   00000024   0A83               STRH     R2,[R1, #+24]
   \   00000026   01E0               B.N      ??USBH_GetDescriptor_1
    224            }
    225            else
    226            {
    227              phost->Control.setup.b.wIndex.w = 0;
   \                     ??USBH_GetDescriptor_0:
   \   00000028   0022               MOVS     R2,#+0
   \   0000002A   0A83               STRH     R2,[R1, #+24]
    228            }
    229            phost->Control.setup.b.wLength.w = length;           
   \                     ??USBH_GetDescriptor_1:
   \   0000002C   4C83               STRH     R4,[R1, #+26]
    230            return USBH_CtlReq(pdev, phost, buff , length );     
   \   0000002E   2300               MOVS     R3,R4
   \   00000030   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000032   2A00               MOVS     R2,R5
   \   00000034   ........           BL       USBH_CtlReq
   \   00000038   32BD               POP      {R1,R4,R5,PC}    ;; return
    231          }
    232          
    233          /**
    234          * @brief  USBH_SetAddress
    235          *         This command sets the address to the connected device
    236          * @param  pdev: Selected device
    237          * @param  DeviceAddress: Device address to assign
    238          * @retval Status
    239          */

   \                                 In section .text, align 2, keep-with-next
    240          USBH_Status USBH_SetAddress(USB_OTG_CORE_HANDLE *pdev, 
    241                                      USBH_HOST *phost,
    242                                      uint8_t DeviceAddress)
    243          {
   \                     USBH_SetAddress:
   \   00000000   80B5               PUSH     {R7,LR}
    244            phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
    245              USB_REQ_TYPE_STANDARD;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   0B75               STRB     R3,[R1, #+20]
    246            
    247            phost->Control.setup.b.bRequest = USB_REQ_SET_ADDRESS;
   \   00000006   0523               MOVS     R3,#+5
   \   00000008   4B75               STRB     R3,[R1, #+21]
    248            
    249            phost->Control.setup.b.wValue.w = (uint16_t)DeviceAddress;
   \   0000000A   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   CA82               STRH     R2,[R1, #+22]
    250            phost->Control.setup.b.wIndex.w = 0;
   \   0000000E   0022               MOVS     R2,#+0
   \   00000010   0A83               STRH     R2,[R1, #+24]
    251            phost->Control.setup.b.wLength.w = 0;
   \   00000012   0022               MOVS     R2,#+0
   \   00000014   4A83               STRH     R2,[R1, #+26]
    252            
    253            return USBH_CtlReq(pdev, phost, 0 , 0 );
   \   00000016   0023               MOVS     R3,#+0
   \   00000018   0022               MOVS     R2,#+0
   \   0000001A   ........           BL       USBH_CtlReq
   \   0000001E   02BD               POP      {R1,PC}          ;; return
    254          }
    255          
    256          /**
    257          * @brief  USBH_SetCfg
    258          *         The command sets the configuration value to the connected device
    259          * @param  pdev: Selected device
    260          * @param  cfg_idx: Configuration value
    261          * @retval Status
    262          */

   \                                 In section .text, align 2, keep-with-next
    263          USBH_Status USBH_SetCfg(USB_OTG_CORE_HANDLE *pdev, 
    264                                  USBH_HOST *phost,
    265                                  uint16_t cfg_idx)
    266          {
   \                     USBH_SetCfg:
   \   00000000   80B5               PUSH     {R7,LR}
    267            
    268            phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE |\
    269              USB_REQ_TYPE_STANDARD;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   0B75               STRB     R3,[R1, #+20]
    270            phost->Control.setup.b.bRequest = USB_REQ_SET_CONFIGURATION;
   \   00000006   0923               MOVS     R3,#+9
   \   00000008   4B75               STRB     R3,[R1, #+21]
    271            phost->Control.setup.b.wValue.w = cfg_idx;
   \   0000000A   CA82               STRH     R2,[R1, #+22]
    272            phost->Control.setup.b.wIndex.w = 0;
   \   0000000C   0022               MOVS     R2,#+0
   \   0000000E   0A83               STRH     R2,[R1, #+24]
    273            phost->Control.setup.b.wLength.w = 0;           
   \   00000010   0022               MOVS     R2,#+0
   \   00000012   4A83               STRH     R2,[R1, #+26]
    274            
    275            return USBH_CtlReq(pdev, phost, 0 , 0 );      
   \   00000014   0023               MOVS     R3,#+0
   \   00000016   0022               MOVS     R2,#+0
   \   00000018   ........           BL       USBH_CtlReq
   \   0000001C   02BD               POP      {R1,PC}          ;; return
    276          }
    277          
    278          /**
    279          * @brief  USBH_ClrFeature
    280          *         This request is used to clear or disable a specific feature.
    281          
    282          * @param  pdev: Selected device
    283          * @param  ep_num: endpoint number 
    284          * @param  hc_num: Host channel number 
    285          * @retval Status
    286          */

   \                                 In section .text, align 2, keep-with-next
    287          USBH_Status USBH_ClrFeature(USB_OTG_CORE_HANDLE *pdev,
    288                                      USBH_HOST *phost,
    289                                      uint8_t ep_num, 
    290                                      uint8_t hc_num) 
    291          {
   \                     USBH_ClrFeature:
   \   00000000   10B5               PUSH     {R4,LR}
    292            
    293            phost->Control.setup.b.bmRequestType = USB_H2D | 
    294                                                   USB_REQ_RECIPIENT_ENDPOINT |
    295                                                   USB_REQ_TYPE_STANDARD;
   \   00000002   0224               MOVS     R4,#+2
   \   00000004   0C75               STRB     R4,[R1, #+20]
    296            
    297            phost->Control.setup.b.bRequest = USB_REQ_CLEAR_FEATURE;
   \   00000006   0124               MOVS     R4,#+1
   \   00000008   4C75               STRB     R4,[R1, #+21]
    298            phost->Control.setup.b.wValue.w = FEATURE_SELECTOR_ENDPOINT;
   \   0000000A   0024               MOVS     R4,#+0
   \   0000000C   CC82               STRH     R4,[R1, #+22]
    299            phost->Control.setup.b.wIndex.w = ep_num;
   \   0000000E   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000010   0A83               STRH     R2,[R1, #+24]
    300            phost->Control.setup.b.wLength.w = 0;           
   \   00000012   0024               MOVS     R4,#+0
   \   00000014   4C83               STRH     R4,[R1, #+26]
    301            
    302            if ((ep_num & USB_REQ_DIR_MASK ) == USB_D2H)
   \   00000016   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000018   1206               LSLS     R2,R2,#+24
   \   0000001A   06D5               BPL.N    ??USBH_ClrFeature_0
    303            { /* EP Type is IN */
    304              pdev->host.hc[hc_num].toggle_in = 0; 
   \   0000001C   DBB2               UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000001E   10EB4312           ADDS     R2,R0,R3, LSL #+5
   \   00000022   0023               MOVS     R3,#+0
   \   00000024   82F8C432           STRB     R3,[R2, #+708]
   \   00000028   05E0               B.N      ??USBH_ClrFeature_1
    305            }
    306            else
    307            {/* EP Type is OUT */
    308              pdev->host.hc[hc_num].toggle_out = 0; 
   \                     ??USBH_ClrFeature_0:
   \   0000002A   DBB2               UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000002C   10EB4312           ADDS     R2,R0,R3, LSL #+5
   \   00000030   0023               MOVS     R3,#+0
   \   00000032   82F8C532           STRB     R3,[R2, #+709]
    309            }
    310            
    311            return USBH_CtlReq(pdev, phost, 0 , 0 );   
   \                     ??USBH_ClrFeature_1:
   \   00000036   0023               MOVS     R3,#+0
   \   00000038   0022               MOVS     R2,#+0
   \   0000003A   ........           BL       USBH_CtlReq
   \   0000003E   10BD               POP      {R4,PC}          ;; return
    312          }
    313          
    314          /**
    315          * @brief  USBH_ParseDevDesc 
    316          *         This function Parses the device descriptor
    317          * @param  dev_desc: device_descriptor destinaton address 
    318          * @param  buf: Buffer where the source descriptor is available
    319          * @param  length: Length of the descriptor
    320          * @retval None
    321          */

   \                                 In section .text, align 2, keep-with-next
    322          static void  USBH_ParseDevDesc (USBH_DevDesc_TypeDef* dev_desc,
    323                                          uint8_t *buf, 
    324                                          uint16_t length)
    325          {
   \                     USBH_ParseDevDesc:
   \   00000000   10B4               PUSH     {R4}
    326            dev_desc->bLength            = *(uint8_t  *) (buf +  0);
   \   00000002   0B78               LDRB     R3,[R1, #+0]
   \   00000004   0370               STRB     R3,[R0, #+0]
    327            dev_desc->bDescriptorType    = *(uint8_t  *) (buf +  1);
   \   00000006   4B78               LDRB     R3,[R1, #+1]
   \   00000008   4370               STRB     R3,[R0, #+1]
    328            dev_desc->bcdUSB             = LE16 (buf +  2);
   \   0000000A   8B78               LDRB     R3,[R1, #+2]
   \   0000000C   CC78               LDRB     R4,[R1, #+3]
   \   0000000E   13EB0423           ADDS     R3,R3,R4, LSL #+8
   \   00000012   4380               STRH     R3,[R0, #+2]
    329            dev_desc->bDeviceClass       = *(uint8_t  *) (buf +  4);
   \   00000014   0B79               LDRB     R3,[R1, #+4]
   \   00000016   0371               STRB     R3,[R0, #+4]
    330            dev_desc->bDeviceSubClass    = *(uint8_t  *) (buf +  5);
   \   00000018   4B79               LDRB     R3,[R1, #+5]
   \   0000001A   4371               STRB     R3,[R0, #+5]
    331            dev_desc->bDeviceProtocol    = *(uint8_t  *) (buf +  6);
   \   0000001C   8B79               LDRB     R3,[R1, #+6]
   \   0000001E   8371               STRB     R3,[R0, #+6]
    332            dev_desc->bMaxPacketSize     = *(uint8_t  *) (buf +  7);
   \   00000020   CB79               LDRB     R3,[R1, #+7]
   \   00000022   C371               STRB     R3,[R0, #+7]
    333            
    334            if (length > 8)
   \   00000024   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000026   092A               CMP      R2,#+9
   \   00000028   16D3               BCC.N    ??USBH_ParseDevDesc_0
    335            { /* For 1st time after device connection, Host may issue only 8 bytes for 
    336              Device Descriptor Length  */
    337              dev_desc->idVendor           = LE16 (buf +  8);
   \   0000002A   0A7A               LDRB     R2,[R1, #+8]
   \   0000002C   4B7A               LDRB     R3,[R1, #+9]
   \   0000002E   12EB0322           ADDS     R2,R2,R3, LSL #+8
   \   00000032   0281               STRH     R2,[R0, #+8]
    338              dev_desc->idProduct          = LE16 (buf + 10);
   \   00000034   8A7A               LDRB     R2,[R1, #+10]
   \   00000036   CB7A               LDRB     R3,[R1, #+11]
   \   00000038   12EB0322           ADDS     R2,R2,R3, LSL #+8
   \   0000003C   4281               STRH     R2,[R0, #+10]
    339              dev_desc->bcdDevice          = LE16 (buf + 12);
   \   0000003E   0A7B               LDRB     R2,[R1, #+12]
   \   00000040   4B7B               LDRB     R3,[R1, #+13]
   \   00000042   12EB0322           ADDS     R2,R2,R3, LSL #+8
   \   00000046   8281               STRH     R2,[R0, #+12]
    340              dev_desc->iManufacturer      = *(uint8_t  *) (buf + 14);
   \   00000048   8A7B               LDRB     R2,[R1, #+14]
   \   0000004A   8273               STRB     R2,[R0, #+14]
    341              dev_desc->iProduct           = *(uint8_t  *) (buf + 15);
   \   0000004C   CA7B               LDRB     R2,[R1, #+15]
   \   0000004E   C273               STRB     R2,[R0, #+15]
    342              dev_desc->iSerialNumber      = *(uint8_t  *) (buf + 16);
   \   00000050   0A7C               LDRB     R2,[R1, #+16]
   \   00000052   0274               STRB     R2,[R0, #+16]
    343              dev_desc->bNumConfigurations = *(uint8_t  *) (buf + 17);
   \   00000054   497C               LDRB     R1,[R1, #+17]
   \   00000056   4174               STRB     R1,[R0, #+17]
    344            }
    345          }
   \                     ??USBH_ParseDevDesc_0:
   \   00000058   10BC               POP      {R4}
   \   0000005A   7047               BX       LR               ;; return
    346          
    347          /**
    348          * @brief  USBH_ParseCfgDesc 
    349          *         This function Parses the configuration descriptor
    350          * @param  cfg_desc: Configuration Descriptor address
    351          * @param  itf_desc: Interface Descriptor address
    352          * @param  ep_desc: Endpoint Descriptor address
    353          * @param  buf: Buffer where the source descriptor is available
    354          * @param  length: Length of the descriptor
    355          * @retval None
    356          */

   \                                 In section .text, align 2, keep-with-next
    357          static void  USBH_ParseCfgDesc (USBH_CfgDesc_TypeDef* cfg_desc,
    358                                          USBH_InterfaceDesc_TypeDef* itf_desc,
    359                                          USBH_EpDesc_TypeDef*  ep_desc, 
    360                                          uint8_t *buf, 
    361                                          uint16_t length)
    362          {  
   \                     USBH_ParseCfgDesc:
   \   00000000   2DE9F047           PUSH     {R4-R10,LR}
   \   00000004   82B0               SUB      SP,SP,#+8
   \   00000006   0400               MOVS     R4,R0
   \   00000008   0D00               MOVS     R5,R1
   \   0000000A   1600               MOVS     R6,R2
   \   0000000C   1F00               MOVS     R7,R3
   \   0000000E   0A98               LDR      R0,[SP, #+40]
    363            USBH_InterfaceDesc_TypeDef    *pif ;
    364            USBH_EpDesc_TypeDef           *pep;  
    365            USBH_DescHeader_t             *pdesc = (USBH_DescHeader_t *)buf;
    366            uint16_t                      ptr;
    367            int8_t                        if_ix;
    368            int8_t                        ep_ix;  
    369            
    370            pdesc   = (USBH_DescHeader_t *)buf;
    371            
    372            /* Parse configuration descriptor */
    373            cfg_desc->bLength             = *(uint8_t  *) (buf + 0);
   \   00000010   3978               LDRB     R1,[R7, #+0]
   \   00000012   2170               STRB     R1,[R4, #+0]
    374            cfg_desc->bDescriptorType     = *(uint8_t  *) (buf + 1);
   \   00000014   7978               LDRB     R1,[R7, #+1]
   \   00000016   6170               STRB     R1,[R4, #+1]
    375            cfg_desc->wTotalLength        = LE16 (buf + 2);
   \   00000018   B978               LDRB     R1,[R7, #+2]
   \   0000001A   FA78               LDRB     R2,[R7, #+3]
   \   0000001C   11EB0221           ADDS     R1,R1,R2, LSL #+8
   \   00000020   6180               STRH     R1,[R4, #+2]
    376            cfg_desc->bNumInterfaces      = *(uint8_t  *) (buf + 4);
   \   00000022   3979               LDRB     R1,[R7, #+4]
   \   00000024   2171               STRB     R1,[R4, #+4]
    377            cfg_desc->bConfigurationValue = *(uint8_t  *) (buf + 5);
   \   00000026   7979               LDRB     R1,[R7, #+5]
   \   00000028   6171               STRB     R1,[R4, #+5]
    378            cfg_desc->iConfiguration      = *(uint8_t  *) (buf + 6);
   \   0000002A   B979               LDRB     R1,[R7, #+6]
   \   0000002C   A171               STRB     R1,[R4, #+6]
    379            cfg_desc->bmAttributes        = *(uint8_t  *) (buf + 7);
   \   0000002E   F979               LDRB     R1,[R7, #+7]
   \   00000030   E171               STRB     R1,[R4, #+7]
    380            cfg_desc->bMaxPower           = *(uint8_t  *) (buf + 8);    
   \   00000032   397A               LDRB     R1,[R7, #+8]
   \   00000034   2172               STRB     R1,[R4, #+8]
    381            
    382            
    383            if (length > USB_CONFIGURATION_DESC_SIZE)
   \   00000036   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000038   0A28               CMP      R0,#+10
   \   0000003A   0CD3               BCC.N    ??USBH_ParseCfgDesc_0
    384            {
    385              ptr = USB_LEN_CFG_DESC;
   \   0000003C   0920               MOVS     R0,#+9
   \   0000003E   ADF80000           STRH     R0,[SP, #+0]
    386              
    387              if ( cfg_desc->bNumInterfaces <= USBH_MAX_NUM_INTERFACES) 
   \   00000042   2079               LDRB     R0,[R4, #+4]
   \   00000044   0328               CMP      R0,#+3
   \   00000046   06D2               BCS.N    ??USBH_ParseCfgDesc_0
    388              {
    389                if_ix = 0;
   \   00000048   5FF00008           MOVS     R8,#+0
    390                pif = (USBH_InterfaceDesc_TypeDef *)0;
   \   0000004C   5FF00009           MOVS     R9,#+0
    391                
    392                /* Parse Interface descriptor relative to the current configuration */
    393                if(cfg_desc->bNumInterfaces <= USBH_MAX_NUM_INTERFACES)
   \   00000050   2079               LDRB     R0,[R4, #+4]
   \   00000052   0328               CMP      R0,#+3
   \   00000054   03D3               BCC.N    ??USBH_ParseCfgDesc_1
    394                {
    395                  while (if_ix < cfg_desc->bNumInterfaces) 
    396                  {
    397                    pdesc = USBH_GetNextDesc((uint8_t *)pdesc, &ptr);
    398                    if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE) 
    399                    {  
    400                      pif               = &itf_desc[if_ix];
    401                      USBH_ParseInterfaceDesc (pif, (uint8_t *)pdesc);
    402                      ep_ix = 0;
    403                      
    404                      /* Parse Ep descriptors relative to the current interface */
    405                      if(pif->bNumEndpoints <= USBH_MAX_NUM_ENDPOINTS)
    406                      {          
    407                        while (ep_ix < pif->bNumEndpoints) 
    408                        {
    409                          pdesc = USBH_GetNextDesc((void* )pdesc, &ptr);
    410                          if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT) 
    411                          {  
    412                            pep               = &ep_desc[ep_ix];
    413                            USBH_ParseEPDesc (pep, (uint8_t *)pdesc);
    414                            ep_ix++;
    415                          }
    416                          else
    417                          {
    418                            ptr += pdesc->bLength;
    419                          }
    420                        }
    421                      }
    422                      if_ix++;
    423                    }
    424                    else
    425                    {
    426                      ptr += pdesc->bLength;
    427                    }
    428                  }
    429                }
    430              }
    431            }  
    432          }
   \                     ??USBH_ParseCfgDesc_0:
   \   00000056   BDE8F387           POP      {R0,R1,R4-R10,PC}  ;; return
   \                     ??USBH_ParseCfgDesc_2:
   \   0000005A   18F10108           ADDS     R8,R8,#+1
   \                     ??USBH_ParseCfgDesc_1:
   \   0000005E   4046               MOV      R0,R8
   \   00000060   40B2               SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000062   2179               LDRB     R1,[R4, #+4]
   \   00000064   00B2               SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000066   09B2               SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   00000068   8842               CMP      R0,R1
   \   0000006A   F4DA               BGE.N    ??USBH_ParseCfgDesc_0
   \   0000006C   00A9               ADD      R1,SP,#+0
   \   0000006E   3800               MOVS     R0,R7
   \   00000070   ........           BL       USBH_GetNextDesc
   \   00000074   0700               MOVS     R7,R0
   \   00000076   7878               LDRB     R0,[R7, #+1]
   \   00000078   0428               CMP      R0,#+4
   \   0000007A   2FD1               BNE.N    ??USBH_ParseCfgDesc_3
   \   0000007C   4FFA88F8           SXTB     R8,R8            ;; SignExt  R8,R8,#+24,#+24
   \   00000080   0920               MOVS     R0,#+9
   \   00000082   00FB0859           MLA      R9,R0,R8,R5
   \   00000086   3900               MOVS     R1,R7
   \   00000088   4846               MOV      R0,R9
   \   0000008A   ........           BL       USBH_ParseInterfaceDesc
   \   0000008E   5FF0000A           MOVS     R10,#+0
   \   00000092   99F80400           LDRB     R0,[R9, #+4]
   \   00000096   0328               CMP      R0,#+3
   \   00000098   DFD2               BCS.N    ??USBH_ParseCfgDesc_2
   \   0000009A   08E0               B.N      ??USBH_ParseCfgDesc_4
   \                     ??USBH_ParseCfgDesc_5:
   \   0000009C   4FFA8AFA           SXTB     R10,R10          ;; SignExt  R10,R10,#+24,#+24
   \   000000A0   16EBCA00           ADDS     R0,R6,R10, LSL #+3
   \   000000A4   3900               MOVS     R1,R7
   \   000000A6   ........           BL       USBH_ParseEPDesc
   \   000000AA   1AF1010A           ADDS     R10,R10,#+1
   \                     ??USBH_ParseCfgDesc_4:
   \   000000AE   5046               MOV      R0,R10
   \   000000B0   40B2               SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   000000B2   99F80410           LDRB     R1,[R9, #+4]
   \   000000B6   00B2               SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000000B8   09B2               SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   000000BA   8842               CMP      R0,R1
   \   000000BC   CDDA               BGE.N    ??USBH_ParseCfgDesc_2
   \   000000BE   00A9               ADD      R1,SP,#+0
   \   000000C0   3800               MOVS     R0,R7
   \   000000C2   ........           BL       USBH_GetNextDesc
   \   000000C6   0700               MOVS     R7,R0
   \   000000C8   7878               LDRB     R0,[R7, #+1]
   \   000000CA   0528               CMP      R0,#+5
   \   000000CC   E6D0               BEQ.N    ??USBH_ParseCfgDesc_5
   \   000000CE   BDF80000           LDRH     R0,[SP, #+0]
   \   000000D2   3978               LDRB     R1,[R7, #+0]
   \   000000D4   0818               ADDS     R0,R1,R0
   \   000000D6   ADF80000           STRH     R0,[SP, #+0]
   \   000000DA   E8E7               B.N      ??USBH_ParseCfgDesc_4
   \                     ??USBH_ParseCfgDesc_3:
   \   000000DC   BDF80000           LDRH     R0,[SP, #+0]
   \   000000E0   3978               LDRB     R1,[R7, #+0]
   \   000000E2   0818               ADDS     R0,R1,R0
   \   000000E4   ADF80000           STRH     R0,[SP, #+0]
   \   000000E8   B9E7               B.N      ??USBH_ParseCfgDesc_1
    433          
    434          
    435          /**
    436          * @brief  USBH_ParseInterfaceDesc 
    437          *         This function Parses the interface descriptor
    438          * @param  if_descriptor : Interface descriptor destination
    439          * @param  buf: Buffer where the descriptor data is available
    440          * @retval None
    441          */

   \                                 In section .text, align 2, keep-with-next
    442          static void  USBH_ParseInterfaceDesc (USBH_InterfaceDesc_TypeDef *if_descriptor, 
    443                                                uint8_t *buf)
    444          {
    445            if_descriptor->bLength            = *(uint8_t  *) (buf + 0);
   \                     USBH_ParseInterfaceDesc:
   \   00000000   0A78               LDRB     R2,[R1, #+0]
   \   00000002   0270               STRB     R2,[R0, #+0]
    446            if_descriptor->bDescriptorType    = *(uint8_t  *) (buf + 1);
   \   00000004   4A78               LDRB     R2,[R1, #+1]
   \   00000006   4270               STRB     R2,[R0, #+1]
    447            if_descriptor->bInterfaceNumber   = *(uint8_t  *) (buf + 2);
   \   00000008   8A78               LDRB     R2,[R1, #+2]
   \   0000000A   8270               STRB     R2,[R0, #+2]
    448            if_descriptor->bAlternateSetting  = *(uint8_t  *) (buf + 3);
   \   0000000C   CA78               LDRB     R2,[R1, #+3]
   \   0000000E   C270               STRB     R2,[R0, #+3]
    449            if_descriptor->bNumEndpoints      = *(uint8_t  *) (buf + 4);
   \   00000010   0A79               LDRB     R2,[R1, #+4]
   \   00000012   0271               STRB     R2,[R0, #+4]
    450            if_descriptor->bInterfaceClass    = *(uint8_t  *) (buf + 5);
   \   00000014   4A79               LDRB     R2,[R1, #+5]
   \   00000016   4271               STRB     R2,[R0, #+5]
    451            if_descriptor->bInterfaceSubClass = *(uint8_t  *) (buf + 6);
   \   00000018   8A79               LDRB     R2,[R1, #+6]
   \   0000001A   8271               STRB     R2,[R0, #+6]
    452            if_descriptor->bInterfaceProtocol = *(uint8_t  *) (buf + 7);
   \   0000001C   CA79               LDRB     R2,[R1, #+7]
   \   0000001E   C271               STRB     R2,[R0, #+7]
    453            if_descriptor->iInterface         = *(uint8_t  *) (buf + 8);
   \   00000020   097A               LDRB     R1,[R1, #+8]
   \   00000022   0172               STRB     R1,[R0, #+8]
    454          }
   \   00000024   7047               BX       LR               ;; return
    455          
    456          /**
    457          * @brief  USBH_ParseEPDesc 
    458          *         This function Parses the endpoint descriptor
    459          * @param  ep_descriptor: Endpoint descriptor destination address
    460          * @param  buf: Buffer where the parsed descriptor stored
    461          * @retval None
    462          */

   \                                 In section .text, align 2, keep-with-next
    463          static void  USBH_ParseEPDesc (USBH_EpDesc_TypeDef  *ep_descriptor, 
    464                                         uint8_t *buf)
    465          {
    466            
    467            ep_descriptor->bLength          = *(uint8_t  *) (buf + 0);
   \                     USBH_ParseEPDesc:
   \   00000000   0A78               LDRB     R2,[R1, #+0]
   \   00000002   0270               STRB     R2,[R0, #+0]
    468            ep_descriptor->bDescriptorType  = *(uint8_t  *) (buf + 1);
   \   00000004   4A78               LDRB     R2,[R1, #+1]
   \   00000006   4270               STRB     R2,[R0, #+1]
    469            ep_descriptor->bEndpointAddress = *(uint8_t  *) (buf + 2);
   \   00000008   8A78               LDRB     R2,[R1, #+2]
   \   0000000A   8270               STRB     R2,[R0, #+2]
    470            ep_descriptor->bmAttributes     = *(uint8_t  *) (buf + 3);
   \   0000000C   CA78               LDRB     R2,[R1, #+3]
   \   0000000E   C270               STRB     R2,[R0, #+3]
    471            ep_descriptor->wMaxPacketSize   = LE16 (buf + 4);
   \   00000010   0A79               LDRB     R2,[R1, #+4]
   \   00000012   4B79               LDRB     R3,[R1, #+5]
   \   00000014   12EB0322           ADDS     R2,R2,R3, LSL #+8
   \   00000018   8280               STRH     R2,[R0, #+4]
    472            ep_descriptor->bInterval        = *(uint8_t  *) (buf + 6);
   \   0000001A   8979               LDRB     R1,[R1, #+6]
   \   0000001C   8171               STRB     R1,[R0, #+6]
    473          }
   \   0000001E   7047               BX       LR               ;; return
    474          
    475          /**
    476          * @brief  USBH_ParseStringDesc 
    477          *         This function Parses the string descriptor
    478          * @param  psrc: Source pointer containing the descriptor data
    479          * @param  pdest: Destination address pointer
    480          * @param  length: Length of the descriptor
    481          * @retval None
    482          */

   \                                 In section .text, align 2, keep-with-next
    483          static void USBH_ParseStringDesc (uint8_t* psrc, 
    484                                            uint8_t* pdest, 
    485                                            uint16_t length)
    486          {
   \                     USBH_ParseStringDesc:
   \   00000000   10B4               PUSH     {R4}
    487            uint16_t strlength;
    488            uint16_t idx;
    489            
    490            /* The UNICODE string descriptor is not NULL-terminated. The string length is
    491            computed by substracting two from the value of the first byte of the descriptor.
    492            */
    493            
    494            /* Check which is lower size, the Size of string or the length of bytes read 
    495            from the device */
    496            
    497            if ( psrc[1] == USB_DESC_TYPE_STRING)
   \   00000002   4378               LDRB     R3,[R0, #+1]
   \   00000004   032B               CMP      R3,#+3
   \   00000006   15D1               BNE.N    ??USBH_ParseStringDesc_0
    498            { /* Make sure the Descriptor is String Type */
    499              
    500              /* psrc[0] contains Size of Descriptor, subtract 2 to get the length of string */      
    501              strlength = ( ( (psrc[0]-2) <= length) ? (psrc[0]-2) :length); 
   \   00000008   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000A   0378               LDRB     R3,[R0, #+0]
   \   0000000C   9B1E               SUBS     R3,R3,#+2
   \   0000000E   9A42               CMP      R2,R3
   \   00000010   02DB               BLT.N    ??USBH_ParseStringDesc_1
   \   00000012   0278               LDRB     R2,[R0, #+0]
   \   00000014   921E               SUBS     R2,R2,#+2
   \   00000016   FFE7               B.N      ??USBH_ParseStringDesc_2
    502              psrc += 2; /* Adjust the offset ignoring the String Len and Descriptor type */
   \                     ??USBH_ParseStringDesc_1:
   \                     ??USBH_ParseStringDesc_2:
   \   00000018   801C               ADDS     R0,R0,#+2
    503              
    504              for (idx = 0; idx < strlength; idx+=2 )
   \   0000001A   0023               MOVS     R3,#+0
   \   0000001C   04E0               B.N      ??USBH_ParseStringDesc_3
    505              {/* Copy Only the string and ignore the UNICODE ID, hence add the src */
    506                *pdest =  psrc[idx];
   \                     ??USBH_ParseStringDesc_4:
   \   0000001E   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000020   1C5C               LDRB     R4,[R3, R0]
   \   00000022   0C70               STRB     R4,[R1, #+0]
    507                pdest++;
   \   00000024   491C               ADDS     R1,R1,#+1
    508              }  
   \   00000026   9B1C               ADDS     R3,R3,#+2
   \                     ??USBH_ParseStringDesc_3:
   \   00000028   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000002A   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000002C   9342               CMP      R3,R2
   \   0000002E   F6D3               BCC.N    ??USBH_ParseStringDesc_4
    509              *pdest = 0; /* mark end of string */  
   \   00000030   0020               MOVS     R0,#+0
   \   00000032   0870               STRB     R0,[R1, #+0]
    510            }
    511          }
   \                     ??USBH_ParseStringDesc_0:
   \   00000034   10BC               POP      {R4}
   \   00000036   7047               BX       LR               ;; return
    512          
    513          /**
    514          * @brief  USBH_GetNextDesc 
    515          *         This function return the next descriptor header
    516          * @param  buf: Buffer where the cfg descriptor is available
    517          * @param  ptr: data popinter inside the cfg descriptor
    518          * @retval next header
    519          */

   \                                 In section .text, align 2, keep-with-next
    520          static  USBH_DescHeader_t  *USBH_GetNextDesc (uint8_t   *pbuf, uint16_t  *ptr)
    521          {
    522            USBH_DescHeader_t  *pnext;
    523           
    524            *ptr += ((USBH_DescHeader_t *)pbuf)->bLength;  
   \                     USBH_GetNextDesc:
   \   00000000   0A88               LDRH     R2,[R1, #+0]
   \   00000002   0378               LDRB     R3,[R0, #+0]
   \   00000004   9A18               ADDS     R2,R3,R2
   \   00000006   0A80               STRH     R2,[R1, #+0]
    525            pnext = (USBH_DescHeader_t *)((uint8_t *)pbuf + \
    526                   ((USBH_DescHeader_t *)pbuf)->bLength);
   \   00000008   0178               LDRB     R1,[R0, #+0]
   \   0000000A   0818               ADDS     R0,R1,R0
    527           
    528            return(pnext);
   \   0000000C   7047               BX       LR               ;; return
    529          }
    530          
    531          /**
    532          * @}
    533          */ 
    534          
    535          /**
    536          * @}
    537          */ 
    538          
    539          /**
    540          * @}
    541          */
    542          
    543          /**
    544          * @}
    545          */ 
    546          
    547          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
    548          
    549          
    550          
    551          

   Maximum stack usage in bytes:

     Function                .cstack
     --------                -------
     USBH_ClrFeature              8
     USBH_GetDescriptor          16
     USBH_GetNextDesc             0
     USBH_Get_CfgDesc            32
     USBH_Get_DevDesc            32
     USBH_Get_StringDesc         32
     USBH_ParseCfgDesc           40
     USBH_ParseDevDesc            4
     USBH_ParseEPDesc             0
     USBH_ParseInterfaceDesc      0
     USBH_ParseStringDesc         4
     USBH_SetAddress              8
     USBH_SetCfg                  8


   Section sizes:

     Function/Label          Bytes
     --------------          -----
     USBH_Get_DevDesc          70
     USBH_Get_CfgDesc          74
     USBH_Get_StringDesc       70
     USBH_GetDescriptor        58
     USBH_SetAddress           32
     USBH_SetCfg               30
     USBH_ClrFeature           64
     USBH_ParseDevDesc         92
     USBH_ParseCfgDesc        234
     USBH_ParseInterfaceDesc   38
     USBH_ParseEPDesc          32
     USBH_ParseStringDesc      56
     USBH_GetNextDesc          14

 
 864 bytes in section .text
 
 864 bytes of CODE memory

Errors: none
Warnings: none
