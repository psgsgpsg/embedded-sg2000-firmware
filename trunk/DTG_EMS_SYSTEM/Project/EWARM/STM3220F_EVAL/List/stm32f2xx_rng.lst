###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     08/Jan/2012  13:10:08 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Libraries\STM32F2xx_ #
#                    StdPeriph_Driver\src\stm32f2xx_rng.c                     #
#    Command line =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Libraries\STM32F2xx_ #
#                    StdPeriph_Driver\src\stm32f2xx_rng.c -D                  #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D RTC_CLOCK_SOURCE_LSE -lC            #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\List\ -lA E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Pr #
#                    oject\EWARM\STM3220F_EVAL\List\ -o                       #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\Obj\ --no_cse --no_unroll --no_inline            #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWAR #
#                    M\..\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWA #
#                    RM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I             #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I       #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I             #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Utilities\STM32_EVAL\ -I E:\Work\Firmware\DTG\DTG_EMS_SY #
#                    STEM\Project\EWARM\..\..\Utilities\STM32_EVAL\Common\    #
#                    -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\ #
#                    ..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I                #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_OTG_Driver\inc\ -I                   #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_Device_Library\Core\inc\ -I          #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_Device_Library\Class\msc\inc\ -I     #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\Usb #
#                    \ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\. #
#                    .\Usb\Inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Projec #
#                    t\EWARM\..\Usb\src\ -I E:\Work\Firmware\DTG\DTG_EMS_SYST #
#                    EM\Project\EWARM\..\..\Libraries\STM32_USB_HOST_Library\ #
#                    Core\inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project #
#                    \EWARM\..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\ #
#                    inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWAR #
#                    M\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc #
#                    \ -Ol --use_c++_inline                                   #
#    List file    =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\List\stm32f2xx_rng.lst                           #
#    Object file  =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\Obj\stm32f2xx_rng.o                              #
#                                                                             #
#                                                                             #
###############################################################################

E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_rng.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_rng.c
      4            * @author  MCD Application Team
      5            * @version V0.0.4
      6            * @date    13-January-2011
      7            * @brief   This file provides all the Random Number Generator(RNG) firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f2xx_rng.h"
     24          #include "stm32f2xx_rcc.h"
     25          
     26          /** @addtogroup STM32F2xx_StdPeriph_Driver
     27            * @{
     28            */
     29          
     30          
     31          
     32          /** @defgroup RNG 
     33            * @brief RNG driver modules
     34            * @{
     35            */ 
     36          
     37          /** @defgroup RNG_Private_TypesDefinitions
     38            * @{
     39            */ 
     40          /**
     41            * @}
     42            */ 
     43          
     44          
     45          /** @defgroup RNG_Private_Defines
     46            * @{
     47            */ 
     48          /**
     49            * @}
     50            */ 
     51          
     52          
     53          /** @defgroup RNG_Private_Macros
     54            * @{
     55            */ 
     56          /**
     57            * @}
     58            */ 
     59          
     60          
     61          /** @defgroup RNG_Private_Variables
     62            * @{
     63            */ 
     64          /**
     65            * @}
     66            */ 
     67          
     68          
     69          /** @defgroup RNG_Private_FunctionPrototypes
     70            * @{
     71            */ 
     72          /**
     73            * @}
     74            */ 
     75          
     76          
     77          /** @defgroup RNG_Private_Functions
     78            * @{
     79            */ 
     80          
     81          
     82          /**
     83            * @brief  Deinitializes the RNG peripheral registers to their default reset values.
     84            * @param  None
     85            * @retval None
     86            */

   \                                 In section .text, align 2, keep-with-next
     87          void RNG_DeInit()
     88          {
   \                     RNG_DeInit:
   \   00000000   80B5               PUSH     {R7,LR}
     89            /* Enable RNG reset state */
     90            RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_RNG, ENABLE);
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   4020               MOVS     R0,#+64
   \   00000006   ........           BL       RCC_AHB2PeriphResetCmd
     91          
     92            /* Release RNG from reset state */
     93            RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_RNG, DISABLE);
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   4020               MOVS     R0,#+64
   \   0000000E   ........           BL       RCC_AHB2PeriphResetCmd
     94          }
   \   00000012   01BD               POP      {R0,PC}          ;; return
     95          
     96          /**
     97            * @brief  Enables or disables the RNG peripheral.
     98            * @param  NewState: new state of the RNG peripheral.
     99            *   This parameter can be: ENABLE or DISABLE.
    100            * @retval None
    101            */

   \                                 In section .text, align 2, keep-with-next
    102          void RNG_Cmd(FunctionalState NewState)
    103          {
    104            /* Check the parameters */
    105            assert_param(IS_FUNCTIONAL_STATE(NewState));
    106          
    107            if (NewState != DISABLE)
   \                     RNG_Cmd:
   \   00000000   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0028               CMP      R0,#+0
   \   00000004   06D0               BEQ.N    ??RNG_Cmd_0
    108            {
    109              /* Enable the RNG */
    110              RNG->CR |= RNG_CR_RNGEN;
   \   00000006   ....               LDR.N    R0,??DataTable5  ;; 0x50060800
   \   00000008   0068               LDR      R0,[R0, #+0]
   \   0000000A   50F00400           ORRS     R0,R0,#0x4
   \   0000000E   ....               LDR.N    R1,??DataTable5  ;; 0x50060800
   \   00000010   0860               STR      R0,[R1, #+0]
   \   00000012   05E0               B.N      ??RNG_Cmd_1
    111            }
    112            else
    113            {
    114              /* Disable the RNG */
    115              RNG->CR &= ~RNG_CR_RNGEN;
   \                     ??RNG_Cmd_0:
   \   00000014   ....               LDR.N    R0,??DataTable5  ;; 0x50060800
   \   00000016   0068               LDR      R0,[R0, #+0]
   \   00000018   30F00400           BICS     R0,R0,#0x4
   \   0000001C   ....               LDR.N    R1,??DataTable5  ;; 0x50060800
   \   0000001E   0860               STR      R0,[R1, #+0]
    116            }
    117          }
   \                     ??RNG_Cmd_1:
   \   00000020   7047               BX       LR               ;; return
    118          
    119          /**
    120            * @brief  Enables or disables the RNG interrupt.
    121            * @note   The RNG has two interrupt sources; Seed error interrupt (SEI) and 
    122            *         Clock error interrupt (CEI), both interrupts are enabled by setting 
    123            *         the IM bit in CR register. However, each interrupt have its specific 
    124            *         status bit (see RNG_GetITStatus() function) and clear bit (see 
    125            *         RNG_ClearITPendingBit() function).
    126            * @param  NewState: new state of the RNG interrupt.
    127            *   This parameter can be: ENABLE or DISABLE.
    128            * @retval None
    129            */

   \                                 In section .text, align 2, keep-with-next
    130          void RNG_ITConfig(FunctionalState NewState)
    131          {
    132            /* Check the parameters */
    133            assert_param(IS_FUNCTIONAL_STATE(NewState));
    134          
    135            if (NewState != DISABLE)
   \                     RNG_ITConfig:
   \   00000000   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0028               CMP      R0,#+0
   \   00000004   06D0               BEQ.N    ??RNG_ITConfig_0
    136            {
    137              /* Enable the RNG interrupt */
    138              RNG->CR |= RNG_CR_IM;
   \   00000006   ....               LDR.N    R0,??DataTable5  ;; 0x50060800
   \   00000008   0068               LDR      R0,[R0, #+0]
   \   0000000A   50F00800           ORRS     R0,R0,#0x8
   \   0000000E   ....               LDR.N    R1,??DataTable5  ;; 0x50060800
   \   00000010   0860               STR      R0,[R1, #+0]
   \   00000012   05E0               B.N      ??RNG_ITConfig_1
    139            }
    140            else
    141            {
    142              /* Disable the RNG interrupt */
    143              RNG->CR &= ~RNG_CR_IM;
   \                     ??RNG_ITConfig_0:
   \   00000014   ....               LDR.N    R0,??DataTable5  ;; 0x50060800
   \   00000016   0068               LDR      R0,[R0, #+0]
   \   00000018   30F00800           BICS     R0,R0,#0x8
   \   0000001C   ....               LDR.N    R1,??DataTable5  ;; 0x50060800
   \   0000001E   0860               STR      R0,[R1, #+0]
    144            }
    145          }
   \                     ??RNG_ITConfig_1:
   \   00000020   7047               BX       LR               ;; return
    146          
    147          /**
    148            * @brief  Returns a 32-bit random number.
    149            * @note   Before to call this function you have to wait till DRDY flag is set,
    150            *         using RNG_GetFlagStatus(RNG_FLAG_DRDY) function. 
    151            * @param  None
    152            * @retval 32-bit random number.
    153            */

   \                                 In section .text, align 2, keep-with-next
    154          uint32_t RNG_GetRandomNumber(void)
    155          {
    156            /* Return the random number from the DR register */
    157            return RNG->DR;
   \                     RNG_GetRandomNumber:
   \   00000000   ....               LDR.N    R0,??DataTable5_1  ;; 0x50060808
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   7047               BX       LR               ;; return
    158          }
    159          
    160          
    161          /**
    162            * @brief  Checks whether the specified RNG flag is set or not.
    163            * @param  RNG_FLAG: specifies the RNG flag to check.
    164            *   This parameter can be one of the following values:
    165            *     @arg RNG_FLAG_DRDY: Data Ready flag.
    166            *     @arg RNG_FLAG_CECS: Clock Error Current flag.
    167            *     @arg RNG_FLAG_SECS: Seed Error Current flag.
    168            * @retval The new state of RNG_FLAG (SET or RESET).
    169            */

   \                                 In section .text, align 2, keep-with-next
    170          FlagStatus RNG_GetFlagStatus(uint8_t RNG_FLAG)
    171          {
    172            FlagStatus bitstatus = RESET;
   \                     RNG_GetFlagStatus:
   \   00000000   0021               MOVS     R1,#+0
    173            /* Check the parameters */
    174            assert_param(IS_RNG_GET_FLAG(RNG_FLAG));
    175          
    176            /* Check the status of the specified RNG flag */
    177            if ((RNG->SR & RNG_FLAG) != (uint8_t)RESET)
   \   00000002   ....               LDR.N    R2,??DataTable5_2  ;; 0x50060804
   \   00000004   1268               LDR      R2,[R2, #+0]
   \   00000006   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0242               TST      R2,R0
   \   0000000A   01D0               BEQ.N    ??RNG_GetFlagStatus_0
    178            {
    179              /* RNG_FLAG is set */
    180              bitstatus = SET;
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   00E0               B.N      ??RNG_GetFlagStatus_1
    181            }
    182            else
    183            {
    184              /* RNG_FLAG is reset */
    185              bitstatus = RESET;
   \                     ??RNG_GetFlagStatus_0:
   \   00000010   0021               MOVS     R1,#+0
    186            }
    187            /* Return the RNG_FLAG status */
    188            return  bitstatus;
   \                     ??RNG_GetFlagStatus_1:
   \   00000012   0800               MOVS     R0,R1
   \   00000014   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   7047               BX       LR               ;; return
    189          }
    190          
    191          /**
    192            * @brief  Checks whether the specified RNG interrupt has occurred or not.
    193            * @param  RNG_IT: specifies the RNG interrupt source to check.
    194            *   This parameter can be one of the following values:
    195            *     @arg RNG_IT_CEI: Clock Error Interrupt.
    196            *     @arg RNG_IT_SEI: Seed Error Interrupt.
    197            * @retval The new state of RNG_IT (SET or RESET).
    198            */

   \                                 In section .text, align 2, keep-with-next
    199          ITStatus RNG_GetITStatus(uint8_t RNG_IT)
    200          {
    201            ITStatus bitstatus = RESET;
   \                     RNG_GetITStatus:
   \   00000000   0021               MOVS     R1,#+0
    202            /* Check the parameters */
    203            assert_param(IS_RNG_GET_IT(RNG_IT));
    204          
    205            /* Check the status of the specified RNG interrupt */
    206            if ((RNG->SR & RNG_IT) != (uint8_t)RESET)
   \   00000002   ....               LDR.N    R2,??DataTable5_2  ;; 0x50060804
   \   00000004   1268               LDR      R2,[R2, #+0]
   \   00000006   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0242               TST      R2,R0
   \   0000000A   01D0               BEQ.N    ??RNG_GetITStatus_0
    207            {
    208              /* RNG_IT is set */
    209              bitstatus = SET;
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   00E0               B.N      ??RNG_GetITStatus_1
    210            }
    211            else
    212            {
    213              /* RNG_IT is reset */
    214              bitstatus = RESET;
   \                     ??RNG_GetITStatus_0:
   \   00000010   0021               MOVS     R1,#+0
    215            }
    216            /* Return the RNG_IT status */
    217            return bitstatus;
   \                     ??RNG_GetITStatus_1:
   \   00000012   0800               MOVS     R0,R1
   \   00000014   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   7047               BX       LR               ;; return
    218          }
    219          
    220          
    221          /**
    222            * @brief  Clears the RNG interrupt pending bit(s).
    223            * @param  RNG_IT: specifies the RNG interrupt pending bit(s) to clear.
    224            *   This parameter can be any combination of the following values:
    225            *     @arg RNG_IT_CEI: Clock Error Interrupt.
    226            *     @arg RNG_IT_SEI: Seed Error Interrupt.
    227            * @retval None
    228            */

   \                                 In section .text, align 2, keep-with-next
    229          void RNG_ClearITPendingBit(uint8_t RNG_IT)
    230          {
    231            /* Check the parameters */
    232            assert_param(IS_RNG_IT(RNG_IT));
    233          
    234            /* Clear the selected RNG interrupt pending bit */
    235            RNG->SR = (uint8_t)~RNG_IT;
   \                     RNG_ClearITPendingBit:
   \   00000000   C043               MVNS     R0,R0
   \   00000002   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   ....               LDR.N    R1,??DataTable5_2  ;; 0x50060804
   \   00000006   0860               STR      R0,[R1, #+0]
    236          }
   \   00000008   7047               BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   00080650           DC32     0x50060800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   08080650           DC32     0x50060808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   04080650           DC32     0x50060804
    237          /**
    238            * @}
    239            */ 
    240          
    241          
    242          /**
    243            * @}
    244            */ 
    245          
    246          
    247          /**
    248            * @}
    249            */ 
    250          
    251          
    252          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function              .cstack
     --------              -------
     RNG_ClearITPendingBit      0
     RNG_Cmd                    0
     RNG_DeInit                 8
     RNG_GetFlagStatus          0
     RNG_GetITStatus            0
     RNG_GetRandomNumber        0
     RNG_ITConfig               0


   Section sizes:

     Function/Label        Bytes
     --------------        -----
     RNG_DeInit              20
     RNG_Cmd                 34
     RNG_ITConfig            34
     RNG_GetRandomNumber      6
     RNG_GetFlagStatus       24
     RNG_GetITStatus         24
     RNG_ClearITPendingBit   10
     ??DataTable5             4
     ??DataTable5_1           4
     ??DataTable5_2           4

 
 164 bytes in section .text
 
 164 bytes of CODE memory

Errors: none
Warnings: none
