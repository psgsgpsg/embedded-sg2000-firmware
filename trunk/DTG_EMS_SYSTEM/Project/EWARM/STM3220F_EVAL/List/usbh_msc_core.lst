###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     08/Jan/2012  13:10:13 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Libraries\STM32_USB_ #
#                    HOST_Library\Class\MSC\src\usbh_msc_core.c               #
#    Command line =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Libraries\STM32_USB_ #
#                    HOST_Library\Class\MSC\src\usbh_msc_core.c -D            #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D RTC_CLOCK_SOURCE_LSE -lC            #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\List\ -lA E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Pr #
#                    oject\EWARM\STM3220F_EVAL\List\ -o                       #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\Obj\ --no_cse --no_unroll --no_inline            #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWAR #
#                    M\..\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWA #
#                    RM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I             #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I       #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I             #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Utilities\STM32_EVAL\ -I E:\Work\Firmware\DTG\DTG_EMS_SY #
#                    STEM\Project\EWARM\..\..\Utilities\STM32_EVAL\Common\    #
#                    -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\ #
#                    ..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I                #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_OTG_Driver\inc\ -I                   #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_Device_Library\Core\inc\ -I          #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_Device_Library\Class\msc\inc\ -I     #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\Usb #
#                    \ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\. #
#                    .\Usb\Inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Projec #
#                    t\EWARM\..\Usb\src\ -I E:\Work\Firmware\DTG\DTG_EMS_SYST #
#                    EM\Project\EWARM\..\..\Libraries\STM32_USB_HOST_Library\ #
#                    Core\inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project #
#                    \EWARM\..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\ #
#                    inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWAR #
#                    M\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc #
#                    \ -Ol --use_c++_inline                                   #
#    List file    =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\List\usbh_msc_core.lst                           #
#    Object file  =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\Obj\usbh_msc_core.o                              #
#                                                                             #
#                                                                             #
###############################################################################

E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Libraries\STM32_USB_HOST_Library\Class\MSC\src\usbh_msc_core.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbh_msc_core.c
      4            * @author  MCD Application Team
      5            * @version V2.0.0RC1
      6            * @date    18-March-2011
      7            * @brief   This file implements the MSC class driver functions
      8            *          ===================================================================      
      9            *                                MSC Class  Description
     10            *          =================================================================== 
     11            *           This module manages the MSC class V1.0 following the "Universal 
     12            *           Serial Bus Mass Storage Class (MSC) Bulk-Only Transport (BOT) Version 1.0
     13            *           Sep. 31, 1999".
     14            *           This driver implements the following aspects of the specification:
     15            *             - Bulk-Only Transport protocol
     16            *             - Subclass : SCSI transparent command set (ref. SCSI Primary Commands - 3 (SPC-3))
     17            *      
     18            *  @endverbatim
     19            *
     20            ******************************************************************************
     21            * @attention
     22            *
     23            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     24            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     25            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     26            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     27            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     28            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     29            *
     30            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     31          */ 
     32          
     33          /* Includes ------------------------------------------------------------------*/
     34          
     35          #include "usbh_msc_core.h"
     36          #include "usbh_msc_scsi.h"
     37          #include "usbh_msc_bot.h"
     38          #include "usbh_core.h"
     39          
     40          
     41          /** @addtogroup USBH_LIB
     42            * @{
     43            */
     44          
     45          /** @addtogroup USBH_CLASS
     46            * @{
     47            */
     48          
     49          /** @addtogroup USBH_MSC_CLASS
     50            * @{
     51            */
     52            
     53          /** @defgroup USBH_MSC_CORE 
     54            * @brief    This file includes the mass storage related functions
     55            * @{
     56            */ 
     57          
     58          
     59          /** @defgroup USBH_MSC_CORE_Private_TypesDefinitions
     60            * @{
     61            */ 
     62          /**
     63            * @}
     64            */ 
     65          
     66          /** @defgroup USBH_MSC_CORE_Private_Defines
     67            * @{
     68            */ 
     69          #define USBH_MSC_ERROR_RETRY_LIMIT 10
     70          /**
     71            * @}
     72            */ 
     73          
     74          /** @defgroup USBH_MSC_CORE_Private_Macros
     75            * @{
     76            */ 
     77          /**
     78            * @}
     79            */ 
     80          
     81          
     82          /** @defgroup USBH_MSC_CORE_Private_Variables
     83            * @{
     84            */ 
     85          #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED
     86          #pragma data_alignment = 4 
     87          #endif

   \                                 In section .bss, align 4
     88          MSC_Machine_TypeDef         MSC_Machine;
   \                     MSC_Machine:
   \   00000000                      DS8 76

   \                                 In section .bss, align 4
     89          USB_Setup_TypeDef           MSC_Setup;
   \                     MSC_Setup:
   \   00000000                      DS8 8

   \                                 In section .bss, align 1
     90          uint8_t MSCErrorCount = 0;
   \                     MSCErrorCount:
   \   00000000                      DS8 1
     91          
     92          
     93          /**
     94            * @}
     95            */ 
     96          
     97          
     98          /** @defgroup USBH_MSC_CORE_Private_FunctionPrototypes
     99            * @{
    100            */ 
    101          
    102          static USBH_Status USBH_MSC_InterfaceInit  (USB_OTG_CORE_HANDLE *pdev , 
    103                                                      void *phost);
    104          
    105          static void USBH_MSC_InterfaceDeInit  (USB_OTG_CORE_HANDLE *pdev , 
    106                                                 void *phost);
    107          
    108          static USBH_Status USBH_MSC_Handle(USB_OTG_CORE_HANDLE *pdev , 
    109                                      void *phost);
    110          
    111          static USBH_Status USBH_MSC_ClassRequest(USB_OTG_CORE_HANDLE *pdev , 
    112                                                   void *phost);
    113          
    114          static USBH_Status USBH_MSC_BOTReset(USB_OTG_CORE_HANDLE *pdev,
    115                                        USBH_HOST *phost);
    116          static USBH_Status USBH_MSC_GETMaxLUN(USB_OTG_CORE_HANDLE *pdev,
    117                                         USBH_HOST *phost);
    118          
    119          

   \                                 In section .data, align 4
    120          USBH_Class_cb_TypeDef  USBH_MSC_cb = 
   \                     USBH_MSC_cb:
   \   00000000   ............       DC32 USBH_MSC_InterfaceInit, USBH_MSC_InterfaceDeInit
   \              ....        
   \   00000008   ............       DC32 USBH_MSC_ClassRequest, USBH_MSC_Handle
   \              ....        
    121          {
    122            USBH_MSC_InterfaceInit,
    123            USBH_MSC_InterfaceDeInit,
    124            USBH_MSC_ClassRequest,
    125            USBH_MSC_Handle,
    126          };
    127          
    128          void USBH_MSC_ErrorHandle(uint8_t status);
    129          
    130          /**
    131            * @}
    132            */ 
    133          
    134          
    135          /** @defgroup USBH_MSC_CORE_Exported_Variables
    136            * @{
    137            */ 
    138          
    139          /**
    140            * @}
    141            */ 
    142          
    143          
    144          /** @defgroup USBH_MSC_CORE_Private_Functions
    145            * @{
    146            */ 
    147          
    148          
    149          /**
    150            * @brief  USBH_MSC_InterfaceInit 
    151            *         Interface initialization for MSC class.
    152            * @param  pdev: Selected device
    153            * @param  hdev: Selected device property
    154            * @retval USBH_Status : Status of class request handled.
    155            */

   \                                 In section .text, align 2, keep-with-next
    156          static USBH_Status USBH_MSC_InterfaceInit ( USB_OTG_CORE_HANDLE *pdev, 
    157                                                  void *phost)
    158          {	 
   \                     USBH_MSC_InterfaceInit:
   \   00000000   30B5               PUSH     {R4,R5,LR}
   \   00000002   83B0               SUB      SP,SP,#+12
   \   00000004   0400               MOVS     R4,R0
   \   00000006   0D00               MOVS     R5,R1
    159            USBH_HOST *pphost = phost;
    160            
    161            if((pphost->device_prop.Itf_Desc[0].bInterfaceClass == MSC_CLASS) && \
    162               (pphost->device_prop.Itf_Desc[0].bInterfaceProtocol == MSC_PROTOCOL))
   \   00000008   95F84300           LDRB     R0,[R5, #+67]
   \   0000000C   0828               CMP      R0,#+8
   \   0000000E   61D1               BNE.N    ??USBH_MSC_InterfaceInit_0
   \   00000010   95F84500           LDRB     R0,[R5, #+69]
   \   00000014   5028               CMP      R0,#+80
   \   00000016   5DD1               BNE.N    ??USBH_MSC_InterfaceInit_0
    163            {
    164              if(pphost->device_prop.Ep_Desc[0][0].bEndpointAddress & 0x80)
   \   00000018   95F85200           LDRB     R0,[R5, #+82]
   \   0000001C   0006               LSLS     R0,R0,#+24
   \   0000001E   0AD5               BPL.N    ??USBH_MSC_InterfaceInit_1
    165              {
    166                MSC_Machine.MSBulkInEp = (pphost->device_prop.Ep_Desc[0][0].bEndpointAddress);
   \   00000020   ........           LDR.W    R0,??DataTable5
   \   00000024   95F85210           LDRB     R1,[R5, #+82]
   \   00000028   C170               STRB     R1,[R0, #+3]
    167                MSC_Machine.MSBulkInEpSize  = pphost->device_prop.Ep_Desc[0][0].wMaxPacketSize;
   \   0000002A   ........           LDR.W    R0,??DataTable5
   \   0000002E   B5F85410           LDRH     R1,[R5, #+84]
   \   00000032   8180               STRH     R1,[R0, #+4]
   \   00000034   09E0               B.N      ??USBH_MSC_InterfaceInit_2
    168              }
    169              else
    170              {
    171                MSC_Machine.MSBulkOutEp = (pphost->device_prop.Ep_Desc[0][0].bEndpointAddress);
   \                     ??USBH_MSC_InterfaceInit_1:
   \   00000036   ........           LDR.W    R0,??DataTable5
   \   0000003A   95F85210           LDRB     R1,[R5, #+82]
   \   0000003E   8170               STRB     R1,[R0, #+2]
    172                MSC_Machine.MSBulkOutEpSize  = pphost->device_prop.Ep_Desc[0] [0].wMaxPacketSize;      
   \   00000040   ........           LDR.W    R0,??DataTable5
   \   00000044   B5F85410           LDRH     R1,[R5, #+84]
   \   00000048   C180               STRH     R1,[R0, #+6]
    173              }
    174              
    175              if(pphost->device_prop.Ep_Desc[0][1].bEndpointAddress & 0x80)
   \                     ??USBH_MSC_InterfaceInit_2:
   \   0000004A   95F85A00           LDRB     R0,[R5, #+90]
   \   0000004E   0006               LSLS     R0,R0,#+24
   \   00000050   0AD5               BPL.N    ??USBH_MSC_InterfaceInit_3
    176              {
    177                MSC_Machine.MSBulkInEp = (pphost->device_prop.Ep_Desc[0][1].bEndpointAddress);
   \   00000052   ........           LDR.W    R0,??DataTable5
   \   00000056   95F85A10           LDRB     R1,[R5, #+90]
   \   0000005A   C170               STRB     R1,[R0, #+3]
    178                MSC_Machine.MSBulkInEpSize  = pphost->device_prop.Ep_Desc[0][1].wMaxPacketSize;      
   \   0000005C   ........           LDR.W    R0,??DataTable5
   \   00000060   B5F85C10           LDRH     R1,[R5, #+92]
   \   00000064   8180               STRH     R1,[R0, #+4]
   \   00000066   09E0               B.N      ??USBH_MSC_InterfaceInit_4
    179              }
    180              else
    181              {
    182                MSC_Machine.MSBulkOutEp = (pphost->device_prop.Ep_Desc[0][1].bEndpointAddress);
   \                     ??USBH_MSC_InterfaceInit_3:
   \   00000068   ........           LDR.W    R0,??DataTable5
   \   0000006C   95F85A10           LDRB     R1,[R5, #+90]
   \   00000070   8170               STRB     R1,[R0, #+2]
    183                MSC_Machine.MSBulkOutEpSize  = pphost->device_prop.Ep_Desc[0][1].wMaxPacketSize;      
   \   00000072   ........           LDR.W    R0,??DataTable5
   \   00000076   B5F85C10           LDRH     R1,[R5, #+92]
   \   0000007A   C180               STRH     R1,[R0, #+6]
    184              }
    185              
    186              MSC_Machine.hc_num_out = USBH_Alloc_Channel(pdev, 
    187                                                          MSC_Machine.MSBulkOutEp);
   \                     ??USBH_MSC_InterfaceInit_4:
   \   0000007C   ........           LDR.W    R0,??DataTable5
   \   00000080   8178               LDRB     R1,[R0, #+2]
   \   00000082   2000               MOVS     R0,R4
   \   00000084   ........           BL       USBH_Alloc_Channel
   \   00000088   ....               LDR.N    R1,??DataTable5
   \   0000008A   4870               STRB     R0,[R1, #+1]
    188              MSC_Machine.hc_num_in = USBH_Alloc_Channel(pdev,
    189                                                          MSC_Machine.MSBulkInEp);  
   \   0000008C   ....               LDR.N    R0,??DataTable5
   \   0000008E   C178               LDRB     R1,[R0, #+3]
   \   00000090   2000               MOVS     R0,R4
   \   00000092   ........           BL       USBH_Alloc_Channel
   \   00000096   ....               LDR.N    R1,??DataTable5
   \   00000098   0870               STRB     R0,[R1, #+0]
    190              
    191              /* Open the new channels */
    192              USBH_Open_Channel  (pdev,
    193                                  MSC_Machine.hc_num_out,
    194                                  pphost->device_prop.address,
    195                                  pphost->device_prop.speed,
    196                                  EP_TYPE_BULK,
    197                                  MSC_Machine.MSBulkOutEpSize);  
   \   0000009A   ....               LDR.N    R0,??DataTable5
   \   0000009C   C088               LDRH     R0,[R0, #+6]
   \   0000009E   0190               STR      R0,[SP, #+4]
   \   000000A0   0220               MOVS     R0,#+2
   \   000000A2   0090               STR      R0,[SP, #+0]
   \   000000A4   95F82130           LDRB     R3,[R5, #+33]
   \   000000A8   95F82020           LDRB     R2,[R5, #+32]
   \   000000AC   ....               LDR.N    R0,??DataTable5
   \   000000AE   4178               LDRB     R1,[R0, #+1]
   \   000000B0   2000               MOVS     R0,R4
   \   000000B2   ........           BL       USBH_Open_Channel
    198              
    199              USBH_Open_Channel  (pdev,
    200                                  MSC_Machine.hc_num_in,
    201                                  pphost->device_prop.address,
    202                                  pphost->device_prop.speed,
    203                                  EP_TYPE_BULK,
    204                                  MSC_Machine.MSBulkInEpSize);    
   \   000000B6   ....               LDR.N    R0,??DataTable5
   \   000000B8   8088               LDRH     R0,[R0, #+4]
   \   000000BA   0190               STR      R0,[SP, #+4]
   \   000000BC   0220               MOVS     R0,#+2
   \   000000BE   0090               STR      R0,[SP, #+0]
   \   000000C0   95F82130           LDRB     R3,[R5, #+33]
   \   000000C4   95F82020           LDRB     R2,[R5, #+32]
   \   000000C8   ....               LDR.N    R0,??DataTable5
   \   000000CA   0178               LDRB     R1,[R0, #+0]
   \   000000CC   2000               MOVS     R0,R4
   \   000000CE   ........           BL       USBH_Open_Channel
   \   000000D2   03E0               B.N      ??USBH_MSC_InterfaceInit_5
    205              
    206            }
    207            
    208            else
    209            {
    210              pphost->usr_cb->USBH_USR_DeviceNotSupported(); 
   \                     ??USBH_MSC_InterfaceInit_0:
   \   000000D4   D5F88000           LDR      R0,[R5, #+128]
   \   000000D8   006C               LDR      R0,[R0, #+64]
   \   000000DA   8047               BLX      R0
    211            }
    212            
    213            return USBH_OK ;
   \                     ??USBH_MSC_InterfaceInit_5:
   \   000000DC   0020               MOVS     R0,#+0
   \   000000DE   3EBD               POP      {R1-R5,PC}       ;; return
    214           
    215          }
    216          
    217          
    218          /**
    219            * @brief  USBH_MSC_InterfaceDeInit 
    220            *         De-Initialize interface by freeing host channels allocated to interface
    221            * @param  pdev: Selected device
    222            * @param  hdev: Selected device property
    223            * @retval None
    224            */

   \                                 In section .text, align 2, keep-with-next
    225          void USBH_MSC_InterfaceDeInit ( USB_OTG_CORE_HANDLE *pdev,
    226                                          void *phost)
    227          {	
   \                     USBH_MSC_InterfaceDeInit:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    228            if ( MSC_Machine.hc_num_out)
   \   00000004   ....               LDR.N    R0,??DataTable5
   \   00000006   4078               LDRB     R0,[R0, #+1]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   0CD0               BEQ.N    ??USBH_MSC_InterfaceDeInit_0
    229            {
    230              USB_OTG_HC_Halt(pdev, MSC_Machine.hc_num_out);
   \   0000000C   ....               LDR.N    R0,??DataTable5
   \   0000000E   4178               LDRB     R1,[R0, #+1]
   \   00000010   2000               MOVS     R0,R4
   \   00000012   ........           BL       USB_OTG_HC_Halt
    231              USBH_Free_Channel  (pdev, MSC_Machine.hc_num_out);
   \   00000016   ....               LDR.N    R0,??DataTable5
   \   00000018   4178               LDRB     R1,[R0, #+1]
   \   0000001A   2000               MOVS     R0,R4
   \   0000001C   ........           BL       USBH_Free_Channel
    232              MSC_Machine.hc_num_out = 0;     /* Reset the Channel as Free */
   \   00000020   ....               LDR.N    R0,??DataTable5
   \   00000022   0021               MOVS     R1,#+0
   \   00000024   4170               STRB     R1,[R0, #+1]
    233            }
    234             
    235            if ( MSC_Machine.hc_num_in)
   \                     ??USBH_MSC_InterfaceDeInit_0:
   \   00000026   ....               LDR.N    R0,??DataTable5
   \   00000028   0078               LDRB     R0,[R0, #+0]
   \   0000002A   0028               CMP      R0,#+0
   \   0000002C   0CD0               BEQ.N    ??USBH_MSC_InterfaceDeInit_1
    236            {
    237              USB_OTG_HC_Halt(pdev, MSC_Machine.hc_num_in);
   \   0000002E   ....               LDR.N    R0,??DataTable5
   \   00000030   0178               LDRB     R1,[R0, #+0]
   \   00000032   2000               MOVS     R0,R4
   \   00000034   ........           BL       USB_OTG_HC_Halt
    238              USBH_Free_Channel  (pdev, MSC_Machine.hc_num_in);
   \   00000038   ....               LDR.N    R0,??DataTable5
   \   0000003A   0178               LDRB     R1,[R0, #+0]
   \   0000003C   2000               MOVS     R0,R4
   \   0000003E   ........           BL       USBH_Free_Channel
    239              MSC_Machine.hc_num_in = 0;     /* Reset the Channel as Free */
   \   00000042   ....               LDR.N    R0,??DataTable5
   \   00000044   0021               MOVS     R1,#+0
   \   00000046   0170               STRB     R1,[R0, #+0]
    240            } 
    241          }
   \                     ??USBH_MSC_InterfaceDeInit_1:
   \   00000048   10BD               POP      {R4,PC}          ;; return
    242          
    243          /**
    244            * @brief  USBH_MSC_ClassRequest 
    245            *         This function will only initialize the MSC state machine
    246            * @param  pdev: Selected device
    247            * @param  hdev: Selected device property
    248            * @retval USBH_Status : Status of class request handled.
    249            */
    250          

   \                                 In section .text, align 2, keep-with-next
    251          static USBH_Status USBH_MSC_ClassRequest(USB_OTG_CORE_HANDLE *pdev , 
    252                                                  void *phost)
    253          {   
    254            
    255            USBH_Status status = USBH_OK ;
   \                     USBH_MSC_ClassRequest:
   \   00000000   0020               MOVS     R0,#+0
    256            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_INIT_STATE;
   \   00000002   ....               LDR.N    R1,??DataTable5_1
   \   00000004   0022               MOVS     R2,#+0
   \   00000006   0A70               STRB     R2,[R1, #+0]
    257            
    258            return status; 
   \   00000008   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   7047               BX       LR               ;; return
    259          }
    260          
    261          
    262          /**
    263            * @brief  USBH_MSC_Handle 
    264            *         MSC state machine handler 
    265            * @param  pdev: Selected device
    266            * @param  hdev: Selected device property
    267            * @retval USBH_Status
    268            */
    269          

   \                                 In section .text, align 2, keep-with-next
    270          static USBH_Status USBH_MSC_Handle(USB_OTG_CORE_HANDLE *pdev , 
    271                                             void   *phost)
    272          {
   \                     USBH_MSC_Handle:
   \   00000000   2DE9F843           PUSH     {R3-R9,LR}
   \   00000004   0600               MOVS     R6,R0
   \   00000006   0F00               MOVS     R7,R1
    273            USBH_HOST *pphost = phost;
   \   00000008   3D00               MOVS     R5,R7
    274              
    275            USBH_Status status = USBH_BUSY;
   \   0000000A   0124               MOVS     R4,#+1
    276            uint8_t mscStatus = USBH_MSC_BUSY;
   \   0000000C   5FF00308           MOVS     R8,#+3
    277            uint8_t appliStatus = 0;
   \   00000010   5FF00009           MOVS     R9,#+0
    278            
    279            static uint8_t maxLunExceed = FALSE;
    280            
    281              
    282            if(HCD_IsDeviceConnected(pdev))
   \   00000014   3000               MOVS     R0,R6
   \   00000016   ........           BL       HCD_IsDeviceConnected
   \   0000001A   0028               CMP      R0,#+0
   \   0000001C   00F0E680           BEQ.W    ??USBH_MSC_Handle_0
    283            {   
    284              switch(USBH_MSC_BOTXferParam.MSCState)
   \   00000020   ....               LDR.N    R0,??DataTable5_1
   \   00000022   0078               LDRB     R0,[R0, #+0]
   \   00000024   0028               CMP      R0,#+0
   \   00000026   15D0               BEQ.N    ??USBH_MSC_Handle_1
   \   00000028   0228               CMP      R0,#+2
   \   0000002A   2FD0               BEQ.N    ??USBH_MSC_Handle_2
   \   0000002C   19D3               BCC.N    ??USBH_MSC_Handle_3
   \   0000002E   0428               CMP      R0,#+4
   \   00000030   00F08080           BEQ.W    ??USBH_MSC_Handle_4
   \   00000034   68D3               BCC.N    ??USBH_MSC_Handle_5
   \   00000036   0628               CMP      R0,#+6
   \   00000038   00F0A880           BEQ.W    ??USBH_MSC_Handle_6
   \   0000003C   C0F09080           BCC.W    ??USBH_MSC_Handle_7
   \   00000040   0828               CMP      R0,#+8
   \   00000042   00F0BC80           BEQ.W    ??USBH_MSC_Handle_8
   \   00000046   C0F0B580           BCC.W    ??USBH_MSC_Handle_9
   \   0000004A   0A28               CMP      R0,#+10
   \   0000004C   00F0CC80           BEQ.W    ??USBH_MSC_Handle_10
   \   00000050   47D3               BCC.N    ??USBH_MSC_Handle_11
   \   00000052   CBE0               B.N      ??USBH_MSC_Handle_12
    285              {
    286              case USBH_MSC_BOT_INIT_STATE:
    287                USBH_MSC_Init(pdev);
   \                     ??USBH_MSC_Handle_1:
   \   00000054   3000               MOVS     R0,R6
   \   00000056   ........           BL       USBH_MSC_Init
    288                USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_RESET;  
   \   0000005A   ....               LDR.N    R0,??DataTable5_1
   \   0000005C   0121               MOVS     R1,#+1
   \   0000005E   0170               STRB     R1,[R0, #+0]
    289                break;
   \   00000060   C4E0               B.N      ??USBH_MSC_Handle_0
    290                
    291              case USBH_MSC_BOT_RESET:   
    292                /* Issue BOT RESET request */
    293                status = USBH_MSC_BOTReset(pdev, phost);
   \                     ??USBH_MSC_Handle_3:
   \   00000062   3900               MOVS     R1,R7
   \   00000064   3000               MOVS     R0,R6
   \   00000066   ........           BL       USBH_MSC_BOTReset
   \   0000006A   0400               MOVS     R4,R0
    294                if(status == USBH_OK )
   \   0000006C   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006E   002C               CMP      R4,#+0
   \   00000070   02D1               BNE.N    ??USBH_MSC_Handle_13
    295                {
    296                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_GET_MAX_LUN;
   \   00000072   ....               LDR.N    R0,??DataTable5_1
   \   00000074   0221               MOVS     R1,#+2
   \   00000076   0170               STRB     R1,[R0, #+0]
    297                }
    298                
    299                if(status == USBH_NOT_SUPPORTED )
   \                     ??USBH_MSC_Handle_13:
   \   00000078   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007A   032C               CMP      R4,#+3
   \   0000007C   05D1               BNE.N    ??USBH_MSC_Handle_14
    300                {
    301                 /* If the Command has failed, then we need to move to Next State, after
    302                  STALL condition is cleared by Control-Transfer */
    303                  USBH_MSC_BOTXferParam.MSCStateBkp = USBH_MSC_GET_MAX_LUN; 
   \   0000007E   ....               LDR.N    R0,??DataTable5_1
   \   00000080   0221               MOVS     R1,#+2
   \   00000082   4170               STRB     R1,[R0, #+1]
    304          
    305                  /* a Clear Feature should be issued here */
    306                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_CTRL_ERROR_STATE;
   \   00000084   ....               LDR.N    R0,??DataTable5_1
   \   00000086   0921               MOVS     R1,#+9
   \   00000088   0170               STRB     R1,[R0, #+0]
    307                }  
    308                break;
   \                     ??USBH_MSC_Handle_14:
   \   0000008A   AFE0               B.N      ??USBH_MSC_Handle_0
    309                
    310              case USBH_MSC_GET_MAX_LUN:
    311                /* Issue GetMaxLUN request */
    312                status = USBH_MSC_GETMaxLUN(pdev, phost);
   \                     ??USBH_MSC_Handle_2:
   \   0000008C   3900               MOVS     R1,R7
   \   0000008E   3000               MOVS     R0,R6
   \   00000090   ........           BL       USBH_MSC_GETMaxLUN
   \   00000094   0400               MOVS     R4,R0
    313                
    314                if(status == USBH_OK )
   \   00000096   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000098   002C               CMP      R4,#+0
   \   0000009A   18D1               BNE.N    ??USBH_MSC_Handle_15
    315                {
    316                  MSC_Machine.maxLun = *(MSC_Machine.buff) ;
   \   0000009C   ....               LDR.N    R0,??DataTable5
   \   0000009E   ....               LDR.N    R1,??DataTable5
   \   000000A0   097A               LDRB     R1,[R1, #+8]
   \   000000A2   80F84810           STRB     R1,[R0, #+72]
    317                  
    318                  /* If device has more that one logical unit then it is not supported */
    319                  if((MSC_Machine.maxLun > 0) && (maxLunExceed == FALSE))
   \   000000A6   ....               LDR.N    R0,??DataTable5
   \   000000A8   90F84800           LDRB     R0,[R0, #+72]
   \   000000AC   0128               CMP      R0,#+1
   \   000000AE   0BD3               BCC.N    ??USBH_MSC_Handle_16
   \   000000B0   ....               LDR.N    R0,??DataTable5_2
   \   000000B2   0078               LDRB     R0,[R0, #+0]
   \   000000B4   0028               CMP      R0,#+0
   \   000000B6   07D1               BNE.N    ??USBH_MSC_Handle_16
    320                  {
    321                    maxLunExceed = TRUE;
   \   000000B8   ....               LDR.N    R0,??DataTable5_2
   \   000000BA   0121               MOVS     R1,#+1
   \   000000BC   0170               STRB     R1,[R0, #+0]
    322                    pphost->usr_cb->USBH_USR_DeviceNotSupported();
   \   000000BE   D5F88000           LDR      R0,[R5, #+128]
   \   000000C2   006C               LDR      R0,[R0, #+64]
   \   000000C4   8047               BLX      R0
    323                    
    324                    break;
   \   000000C6   91E0               B.N      ??USBH_MSC_Handle_0
    325                  }
    326                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_TEST_UNIT_READY;
   \                     ??USBH_MSC_Handle_16:
   \   000000C8   ....               LDR.N    R0,??DataTable5_1
   \   000000CA   0321               MOVS     R1,#+3
   \   000000CC   0170               STRB     R1,[R0, #+0]
    327                }
    328                
    329                if(status == USBH_NOT_SUPPORTED )
   \                     ??USBH_MSC_Handle_15:
   \   000000CE   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D0   032C               CMP      R4,#+3
   \   000000D2   05D1               BNE.N    ??USBH_MSC_Handle_17
    330                {
    331                         /* If the Command has failed, then we need to move to Next State, after
    332                  STALL condition is cleared by Control-Transfer */
    333                  USBH_MSC_BOTXferParam.MSCStateBkp = USBH_MSC_TEST_UNIT_READY; 
   \   000000D4   ....               LDR.N    R0,??DataTable5_1
   \   000000D6   0321               MOVS     R1,#+3
   \   000000D8   4170               STRB     R1,[R0, #+1]
    334                  
    335                  /* a Clear Feature should be issued here */
    336                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_CTRL_ERROR_STATE;
   \   000000DA   ....               LDR.N    R0,??DataTable5_1
   \   000000DC   0921               MOVS     R1,#+9
   \   000000DE   0170               STRB     R1,[R0, #+0]
    337                }    
    338                break;
   \                     ??USBH_MSC_Handle_17:
   \   000000E0   84E0               B.N      ??USBH_MSC_Handle_0
    339                
    340              case USBH_MSC_CTRL_ERROR_STATE:
    341                /* Issue Clearfeature request */
    342                status = USBH_ClrFeature(pdev,
    343                                         phost,
    344                                         0x00,
    345                                         pphost->Control.hc_num_out);
   \                     ??USBH_MSC_Handle_11:
   \   000000E2   6B79               LDRB     R3,[R5, #+5]
   \   000000E4   0022               MOVS     R2,#+0
   \   000000E6   3900               MOVS     R1,R7
   \   000000E8   3000               MOVS     R0,R6
   \   000000EA   ........           BL       USBH_ClrFeature
   \   000000EE   0400               MOVS     R4,R0
    346                if(status == USBH_OK )
   \   000000F0   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F2   002C               CMP      R4,#+0
   \   000000F4   07D1               BNE.N    ??USBH_MSC_Handle_18
    347                {
    348                  /* If GetMaxLun Request not support, assume Single LUN configuration */
    349                  MSC_Machine.maxLun = 0;  
   \   000000F6   ....               LDR.N    R0,??DataTable5
   \   000000F8   0021               MOVS     R1,#+0
   \   000000FA   80F84810           STRB     R1,[R0, #+72]
    350                  
    351                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOTXferParam.MSCStateBkp;     
   \   000000FE   ....               LDR.N    R0,??DataTable5_1
   \   00000100   4078               LDRB     R0,[R0, #+1]
   \   00000102   ....               LDR.N    R1,??DataTable5_1
   \   00000104   0870               STRB     R0,[R1, #+0]
    352                }
    353                break;  
   \                     ??USBH_MSC_Handle_18:
   \   00000106   71E0               B.N      ??USBH_MSC_Handle_0
    354                
    355              case USBH_MSC_TEST_UNIT_READY:
    356                /* Issue SCSI command TestUnitReady */ 
    357                mscStatus = USBH_MSC_TestUnitReady(pdev);
   \                     ??USBH_MSC_Handle_5:
   \   00000108   3000               MOVS     R0,R6
   \   0000010A   ........           BL       USBH_MSC_TestUnitReady
   \   0000010E   8046               MOV      R8,R0
    358                
    359                if(mscStatus == USBH_MSC_OK )
   \   00000110   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000114   B8F1000F           CMP      R8,#+0
   \   00000118   07D1               BNE.N    ??USBH_MSC_Handle_19
    360                {
    361                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_READ_CAPACITY10;
   \   0000011A   ....               LDR.N    R0,??DataTable5_1
   \   0000011C   0421               MOVS     R1,#+4
   \   0000011E   0170               STRB     R1,[R0, #+0]
    362                  MSCErrorCount = 0;
   \   00000120   ....               LDR.N    R0,??DataTable5_3
   \   00000122   0021               MOVS     R1,#+0
   \   00000124   0170               STRB     R1,[R0, #+0]
    363                  status = USBH_OK;
   \   00000126   0024               MOVS     R4,#+0
   \   00000128   03E0               B.N      ??USBH_MSC_Handle_20
    364                }
    365                else
    366                {
    367                  USBH_MSC_ErrorHandle(mscStatus);
   \                     ??USBH_MSC_Handle_19:
   \   0000012A   4046               MOV      R0,R8
   \   0000012C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000012E   ........           BL       USBH_MSC_ErrorHandle
    368                } 
    369                break;
   \                     ??USBH_MSC_Handle_20:
   \   00000132   5BE0               B.N      ??USBH_MSC_Handle_0
    370                
    371              case USBH_MSC_READ_CAPACITY10:
    372                /* Issue READ_CAPACITY10 SCSI command */
    373                mscStatus = USBH_MSC_ReadCapacity10(pdev);
   \                     ??USBH_MSC_Handle_4:
   \   00000134   3000               MOVS     R0,R6
   \   00000136   ........           BL       USBH_MSC_ReadCapacity10
   \   0000013A   8046               MOV      R8,R0
    374                if(mscStatus == USBH_MSC_OK )
   \   0000013C   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000140   B8F1000F           CMP      R8,#+0
   \   00000144   07D1               BNE.N    ??USBH_MSC_Handle_21
    375                {
    376                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_MODE_SENSE6;
   \   00000146   ....               LDR.N    R0,??DataTable5_1
   \   00000148   0521               MOVS     R1,#+5
   \   0000014A   0170               STRB     R1,[R0, #+0]
    377                  MSCErrorCount = 0;
   \   0000014C   ....               LDR.N    R0,??DataTable5_3
   \   0000014E   0021               MOVS     R1,#+0
   \   00000150   0170               STRB     R1,[R0, #+0]
    378                  status = USBH_OK;
   \   00000152   0024               MOVS     R4,#+0
   \   00000154   03E0               B.N      ??USBH_MSC_Handle_22
    379                }
    380                else
    381                {
    382                  USBH_MSC_ErrorHandle(mscStatus);
   \                     ??USBH_MSC_Handle_21:
   \   00000156   4046               MOV      R0,R8
   \   00000158   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000015A   ........           BL       USBH_MSC_ErrorHandle
    383                }
    384                break;
   \                     ??USBH_MSC_Handle_22:
   \   0000015E   45E0               B.N      ??USBH_MSC_Handle_0
    385          
    386              case USBH_MSC_MODE_SENSE6:
    387                /* Issue ModeSense6 SCSI command for detecting if device is write-protected */
    388                mscStatus = USBH_MSC_ModeSense6(pdev);
   \                     ??USBH_MSC_Handle_7:
   \   00000160   3000               MOVS     R0,R6
   \   00000162   ........           BL       USBH_MSC_ModeSense6
   \   00000166   8046               MOV      R8,R0
    389                if(mscStatus == USBH_MSC_OK )
   \   00000168   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000016C   B8F1000F           CMP      R8,#+0
   \   00000170   07D1               BNE.N    ??USBH_MSC_Handle_23
    390                {
    391                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_DEFAULT_APPLI_STATE;
   \   00000172   ....               LDR.N    R0,??DataTable5_1
   \   00000174   0821               MOVS     R1,#+8
   \   00000176   0170               STRB     R1,[R0, #+0]
    392                  MSCErrorCount = 0;
   \   00000178   ....               LDR.N    R0,??DataTable5_3
   \   0000017A   0021               MOVS     R1,#+0
   \   0000017C   0170               STRB     R1,[R0, #+0]
    393                  status = USBH_OK;
   \   0000017E   0024               MOVS     R4,#+0
   \   00000180   03E0               B.N      ??USBH_MSC_Handle_24
    394                }
    395                else
    396                {
    397                  USBH_MSC_ErrorHandle(mscStatus);
   \                     ??USBH_MSC_Handle_23:
   \   00000182   4046               MOV      R0,R8
   \   00000184   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000186   ........           BL       USBH_MSC_ErrorHandle
    398                }
    399                break;
   \                     ??USBH_MSC_Handle_24:
   \   0000018A   2FE0               B.N      ??USBH_MSC_Handle_0
    400                
    401              case USBH_MSC_REQUEST_SENSE:
    402                /* Issue RequestSense SCSI command for retreiving error code */
    403                mscStatus = USBH_MSC_RequestSense(pdev);
   \                     ??USBH_MSC_Handle_6:
   \   0000018C   3000               MOVS     R0,R6
   \   0000018E   ........           BL       USBH_MSC_RequestSense
   \   00000192   8046               MOV      R8,R0
    404                if(mscStatus == USBH_MSC_OK )
   \   00000194   5FFA88F8           UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000198   B8F1000F           CMP      R8,#+0
   \   0000019C   05D1               BNE.N    ??USBH_MSC_Handle_25
    405                {
    406                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOTXferParam.MSCStateBkp;
   \   0000019E   ....               LDR.N    R0,??DataTable5_1
   \   000001A0   4078               LDRB     R0,[R0, #+1]
   \   000001A2   ....               LDR.N    R1,??DataTable5_1
   \   000001A4   0870               STRB     R0,[R1, #+0]
    407                  status = USBH_OK;
   \   000001A6   0024               MOVS     R4,#+0
   \   000001A8   03E0               B.N      ??USBH_MSC_Handle_26
    408                }
    409                else
    410                {
    411                  USBH_MSC_ErrorHandle(mscStatus);
   \                     ??USBH_MSC_Handle_25:
   \   000001AA   4046               MOV      R0,R8
   \   000001AC   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001AE   ........           BL       USBH_MSC_ErrorHandle
    412                }  
    413                break;
   \                     ??USBH_MSC_Handle_26:
   \   000001B2   1BE0               B.N      ??USBH_MSC_Handle_0
    414                
    415              case USBH_MSC_BOT_USB_TRANSFERS:
    416                /* Process the BOT state machine */
    417                USBH_MSC_HandleBOTXfer(pdev , phost);
   \                     ??USBH_MSC_Handle_9:
   \   000001B4   3900               MOVS     R1,R7
   \   000001B6   3000               MOVS     R0,R6
   \   000001B8   ........           BL       USBH_MSC_HandleBOTXfer
    418                break;
   \   000001BC   16E0               B.N      ??USBH_MSC_Handle_0
    419              
    420              case USBH_MSC_DEFAULT_APPLI_STATE:
    421                /* Process Application callback for MSC */
    422                appliStatus = pphost->usr_cb->USBH_USR_MSC_Application();
   \                     ??USBH_MSC_Handle_8:
   \   000001BE   D5F88000           LDR      R0,[R5, #+128]
   \   000001C2   C06B               LDR      R0,[R0, #+60]
   \   000001C4   8047               BLX      R0
   \   000001C6   8146               MOV      R9,R0
    423                if(appliStatus == 0)
   \   000001C8   5FFA89F9           UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001CC   B9F1000F           CMP      R9,#+0
   \   000001D0   03D1               BNE.N    ??USBH_MSC_Handle_27
    424                {
    425                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_DEFAULT_APPLI_STATE;
   \   000001D2   ....               LDR.N    R0,??DataTable5_1
   \   000001D4   0821               MOVS     R1,#+8
   \   000001D6   0170               STRB     R1,[R0, #+0]
   \   000001D8   05E0               B.N      ??USBH_MSC_Handle_28
    426                }
    427                else if (appliStatus == 1) 
   \                     ??USBH_MSC_Handle_27:
   \   000001DA   5FFA89F9           UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001DE   B9F1010F           CMP      R9,#+1
   \   000001E2   00D1               BNE.N    ??USBH_MSC_Handle_28
    428                {
    429                  /* De-init requested from application layer */
    430                  status =  USBH_APPLY_DEINIT;
   \   000001E4   0624               MOVS     R4,#+6
    431                }
    432                break;
   \                     ??USBH_MSC_Handle_28:
   \   000001E6   01E0               B.N      ??USBH_MSC_Handle_0
    433                
    434              case USBH_MSC_UNRECOVERED_STATE:
    435                
    436                status = USBH_UNRECOVERED_ERROR;
   \                     ??USBH_MSC_Handle_10:
   \   000001E8   0424               MOVS     R4,#+4
    437                
    438                break;
   \   000001EA   FFE7               B.N      ??USBH_MSC_Handle_0
    439                
    440              default:
    441                break; 
    442                
    443              }
    444            }
    445             return status;
   \                     ??USBH_MSC_Handle_12:
   \                     ??USBH_MSC_Handle_0:
   \   000001EC   2000               MOVS     R0,R4
   \   000001EE   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001F0   BDE8F283           POP      {R1,R4-R9,PC}    ;; return
    446          }

   \                                 In section .bss, align 1
   \                     ??maxLunExceed:
   \   00000000                      DS8 1
    447          
    448          
    449          
    450          /**
    451            * @brief  USBH_MSC_BOTReset
    452            *         This request is used to reset the mass storage device and its 
    453            *         associated interface. This class-specific request shall ready the 
    454            *         device for the next CBW from the host.
    455            * @param  pdev: Selected device
    456            * @retval USBH_Status : Status of class request handled.
    457            */

   \                                 In section .text, align 2, keep-with-next
    458          static USBH_Status USBH_MSC_BOTReset(USB_OTG_CORE_HANDLE *pdev,
    459                                        USBH_HOST *phost)
    460          {
   \                     USBH_MSC_BOTReset:
   \   00000000   80B5               PUSH     {R7,LR}
    461            
    462            phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_TYPE_CLASS | \
    463                                        USB_REQ_RECIPIENT_INTERFACE;
   \   00000002   2122               MOVS     R2,#+33
   \   00000004   0A75               STRB     R2,[R1, #+20]
    464            
    465            phost->Control.setup.b.bRequest = USB_REQ_BOT_RESET;
   \   00000006   FF22               MOVS     R2,#+255
   \   00000008   4A75               STRB     R2,[R1, #+21]
    466            phost->Control.setup.b.wValue.w = 0;
   \   0000000A   0022               MOVS     R2,#+0
   \   0000000C   CA82               STRH     R2,[R1, #+22]
    467            phost->Control.setup.b.wIndex.w = 0;
   \   0000000E   0022               MOVS     R2,#+0
   \   00000010   0A83               STRH     R2,[R1, #+24]
    468            phost->Control.setup.b.wLength.w = 0;           
   \   00000012   0022               MOVS     R2,#+0
   \   00000014   4A83               STRH     R2,[R1, #+26]
    469            
    470            return USBH_CtlReq(pdev, phost, 0 , 0 ); 
   \   00000016   0023               MOVS     R3,#+0
   \   00000018   0022               MOVS     R2,#+0
   \   0000001A   ........           BL       USBH_CtlReq
   \   0000001E   02BD               POP      {R1,PC}          ;; return
    471          }
    472          
    473          
    474          /**
    475            * @brief  USBH_MSC_GETMaxLUN
    476            *         This request is used to reset the mass storage device and its 
    477            *         associated interface. This class-specific request shall ready the 
    478            *         device for the next CBW from the host.
    479            * @param  pdev: Selected device
    480            * @retval USBH_Status : USB ctl xfer status
    481            */

   \                                 In section .text, align 2, keep-with-next
    482          static USBH_Status USBH_MSC_GETMaxLUN(USB_OTG_CORE_HANDLE *pdev , USBH_HOST *phost)
    483          {
   \                     USBH_MSC_GETMaxLUN:
   \   00000000   80B5               PUSH     {R7,LR}
    484            phost->Control.setup.b.bmRequestType = USB_D2H | USB_REQ_TYPE_CLASS | \
    485                                        USB_REQ_RECIPIENT_INTERFACE;
   \   00000002   A122               MOVS     R2,#+161
   \   00000004   0A75               STRB     R2,[R1, #+20]
    486            
    487            phost->Control.setup.b.bRequest = USB_REQ_GET_MAX_LUN;
   \   00000006   FE22               MOVS     R2,#+254
   \   00000008   4A75               STRB     R2,[R1, #+21]
    488            phost->Control.setup.b.wValue.w = 0;
   \   0000000A   0022               MOVS     R2,#+0
   \   0000000C   CA82               STRH     R2,[R1, #+22]
    489            phost->Control.setup.b.wIndex.w = 0;
   \   0000000E   0022               MOVS     R2,#+0
   \   00000010   0A83               STRH     R2,[R1, #+24]
    490            phost->Control.setup.b.wLength.w = 1;           
   \   00000012   0122               MOVS     R2,#+1
   \   00000014   4A83               STRH     R2,[R1, #+26]
    491            
    492            return USBH_CtlReq(pdev, phost, MSC_Machine.buff , 1 ); 
   \   00000016   0123               MOVS     R3,#+1
   \   00000018   ....               LDR.N    R2,??DataTable5_4
   \   0000001A   ........           BL       USBH_CtlReq
   \   0000001E   02BD               POP      {R1,PC}          ;; return
    493          }
    494          
    495          /**
    496            * @brief  USBH_MSC_ErrorHandle 
    497            *         The function is for handling errors occuring during the MSC
    498            *         state machine   
    499            * @param  status
    500            * @retval None
    501            */
    502          

   \                                 In section .text, align 2, keep-with-next
    503          void USBH_MSC_ErrorHandle(uint8_t status)
    504          {  
    505              if(status == USBH_MSC_FAIL)
   \                     USBH_MSC_ErrorHandle:
   \   00000000   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0128               CMP      R0,#+1
   \   00000004   13D1               BNE.N    ??USBH_MSC_ErrorHandle_0
    506              { 
    507                MSCErrorCount++;
   \   00000006   ....               LDR.N    R0,??DataTable5_3
   \   00000008   0078               LDRB     R0,[R0, #+0]
   \   0000000A   401C               ADDS     R0,R0,#+1
   \   0000000C   ....               LDR.N    R1,??DataTable5_3
   \   0000000E   0870               STRB     R0,[R1, #+0]
    508                if(MSCErrorCount < USBH_MSC_ERROR_RETRY_LIMIT)
   \   00000010   ....               LDR.N    R0,??DataTable5_3
   \   00000012   0078               LDRB     R0,[R0, #+0]
   \   00000014   0A28               CMP      R0,#+10
   \   00000016   06D2               BCS.N    ??USBH_MSC_ErrorHandle_1
    509                { /* Try MSC level error recovery, Issue the request Sense to get 
    510                  Drive error reason  */
    511                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_REQUEST_SENSE;
   \   00000018   ....               LDR.N    R0,??DataTable5_1
   \   0000001A   0621               MOVS     R1,#+6
   \   0000001C   0170               STRB     R1,[R0, #+0]
    512                  USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
   \   0000001E   ....               LDR.N    R0,??DataTable5_1
   \   00000020   0121               MOVS     R1,#+1
   \   00000022   C170               STRB     R1,[R0, #+3]
   \   00000024   0AE0               B.N      ??USBH_MSC_ErrorHandle_2
    513                }
    514                else
    515                {
    516                  /* Error trials exceeded the limit, go to unrecovered state */
    517                  USBH_MSC_BOTXferParam.MSCState = USBH_MSC_UNRECOVERED_STATE;
   \                     ??USBH_MSC_ErrorHandle_1:
   \   00000026   ....               LDR.N    R0,??DataTable5_1
   \   00000028   0A21               MOVS     R1,#+10
   \   0000002A   0170               STRB     R1,[R0, #+0]
   \   0000002C   06E0               B.N      ??USBH_MSC_ErrorHandle_2
    518                }
    519              } 
    520              else if(status == USBH_MSC_PHASE_ERROR)
   \                     ??USBH_MSC_ErrorHandle_0:
   \   0000002E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0228               CMP      R0,#+2
   \   00000032   03D1               BNE.N    ??USBH_MSC_ErrorHandle_3
    521              {
    522                /* Phase error, Go to Unrecoovered state */
    523                USBH_MSC_BOTXferParam.MSCState = USBH_MSC_UNRECOVERED_STATE;
   \   00000034   ....               LDR.N    R0,??DataTable5_1
   \   00000036   0A21               MOVS     R1,#+10
   \   00000038   0170               STRB     R1,[R0, #+0]
   \   0000003A   FFE7               B.N      ??USBH_MSC_ErrorHandle_2
    524              }
    525              else if(status == USBH_MSC_BUSY)
    526              {
    527                /*No change in state*/
    528              }
    529          }
   \                     ??USBH_MSC_ErrorHandle_3:
   \                     ??USBH_MSC_ErrorHandle_2:
   \   0000003C   7047               BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     MSC_Machine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   ........           DC32     USBH_MSC_BOTXferParam

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   ........           DC32     ??maxLunExceed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   ........           DC32     MSCErrorCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   ........           DC32     MSC_Machine+0x8
    530          
    531          /**
    532            * @}
    533            */ 
    534          
    535          /**
    536            * @}
    537            */ 
    538          
    539          /**
    540            * @}
    541            */
    542          
    543          /**
    544            * @}
    545            */ 
    546          
    547          /**
    548            * @}
    549            */
    550          
    551          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                 .cstack
     --------                 -------
     USBH_MSC_BOTReset             8
     USBH_MSC_ClassRequest         0
     USBH_MSC_ErrorHandle          0
     USBH_MSC_GETMaxLUN            8
     USBH_MSC_Handle              32
     USBH_MSC_InterfaceDeInit      8
     USBH_MSC_InterfaceInit       24


   Section sizes:

     Function/Label           Bytes
     --------------           -----
     MSC_Machine                76
     MSC_Setup                   8
     MSCErrorCount               1
     USBH_MSC_cb                16
     USBH_MSC_InterfaceInit    224
     USBH_MSC_InterfaceDeInit   74
     USBH_MSC_ClassRequest      12
     USBH_MSC_Handle           500
     maxLunExceed                1
     USBH_MSC_BOTReset          32
     USBH_MSC_GETMaxLUN         32
     USBH_MSC_ErrorHandle       62
     ??DataTable5                4
     ??DataTable5_1              4
     ??DataTable5_2              4
     ??DataTable5_3              4
     ??DataTable5_4              4

 
  86 bytes in section .bss
  16 bytes in section .data
 956 bytes in section .text
 
 956 bytes of CODE memory
 102 bytes of DATA memory

Errors: none
Warnings: none
