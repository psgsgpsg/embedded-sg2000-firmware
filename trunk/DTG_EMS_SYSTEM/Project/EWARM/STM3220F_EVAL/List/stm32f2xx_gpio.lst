###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     08/Jan/2012  13:10:31 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Libraries\STM32F2xx_ #
#                    StdPeriph_Driver\src\stm32f2xx_gpio.c                    #
#    Command line =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Libraries\STM32F2xx_ #
#                    StdPeriph_Driver\src\stm32f2xx_gpio.c -D                 #
#                    USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM3220F_EVAL   #
#                    -D USE_USB_OTG_FS -D RTC_CLOCK_SOURCE_LSE -lC            #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\List\ -lA E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Pr #
#                    oject\EWARM\STM3220F_EVAL\List\ -o                       #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\Obj\ --no_cse --no_unroll --no_inline            #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWAR #
#                    M\..\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWA #
#                    RM\..\..\Libraries\CMSIS\CM3\CoreSupport\ -I             #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\ -I       #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32F2xx_StdPeriph_Driver\inc\ -I             #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Utilities\STM32_EVAL\ -I E:\Work\Firmware\DTG\DTG_EMS_SY #
#                    STEM\Project\EWARM\..\..\Utilities\STM32_EVAL\Common\    #
#                    -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\ #
#                    ..\Utilities\STM32_EVAL\STM3220F_EVAL\ -I                #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_OTG_Driver\inc\ -I                   #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_Device_Library\Core\inc\ -I          #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\..\ #
#                    Libraries\STM32_USB_Device_Library\Class\msc\inc\ -I     #
#                    E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\..\Usb #
#                    \ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\. #
#                    .\Usb\Inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Projec #
#                    t\EWARM\..\Usb\src\ -I E:\Work\Firmware\DTG\DTG_EMS_SYST #
#                    EM\Project\EWARM\..\..\Libraries\STM32_USB_HOST_Library\ #
#                    Core\inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project #
#                    \EWARM\..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\ #
#                    inc\ -I E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWAR #
#                    M\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc #
#                    \ -Ol --use_c++_inline                                   #
#    List file    =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\List\stm32f2xx_gpio.lst                          #
#    Object file  =  E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Project\EWARM\STM322 #
#                    0F_EVAL\Obj\stm32f2xx_gpio.o                             #
#                                                                             #
#                                                                             #
###############################################################################

E:\Work\Firmware\DTG\DTG_EMS_SYSTEM\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_gpio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_gpio.c
      4            * @author  MCD Application Team
      5            * @version V0.0.4
      6            * @date    13-January-2011
      7            * @brief   This file provides all the GPIO firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f2xx_gpio.h"
     24          #include "stm32f2xx_rcc.h"
     25          
     26          /** @addtogroup STM32F2xx_StdPeriph_Driver
     27            * @{
     28            */
     29          
     30          
     31          
     32          /** @defgroup GPIO 
     33            * @brief GPIO driver modules
     34            * @{
     35            */ 
     36          
     37          /** @defgroup GPIO_Private_TypesDefinitions
     38            * @{
     39            */ 
     40          /**
     41            * @}
     42            */ 
     43          
     44          
     45          /** @defgroup GPIO_Private_Defines
     46            * @{
     47            */ 
     48          /* Bits definitions ----------------------------------------------------------*/
     49          /**
     50            * @}
     51            */ 
     52          
     53          
     54          /** @defgroup GPIO_Private_Macros
     55            * @{
     56            */ 
     57          /**
     58            * @}
     59            */ 
     60          
     61          
     62          /** @defgroup GPIO_Private_Variables
     63            * @{
     64            */ 
     65          /**
     66            * @}
     67            */ 
     68          
     69          
     70          /** @defgroup GPIO_Private_FunctionPrototypes
     71            * @{
     72            */ 
     73          /**
     74            * @}
     75            */ 
     76          
     77          
     78          /** @defgroup GPIO_Private_Functions
     79            * @{
     80            */ 
     81          
     82          
     83          /**
     84            * @brief  Deinitializes the GPIOx peripheral registers to their default reset values.
     85            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
     86            * @retval None
     87            */

   \                                 In section .text, align 2, keep-with-next
     88          void GPIO_DeInit(GPIO_TypeDef* GPIOx)
     89          {
   \                     GPIO_DeInit:
   \   00000000   80B5               PUSH     {R7,LR}
     90            /* Check the parameters */
     91            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
     92          
     93            if (GPIOx == GPIOA)
   \   00000002   ....               LDR.N    R1,??DataTable0  ;; 0x40020000
   \   00000004   8842               CMP      R0,R1
   \   00000006   08D1               BNE.N    ??GPIO_DeInit_0
     94            {
     95              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
   \   00000008   0121               MOVS     R1,#+1
   \   0000000A   0120               MOVS     R0,#+1
   \   0000000C   ........           BL       RCC_AHB1PeriphResetCmd
     96              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   0120               MOVS     R0,#+1
   \   00000014   ........           BL       RCC_AHB1PeriphResetCmd
   \   00000018   60E0               B.N      ??GPIO_DeInit_1
     97            }
     98            else if (GPIOx == GPIOB)
   \                     ??GPIO_DeInit_0:
   \   0000001A   ....               LDR.N    R1,??DataTable0_1  ;; 0x40020400
   \   0000001C   8842               CMP      R0,R1
   \   0000001E   08D1               BNE.N    ??GPIO_DeInit_2
     99            {
    100              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
   \   00000020   0121               MOVS     R1,#+1
   \   00000022   0220               MOVS     R0,#+2
   \   00000024   ........           BL       RCC_AHB1PeriphResetCmd
    101              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
   \   00000028   0021               MOVS     R1,#+0
   \   0000002A   0220               MOVS     R0,#+2
   \   0000002C   ........           BL       RCC_AHB1PeriphResetCmd
   \   00000030   54E0               B.N      ??GPIO_DeInit_1
    102            }
    103            else if (GPIOx == GPIOC)
   \                     ??GPIO_DeInit_2:
   \   00000032   ....               LDR.N    R1,??DataTable0_2  ;; 0x40020800
   \   00000034   8842               CMP      R0,R1
   \   00000036   08D1               BNE.N    ??GPIO_DeInit_3
    104            {
    105              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
   \   00000038   0121               MOVS     R1,#+1
   \   0000003A   0420               MOVS     R0,#+4
   \   0000003C   ........           BL       RCC_AHB1PeriphResetCmd
    106              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
   \   00000040   0021               MOVS     R1,#+0
   \   00000042   0420               MOVS     R0,#+4
   \   00000044   ........           BL       RCC_AHB1PeriphResetCmd
   \   00000048   48E0               B.N      ??GPIO_DeInit_1
    107            }
    108            else if (GPIOx == GPIOD)
   \                     ??GPIO_DeInit_3:
   \   0000004A   ....               LDR.N    R1,??DataTable0_3  ;; 0x40020c00
   \   0000004C   8842               CMP      R0,R1
   \   0000004E   08D1               BNE.N    ??GPIO_DeInit_4
    109            {
    110              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
   \   00000050   0121               MOVS     R1,#+1
   \   00000052   0820               MOVS     R0,#+8
   \   00000054   ........           BL       RCC_AHB1PeriphResetCmd
    111              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
   \   00000058   0021               MOVS     R1,#+0
   \   0000005A   0820               MOVS     R0,#+8
   \   0000005C   ........           BL       RCC_AHB1PeriphResetCmd
   \   00000060   3CE0               B.N      ??GPIO_DeInit_1
    112            }
    113            else if (GPIOx == GPIOE)
   \                     ??GPIO_DeInit_4:
   \   00000062   ....               LDR.N    R1,??DataTable0_4  ;; 0x40021000
   \   00000064   8842               CMP      R0,R1
   \   00000066   08D1               BNE.N    ??GPIO_DeInit_5
    114            {
    115              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
   \   00000068   0121               MOVS     R1,#+1
   \   0000006A   1020               MOVS     R0,#+16
   \   0000006C   ........           BL       RCC_AHB1PeriphResetCmd
    116              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
   \   00000070   0021               MOVS     R1,#+0
   \   00000072   1020               MOVS     R0,#+16
   \   00000074   ........           BL       RCC_AHB1PeriphResetCmd
   \   00000078   30E0               B.N      ??GPIO_DeInit_1
    117            }
    118            else if (GPIOx == GPIOF)
   \                     ??GPIO_DeInit_5:
   \   0000007A   ....               LDR.N    R1,??DataTable0_5  ;; 0x40021400
   \   0000007C   8842               CMP      R0,R1
   \   0000007E   08D1               BNE.N    ??GPIO_DeInit_6
    119            {
    120              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
   \   00000080   0121               MOVS     R1,#+1
   \   00000082   2020               MOVS     R0,#+32
   \   00000084   ........           BL       RCC_AHB1PeriphResetCmd
    121              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
   \   00000088   0021               MOVS     R1,#+0
   \   0000008A   2020               MOVS     R0,#+32
   \   0000008C   ........           BL       RCC_AHB1PeriphResetCmd
   \   00000090   24E0               B.N      ??GPIO_DeInit_1
    122            }
    123            else if (GPIOx == GPIOG)
   \                     ??GPIO_DeInit_6:
   \   00000092   ....               LDR.N    R1,??DataTable0_6  ;; 0x40021800
   \   00000094   8842               CMP      R0,R1
   \   00000096   08D1               BNE.N    ??GPIO_DeInit_7
    124            {
    125              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
   \   00000098   0121               MOVS     R1,#+1
   \   0000009A   4020               MOVS     R0,#+64
   \   0000009C   ........           BL       RCC_AHB1PeriphResetCmd
    126              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
   \   000000A0   0021               MOVS     R1,#+0
   \   000000A2   4020               MOVS     R0,#+64
   \   000000A4   ........           BL       RCC_AHB1PeriphResetCmd
   \   000000A8   18E0               B.N      ??GPIO_DeInit_1
    127            }
    128            else if (GPIOx == GPIOH)
   \                     ??GPIO_DeInit_7:
   \   000000AA   ....               LDR.N    R1,??DataTable0_7  ;; 0x40021c00
   \   000000AC   8842               CMP      R0,R1
   \   000000AE   08D1               BNE.N    ??GPIO_DeInit_8
    129            {
    130              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
   \   000000B0   0121               MOVS     R1,#+1
   \   000000B2   8020               MOVS     R0,#+128
   \   000000B4   ........           BL       RCC_AHB1PeriphResetCmd
    131              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
   \   000000B8   0021               MOVS     R1,#+0
   \   000000BA   8020               MOVS     R0,#+128
   \   000000BC   ........           BL       RCC_AHB1PeriphResetCmd
   \   000000C0   0CE0               B.N      ??GPIO_DeInit_1
    132            }
    133            else
    134            {
    135              if (GPIOx == GPIOI)
   \                     ??GPIO_DeInit_8:
   \   000000C2   ....               LDR.N    R1,??DataTable0_8  ;; 0x40022000
   \   000000C4   8842               CMP      R0,R1
   \   000000C6   09D1               BNE.N    ??GPIO_DeInit_1
    136              {
    137                RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
   \   000000C8   0121               MOVS     R1,#+1
   \   000000CA   4FF48070           MOV      R0,#+256
   \   000000CE   ........           BL       RCC_AHB1PeriphResetCmd
    138                RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
   \   000000D2   0021               MOVS     R1,#+0
   \   000000D4   4FF48070           MOV      R0,#+256
   \   000000D8   ........           BL       RCC_AHB1PeriphResetCmd
    139              }
    140            }
    141          }
   \                     ??GPIO_DeInit_1:
   \   000000DC   01BD               POP      {R0,PC}          ;; return
    142          
    143          /**
    144            * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_InitStruct.
    145            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    146            * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
    147            *   the configuration information for the specified GPIO peripheral.
    148            * @retval None
    149            */

   \                                 In section .text, align 2, keep-with-next
    150          void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
    151          {
   \                     GPIO_Init:
   \   00000000   30B4               PUSH     {R4,R5}
    152            uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   0023               MOVS     R3,#+0
   \   00000006   0024               MOVS     R4,#+0
    153          
    154            /* Check the parameters */
    155            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    156            assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
    157            assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
    158            assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));
    159          
    160            /* -------------------------Configure the port pins---------------- */
    161            /*-- GPIO Mode Configuration --*/
    162            for (pinpos = 0x00; pinpos < 0x10; pinpos++)
   \   00000008   0025               MOVS     R5,#+0
   \   0000000A   2A00               MOVS     R2,R5
   \   0000000C   47E0               B.N      ??GPIO_Init_0
    163            {
    164              pos = ((uint32_t)0x01) << pinpos;
   \                     ??GPIO_Init_1:
   \   0000000E   0123               MOVS     R3,#+1
   \   00000010   9340               LSLS     R3,R3,R2
    165              /* Get the port pins position */
    166              currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
   \   00000012   0C68               LDR      R4,[R1, #+0]
   \   00000014   1C40               ANDS     R4,R3,R4
    167              if (currentpin == pos)
   \   00000016   9C42               CMP      R4,R3
   \   00000018   40D1               BNE.N    ??GPIO_Init_2
    168              {
    169                GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
   \   0000001A   0368               LDR      R3,[R0, #+0]
   \   0000001C   0324               MOVS     R4,#+3
   \   0000001E   1500               MOVS     R5,R2
   \   00000020   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   6D00               LSLS     R5,R5,#+1
   \   00000024   AC40               LSLS     R4,R4,R5
   \   00000026   A343               BICS     R3,R3,R4
   \   00000028   0360               STR      R3,[R0, #+0]
    170                GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
   \   0000002A   0368               LDR      R3,[R0, #+0]
   \   0000002C   0C79               LDRB     R4,[R1, #+4]
   \   0000002E   1500               MOVS     R5,R2
   \   00000030   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   6D00               LSLS     R5,R5,#+1
   \   00000034   AC40               LSLS     R4,R4,R5
   \   00000036   2343               ORRS     R3,R4,R3
   \   00000038   0360               STR      R3,[R0, #+0]
    171                if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
   \   0000003A   0B79               LDRB     R3,[R1, #+4]
   \   0000003C   012B               CMP      R3,#+1
   \   0000003E   02D0               BEQ.N    ??GPIO_Init_3
   \   00000040   0B79               LDRB     R3,[R1, #+4]
   \   00000042   022B               CMP      R3,#+2
   \   00000044   1AD1               BNE.N    ??GPIO_Init_4
    172                {
    173                  /*Check Speed mode parameters */
    174                  assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    175                  /*Speed mode configuration */
    176                  GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
   \                     ??GPIO_Init_3:
   \   00000046   8368               LDR      R3,[R0, #+8]
   \   00000048   0324               MOVS     R4,#+3
   \   0000004A   1500               MOVS     R5,R2
   \   0000004C   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   6D00               LSLS     R5,R5,#+1
   \   00000050   AC40               LSLS     R4,R4,R5
   \   00000052   A343               BICS     R3,R3,R4
   \   00000054   8360               STR      R3,[R0, #+8]
    177                  GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
   \   00000056   8368               LDR      R3,[R0, #+8]
   \   00000058   4C79               LDRB     R4,[R1, #+5]
   \   0000005A   1500               MOVS     R5,R2
   \   0000005C   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   6D00               LSLS     R5,R5,#+1
   \   00000060   AC40               LSLS     R4,R4,R5
   \   00000062   2343               ORRS     R3,R4,R3
   \   00000064   8360               STR      R3,[R0, #+8]
    178                  /*Check Output mode parameters */
    179                  assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));
    180                  /* Output mode configuartion*/
    181                  GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
   \   00000066   4368               LDR      R3,[R0, #+4]
   \   00000068   0124               MOVS     R4,#+1
   \   0000006A   9440               LSLS     R4,R4,R2
   \   0000006C   A343               BICS     R3,R3,R4
   \   0000006E   4360               STR      R3,[R0, #+4]
    182                  GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
   \   00000070   4368               LDR      R3,[R0, #+4]
   \   00000072   8C79               LDRB     R4,[R1, #+6]
   \   00000074   9440               LSLS     R4,R4,R2
   \   00000076   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000078   2343               ORRS     R3,R4,R3
   \   0000007A   4360               STR      R3,[R0, #+4]
    183                }
    184                /*Pull-up Pull down resistor configuration*/
    185                GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
   \                     ??GPIO_Init_4:
   \   0000007C   C368               LDR      R3,[R0, #+12]
   \   0000007E   0324               MOVS     R4,#+3
   \   00000080   1500               MOVS     R5,R2
   \   00000082   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000084   6D00               LSLS     R5,R5,#+1
   \   00000086   AC40               LSLS     R4,R4,R5
   \   00000088   A343               BICS     R3,R3,R4
   \   0000008A   C360               STR      R3,[R0, #+12]
    186                GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
   \   0000008C   C368               LDR      R3,[R0, #+12]
   \   0000008E   CC79               LDRB     R4,[R1, #+7]
   \   00000090   1500               MOVS     R5,R2
   \   00000092   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000094   6D00               LSLS     R5,R5,#+1
   \   00000096   AC40               LSLS     R4,R4,R5
   \   00000098   2343               ORRS     R3,R4,R3
   \   0000009A   C360               STR      R3,[R0, #+12]
    187              }
    188            }
   \                     ??GPIO_Init_2:
   \   0000009C   521C               ADDS     R2,R2,#+1
   \                     ??GPIO_Init_0:
   \   0000009E   102A               CMP      R2,#+16
   \   000000A0   B5D3               BCC.N    ??GPIO_Init_1
    189          }
   \   000000A2   30BC               POP      {R4,R5}
   \   000000A4   7047               BX       LR               ;; return
    190          
    191          /**
    192            * @brief  Fills each GPIO_InitStruct member with its default value.
    193            * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will be initialized.
    194            * @retval None
    195            */

   \                                 In section .text, align 2, keep-with-next
    196          void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
    197          {
    198            /* Reset GPIO init structure parameters values */
    199            GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
   \                     GPIO_StructInit:
   \   00000000   4FF6FF71           MOVW     R1,#+65535
   \   00000004   0160               STR      R1,[R0, #+0]
    200            GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   0171               STRB     R1,[R0, #+4]
    201            GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   4171               STRB     R1,[R0, #+5]
    202            GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
   \   0000000E   0021               MOVS     R1,#+0
   \   00000010   8171               STRB     R1,[R0, #+6]
    203            GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
   \   00000012   0021               MOVS     R1,#+0
   \   00000014   C171               STRB     R1,[R0, #+7]
    204          }
   \   00000016   7047               BX       LR               ;; return
    205          
    206          /**
    207            * @brief  Reads the specified input port pin.
    208            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    209            * @param  GPIO_Pin:  specifies the port bit to read.
    210            *   This parameter can be GPIO_Pin_x where x can be (0..15).
    211            * @retval The input port pin value.
    212            */

   \                                 In section .text, align 2, keep-with-next
    213          uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    214          {
    215            uint8_t bitstatus = 0x00;
   \                     GPIO_ReadInputDataBit:
   \   00000000   0022               MOVS     R2,#+0
    216          
    217            /* Check the parameters */
    218            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    219            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    220          
    221            if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
   \   00000002   0069               LDR      R0,[R0, #+16]
   \   00000004   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000006   0842               TST      R0,R1
   \   00000008   01D0               BEQ.N    ??GPIO_ReadInputDataBit_0
    222            {
    223              bitstatus = (uint8_t)Bit_SET;
   \   0000000A   0122               MOVS     R2,#+1
   \   0000000C   00E0               B.N      ??GPIO_ReadInputDataBit_1
    224            }
    225            else
    226            {
    227              bitstatus = (uint8_t)Bit_RESET;
   \                     ??GPIO_ReadInputDataBit_0:
   \   0000000E   0022               MOVS     R2,#+0
    228            }
    229            return bitstatus;
   \                     ??GPIO_ReadInputDataBit_1:
   \   00000010   1000               MOVS     R0,R2
   \   00000012   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   7047               BX       LR               ;; return
    230          }
    231          
    232          /**
    233            * @brief  Reads the specified GPIO input data port.
    234            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    235            * @retval GPIO input data port value.
    236            */

   \                                 In section .text, align 2, keep-with-next
    237          uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
    238          {
    239            /* Check the parameters */
    240            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    241          
    242            return ((uint16_t)GPIOx->IDR);
   \                     GPIO_ReadInputData:
   \   00000000   0069               LDR      R0,[R0, #+16]
   \   00000002   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   7047               BX       LR               ;; return
    243          }
    244          
    245          /**
    246            * @brief  Reads the specified output data port bit.
    247            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    248            * @param  GPIO_Pin:  specifies the port bit to read.
    249            *   This parameter can be GPIO_Pin_x where x can be (0..15).
    250            * @retval The output port pin value.
    251            */

   \                                 In section .text, align 2, keep-with-next
    252          uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    253          {
    254            uint8_t bitstatus = 0x00;
   \                     GPIO_ReadOutputDataBit:
   \   00000000   0022               MOVS     R2,#+0
    255            /* Check the parameters */
    256            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    257            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    258          
    259            if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
   \   00000002   4069               LDR      R0,[R0, #+20]
   \   00000004   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000006   0842               TST      R0,R1
   \   00000008   01D0               BEQ.N    ??GPIO_ReadOutputDataBit_0
    260            {
    261              bitstatus = (uint8_t)Bit_SET;
   \   0000000A   0122               MOVS     R2,#+1
   \   0000000C   00E0               B.N      ??GPIO_ReadOutputDataBit_1
    262            }
    263            else
    264            {
    265              bitstatus = (uint8_t)Bit_RESET;
   \                     ??GPIO_ReadOutputDataBit_0:
   \   0000000E   0022               MOVS     R2,#+0
    266            }
    267            return bitstatus;
   \                     ??GPIO_ReadOutputDataBit_1:
   \   00000010   1000               MOVS     R0,R2
   \   00000012   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   7047               BX       LR               ;; return
    268          }
    269          
    270          /**
    271            * @brief  Reads the specified GPIO output data port.
    272            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    273            * @retval GPIO output data port value.
    274            */

   \                                 In section .text, align 2, keep-with-next
    275          uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
    276          {
    277            /* Check the parameters */
    278            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    279          
    280            return ((uint16_t)GPIOx->ODR);
   \                     GPIO_ReadOutputData:
   \   00000000   4069               LDR      R0,[R0, #+20]
   \   00000002   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   7047               BX       LR               ;; return
    281          }
    282          
    283          /**
    284            * @brief  Sets the selected data port bits.
    285            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    286            * @param  GPIO_Pin: specifies the port bits to be written.
    287            *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    288            * @retval None
    289            */

   \                                 In section .text, align 2, keep-with-next
    290          void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    291          {
    292            /* Check the parameters */
    293            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    294            assert_param(IS_GPIO_PIN(GPIO_Pin));
    295          
    296            GPIOx->BSRRL = GPIO_Pin;
   \                     GPIO_SetBits:
   \   00000000   0183               STRH     R1,[R0, #+24]
    297          }
   \   00000002   7047               BX       LR               ;; return
    298          
    299          /**
    300            * @brief  Clears the selected data port bits.
    301            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    302            * @param  GPIO_Pin: specifies the port bits to be written.
    303            *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    304            * @retval None
    305            */

   \                                 In section .text, align 2, keep-with-next
    306          void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    307          {
    308            /* Check the parameters */
    309            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    310            assert_param(IS_GPIO_PIN(GPIO_Pin));
    311          
    312            GPIOx->BSRRH = GPIO_Pin;
   \                     GPIO_ResetBits:
   \   00000000   4183               STRH     R1,[R0, #+26]
    313          }
   \   00000002   7047               BX       LR               ;; return
    314          
    315          /**
    316            * @brief  Sets or clears the selected data port bit.
    317            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    318            * @param  GPIO_Pin: specifies the port bit to be written.
    319            *   This parameter can be one of GPIO_Pin_x where x can be (0..15).
    320            * @param  BitVal: specifies the value to be written to the selected bit.
    321            *   This parameter can be one of the BitAction enum values:
    322            *     @arg Bit_RESET: to clear the port pin
    323            *     @arg Bit_SET: to set the port pin
    324            * @retval None
    325            */

   \                                 In section .text, align 2, keep-with-next
    326          void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
    327          {
    328            /* Check the parameters */
    329            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    330            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    331            assert_param(IS_GPIO_BIT_ACTION(BitVal));
    332          
    333            if (BitVal != Bit_RESET)
   \                     GPIO_WriteBit:
   \   00000000   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   002A               CMP      R2,#+0
   \   00000004   01D0               BEQ.N    ??GPIO_WriteBit_0
    334            {
    335              GPIOx->BSRRL = GPIO_Pin;
   \   00000006   0183               STRH     R1,[R0, #+24]
   \   00000008   00E0               B.N      ??GPIO_WriteBit_1
    336            }
    337            else
    338            {
    339              GPIOx->BSRRH = GPIO_Pin ;
   \                     ??GPIO_WriteBit_0:
   \   0000000A   4183               STRH     R1,[R0, #+26]
    340            }
    341          }
   \                     ??GPIO_WriteBit_1:
   \   0000000C   7047               BX       LR               ;; return
    342          
    343          /**
    344            * @brief  Writes data to the specified GPIO data port.
    345            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    346            * @param  PortVal: specifies the value to be written to the port output data register.
    347            * @retval None
    348            */

   \                                 In section .text, align 2, keep-with-next
    349          void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
    350          {
    351            /* Check the parameters */
    352            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    353          
    354            GPIOx->ODR = PortVal;
   \                     GPIO_Write:
   \   00000000   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   4161               STR      R1,[R0, #+20]
    355          }
   \   00000004   7047               BX       LR               ;; return
    356          
    357          /**
    358            * @brief  Toggles the specified GPIO pins..
    359            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    360            * @param  GPIO_Pin: SSpecifies the pins to be toggled.
    361            * @retval None
    362            */

   \                                 In section .text, align 2, keep-with-next
    363          void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    364          {
    365            /* Check the parameters */
    366            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    367          
    368            GPIOx->ODR ^= GPIO_Pin;
   \                     GPIO_ToggleBits:
   \   00000000   4269               LDR      R2,[R0, #+20]
   \   00000002   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000004   5140               EORS     R1,R1,R2
   \   00000006   4161               STR      R1,[R0, #+20]
    369          }
   \   00000008   7047               BX       LR               ;; return
    370          
    371          /**
    372            * @brief  Locks GPIO Pins configuration registers.
    373            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    374            * @param  GPIO_Pin: specifies the port bit to be locked.
    375            *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    376            * @retval None
    377            */

   \                                 In section .text, align 2, keep-with-next
    378          void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    379          {
    380            uint32_t tmp = 0x00010000;
   \                     GPIO_PinLockConfig:
   \   00000000   5FF48032           MOVS     R2,#+65536
    381          
    382            /* Check the parameters */
    383            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    384            assert_param(IS_GPIO_PIN(GPIO_Pin));
    385          
    386            tmp |= GPIO_Pin;
   \   00000004   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   0A43               ORRS     R2,R1,R2
    387            /* Set LCKK bit */
    388            GPIOx->LCKR = tmp;
   \   00000008   C261               STR      R2,[R0, #+28]
    389            /* Reset LCKK bit */
    390            GPIOx->LCKR =  GPIO_Pin;
   \   0000000A   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   C161               STR      R1,[R0, #+28]
    391            /* Set LCKK bit */
    392            GPIOx->LCKR = tmp;
   \   0000000E   C261               STR      R2,[R0, #+28]
    393            /* Read LCKK bit*/
    394            tmp = GPIOx->LCKR;
   \   00000010   C269               LDR      R2,[R0, #+28]
    395            /* Read LCKK bit*/
    396            tmp = GPIOx->LCKR;
   \   00000012   C069               LDR      R0,[R0, #+28]
   \   00000014   0200               MOVS     R2,R0
    397          }
   \   00000016   7047               BX       LR               ;; return
    398          
    399          
    400          /**
    401            * @brief  Changes the mapping of the specified pin.
    402            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    403            * @param  GPIO_PinSource: specifies the pin for the Alternate function.
    404            *   This parameter can be GPIO_PinSourcex where x can be (0..15).
    405            * @param  GPIO_AFSelection: selects the pin to used as Alternat function.
    406            *   This parameter can be one of the following values:
    407            *     @arg GPIO_AF_RTC_50Hz
    408            *     @arg GPIO_AF_MCO
    409            *     @arg GPIO_AF_TAMPER
    410            *     @arg GPIO_AF_SWJ
    411            *     @arg GPIO_AF_TRACE
    412            *     @arg GPIO_AF_TIM1
    413            *     @arg GPIO_AF_TIM2
    414            *     @arg GPIO_AF_TIM3
    415            *     @arg GPIO_AF_TIM4
    416            *     @arg GPIO_AF_TIM5
    417            *     @arg GPIO_AF_TIM8
    418            *     @arg GPIO_AF_TIM9
    419            *     @arg GPIO_AF_TIM10
    420            *     @arg GPIO_AF_TIM11
    421            *     @arg GPIO_AF_I2C1
    422            *     @arg GPIO_AF_I2C2
    423            *     @arg GPIO_AF_I2C3
    424            *     @arg GPIO_AF_SPI1
    425            *     @arg GPIO_AF_SPI2
    426            *     @arg GPIO_AF_SPI3
    427            *     @arg GPIO_AF_USART1
    428            *     @arg GPIO_AF_USART2
    429            *     @arg GPIO_AF_USART3
    430            *     @arg GPIO_AF_UART4
    431            *     @arg GPIO_AF_UART5
    432            *     @arg GPIO_AF_USART6
    433            *     @arg GPIO_AF_CAN1
    434            *     @arg GPIO_AF_CAN2
    435            *     @arg GPIO_AF_TIM12
    436            *     @arg GPIO_AF_TIM13
    437            *     @arg GPIO_AF_TIM14
    438            *     @arg GPIO_AF_OTG1_FS
    439            *     @arg GPIO_AF_OTG2_HS
    440            *     @arg GPIO_AF_ETH
    441            *     @arg GPIO_AF_FSMC
    442            *     @arg GPIO_AF_OTG2_FS
    443            *     @arg GPIO_AF_SDIO
    444            *     @arg GPIO_AF_DCMI
    445            *     @arg GPIO_AF_EVENTOUT
    446            * @retval None
    447            */

   \                                 In section .text, align 2, keep-with-next
    448          void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
    449          {
   \                     GPIO_PinAFConfig:
   \   00000000   F0B4               PUSH     {R4-R7}
    450            uint32_t temp = 0x00;
   \   00000002   0023               MOVS     R3,#+0
    451            uint32_t temp_2 = 0x00;
   \   00000004   0024               MOVS     R4,#+0
    452            
    453            /* Check the parameters */
    454            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    455            assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    456            assert_param(IS_GPIO_AF(GPIO_AF));
    457            
    458            temp = ((uint32_t)(GPIO_AF) << ((uint32_t)(GPIO_PinSource & (uint32_t)0x07) * 4)) ;
   \   00000006   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   11F00705           ANDS     R5,R1,#0x7
   \   0000000C   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   AD00               LSLS     R5,R5,#+2
   \   00000010   AA40               LSLS     R2,R2,R5
   \   00000012   1300               MOVS     R3,R2
    459            GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)(GPIO_PinSource & (uint32_t)0x07) * 4)) ;
   \   00000014   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000016   CA10               ASRS     R2,R1,#+3
   \   00000018   10EB8202           ADDS     R2,R0,R2, LSL #+2
   \   0000001C   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001E   CD10               ASRS     R5,R1,#+3
   \   00000020   10EB8505           ADDS     R5,R0,R5, LSL #+2
   \   00000024   2D6A               LDR      R5,[R5, #+32]
   \   00000026   0F26               MOVS     R6,#+15
   \   00000028   11F00707           ANDS     R7,R1,#0x7
   \   0000002C   FFB2               UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002E   BF00               LSLS     R7,R7,#+2
   \   00000030   BE40               LSLS     R6,R6,R7
   \   00000032   B543               BICS     R5,R5,R6
   \   00000034   1562               STR      R5,[R2, #+32]
    460            temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
   \   00000036   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000038   CA10               ASRS     R2,R1,#+3
   \   0000003A   10EB8202           ADDS     R2,R0,R2, LSL #+2
   \   0000003E   126A               LDR      R2,[R2, #+32]
   \   00000040   1A43               ORRS     R2,R3,R2
   \   00000042   1400               MOVS     R4,R2
    461            GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
   \   00000044   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000046   C910               ASRS     R1,R1,#+3
   \   00000048   10EB8100           ADDS     R0,R0,R1, LSL #+2
   \   0000004C   0462               STR      R4,[R0, #+32]
    462          }
   \   0000004E   F0BC               POP      {R4-R7}
   \   00000050   7047               BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   00000240           DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   00040240           DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   00080240           DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_3:
   \   00000000   000C0240           DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_4:
   \   00000000   00100240           DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_5:
   \   00000000   00140240           DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_6:
   \   00000000   00180240           DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_7:
   \   00000000   001C0240           DC32     0x40021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_8:
   \   00000000   00200240           DC32     0x40022000
    463          /**
    464            * @}
    465            */ 
    466          
    467          
    468          /**
    469            * @}
    470            */ 
    471          
    472          
    473          /**
    474            * @}
    475            */ 
    476          
    477          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function               .cstack
     --------               -------
     GPIO_DeInit                 8
     GPIO_Init                   8
     GPIO_PinAFConfig           16
     GPIO_PinLockConfig          0
     GPIO_ReadInputData          0
     GPIO_ReadInputDataBit       0
     GPIO_ReadOutputData         0
     GPIO_ReadOutputDataBit      0
     GPIO_ResetBits              0
     GPIO_SetBits                0
     GPIO_StructInit             0
     GPIO_ToggleBits             0
     GPIO_Write                  0
     GPIO_WriteBit               0


   Section sizes:

     Function/Label         Bytes
     --------------         -----
     GPIO_DeInit             222
     GPIO_Init               166
     GPIO_StructInit          24
     GPIO_ReadInputDataBit    22
     GPIO_ReadInputData        6
     GPIO_ReadOutputDataBit   22
     GPIO_ReadOutputData       6
     GPIO_SetBits              4
     GPIO_ResetBits            4
     GPIO_WriteBit            14
     GPIO_Write                6
     GPIO_ToggleBits          10
     GPIO_PinLockConfig       24
     GPIO_PinAFConfig         82
     ??DataTable0              4
     ??DataTable0_1            4
     ??DataTable0_2            4
     ??DataTable0_3            4
     ??DataTable0_4            4
     ??DataTable0_5            4
     ??DataTable0_6            4
     ??DataTable0_7            4
     ??DataTable0_8            4

 
 648 bytes in section .text
 
 648 bytes of CODE memory

Errors: none
Warnings: none
