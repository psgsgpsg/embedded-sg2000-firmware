###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.1.52143/W32 for ARM     12/Jan/2012  04:01:44 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\Memory. #
#                    c                                                        #
#    Command line =  "F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\Memory #
#                    .c" -D USE_STDPERIPH_DRIVER -D STM32F2XX -D              #
#                    USE_STM3220F_EVAL -D USE_USB_OTG_FS -D                   #
#                    RTC_CLOCK_SOURCE_LSE -lC "F:\묵작업\[ NewDTG             #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\STM3220F_EVAL\List\" #
#                     -lA "F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\E #
#                    WARM\STM3220F_EVAL\List\" -o "F:\묵작업\[ NewDTG         #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\STM3220F_EVAL\Obj\"  #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0\arm\INC\c\DLib_Config_Full.h" -I           #
#                    "F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\" -I "F:\묵작업\[ NewDTG                              #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\CMSI #
#                    S\CM3\CoreSupport\" -I "F:\묵작업\[ NewDTG               #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\CMSI #
#                    S\CM3\DeviceSupport\ST\STM32F2xx\" -I "F:\묵작업\[       #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Librari #
#                    es\STM32F2xx_StdPeriph_Driver\inc\" -I "F:\묵작업\[      #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utiliti #
#                    es\STM32_EVAL\" -I "F:\묵작업\[ NewDTG                   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\Common\" -I "F:\묵작업\[ NewDTG                   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Utilities\STM3 #
#                    2_EVAL\STM3220F_EVAL\" -I "F:\묵작업\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_OTG_Driver\inc\" -I "F:\묵작업\[ NewDTG            #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Core\inc\" -I "F:\묵작업\[ NewDTG   #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\..\Libraries\STM3 #
#                    2_USB_Device_Library\Class\msc\inc\" -I "F:\묵작업\[     #
#                    NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\" -I   #
#                    "F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\Usb\Inc\" -I "F:\묵작업\[ NewDTG                      #
#                    ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\..\Usb\src\" -I      #
#                    "F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Core\inc\" -I     #
#                    "F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\ #
#                    ..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc\"   #
#                    -I "F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWA #
#                    RM\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\in #
#                    c\" -Ol --use_c++_inline                                 #
#    List file    =  F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\List\Memory.lst                             #
#    Object file  =  F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\EWARM\S #
#                    TM3220F_EVAL\Obj\Memory.o                                #
#                                                                             #
#                                                                             #
###############################################################################

F:\묵작업\[ NewDTG ]\WORK\DTG_EMS_SYSTEM\Project\Memory.c
      1          #include <stdio.h>
      2          #include "Memory.h"
      3          #include "fsmc_nand.h"
      4          #include "main.h"

   \                                 In section .text, align 2
   \   __intrinsic __interwork __softfp void *memcpy(void *, void const *, size_t)
   \                     memcpy:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           BL       __aeabi_memcpy
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   10BD               POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __intrinsic __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   1000               MOVS     R0,R2
   \   00000006   0A00               MOVS     R2,R1
   \   00000008   0100               MOVS     R1,R0
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   ........           BL       __aeabi_memset
   \   00000010   2000               MOVS     R0,R4
   \   00000012   10BD               POP      {R4,PC}          ;; return
      5          #include "Eeprom.h"
      6          #include "i2c_ee.h"
      7          #ifdef DEBUG_LOG 
      8               #include "Log.h"
      9          #endif
     10          #include "rtc.h"
     11          #include "usbh_usr.h"
     12          #include "nand_if.h"
     13          #include "Ems_System.h"

   \                                 In section .bss, align 4
     14          struct __ViewHeader VIEW_Header;              // 읽어올때 해더를 가르킨다.              // 읽어올때 해더를 가르킨다.
   \                     VIEW_Header:
   \   00000000                      DS8 24
     15          

   \                                 In section .bss, align 4
     16          HEADER_EMS_ACCRUE I2C_Ems_Accure;
   \                     I2C_Ems_Accure:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
     17          HEADER_Info NAND_Header_Info;				// PAGE에 저장하기 위한 변수
   \                     NAND_Header_Info:
   \   00000000                      DS8 16

   \                                 In section .bss, align 4
     18          HEADER_Index NAND_Header_Index;
   \                     NAND_Header_Index:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
     19          DATA_Transmit NAND_Data_Transmit;
   \                     NAND_Data_Transmit:
   \   00000000                      DS8 12
     20          
     21          //struct __BIN_AVERAGE_BUFFER Average_Memory[10];		// 1초간 10개의 평균 내기위한 변수
     22          

   \                                 In section .text, align 2, keep-with-next
     23          u16 GetHeader_Index(u16 PageNum, s16 Add)        // 페이지의 
     24          {
     25               int Page;
     26               Page = PageNum;     
   \                     GetHeader_Index:
   \   00000000   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
     27               
     28               if( Page + Add < 0 )
   \   00000002   09B2               SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   00000004   0A18               ADDS     R2,R1,R0
   \   00000006   002A               CMP      R2,#+0
   \   00000008   03D5               BPL.N    ??GetHeader_Index_0
     29               {
     30                    Page = MAX_HEADER_PAGE + Page + Add;
   \   0000000A   09B2               SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   0000000C   D231               ADDS     R1,R1,#+210
   \   0000000E   0818               ADDS     R0,R1,R0
   \   00000010   09E0               B.N      ??GetHeader_Index_1
     31               }else if ( Page + Add > MAX_HEADER_PAGE )    // 210 을 넘었다면
   \                     ??GetHeader_Index_0:
   \   00000012   09B2               SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   00000014   0A18               ADDS     R2,R1,R0
   \   00000016   D32A               CMP      R2,#+211
   \   00000018   03DB               BLT.N    ??GetHeader_Index_2
     32               {
     33                    Page = Add  - ( MAX_HEADER_PAGE - Page + 1);
   \   0000001A   09B2               SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   0000001C   D339               SUBS     R1,R1,#+211
   \   0000001E   0818               ADDS     R0,R1,R0
   \   00000020   01E0               B.N      ??GetHeader_Index_1
     34               }else
     35                    Page += Add;
   \                     ??GetHeader_Index_2:
   \   00000022   09B2               SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   00000024   0818               ADDS     R0,R1,R0
     36               
     37               return Page;
   \                     ??GetHeader_Index_1:
   \   00000026   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000028   7047               BX       LR               ;; return
     38          }
     39          

   \                                 In section .bss, align 4
     40          struct _BIN_NAND_DTG_DATA DTG_NAND_Binary[DATA_IN_PAGE_SIZE];
   \                     DTG_NAND_Binary:
   \   00000000                      DS8 6392
     41          
     42          //////////////////////////////////////////////////////////////////////////////////
     43          // 
     44          // 검색 날짜와 종료 날짜를 입력 받아서 
     45          // VIEW_Header.Start_Index, VIEW_Header.End_Index 로 반환해준다.
     46          //

   \                                 In section .text, align 2, keep-with-next
     47          void Search_Header( u32 StartTime ,u32 Time)
     48          {
     49          //     
     50          //     HEADER_Info Tmp_Info;
     51          //
     52          //     VIEW_Header.End_Index = StartTime;       // 시작하는 오늘 카운터                 
     53          //     for( i = Time ; i > Time ; i-- )
     54          //     {
     55          //          Tmp_Info = Read_Header_Information( i );   // 순서대로 저장되어있는 해더 데이터를 읽어온다.
     56          //          if( Tmp_Info.Verify == I2C_EEPROM_VERIFY3 )
     57          //          {
     58          //               VIEW_Header.Start_Index = i;               
     59          //          } 
     60          //          if( i == 0 )
     61          //          {
     62          //               
     63          //          }
     64          //     }     
     65          }
   \                     Search_Header:
   \   00000000   7047               BX       LR               ;; return
     66          

   \                                 In section .text, align 2, keep-with-next
     67          void Setting_Header_Information(void)
     68          {	   
   \                     Setting_Header_Information:
   \   00000000   80B5               PUSH     {R7,LR}
     69          	//  ----- 신규 해더를 세팅한다. -----------------------------------------
     70               memset(&NAND_Header_Info,0,sizeof(NAND_Header_Info));
   \   00000002   1022               MOVS     R2,#+16
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   ........           LDR.W    R0,??DataTable16
   \   0000000A   ........           BL       memset
     71          	NAND_Header_Info.Date[0] = SYSTEM_TIME.tm_year - 2000;
   \   0000000E   ........           LDR.W    R0,??DataTable16_1
   \   00000012   4069               LDR      R0,[R0, #+20]
   \   00000014   3030               ADDS     R0,R0,#+48
   \   00000016   ........           LDR.W    R1,??DataTable16
   \   0000001A   0870               STRB     R0,[R1, #+0]
     72          	NAND_Header_Info.Date[1] = SYSTEM_TIME.tm_mon;
   \   0000001C   ........           LDR.W    R0,??DataTable16
   \   00000020   ........           LDR.W    R1,??DataTable16_1
   \   00000024   0969               LDR      R1,[R1, #+16]
   \   00000026   4170               STRB     R1,[R0, #+1]
     73          	NAND_Header_Info.Date[2] = SYSTEM_TIME.tm_mday;	//현재 날짜와 마지막 페이지 주소를 기록
   \   00000028   ........           LDR.W    R0,??DataTable16
   \   0000002C   ........           LDR.W    R1,??DataTable16_1
   \   00000030   C968               LDR      R1,[R1, #+12]
   \   00000032   8170               STRB     R1,[R0, #+2]
     74          	NAND_Header_Info.Start_Page = NAND_Header_Index.Page_Count;	// 지난 마지막 해더의 페이지 번호를 읽어 온다.
   \   00000034   ........           LDR.W    R0,??DataTable16
   \   00000038   ........           LDR.W    R1,??DataTable16_2
   \   0000003C   4968               LDR      R1,[R1, #+4]
   \   0000003E   4160               STR      R1,[R0, #+4]
     75          	NAND_Header_Info.End_Page = NAND_Header_Index.Page_Count;	
   \   00000040   ........           LDR.W    R0,??DataTable16
   \   00000044   ........           LDR.W    R1,??DataTable16_2
   \   00000048   4968               LDR      R1,[R1, #+4]
   \   0000004A   8160               STR      R1,[R0, #+8]
     76               NAND_Header_Info.Verify = I2C_EEPROM_VERIFY3;
   \   0000004C   ........           LDR.W    R0,??DataTable16
   \   00000050   4EF60661           MOVW     R1,#+60934
   \   00000054   8181               STRH     R1,[R0, #+12]
     77          }
   \   00000056   01BD               POP      {R0,PC}          ;; return
     78          

   \                                 In section .text, align 2, keep-with-next
     79          HEADER_Info Read_Header_Information(u16 Header_Index)
     80          {
   \                     Read_Header_Information:
   \   00000000   1FB5               PUSH     {R0-R4,LR}
   \   00000002   0400               MOVS     R4,R0
     81          	HEADER_Info TempHeader;
     82          
     83          	// ----- EEPROM 에 해더의 위치를 찾아 기록 한다.
     84          
     85          	I2C_EE_BufferRead(Buffer, I2C_EEPROM_WriteAddress3 + ( Header_Index * HEADER_INFO_SIZE ) , HEADER_INFO_SIZE ); 	
   \   00000004   1022               MOVS     R2,#+16
   \   00000006   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000008   0801               LSLS     R0,R1,#+4
   \   0000000A   10F18001           ADDS     R1,R0,#+128
   \   0000000E   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000010   ........           LDR.W    R0,??DataTable16_3
   \   00000014   ........           BL       I2C_EE_BufferRead
     86          	memcpy(&TempHeader, Buffer, HEADER_INFO_SIZE );	
   \   00000018   1022               MOVS     R2,#+16
   \   0000001A   ........           LDR.W    R1,??DataTable16_3
   \   0000001E   00A8               ADD      R0,SP,#+0
   \   00000020   ........           BL       memcpy
     87               if( TempHeader.Verify != I2C_EEPROM_VERIFY3 )
   \   00000024   BDF80C00           LDRH     R0,[SP, #+12]
   \   00000028   4EF60661           MOVW     R1,#+60934
   \   0000002C   8842               CMP      R0,R1
   \   0000002E   04D0               BEQ.N    ??Read_Header_Information_0
     88               {
     89                    memset(&TempHeader,0,HEADER_INFO_SIZE);          
   \   00000030   1022               MOVS     R2,#+16
   \   00000032   0021               MOVS     R1,#+0
   \   00000034   00A8               ADD      R0,SP,#+0
   \   00000036   ........           BL       memset
     90               }
     91          #ifdef DEBUG_LOG 
     92          	if(LOGWRITE & LOG_MEMORY)
     93          	{
     94          		sprintf((char *)Buffer,"READ HEADER_INFORMATION %d\r\n", Header_Index);
     95          		Write_Log(Buffer, NORMAL_LOG);
     96          	}	
     97          #endif
     98          	return TempHeader;     
   \                     ??Read_Header_Information_0:
   \   0000003A   2000               MOVS     R0,R4
   \   0000003C   00A9               ADD      R1,SP,#+0
   \   0000003E   1022               MOVS     R2,#+16
   \   00000040   ........           BL       __aeabi_memcpy4
   \   00000044   04B0               ADD      SP,SP,#+16
   \   00000046   10BD               POP      {R4,PC}          ;; return
     99          }
    100          

   \                                 In section .text, align 2, keep-with-next
    101          void Memory_Config(void)
    102          {	
   \                     Memory_Config:
   \   00000000   1FB5               PUSH     {R0-R4,LR}
    103          	// ----- EEPROM 에서 헤더위치를 찾어서 읽어온다.
    104               u32 DataSize;
    105               u32 PageNum;
    106          
    107          
    108          //     NAND_ADDRESS NAND_PAGE;
    109               
    110          	I2C_EE_BufferRead(Buffer, I2C_EEPROM_WriteAddress1 , sizeof(HEADER_Index) ); 	
   \   00000002   0A22               MOVS     R2,#+10
   \   00000004   4021               MOVS     R1,#+64
   \   00000006   ........           LDR.W    R0,??DataTable16_3
   \   0000000A   ........           BL       I2C_EE_BufferRead
    111          	memcpy(&NAND_Header_Index,Buffer,sizeof(HEADER_Index));	
   \   0000000E   0A22               MOVS     R2,#+10
   \   00000010   ........           LDR.W    R1,??DataTable16_3
   \   00000014   ........           LDR.W    R0,??DataTable16_2
   \   00000018   ........           BL       memcpy
    112               
    113               if(NAND_Header_Index.Verify != I2C_EEPROM_VERIFY1)            // 처음라면 리셋 시켜준다.ㄴ
   \   0000001C   ........           LDR.W    R0,??DataTable16_2
   \   00000020   0089               LDRH     R0,[R0, #+8]
   \   00000022   4EF60361           MOVW     R1,#+60931
   \   00000026   8842               CMP      R0,R1
   \   00000028   20D0               BEQ.N    ??Memory_Config_0
    114               {
    115                    NAND_Header_Index.Write_Point = 0;
   \   0000002A   ........           LDR.W    R0,??DataTable16_2
   \   0000002E   0021               MOVS     R1,#+0
   \   00000030   4180               STRH     R1,[R0, #+2]
    116                    NAND_Header_Index.Page_Count = 0;
   \   00000032   ........           LDR.W    R0,??DataTable16_2
   \   00000036   0021               MOVS     R1,#+0
   \   00000038   4160               STR      R1,[R0, #+4]
    117                    NAND_Header_Index.Verify = I2C_EEPROM_VERIFY1;
   \   0000003A   ........           LDR.W    R0,??DataTable16_2
   \   0000003E   4EF60361           MOVW     R1,#+60931
   \   00000042   0181               STRH     R1,[R0, #+8]
    118                    
    119                    memcpy(Buffer,&NAND_Header_Index, sizeof(HEADER_Index));	
   \   00000044   0A22               MOVS     R2,#+10
   \   00000046   ........           LDR.W    R1,??DataTable16_2
   \   0000004A   ........           LDR.W    R0,??DataTable16_3
   \   0000004E   ........           BL       memcpy
    120                    I2C_EE_BufferWrite(Buffer, I2C_EEPROM_WriteAddress1 , sizeof(HEADER_Index) ); 	
   \   00000052   0A22               MOVS     R2,#+10
   \   00000054   4021               MOVS     R1,#+64
   \   00000056   ........           LDR.W    R0,??DataTable16_3
   \   0000005A   ........           BL       I2C_EE_BufferWrite
    121                    
    122                    memset(&NAND_Header_Info,0,sizeof(NAND_Header_Info));
   \   0000005E   1022               MOVS     R2,#+16
   \   00000060   0021               MOVS     R1,#+0
   \   00000062   ........           LDR.W    R0,??DataTable16
   \   00000066   ........           BL       memset
   \   0000006A   0BE0               B.N      ??Memory_Config_1
    123                    
    124               }else
    125               {
    126               // -----------------------------------------------------------------------
    127               // 
    128               // - 정보 읽기
    129               // - 현재 인포의 정보를 읽어온다.
    130               //
    131               // -----------------------------------------------------------------------
    132          
    133                    NAND_Header_Info = Read_Header_Information(NAND_Header_Index.Write_Point);
   \                     ??Memory_Config_0:
   \   0000006C   ........           LDR.W    R0,??DataTable16_2
   \   00000070   4188               LDRH     R1,[R0, #+2]
   \   00000072   00A8               ADD      R0,SP,#+0
   \   00000074   ........           BL       Read_Header_Information
   \   00000078   ........           LDR.W    R0,??DataTable16
   \   0000007C   00A9               ADD      R1,SP,#+0
   \   0000007E   1022               MOVS     R2,#+16
   \   00000080   ........           BL       __aeabi_memcpy4
    134               }
    135               //------------------------------------------------------------------------
    136               //
    137               //   전송 데이터 위치 저장
    138               //
    139               //------------------------------------------------------------------------
    140          
    141          	I2C_EE_BufferRead(Buffer, I2C_EEPROM_WriteAddress2 , sizeof(DATA_Transmit) ); 	
   \                     ??Memory_Config_1:
   \   00000084   0A22               MOVS     R2,#+10
   \   00000086   6021               MOVS     R1,#+96
   \   00000088   ........           LDR.W    R0,??DataTable16_3
   \   0000008C   ........           BL       I2C_EE_BufferRead
    142          	memcpy(&NAND_Data_Transmit,Buffer,sizeof(DATA_Transmit));	
   \   00000090   0A22               MOVS     R2,#+10
   \   00000092   ........           LDR.W    R1,??DataTable16_3
   \   00000096   ........           LDR.W    R0,??DataTable16_4
   \   0000009A   ........           BL       memcpy
    143               
    144               if(NAND_Data_Transmit.Verify != I2C_EEPROM_VERIFY2)            // 처음라면 리셋 시켜준다.
   \   0000009E   ........           LDR.W    R0,??DataTable16_4
   \   000000A2   0089               LDRH     R0,[R0, #+8]
   \   000000A4   4EF60461           MOVW     R1,#+60932
   \   000000A8   8842               CMP      R0,R1
   \   000000AA   19D0               BEQ.N    ??Memory_Config_2
    145               {
    146                    NAND_Data_Transmit.Start_Page = 0;
   \   000000AC   ........           LDR.W    R0,??DataTable16_4
   \   000000B0   0021               MOVS     R1,#+0
   \   000000B2   0160               STR      R1,[R0, #+0]
    147                    NAND_Data_Transmit.End_Page = 0;
   \   000000B4   ........           LDR.W    R0,??DataTable16_4
   \   000000B8   0021               MOVS     R1,#+0
   \   000000BA   4160               STR      R1,[R0, #+4]
    148                    NAND_Data_Transmit.Verify = I2C_EEPROM_VERIFY2;
   \   000000BC   ........           LDR.W    R0,??DataTable16_4
   \   000000C0   4EF60461           MOVW     R1,#+60932
   \   000000C4   0181               STRH     R1,[R0, #+8]
    149                    
    150                    memcpy(Buffer,&NAND_Data_Transmit, sizeof(DATA_Transmit));	
   \   000000C6   0A22               MOVS     R2,#+10
   \   000000C8   ........           LDR.W    R1,??DataTable16_4
   \   000000CC   ........           LDR.W    R0,??DataTable16_3
   \   000000D0   ........           BL       memcpy
    151                    I2C_EE_BufferWrite(Buffer, I2C_EEPROM_WriteAddress2 , sizeof(DATA_Transmit) ); 	
   \   000000D4   0A22               MOVS     R2,#+10
   \   000000D6   6021               MOVS     R1,#+96
   \   000000D8   ........           LDR.W    R0,??DataTable16_3
   \   000000DC   ........           BL       I2C_EE_BufferWrite
    152               }
    153               
    154              	I2C_EE_BufferRead(Buffer, I2C_EEPROM_WriteAddress0 , sizeof(I2C_Ems_Accure) ); 	
   \                     ??Memory_Config_2:
   \   000000E0   0722               MOVS     R2,#+7
   \   000000E2   0021               MOVS     R1,#+0
   \   000000E4   ........           LDR.W    R0,??DataTable16_3
   \   000000E8   ........           BL       I2C_EE_BufferRead
    155          	memcpy(&I2C_Ems_Accure,Buffer,sizeof(I2C_Ems_Accure));	
   \   000000EC   0722               MOVS     R2,#+7
   \   000000EE   ........           LDR.W    R1,??DataTable16_3
   \   000000F2   ........           LDR.W    R0,??DataTable16_5
   \   000000F6   ........           BL       memcpy
    156               
    157               if(I2C_Ems_Accure.Verify != I2C_EEPROM_VERIFY0)
   \   000000FA   ........           LDR.W    R0,??DataTable16_5
   \   000000FE   B0F80500           LDRH     R0,[R0, #+5]
   \   00000102   4EF60261           MOVW     R1,#+60930
   \   00000106   8842               CMP      R0,R1
   \   00000108   11D0               BEQ.N    ??Memory_Config_3
    158               {                    
    159                    memset(&I2C_Ems_Accure,0,sizeof(I2C_Ems_Accure));            
   \   0000010A   0722               MOVS     R2,#+7
   \   0000010C   0021               MOVS     R1,#+0
   \   0000010E   ........           LDR.W    R0,??DataTable16_5
   \   00000112   ........           BL       memset
    160                    I2C_Ems_Accure.Verify = I2C_EEPROM_VERIFY0;          
   \   00000116   ........           LDR.W    R0,??DataTable16_5
   \   0000011A   4EF60261           MOVW     R1,#+60930
   \   0000011E   A0F80510           STRH     R1,[R0, #+5]
    161                    I2C_EE_BufferWrite(Buffer, I2C_EEPROM_WriteAddress0 , sizeof(I2C_Ems_Accure)  );
   \   00000122   0722               MOVS     R2,#+7
   \   00000124   0021               MOVS     R1,#+0
   \   00000126   ........           LDR.W    R0,??DataTable16_3
   \   0000012A   ........           BL       I2C_EE_BufferWrite
    162               }
    163          
    164               Info.EcoStatus = I2C_Ems_Accure.ECO_Drive;     
   \                     ??Memory_Config_3:
   \   0000012E   ........           LDR.W    R0,??DataTable16_6
   \   00000132   ........           LDR.W    R1,??DataTable16_5
   \   00000136   0978               LDRB     R1,[R1, #+0]
   \   00000138   0176               STRB     R1,[R0, #+24]
    165              
    166               
    167               Info.AccidentCount = I2C_Ems_Accure.AccidentCount;
   \   0000013A   ........           LDR.W    R0,??DataTable16_6
   \   0000013E   ........           LDR.W    R1,??DataTable16_5
   \   00000142   B1F80310           LDRH     R1,[R1, #+3]
   \   00000146   8184               STRH     R1,[R0, #+36]
    168               Info.Accident_WritePoint = I2C_Ems_Accure.Accident_WritePoint;
   \   00000148   ........           LDR.W    R0,??DataTable16_6
   \   0000014C   ........           LDR.W    R1,??DataTable16_5
   \   00000150   B1F80110           LDRH     R1,[R1, #+1]
   \   00000154   C184               STRH     R1,[R0, #+38]
    169               
    170               DTG_EMS_DataLoad( NAND_Header_Index.Page_Count - 1);  
   \   00000156   ........           LDR.W    R0,??DataTable16_2
   \   0000015A   4068               LDR      R0,[R0, #+4]
   \   0000015C   401E               SUBS     R0,R0,#+1
   \   0000015E   ........           BL       DTG_EMS_DataLoad
    171               
    172               DataSize = sizeof(EMS_DRIVE_VALUE);
   \   00000162   2524               MOVS     R4,#+37
    173               
    174               memcpy(&EMS_Drive_Value, NAND_Buffer,sizeof(EMS_DRIVE_VALUE));
   \   00000164   2522               MOVS     R2,#+37
   \   00000166   ........           LDR.W    R1,??DataTable16_7
   \   0000016A   ........           LDR.W    R0,??DataTable16_8
   \   0000016E   ........           BL       memcpy
    175              
    176               memcpy(&ACC_Drive_Value, &NAND_Buffer[DataSize],sizeof(ACC_DRIVE_VALUE)); 
   \   00000172   0922               MOVS     R2,#+9
   \   00000174   ........           LDR.W    R0,??DataTable16_7
   \   00000178   2118               ADDS     R1,R4,R0
   \   0000017A   ........           LDR.W    R0,??DataTable16_9
   \   0000017E   ........           BL       memcpy
    177               
    178               // [V000031] 누적데이터가 깨질경우 클리어 추가 --------------------------
    179               
    180               if(EMS_Drive_Value.DataValid != 1) 
   \   00000182   ........           LDR.W    R0,??DataTable16_8
   \   00000186   90F82400           LDRB     R0,[R0, #+36]
   \   0000018A   0128               CMP      R0,#+1
   \   0000018C   05D0               BEQ.N    ??Memory_Config_4
    181                    memset(&EMS_Drive_Value, 0,sizeof(EMS_DRIVE_VALUE));
   \   0000018E   2522               MOVS     R2,#+37
   \   00000190   0021               MOVS     R1,#+0
   \   00000192   ........           LDR.W    R0,??DataTable16_8
   \   00000196   ........           BL       memset
    182               
    183               if(ACC_Drive_Value.DataValid != 1)
   \                     ??Memory_Config_4:
   \   0000019A   ........           LDR.W    R0,??DataTable16_9
   \   0000019E   007A               LDRB     R0,[R0, #+8]
   \   000001A0   0128               CMP      R0,#+1
   \   000001A2   05D0               BEQ.N    ??Memory_Config_5
    184                    memset(&ACC_Drive_Value, 0 ,sizeof(ACC_DRIVE_VALUE)); 
   \   000001A4   0922               MOVS     R2,#+9
   \   000001A6   0021               MOVS     R1,#+0
   \   000001A8   ........           LDR.W    R0,??DataTable16_9
   \   000001AC   ........           BL       memset
    185               //------------------------------------------------------------------------
    186               DTG_EMS_DataLoad( NAND_Header_Index.Page_Count );
   \                     ??Memory_Config_5:
   \   000001B0   ........           LDR.W    R0,??DataTable16_2
   \   000001B4   4068               LDR      R0,[R0, #+4]
   \   000001B6   ........           BL       DTG_EMS_DataLoad
    187               
    188               if(NAND_Buffer[8189] == 0xAA && NAND_Buffer[8190] == 0xAA  && NAND_Buffer[8191] == 0xAA )
   \   000001BA   ........           LDR.W    R0,??DataTable16_10
   \   000001BE   0078               LDRB     R0,[R0, #+0]
   \   000001C0   AA28               CMP      R0,#+170
   \   000001C2   38D1               BNE.N    ??Memory_Config_6
   \   000001C4   ........           LDR.W    R0,??DataTable16_11
   \   000001C8   0078               LDRB     R0,[R0, #+0]
   \   000001CA   AA28               CMP      R0,#+170
   \   000001CC   33D1               BNE.N    ??Memory_Config_6
   \   000001CE   ........           LDR.W    R0,??DataTable16_12
   \   000001D2   0078               LDRB     R0,[R0, #+0]
   \   000001D4   AA28               CMP      R0,#+170
   \   000001D6   2ED1               BNE.N    ??Memory_Config_6
    189               {
    190                    // 시작하는 처음 블럭부터 다시 쓴다.
    191                    PageNum = (( NAND_Header_Index.Page_Count / 128 ) *128);
   \   000001D8   ........           LDR.W    R0,??DataTable16_2
   \   000001DC   4068               LDR      R0,[R0, #+4]
   \   000001DE   C009               LSRS     R0,R0,#+7
   \   000001E0   8021               MOVS     R1,#+128
   \   000001E2   01FB00F4           MUL      R4,R1,R0
    192          
    193                    NAND_ERASE_PAGE(PageNum);          
   \   000001E6   2000               MOVS     R0,R4
   \   000001E8   ........           BL       NAND_ERASE_PAGE
    194                                  
    195                    NAND_Header_Info.End_Page = PageNum;           // 초기화시 마지막 페이지가 더작으면
   \   000001EC   ........           LDR.W    R0,??DataTable16
   \   000001F0   8460               STR      R4,[R0, #+8]
    196                    if(NAND_Header_Info.End_Page < NAND_Header_Info.Start_Page)          
   \   000001F2   ........           LDR.W    R0,??DataTable16
   \   000001F6   8068               LDR      R0,[R0, #+8]
   \   000001F8   ........           LDR.W    R1,??DataTable16
   \   000001FC   4968               LDR      R1,[R1, #+4]
   \   000001FE   8842               CMP      R0,R1
   \   00000200   02D2               BCS.N    ??Memory_Config_7
    197                         NAND_Header_Info.Start_Page = PageNum;
   \   00000202   ........           LDR.W    R0,??DataTable16
   \   00000206   4460               STR      R4,[R0, #+4]
    198                    // 총페이지 수만 그대로 남김
    199                    NAND_Header_Index.Page_Count = PageNum;     
   \                     ??Memory_Config_7:
   \   00000208   ........           LDR.W    R0,??DataTable16_2
   \   0000020C   4460               STR      R4,[R0, #+4]
    200                    // 초기화
    201                    
    202                    NAND_Data_Transmit.End_Page = PageNum;       // 초기화시 마지막 페이지가 더작으면
   \   0000020E   ........           LDR.W    R0,??DataTable16_4
   \   00000212   4460               STR      R4,[R0, #+4]
    203                    if(NAND_Data_Transmit.End_Page < NAND_Data_Transmit.Start_Page )
   \   00000214   ........           LDR.W    R0,??DataTable16_4
   \   00000218   4068               LDR      R0,[R0, #+4]
   \   0000021A   ........           LDR.W    R1,??DataTable16_4
   \   0000021E   0968               LDR      R1,[R1, #+0]
   \   00000220   8842               CMP      R0,R1
   \   00000222   02D2               BCS.N    ??Memory_Config_8
    204                         NAND_Data_Transmit.Start_Page = PageNum; 
   \   00000224   ........           LDR.W    R0,??DataTable16_4
   \   00000228   0460               STR      R4,[R0, #+0]
    205                    Write_Header_Index();
   \                     ??Memory_Config_8:
   \   0000022A   ........           BL       Write_Header_Index
    206                    Write_Transmit_Header();
   \   0000022E   ........           BL       Write_Transmit_Header
    207                    Write_Header_Information();
   \   00000232   ........           BL       Write_Header_Information
    208                    
    209               }
    210          }
   \                     ??Memory_Config_6:
   \   00000236   1FBD               POP      {R0-R4,PC}       ;; return
    211          

   \                                 In section .text, align 2, keep-with-next
    212          void Write_Header_EMS(void)           // 인덱스를 저장한다.
    213          {
   \                     Write_Header_EMS:
   \   00000000   80B5               PUSH     {R7,LR}
    214               u16 DataSize;  
                          ^
Warning[Pe177]: variable "DataSize" was declared but never referenced
    215                    
    216               I2C_Ems_Accure.ECO_Drive = Info.EcoStatus ;                   // 기존 에코상태
   \   00000002   ........           LDR.W    R0,??DataTable16_6
   \   00000006   007E               LDRB     R0,[R0, #+24]
   \   00000008   ........           LDR.W    R1,??DataTable16_5
   \   0000000C   0870               STRB     R0,[R1, #+0]
    217               
    218               I2C_Ems_Accure.AccidentCount = Info.AccidentCount ;                   // 사고 이벤트 카운트
   \   0000000E   ........           LDR.W    R0,??DataTable16_5
   \   00000012   ........           LDR.W    R1,??DataTable16_6
   \   00000016   898C               LDRH     R1,[R1, #+36]
   \   00000018   A0F80310           STRH     R1,[R0, #+3]
    219               I2C_Ems_Accure.Accident_WritePoint = Info.Accident_WritePoint ;
   \   0000001C   ........           LDR.W    R0,??DataTable16_5
   \   00000020   ........           LDR.W    R1,??DataTable16_6
   \   00000024   C98C               LDRH     R1,[R1, #+38]
   \   00000026   A0F80110           STRH     R1,[R0, #+1]
    220               
    221          //     I2C_Ems_Accure.Verify = I2C_EEPROM_VERIFY0;                           // 누적 운행거리 저장한다.
    222               memcpy(&Buffer,&I2C_Ems_Accure,sizeof(I2C_Ems_Accure));	     
   \   0000002A   0722               MOVS     R2,#+7
   \   0000002C   ........           LDR.W    R1,??DataTable16_5
   \   00000030   ........           LDR.W    R0,??DataTable16_3
   \   00000034   ........           BL       memcpy
    223               I2C_EE_BufferWrite(Buffer, I2C_EEPROM_WriteAddress0 , sizeof(I2C_Ems_Accure) ); 	      
   \   00000038   0722               MOVS     R2,#+7
   \   0000003A   0021               MOVS     R1,#+0
   \   0000003C   ........           LDR.W    R0,??DataTable16_3
   \   00000040   ........           BL       I2C_EE_BufferWrite
    224          }
   \   00000044   01BD               POP      {R0,PC}          ;; return
    225          

   \                                 In section .text, align 2, keep-with-next
    226          void Write_Header_Index(void)      // NAND 인덱스를 저장
    227          {
   \                     Write_Header_Index:
   \   00000000   80B5               PUSH     {R7,LR}
    228          
    229               NAND_Header_Index.Verify = I2C_EEPROM_VERIFY1;
   \   00000002   ........           LDR.W    R0,??DataTable16_2
   \   00000006   4EF60361           MOVW     R1,#+60931
   \   0000000A   0181               STRH     R1,[R0, #+8]
    230          	memcpy(Buffer,&NAND_Header_Index,sizeof(HEADER_Index));	     
   \   0000000C   0A22               MOVS     R2,#+10
   \   0000000E   ........           LDR.W    R1,??DataTable16_2
   \   00000012   ........           LDR.W    R0,??DataTable16_3
   \   00000016   ........           BL       memcpy
    231          	I2C_EE_BufferWrite(Buffer, I2C_EEPROM_WriteAddress1 , sizeof(HEADER_Index) ); 	    
   \   0000001A   0A22               MOVS     R2,#+10
   \   0000001C   4021               MOVS     R1,#+64
   \   0000001E   ........           LDR.W    R0,??DataTable16_3
   \   00000022   ........           BL       I2C_EE_BufferWrite
    232          }
   \   00000026   01BD               POP      {R0,PC}          ;; return
    233          

   \                                 In section .text, align 2, keep-with-next
    234          void Write_Transmit_Header(void)        // 정송 시작과 끝을 저장한다.
    235          {
   \                     Write_Transmit_Header:
   \   00000000   80B5               PUSH     {R7,LR}
    236               NAND_Data_Transmit.Verify = I2C_EEPROM_VERIFY2;
   \   00000002   ........           LDR.W    R0,??DataTable16_4
   \   00000006   4EF60461           MOVW     R1,#+60932
   \   0000000A   0181               STRH     R1,[R0, #+8]
    237          	memcpy(Buffer,&NAND_Data_Transmit,sizeof(DATA_Transmit));	     
   \   0000000C   0A22               MOVS     R2,#+10
   \   0000000E   ........           LDR.W    R1,??DataTable16_4
   \   00000012   ........           LDR.W    R0,??DataTable16_3
   \   00000016   ........           BL       memcpy
    238          	I2C_EE_BufferWrite(Buffer, I2C_EEPROM_WriteAddress2 , sizeof(DATA_Transmit) ); 	     
   \   0000001A   0A22               MOVS     R2,#+10
   \   0000001C   6021               MOVS     R1,#+96
   \   0000001E   ........           LDR.W    R0,??DataTable16_3
   \   00000022   ........           BL       I2C_EE_BufferWrite
    239          }
   \   00000026   01BD               POP      {R0,PC}          ;; return
    240          

   \                                 In section .text, align 2, keep-with-next
    241          void Write_Header_Information(void)          // 실제 NAND 데이터를 저장하고 기록 한다.
    242          {
   \                     Write_Header_Information:
   \   00000000   80B5               PUSH     {R7,LR}
    243               memset(&Buffer , 0 , sizeof(Buffer) );     
   \   00000002   4FF40072           MOV      R2,#+512
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   ........           LDR.W    R0,??DataTable16_3
   \   0000000C   ........           BL       memset
    244               memcpy(Buffer, &NAND_Header_Info, HEADER_INFO_SIZE ) ;            
   \   00000010   1022               MOVS     R2,#+16
   \   00000012   ........           LDR.W    R1,??DataTable16
   \   00000016   ........           LDR.W    R0,??DataTable16_3
   \   0000001A   ........           BL       memcpy
    245               I2C_EE_BufferWrite( Buffer, I2C_EEPROM_WriteAddress3 + ( NAND_Header_Index.Write_Point * HEADER_INFO_SIZE ), HEADER_INFO_SIZE  ) ;
   \   0000001E   1022               MOVS     R2,#+16
   \   00000020   ........           LDR.W    R0,??DataTable16_2
   \   00000024   4088               LDRH     R0,[R0, #+2]
   \   00000026   0001               LSLS     R0,R0,#+4
   \   00000028   10F18001           ADDS     R1,R0,#+128
   \   0000002C   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000002E   ........           LDR.W    R0,??DataTable16_3
   \   00000032   ........           BL       I2C_EE_BufferWrite
    246          
    247               // 다음 위치 인덱스 클리어 시키기
    248          //     memset(&Buffer , 0 , sizeof(Buffer) );
    249          //     I2C_EE_BufferWrite( Buffer, I2C_EEPROM_WriteAddress3 + ( ( NAND_Header_Index.Write_Point + 1 ) * HEADER_INFO_SIZE ) , HEADER_INFO_SIZE  ) ;            
    250          }
   \   00000036   01BD               POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    251          void Accident_DataLoad( u16 Count )
    252          {
   \                     Accident_DataLoad:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   83B0               SUB      SP,SP,#+12
    253               NAND_ADDRESS NAND_PAGE;
    254               
    255               NAND_PAGE = Get_NAND_PageAddress( ( MAX_NAND_PAGE + 1 ) + Count );
   \   00000004   B0F5C051           SUBS     R1,R0,#+6144
   \   00000008   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000A   00A8               ADD      R0,SP,#+0
   \   0000000C   ........           BL       Get_NAND_PageAddress
    256          
    257          	memset(NAND_Buffer, 0 ,sizeof(NAND_Buffer) );
   \   00000010   42F20102           MOVW     R2,#+8193
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   ........           LDR.W    R0,??DataTable16_7
   \   0000001A   ........           BL       memset
    258               FSMC_NAND_ReadSmallPage( NAND_Buffer, NAND_PAGE, 1);		// 데이터를 기록을 읽는다.
   \   0000001E   0123               MOVS     R3,#+1
   \   00000020   DDE90012           LDRD     R1,R2,[SP, #+0]
   \   00000024   ........           LDR.W    R0,??DataTable16_7
   \   00000028   ........           BL       FSMC_NAND_ReadSmallPage
    259          	          
    260          }
   \   0000002C   07BD               POP      {R0-R2,PC}       ;; return
    261          

   \                                 In section .text, align 2, keep-with-next
    262          void Accident_DataSave( u16 Count )     // 충돌이벤트 저장
    263          {
   \                     Accident_DataSave:
   \   00000000   1CB5               PUSH     {R2-R4,LR}
    264          
    265               NAND_ADDRESS NAND_PAGE;
    266               u32 DataSize = 0;
   \   00000002   0024               MOVS     R4,#+0
    267               NAND_PAGE = Get_NAND_PageAddress( ( MAX_NAND_PAGE + 1 ) + Count );
   \   00000004   B0F5C051           SUBS     R1,R0,#+6144
   \   00000008   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000A   00A8               ADD      R0,SP,#+0
   \   0000000C   ........           BL       Get_NAND_PageAddress
    268          
    269               //printf("%d %d %d %d \r\n",Page_Num, NAND_PAGE.Zone,NAND_PAGE.Block,NAND_PAGE.Page);	
    270          	if( NAND_PAGE.Page == 0 )
   \   00000010   BDF80400           LDRH     R0,[SP, #+4]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   03D1               BNE.N    ??Accident_DataSave_0
    271          	{
    272                    // 페이지가 첫번째 페이지를 기록하기 전에 블럭을 삭제한다.
    273                 //   printf("NAND ERASE!!!!!!!!!!!\r\n");
    274                  FSMC_NAND_EraseBlock(NAND_PAGE);
   \   00000018   DDE90001           LDRD     R0,R1,[SP, #+0]
   \   0000001C   ........           BL       FSMC_NAND_EraseBlock
    275          	}
    276          
    277               DataSize = sizeof(DTG_NAND_Binary[0]);     
   \                     ??Accident_DataSave_0:
   \   00000020   4724               MOVS     R4,#+71
    278               
    279               memset(NAND_Buffer, 0, sizeof( NAND_Buffer ) );
   \   00000022   42F20102           MOVW     R2,#+8193
   \   00000026   0021               MOVS     R1,#+0
   \   00000028   ........           LDR.W    R0,??DataTable16_7
   \   0000002C   ........           BL       memset
    280               
    281               //----- EMS 데이터 저장 ---------------------------------------------------    
    282          
    283               DataSize = sizeof(Accident_Time);
   \   00000030   0D20               MOVS     R0,#+13
   \   00000032   0400               MOVS     R4,R0
    284               // 0.01초 데이터 저장
    285               memcpy( &NAND_Buffer , &Accident_Time , DataSize );
   \   00000034   2200               MOVS     R2,R4
   \   00000036   ........           LDR.W    R1,??DataTable16_13
   \   0000003A   ........           LDR.W    R0,??DataTable16_7
   \   0000003E   ........           BL       memcpy
    286               memcpy( &NAND_Buffer[ DataSize ] ,Accident_SaveBuffer, sizeof(Accident_SaveBuffer));
   \   00000042   4FF4FA52           MOV      R2,#+8000
   \   00000046   ........           LDR.W    R1,??DataTable16_14
   \   0000004A   ........           LDR.W    R0,??DataTable16_7
   \   0000004E   2018               ADDS     R0,R4,R0
   \   00000050   ........           BL       memcpy
    287               // 1 초 데이터 저장
    288               DataSize += sizeof(Accident_SaveBuffer);
   \   00000054   14F5FA54           ADDS     R4,R4,#+8000
    289               memcpy( &NAND_Buffer[ DataSize ] ,Accident2_SaveBuffer, sizeof(Accident2_SaveBuffer));          
   \   00000058   AA22               MOVS     R2,#+170
   \   0000005A   ........           LDR.W    R1,??DataTable16_15
   \   0000005E   ........           LDR.W    R0,??DataTable16_7
   \   00000062   2018               ADDS     R0,R4,R0
   \   00000064   ........           BL       memcpy
    290          
    291               NAND_Buffer[8190] = 0xAA;
   \   00000068   ........           LDR.W    R0,??DataTable16_11
   \   0000006C   AA21               MOVS     R1,#+170
   \   0000006E   0170               STRB     R1,[R0, #+0]
    292               NAND_Buffer[8191] = 0xAA; 
   \   00000070   ........           LDR.W    R0,??DataTable16_12
   \   00000074   AA21               MOVS     R1,#+170
   \   00000076   0170               STRB     R1,[R0, #+0]
    293               // 저장 하기
    294               FSMC_NAND_WriteSmallPage(NAND_Buffer,NAND_PAGE,1);		// 데이터를 기록 한다.
   \   00000078   0123               MOVS     R3,#+1
   \   0000007A   DDE90012           LDRD     R1,R2,[SP, #+0]
   \   0000007E   ........           LDR.W    R0,??DataTable16_7
   \   00000082   ........           BL       FSMC_NAND_WriteSmallPage
    295               
    296          }
   \   00000086   13BD               POP      {R0,R1,R4,PC}    ;; return
    297          

   \                                 In section .text, align 2, keep-with-next
    298          u8 NAND_ERASE_PAGE(u32 Page_Num)
    299          {
   \                     NAND_ERASE_PAGE:
   \   00000000   1CB5               PUSH     {R2-R4,LR}
   \   00000002   0400               MOVS     R4,R0
    300               u16 i;
    301               NAND_ADDRESS NAND_PAGE;
    302             
    303          
    304               NAND_PAGE = Get_NAND_PageAddress(Page_Num);     
   \   00000004   2100               MOVS     R1,R4
   \   00000006   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000008   00A8               ADD      R0,SP,#+0
   \   0000000A   ........           BL       Get_NAND_PageAddress
   \   0000000E   12E0               B.N      ??NAND_ERASE_PAGE_0
    305               
    306               while(1)
    307               {
    308                    // 블럭 오류 확인
    309                    //
    310                    if( FSMC_NAND_EraseBlock(NAND_PAGE) == NAND_TIMEOUT_ERROR )
    311                    {
    312                         //                    LUT[Address.Block] = Page_Num ;
    313                         // 배드블럭이라고 한다면 
    314                         Page_Num+=128;
    315                         NAND_PAGE = Get_NAND_PageAddress(Page_Num);      
    316                         
    317                         for( i = ( Page_Num / 128 )  ; i < 2075 ; i++ )
    318                              LookUpTable.LUT[i] = LookUpTable.LUT[i +1] ;
   \                     ??NAND_ERASE_PAGE_1:
   \   00000010   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000012   ........           LDR.W    R1,??DataTable16_16
   \   00000016   11EB4001           ADDS     R1,R1,R0, LSL #+1
   \   0000001A   4988               LDRH     R1,[R1, #+2]
   \   0000001C   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001E   ........           LDR.W    R2,??DataTable16_16
   \   00000022   22F81010           STRH     R1,[R2, R0, LSL #+1]
   \   00000026   401C               ADDS     R0,R0,#+1
   \                     ??NAND_ERASE_PAGE_2:
   \   00000028   40F61B01           MOVW     R1,#+2075
   \   0000002C   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002E   8842               CMP      R0,R1
   \   00000030   EED3               BCC.N    ??NAND_ERASE_PAGE_1
    319                         
    320                         Save_LookupTable();
   \   00000032   ........           BL       Save_LookupTable
   \                     ??NAND_ERASE_PAGE_0:
   \   00000036   DDE90001           LDRD     R0,R1,[SP, #+0]
   \   0000003A   ........           BL       FSMC_NAND_EraseBlock
   \   0000003E   B0F5806F           CMP      R0,#+1024
   \   00000042   07D1               BNE.N    ??NAND_ERASE_PAGE_3
   \   00000044   8034               ADDS     R4,R4,#+128
   \   00000046   2100               MOVS     R1,R4
   \   00000048   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000004A   00A8               ADD      R0,SP,#+0
   \   0000004C   ........           BL       Get_NAND_PageAddress
   \   00000050   E009               LSRS     R0,R4,#+7
   \   00000052   E9E7               B.N      ??NAND_ERASE_PAGE_2
    321                    }else
    322                    {
    323                         break;
    324                    }
    325               }
    326               return 0;
   \                     ??NAND_ERASE_PAGE_3:
   \   00000054   0020               MOVS     R0,#+0
   \   00000056   16BD               POP      {R1,R2,R4,PC}    ;; return
    327          }
    328          

   \                                 In section .text, align 2, keep-with-next
    329          void DTG_EMS_DataSave(u32 Page_Num , u16 DataCount)
    330          {
   \                     DTG_EMS_DataSave:
   \   00000000   F0B5               PUSH     {R4-R7,LR}
   \   00000002   83B0               SUB      SP,SP,#+12
   \   00000004   0500               MOVS     R5,R0
   \   00000006   0C00               MOVS     R4,R1
    331          
    332               u16 DataSize ;
    333               u16 DataSize2;
    334               u16 i;
    335               NAND_ADDRESS NAND_PAGE;
    336               
    337          //     if(!CheckTimeOver(10,MemoryTime))     // 1초마다 한번씩만 동작하도록한다.
    338          //		return ;     
    339          //     MemoryTime = MS_TIMER;     
    340          
    341               NAND_PAGE = Get_NAND_PageAddress(Page_Num);
   \   00000008   2900               MOVS     R1,R5
   \   0000000A   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   00A8               ADD      R0,SP,#+0
   \   0000000E   ........           BL       Get_NAND_PageAddress
    342          
    343               //printf("%d %d %d %d \r\n",Page_Num, NAND_PAGE.Zone,NAND_PAGE.Block,NAND_PAGE.Page);	
    344          	if( NAND_PAGE.Page == 0 )
   \   00000012   BDF80400           LDRH     R0,[SP, #+4]
   \   00000016   0028               CMP      R0,#+0
   \   00000018   02D1               BNE.N    ??DTG_EMS_DataSave_0
    345          	{
    346                    // 페이지가 첫번째 페이지를 기록하기 전에 블럭을 삭제한다.
    347                 //   printf("NAND ERASE!!!!!!!!!!!\r\n");
    348                       NAND_ERASE_PAGE(Page_Num);
   \   0000001A   2800               MOVS     R0,R5
   \   0000001C   ........           BL       NAND_ERASE_PAGE
    349          	}
    350          
    351               DataSize = sizeof(DTG_NAND_Binary[0]);     
   \                     ??DTG_EMS_DataSave_0:
   \   00000020   4725               MOVS     R5,#+71
    352               
    353               memset(NAND_Buffer,0, sizeof( NAND_Buffer ) );
   \   00000022   42F20102           MOVW     R2,#+8193
   \   00000026   0021               MOVS     R1,#+0
   \   00000028   ........           LDR.W    R0,??DataTable16_7
   \   0000002C   ........           BL       memset
    354               
    355               //----- EMS 데이터 저장 ---------------------------------------------------    
    356               DataSize2 = EMS_SIZE;
   \   00000030   2526               MOVS     R6,#+37
    357               
    358               EMS_Drive_Value.DataValid = 1;
   \   00000032   ........           LDR.W    R0,??DataTable16_8
   \   00000036   0121               MOVS     R1,#+1
   \   00000038   80F82410           STRB     R1,[R0, #+36]
    359               
    360               memcpy( &NAND_Buffer , &EMS_Drive_Value , EMS_SIZE );
   \   0000003C   2522               MOVS     R2,#+37
   \   0000003E   ........           LDR.W    R1,??DataTable16_8
   \   00000042   ........           LDR.W    R0,??DataTable16_7
   \   00000046   ........           BL       memcpy
    361               
    362               ACC_Drive_Value.DataValid = 1;
   \   0000004A   ........           LDR.W    R0,??DataTable16_9
   \   0000004E   0121               MOVS     R1,#+1
   \   00000050   0172               STRB     R1,[R0, #+8]
    363               
    364               memcpy( &NAND_Buffer[DataSize2] , &ACC_Drive_Value , sizeof(ACC_DRIVE_VALUE));
   \   00000052   0922               MOVS     R2,#+9
   \   00000054   ........           LDR.W    R1,??DataTable16_9
   \   00000058   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000005A   ........           LDR.W    R0,??DataTable16_7
   \   0000005E   3018               ADDS     R0,R6,R0
   \   00000060   ........           BL       memcpy
    365               
    366               DataSize2+= sizeof(ACC_DRIVE_VALUE);
   \   00000064   0936               ADDS     R6,R6,#+9
    367                    
    368               //-------------------------------------------------------------------------
    369               for ( i = 0 ; i < DataCount ; i++)
   \   00000066   0027               MOVS     R7,#+0
   \   00000068   12E0               B.N      ??DTG_EMS_DataSave_1
    370               {
    371          	     memcpy( &NAND_Buffer[ ( DataSize2 + ( i * DataSize ) ) ], &DTG_NAND_Binary[i], DataSize );
   \                     ??DTG_EMS_DataSave_2:
   \   0000006A   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006C   2A00               MOVS     R2,R5
   \   0000006E   BFB2               UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000070   4720               MOVS     R0,#+71
   \   00000072   ........           LDR.W    R1,??DataTable16_17
   \   00000076   00FB0711           MLA      R1,R0,R7,R1
   \   0000007A   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000007C   BFB2               UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000007E   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000080   05FB0760           MLA      R0,R5,R7,R6
   \   00000084   ........           LDR.W    R3,??DataTable16_7
   \   00000088   C018               ADDS     R0,R0,R3
   \   0000008A   ........           BL       memcpy
    372               }
   \   0000008E   7F1C               ADDS     R7,R7,#+1
   \                     ??DTG_EMS_DataSave_1:
   \   00000090   BFB2               UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000092   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000094   A742               CMP      R7,R4
   \   00000096   E8D3               BCC.N    ??DTG_EMS_DataSave_2
    373               NAND_Buffer[8189] = 0xAA;
   \   00000098   ........           LDR.W    R0,??DataTable16_10
   \   0000009C   AA21               MOVS     R1,#+170
   \   0000009E   0170               STRB     R1,[R0, #+0]
    374               NAND_Buffer[8190] = 0xAA;
   \   000000A0   ........           LDR.W    R0,??DataTable16_11
   \   000000A4   AA21               MOVS     R1,#+170
   \   000000A6   0170               STRB     R1,[R0, #+0]
    375               NAND_Buffer[8191] = 0xAA;     
   \   000000A8   ........           LDR.W    R0,??DataTable16_12
   \   000000AC   AA21               MOVS     R1,#+170
   \   000000AE   0170               STRB     R1,[R0, #+0]
    376               FSMC_NAND_WriteSmallPage(NAND_Buffer,NAND_PAGE,1);		// 데이터를 기록 한다.
   \   000000B0   0123               MOVS     R3,#+1
   \   000000B2   DDE90012           LDRD     R1,R2,[SP, #+0]
   \   000000B6   ........           LDR.W    R0,??DataTable16_7
   \   000000BA   ........           BL       FSMC_NAND_WriteSmallPage
    377             	#ifdef DEBUG_LOG 
    378          	//--------------------- 로그 기록 --------------------------------------
    379          	if(LOGWRITE & LOG_MEMORY)
    380          	{
    381          		sprintf((char *)Buffer,"NAND_FLASH WRITTEND Z=%d B=%d P=%d \r\n",NAND_PAGE.Zone,NAND_PAGE.Block,NAND_PAGE.Page);
    382          		Write_Log(Buffer, NORMAL_LOG);
    383          	}	
    384          #endif
    385          }
   \   000000BE   F7BD               POP      {R0-R2,R4-R7,PC}  ;; return
    386          

   \                                 In section .text, align 2, keep-with-next
    387          void DTG_EMS_DataLoad(u32 Page_Num)
    388          {
   \                     DTG_EMS_DataLoad:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   83B0               SUB      SP,SP,#+12
    389          //     u16 DataSize ;
    390          
    391               NAND_ADDRESS NAND_PAGE;
    392                    
    393          //     DataSize = sizeof(DTG_NAND_Binary[0]);     
    394          	
    395               NAND_PAGE = Get_NAND_PageAddress(Page_Num);
   \   00000004   0100               MOVS     R1,R0
   \   00000006   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000008   00A8               ADD      R0,SP,#+0
   \   0000000A   ........           BL       Get_NAND_PageAddress
    396          	memset(NAND_Buffer, 0 ,sizeof(NAND_Buffer) );
   \   0000000E   42F20102           MOVW     R2,#+8193
   \   00000012   0021               MOVS     R1,#+0
   \   00000014   ........           LDR.W    R0,??DataTable16_7
   \   00000018   ........           BL       memset
    397               FSMC_NAND_ReadSmallPage( NAND_Buffer, NAND_PAGE, 1);		// 데이터를 기록을 읽는다.
   \   0000001C   0123               MOVS     R3,#+1
   \   0000001E   DDE90012           LDRD     R1,R2,[SP, #+0]
   \   00000022   ........           LDR.W    R0,??DataTable16_7
   \   00000026   ........           BL       FSMC_NAND_ReadSmallPage
    398          	
    399          //     memcpy( &EMS_Drive_Value, &NAND_Buffer, EMS_SIZE );
    400          #ifdef DEBUG_LOG 
    401          	//--------------------- 로그 기록 --------------------------------------
    402          	if(LOGWRITE & LOG_MEMORY)
    403          	{
    404          		sprintf((char *)Buffer,"NAND_FLASH READ Z=%d B=%d P=%d \r\n",NAND_PAGE.Zone,NAND_PAGE.Block,NAND_PAGE.Page);
    405          		Write_Log(Buffer, NORMAL_LOG);
    406          	}
    407          #endif
    408          }
   \   0000002A   07BD               POP      {R0-R2,PC}       ;; return
    409          

   \                                 In section .text, align 2, keep-with-next
    410          void Convert_Binary(char *Str, u32 Num)
    411          {	
    412          	Str[0] = (Num >> 24)&0xff;
   \                     Convert_Binary:
   \   00000000   0A0E               LSRS     R2,R1,#+24
   \   00000002   0270               STRB     R2,[R0, #+0]
    413          	Str[1] = (Num >> 16)&0xff;
   \   00000004   0A0C               LSRS     R2,R1,#+16
   \   00000006   4270               STRB     R2,[R0, #+1]
    414          	Str[2] = (Num >> 8)&0xff;
   \   00000008   0A0A               LSRS     R2,R1,#+8
   \   0000000A   8270               STRB     R2,[R0, #+2]
    415          	Str[3] = Num &0xff;
   \   0000000C   C170               STRB     R1,[R0, #+3]
    416          }
   \   0000000E   7047               BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    417          void Convert_Data(void)
    418          {
    419          //	u16 Index NAND_Index.Index;
    420          	
    421          //	DTG_Raw_Memory.DayDriveLength = 0;
    422          	
    423          //	memcpy(DTG_NAND_Binary[Index], DTG_Raw_Memory, sizeof( DTG_Raw_Memory ) );
    424          //	memcpy(DTG_NAND_Binary[Index], DTG_Raw_Memory, sizeof( DTG_Raw_Memory ) );
    425          }
   \                     Convert_Data:
   \   00000000   7047               BX       LR               ;; return
    426          
    427          //
    428          // 1초 마다 메모리 처리 
    429          //

   \                                 In section .text, align 2, keep-with-next
    430          void Page_Stack(void)
    431          {
    432          	
    433          }
   \                     Page_Stack:
   \   00000000   7047               BX       LR               ;; return
    434          

   \                                 In section .text, align 2, keep-with-next
    435          void Memory_Process(void)		
    436          {	
   \                     Memory_Process:
   \   00000000   38B5               PUSH     {R3-R5,LR}
    437               
    438               static u8 OldSec;
    439               u32 TimerData;
    440          
    441               if(OldSec != SYSTEM_TIME.tm_sec && (Info.Input_Status& INPUT_KEYON_FLAG) )
   \   00000002   ........           LDR.W    R0,??DataTable16_18
   \   00000006   0078               LDRB     R0,[R0, #+0]
   \   00000008   ........           LDR.W    R1,??DataTable16_1
   \   0000000C   0968               LDR      R1,[R1, #+0]
   \   0000000E   8842               CMP      R0,R1
   \   00000010   00F03F81           BEQ.W    ??Memory_Process_0
   \   00000014   ........           LDR.W    R0,??DataTable16_6
   \   00000018   90F85500           LDRB     R0,[R0, #+85]
   \   0000001C   0006               LSLS     R0,R0,#+24
   \   0000001E   40F13881           BPL.W    ??Memory_Process_0
    442               {
    443                     TimerData = RTC_DateToBinary(&SYSTEM_TIME);
   \   00000022   ........           LDR.W    R0,??DataTable16_1
   \   00000026   ........           BL       RTC_DateToBinary
   \   0000002A   0400               MOVS     R4,R0
    444          
    445                     // 거리 계산 공식 임시 적용 0.0196247
    446                     memcpy(DTG_NAND_Binary[Info.DTG_DataCount].Driver_Num, Info.Driver_Num, DRIVER_NUM_SIZE);
   \   0000002C   1222               MOVS     R2,#+18
   \   0000002E   ........           LDR.W    R1,??DataTable16_19
   \   00000032   ........           LDR.W    R0,??DataTable16_6
   \   00000036   90F85A00           LDRB     R0,[R0, #+90]
   \   0000003A   4723               MOVS     R3,#+71
   \   0000003C   ........           LDR.W    R5,??DataTable16_17
   \   00000040   03FB0050           MLA      R0,R3,R0,R5
   \   00000044   ........           BL       memcpy
    447                     DTG_NAND_Binary[Info.DTG_DataCount].DayDriveLength = Info.DayDriveLength;//SYSTEM_TIME.tm_sec;      // 일일 거리
   \   00000048   ........           LDR.W    R0,??DataTable16_6
   \   0000004C   90F85A00           LDRB     R0,[R0, #+90]
   \   00000050   4721               MOVS     R1,#+71
   \   00000052   ........           LDR.W    R2,??DataTable16_17
   \   00000056   01FB0020           MLA      R0,R1,R0,R2
   \   0000005A   ........           LDR.W    R1,??DataTable16_6
   \   0000005E   498B               LDRH     R1,[R1, #+26]
   \   00000060   A0F81310           STRH     R1,[R0, #+19]
    448                     // 거리계산이 필요한가?
    449                     DTG_NAND_Binary[Info.DTG_DataCount].TotalDriveLength = Info.TotalDriveLength;                       // 총운행거리
   \   00000064   ........           LDR.W    R0,??DataTable16_6
   \   00000068   90F85A00           LDRB     R0,[R0, #+90]
   \   0000006C   4721               MOVS     R1,#+71
   \   0000006E   ........           LDR.W    R2,??DataTable16_17
   \   00000072   01FB0020           MLA      R0,R1,R0,R2
   \   00000076   ........           LDR.W    R1,??DataTable16_6
   \   0000007A   C969               LDR      R1,[R1, #+28]
   \   0000007C   C0F81510           STR      R1,[R0, #+21]
    450                    
    451                     
    452                     DTG_NAND_Binary[Info.DTG_DataCount].Datetime = TimerData;
   \   00000080   ........           LDR.W    R0,??DataTable16_6
   \   00000084   90F85A00           LDRB     R0,[R0, #+90]
   \   00000088   4721               MOVS     R1,#+71
   \   0000008A   ........           LDR.W    R2,??DataTable16_17
   \   0000008E   01FB0020           MLA      R0,R1,R0,R2
   \   00000092   C0F81940           STR      R4,[R0, #+25]
    453                     DTG_NAND_Binary[Info.DTG_DataCount].Speed = Info.SPEED_Value;//AvrageTemp1;
   \   00000096   ........           LDR.W    R0,??DataTable16_6
   \   0000009A   90F85A00           LDRB     R0,[R0, #+90]
   \   0000009E   4721               MOVS     R1,#+71
   \   000000A0   ........           LDR.W    R2,??DataTable16_17
   \   000000A4   01FB0020           MLA      R0,R1,R0,R2
   \   000000A8   ........           LDR.W    R1,??DataTable16_6
   \   000000AC   91F82C10           LDRB     R1,[R1, #+44]
   \   000000B0   4177               STRB     R1,[R0, #+29]
    454                     DTG_NAND_Binary[Info.DTG_DataCount].RPM = Info.RPM_Value;//AvrageTemp2;
   \   000000B2   ........           LDR.W    R0,??DataTable16_6
   \   000000B6   90F85A00           LDRB     R0,[R0, #+90]
   \   000000BA   4721               MOVS     R1,#+71
   \   000000BC   ........           LDR.W    R2,??DataTable16_17
   \   000000C0   01FB0020           MLA      R0,R1,R0,R2
   \   000000C4   ........           LDR.W    R1,??DataTable16_6
   \   000000C8   B1F82D10           LDRH     R1,[R1, #+45]
   \   000000CC   C183               STRH     R1,[R0, #+30]
    455                     
    456                     DTG_NAND_Binary[Info.DTG_DataCount].Sign_Break =  Info.Sign_Break ;    				// 브레이크를 밟고 있는가?
   \   000000CE   ........           LDR.W    R0,??DataTable16_6
   \   000000D2   90F85A00           LDRB     R0,[R0, #+90]
   \   000000D6   4721               MOVS     R1,#+71
   \   000000D8   ........           LDR.W    R2,??DataTable16_17
   \   000000DC   01FB0020           MLA      R0,R1,R0,R2
   \   000000E0   ........           LDR.W    R1,??DataTable16_6
   \   000000E4   91F82F10           LDRB     R1,[R1, #+47]
   \   000000E8   80F82010           STRB     R1,[R0, #+32]
    457                     
    458                     DTG_NAND_Binary[Info.DTG_DataCount].GPSX = Info.GPSX ;
   \   000000EC   ........           LDR.W    R0,??DataTable16_6
   \   000000F0   90F85A00           LDRB     R0,[R0, #+90]
   \   000000F4   4721               MOVS     R1,#+71
   \   000000F6   ........           LDR.W    R2,??DataTable16_17
   \   000000FA   01FB0020           MLA      R0,R1,R0,R2
   \   000000FE   ........           LDR.W    R1,??DataTable16_6
   \   00000102   096B               LDR      R1,[R1, #+48]
   \   00000104   C0F82110           STR      R1,[R0, #+33]
    459                     DTG_NAND_Binary[Info.DTG_DataCount].GPSY = Info.GPSY ;	
   \   00000108   ........           LDR.W    R0,??DataTable16_6
   \   0000010C   90F85A00           LDRB     R0,[R0, #+90]
   \   00000110   4721               MOVS     R1,#+71
   \   00000112   ........           LDR.W    R2,??DataTable16_17
   \   00000116   01FB0020           MLA      R0,R1,R0,R2
   \   0000011A   ........           LDR.W    R1,??DataTable16_6
   \   0000011E   496B               LDR      R1,[R1, #+52]
   \   00000120   C0F82510           STR      R1,[R0, #+37]
    460                     DTG_NAND_Binary[Info.DTG_DataCount].Azimuth = Info.Azimuth ;
   \   00000124   ........           LDR.W    R0,??DataTable16_6
   \   00000128   90F85A00           LDRB     R0,[R0, #+90]
   \   0000012C   4721               MOVS     R1,#+71
   \   0000012E   ........           LDR.W    R2,??DataTable16_17
   \   00000132   01FB0020           MLA      R0,R1,R0,R2
   \   00000136   ........           LDR.W    R1,??DataTable16_6
   \   0000013A   098F               LDRH     R1,[R1, #+56]
   \   0000013C   A0F82910           STRH     R1,[R0, #+41]
    461                     
    462                     DTG_NAND_Binary[Info.DTG_DataCount].AccelX = Info.AccelX; //(int)( AvrageTemp3 /9.8 );
   \   00000140   ........           LDR.W    R0,??DataTable16_6
   \   00000144   90F85A00           LDRB     R0,[R0, #+90]
   \   00000148   4721               MOVS     R1,#+71
   \   0000014A   ........           LDR.W    R2,??DataTable16_17
   \   0000014E   01FB0020           MLA      R0,R1,R0,R2
   \   00000152   ........           LDR.W    R1,??DataTable16_6
   \   00000156   498F               LDRH     R1,[R1, #+58]
   \   00000158   A0F82B10           STRH     R1,[R0, #+43]
    463                     DTG_NAND_Binary[Info.DTG_DataCount].AccelY = Info.AccelY; //(int)( AvrageTemp4 /9.8 );		
   \   0000015C   ........           LDR.W    R0,??DataTable16_6
   \   00000160   90F85A00           LDRB     R0,[R0, #+90]
   \   00000164   4721               MOVS     R1,#+71
   \   00000166   ........           LDR.W    R2,??DataTable16_17
   \   0000016A   01FB0020           MLA      R0,R1,R0,R2
   \   0000016E   ........           LDR.W    R1,??DataTable16_6
   \   00000172   898F               LDRH     R1,[R1, #+60]
   \   00000174   A0F82D10           STRH     R1,[R0, #+45]
    464                     
    465                     DTG_NAND_Binary[Info.DTG_DataCount].MachineStatus = Info.MachineStatus ;
   \   00000178   ........           LDR.W    R0,??DataTable16_6
   \   0000017C   90F85A00           LDRB     R0,[R0, #+90]
   \   00000180   4721               MOVS     R1,#+71
   \   00000182   ........           LDR.W    R2,??DataTable16_17
   \   00000186   01FB0020           MLA      R0,R1,R0,R2
   \   0000018A   ........           LDR.W    R1,??DataTable16_6
   \   0000018E   91F83E10           LDRB     R1,[R1, #+62]
   \   00000192   80F82F10           STRB     R1,[R0, #+47]
    466                     //////  EMS   /////////////////////////////////////////////////////
    467                     
    468                     memcpy(&DTG_NAND_Binary[Info.DTG_DataCount].Ems_Data,&Info.EMS_Data,sizeof(EMS_VALUE));
   \   00000196   1622               MOVS     R2,#+22
   \   00000198   ........           LDR.W    R1,??DataTable16_20
   \   0000019C   ........           LDR.W    R0,??DataTable16_6
   \   000001A0   90F85A00           LDRB     R0,[R0, #+90]
   \   000001A4   4723               MOVS     R3,#+71
   \   000001A6   ........           LDR.W    R4,??DataTable16_17
   \   000001AA   03FB0040           MLA      R0,R3,R0,R4
   \   000001AE   3030               ADDS     R0,R0,#+48
   \   000001B0   ........           BL       memcpy
    469                     
    470                     //memcpy(&DTG_NAND_Binary[Info.DTG_DataCount].EMS_Drive_Value,&EMS_Drive_Value,sizeof(EMS_Drive_Value));
    471                     
    472                     ////////////////////////////////////////////////////////////////////////////////
    473                     
    474                     DTG_NAND_Binary[Info.DTG_DataCount].DataValid = 1;		// NAND에 들어갔을때 데이터의 유효성을확인
   \   000001B4   ........           LDR.W    R0,??DataTable16_6
   \   000001B8   90F85A00           LDRB     R0,[R0, #+90]
   \   000001BC   4721               MOVS     R1,#+71
   \   000001BE   ........           LDR.W    R2,??DataTable16_17
   \   000001C2   01FB0020           MLA      R0,R1,R0,R2
   \   000001C6   0121               MOVS     R1,#+1
   \   000001C8   80F84610           STRB     R1,[R0, #+70]
    475                              
    476                     // --------- 1 초 USB에 데이터 기록  ------------------------------------------------ 
    477                     
    478                     if(USBH_USR_ApplicationState == USH_USR_FS_IDLE && USBH_USR_ActionFlag == USH_USR_FS_IDLE)
   \   000001CC   ........           LDR.W    R0,??DataTable16_21
   \   000001D0   0078               LDRB     R0,[R0, #+0]
   \   000001D2   0128               CMP      R0,#+1
   \   000001D4   0ED1               BNE.N    ??Memory_Process_1
   \   000001D6   ........           LDR.W    R0,??DataTable16_22
   \   000001DA   0078               LDRB     R0,[R0, #+0]
   \   000001DC   0128               CMP      R0,#+1
   \   000001DE   09D1               BNE.N    ??Memory_Process_1
    479                     {
    480                          USBH_USR_ActionFlag = USH_USR_FS_WRITEFILE;      // 1초데이터 기록                         
   \   000001E0   ........           LDR.W    R0,??DataTable16_22
   \   000001E4   0321               MOVS     R1,#+3
   \   000001E6   0170               STRB     R1,[R0, #+0]
    481                          Convert_DTG_Data(Info.DTG_DataCount);
   \   000001E8   ........           LDR.W    R0,??DataTable16_6
   \   000001EC   90F85A00           LDRB     R0,[R0, #+90]
   \   000001F0   ........           BL       Convert_DTG_Data
    482                     }
    483                     
    484                     // -----------------------------------------------------------------------------
    485                     
    486                     Info.DTG_DataCount++;		// 중간에 저장하기 위해서 데이터 갯수를 센다.
   \                     ??Memory_Process_1:
   \   000001F4   ........           LDR.W    R0,??DataTable16_6
   \   000001F8   90F85A00           LDRB     R0,[R0, #+90]
   \   000001FC   401C               ADDS     R0,R0,#+1
   \   000001FE   ........           LDR.W    R1,??DataTable16_6
   \   00000202   81F85A00           STRB     R0,[R1, #+90]
    487                    
    488                    /////////////////////////////////////////////////////////////////////
    489                    // 한 페이지가 모두 찼다면 		
    490                    // 30개의 데이터를 수집 하면 저장한다.		
    491                    //
    492                    
    493                     if(Info.DTG_DataCount >= DATA_IN_PAGE_SIZE)
   \   00000206   ....               LDR.N    R0,??DataTable16_6
   \   00000208   90F85A00           LDRB     R0,[R0, #+90]
   \   0000020C   5A28               CMP      R0,#+90
   \   0000020E   40D3               BCC.N    ??Memory_Process_0
    494                     {
    495                          Flag.EMS_Data_Save = 1;
   \   00000210   ........           LDR.W    R0,??DataTable16_23
   \   00000214   0121               MOVS     R1,#+1
   \   00000216   4174               STRB     R1,[R0, #+17]
    496                          // NAND FLASH 데이터 저장
    497                      
    498                               
    499                          DTG_EMS_DataSave(NAND_Header_Index.Page_Count, Info.DTG_DataCount);
   \   00000218   ....               LDR.N    R0,??DataTable16_6
   \   0000021A   90F85A10           LDRB     R1,[R0, #+90]
   \   0000021E   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000220   ....               LDR.N    R0,??DataTable16_2
   \   00000222   4068               LDR      R0,[R0, #+4]
   \   00000224   ........           BL       DTG_EMS_DataSave
    500                          // 헤더 저장
    501                          if(NAND_Data_Transmit.End_Page >= MAX_NAND_PAGE)
   \   00000228   ....               LDR.N    R0,??DataTable16_4
   \   0000022A   4068               LDR      R0,[R0, #+4]
   \   0000022C   ........           LDR.W    R1,??DataTable16_24  ;; 0x3e7ff
   \   00000230   8842               CMP      R0,R1
   \   00000232   03D3               BCC.N    ??Memory_Process_2
    502                               NAND_Data_Transmit.End_Page = 0;
   \   00000234   ....               LDR.N    R0,??DataTable16_4
   \   00000236   0021               MOVS     R1,#+0
   \   00000238   4160               STR      R1,[R0, #+4]
   \   0000023A   04E0               B.N      ??Memory_Process_3
    503                          else
    504                               NAND_Data_Transmit.End_Page ++;         // 데이터 전송 페이지 저장
   \                     ??Memory_Process_2:
   \   0000023C   ....               LDR.N    R0,??DataTable16_4
   \   0000023E   4068               LDR      R0,[R0, #+4]
   \   00000240   401C               ADDS     R0,R0,#+1
   \   00000242   ....               LDR.N    R1,??DataTable16_4
   \   00000244   4860               STR      R0,[R1, #+4]
    505                          if(NAND_Header_Index.Page_Count >= MAX_NAND_PAGE)
   \                     ??Memory_Process_3:
   \   00000246   ....               LDR.N    R0,??DataTable16_2
   \   00000248   4068               LDR      R0,[R0, #+4]
   \   0000024A   ....               LDR.N    R1,??DataTable16_24  ;; 0x3e7ff
   \   0000024C   8842               CMP      R0,R1
   \   0000024E   03D3               BCC.N    ??Memory_Process_4
    506                               NAND_Header_Index.Page_Count = 0;
   \   00000250   ....               LDR.N    R0,??DataTable16_2
   \   00000252   0021               MOVS     R1,#+0
   \   00000254   4160               STR      R1,[R0, #+4]
   \   00000256   04E0               B.N      ??Memory_Process_5
    507                          else
    508                               NAND_Header_Index.Page_Count ++;
   \                     ??Memory_Process_4:
   \   00000258   ....               LDR.N    R0,??DataTable16_2
   \   0000025A   4068               LDR      R0,[R0, #+4]
   \   0000025C   401C               ADDS     R0,R0,#+1
   \   0000025E   ....               LDR.N    R1,??DataTable16_2
   \   00000260   4860               STR      R0,[R1, #+4]
    509                          if(NAND_Header_Info.End_Page >= MAX_NAND_PAGE)        
   \                     ??Memory_Process_5:
   \   00000262   ....               LDR.N    R0,??DataTable16
   \   00000264   8068               LDR      R0,[R0, #+8]
   \   00000266   ....               LDR.N    R1,??DataTable16_24  ;; 0x3e7ff
   \   00000268   8842               CMP      R0,R1
   \   0000026A   03D3               BCC.N    ??Memory_Process_6
    510                               NAND_Header_Info.End_Page = 0;
   \   0000026C   ....               LDR.N    R0,??DataTable16
   \   0000026E   0021               MOVS     R1,#+0
   \   00000270   8160               STR      R1,[R0, #+8]
   \   00000272   04E0               B.N      ??Memory_Process_7
    511                          else
    512                               NAND_Header_Info.End_Page++;
   \                     ??Memory_Process_6:
   \   00000274   ....               LDR.N    R0,??DataTable16
   \   00000276   8068               LDR      R0,[R0, #+8]
   \   00000278   401C               ADDS     R0,R0,#+1
   \   0000027A   ....               LDR.N    R1,??DataTable16
   \   0000027C   8860               STR      R0,[R1, #+8]
    513                          
    514                          // 초기화
    515                          Info.DTG_DataCount = 0;
   \                     ??Memory_Process_7:
   \   0000027E   ....               LDR.N    R0,??DataTable16_6
   \   00000280   0021               MOVS     R1,#+0
   \   00000282   80F85A10           STRB     R1,[R0, #+90]
    516                          memset(DTG_NAND_Binary,0, sizeof(DTG_NAND_Binary));
   \   00000286   41F6F602           MOVW     R2,#+6390
   \   0000028A   0021               MOVS     R1,#+0
   \   0000028C   ....               LDR.N    R0,??DataTable16_17
   \   0000028E   ........           BL       memset
    517                          
    518                     }
    519               }
    520               OldSec = SYSTEM_TIME.tm_sec;
   \                     ??Memory_Process_0:
   \   00000292   ....               LDR.N    R0,??DataTable16_18
   \   00000294   ....               LDR.N    R1,??DataTable16_1
   \   00000296   0968               LDR      R1,[R1, #+0]
   \   00000298   0170               STRB     R1,[R0, #+0]
    521          }
   \   0000029A   31BD               POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .bss, align 1
   \                     ??OldSec:
   \   00000000                      DS8 1

   \                                 In section .text, align 2, keep-with-next
    522          void Convert_DTG_Data(unsigned char Index)
    523          {
   \                     Convert_DTG_Data:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   AAB0               SUB      SP,SP,#+168
   \   00000004   0400               MOVS     R4,R0
    524               TM_Struct Timer;
    525               // -- 초기화 
    526               memset(USBH_USR_DTG_Buffer,0,sizeof(USBH_USR_DTG_Buffer));
   \   00000006   4FF48072           MOV      R2,#+256
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   ....               LDR.N    R0,??DataTable16_25
   \   0000000E   ........           BL       memset
    527               // -- 메인 루트     
    528               RTC_BinaryToDate( DTG_NAND_Binary[Index].Datetime , &Timer );		// 시간저장된 데이터 변환    
   \   00000012   21A9               ADD      R1,SP,#+132
   \   00000014   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   4720               MOVS     R0,#+71
   \   00000018   ....               LDR.N    R2,??DataTable16_17
   \   0000001A   00FB0420           MLA      R0,R0,R4,R2
   \   0000001E   D0F81900           LDR      R0,[R0, #+25]
   \   00000022   ........           BL       RTC_BinaryToDate
    529          
    530               sprintf((char*)USBH_USR_DTG_Buffer,
    531                       "%02d/%02d/%02d-%02d:%02d:%02d,%018s,"
    532                       "%03d,%04d,%d,"
    533                       "%03d.%06d,%03d.%06d,%03d,%0+4d,%0+4d,"
    534                       "%04d,%07d,"
    535                       "%02d,"
    536                       "%04d,%04d,%04d,%04d,%04d,%04d,%+03d,%+03d,%03d,%03d,"
    537                       "%08x,%08x,%04x,"
    538                       "%02x,%02x\r\n",
    539                                 Timer.tm_year,Timer.tm_mon,Timer.tm_mday,
    540                                 Timer.tm_hour,Timer.tm_min,Timer.tm_sec,             
    541                                 Info.Driver_Num,                       
    542          
    543                                 DTG_NAND_Binary[Index].Speed,
    544                                 DTG_NAND_Binary[Index].RPM,
    545                                 DTG_NAND_Binary[Index].Sign_Break,
    546                                 
    547                                 DTG_NAND_Binary[Index].GPSX/ 1000000,
    548                                 DTG_NAND_Binary[Index].GPSX% 1000000,
    549                                 DTG_NAND_Binary[Index].GPSY/ 1000000,
    550                                 DTG_NAND_Binary[Index].GPSY% 1000000,
    551                                 
    552                                 DTG_NAND_Binary[Index].Azimuth,
    553                                 DTG_NAND_Binary[Index].AccelX,
    554                                 DTG_NAND_Binary[Index].AccelY,
    555          
    556                                 DTG_NAND_Binary[Index].DayDriveLength,
    557                                 DTG_NAND_Binary[Index].TotalDriveLength,                       
    558                                 
    559                                 DTG_NAND_Binary[Index].MachineStatus,
    560                                 DTG_NAND_Binary[Index].Ems_Data.Fuel_Volt,
    561                                 DTG_NAND_Binary[Index].Ems_Data.Battery_Volt,
    562                                 DTG_NAND_Binary[Index].Ems_Data.AirPressure_Volt,
    563                                 DTG_NAND_Binary[Index].Ems_Data.CoolWaterTemp_Volt,
    564                                 DTG_NAND_Binary[Index].Ems_Data.Acceller_Volt,	
    565                                 DTG_NAND_Binary[Index].Ems_Data.LPG_PWM_Value,
    566                                 DTG_NAND_Binary[Index].Ems_Data.Tilt_X,
    567                                 DTG_NAND_Binary[Index].Ems_Data.Tilt_Y,
    568                                 DTG_NAND_Binary[Index].Ems_Data.Gps_HDOP,
    569                                 DTG_NAND_Binary[Index].Ems_Data.GPS_Speed,
    570                                 ACC_Drive_Value.Total_StartMotor,
    571                                 ACC_Drive_Value.Total_Drive_PulsCount1,
    572                                 ACC_Drive_Value.Total_Drive_PulsCount2,
    573                                 DTG_NAND_Binary[Index].Ems_Data.Input_Status,
    574                                 DTG_NAND_Binary[Index].Ems_Data.Out_Status
    575                                 );
   \   00000026   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000028   4720               MOVS     R0,#+71
   \   0000002A   ....               LDR.N    R1,??DataTable16_17
   \   0000002C   00FB0410           MLA      R0,R0,R4,R1
   \   00000030   D0F82500           LDR      R0,[R0, #+37]
   \   00000034   ....               LDR.N    R1,??DataTable16_26  ;; 0xf4240
   \   00000036   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   4722               MOVS     R2,#+71
   \   0000003A   ....               LDR.N    R3,??DataTable16_17
   \   0000003C   02FB0432           MLA      R2,R2,R4,R3
   \   00000040   D2F82120           LDR      R2,[R2, #+33]
   \   00000044   ....               LDR.N    R3,??DataTable16_26  ;; 0xf4240
   \   00000046   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000048   4725               MOVS     R5,#+71
   \   0000004A   ....               LDR.N    R6,??DataTable16_17
   \   0000004C   05FB0465           MLA      R5,R5,R4,R6
   \   00000050   B5F84450           LDRH     R5,[R5, #+68]
   \   00000054   2095               STR      R5,[SP, #+128]
   \   00000056   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000058   4725               MOVS     R5,#+71
   \   0000005A   ....               LDR.N    R6,??DataTable16_17
   \   0000005C   05FB0465           MLA      R5,R5,R4,R6
   \   00000060   B5F84250           LDRH     R5,[R5, #+66]
   \   00000064   1F95               STR      R5,[SP, #+124]
   \   00000066   ....               LDR.N    R5,??DataTable16_9
   \   00000068   ED88               LDRH     R5,[R5, #+6]
   \   0000006A   1E95               STR      R5,[SP, #+120]
   \   0000006C   ....               LDR.N    R5,??DataTable16_9
   \   0000006E   D5F80250           LDR      R5,[R5, #+2]
   \   00000072   1D95               STR      R5,[SP, #+116]
   \   00000074   ....               LDR.N    R5,??DataTable16_9
   \   00000076   2D88               LDRH     R5,[R5, #+0]
   \   00000078   1C95               STR      R5,[SP, #+112]
   \   0000007A   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007C   4725               MOVS     R5,#+71
   \   0000007E   ....               LDR.N    R6,??DataTable16_17
   \   00000080   05FB0465           MLA      R5,R5,R4,R6
   \   00000084   ED8F               LDRH     R5,[R5, #+62]
   \   00000086   1B95               STR      R5,[SP, #+108]
   \   00000088   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008A   4725               MOVS     R5,#+71
   \   0000008C   ....               LDR.N    R6,??DataTable16_17
   \   0000008E   05FB0465           MLA      R5,R5,R4,R6
   \   00000092   B5F84050           LDRH     R5,[R5, #+64]
   \   00000096   1A95               STR      R5,[SP, #+104]
   \   00000098   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009A   4725               MOVS     R5,#+71
   \   0000009C   ....               LDR.N    R6,??DataTable16_17
   \   0000009E   05FB0465           MLA      R5,R5,R4,R6
   \   000000A2   95F93D50           LDRSB    R5,[R5, #+61]
   \   000000A6   1995               STR      R5,[SP, #+100]
   \   000000A8   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AA   4725               MOVS     R5,#+71
   \   000000AC   ....               LDR.N    R6,??DataTable16_17
   \   000000AE   05FB0465           MLA      R5,R5,R4,R6
   \   000000B2   95F93C50           LDRSB    R5,[R5, #+60]
   \   000000B6   1895               STR      R5,[SP, #+96]
   \   000000B8   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BA   4725               MOVS     R5,#+71
   \   000000BC   ....               LDR.N    R6,??DataTable16_17
   \   000000BE   05FB0465           MLA      R5,R5,R4,R6
   \   000000C2   6D8F               LDRH     R5,[R5, #+58]
   \   000000C4   1795               STR      R5,[SP, #+92]
   \   000000C6   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C8   4725               MOVS     R5,#+71
   \   000000CA   ....               LDR.N    R6,??DataTable16_17
   \   000000CC   05FB0465           MLA      R5,R5,R4,R6
   \   000000D0   2D8F               LDRH     R5,[R5, #+56]
   \   000000D2   1695               STR      R5,[SP, #+88]
   \   000000D4   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D6   4725               MOVS     R5,#+71
   \   000000D8   ....               LDR.N    R6,??DataTable16_17
   \   000000DA   05FB0465           MLA      R5,R5,R4,R6
   \   000000DE   ED8E               LDRH     R5,[R5, #+54]
   \   000000E0   1595               STR      R5,[SP, #+84]
   \   000000E2   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000E4   4725               MOVS     R5,#+71
   \   000000E6   ....               LDR.N    R6,??DataTable16_17
   \   000000E8   05FB0465           MLA      R5,R5,R4,R6
   \   000000EC   AD8E               LDRH     R5,[R5, #+52]
   \   000000EE   1495               STR      R5,[SP, #+80]
   \   000000F0   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F2   4725               MOVS     R5,#+71
   \   000000F4   ....               LDR.N    R6,??DataTable16_17
   \   000000F6   05FB0465           MLA      R5,R5,R4,R6
   \   000000FA   6D8E               LDRH     R5,[R5, #+50]
   \   000000FC   1395               STR      R5,[SP, #+76]
   \   000000FE   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000100   4725               MOVS     R5,#+71
   \   00000102   ....               LDR.N    R6,??DataTable16_17
   \   00000104   05FB0465           MLA      R5,R5,R4,R6
   \   00000108   2D8E               LDRH     R5,[R5, #+48]
   \   0000010A   1295               STR      R5,[SP, #+72]
   \   0000010C   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000010E   4725               MOVS     R5,#+71
   \   00000110   ....               LDR.N    R6,??DataTable16_17
   \   00000112   05FB0465           MLA      R5,R5,R4,R6
   \   00000116   95F82F50           LDRB     R5,[R5, #+47]
   \   0000011A   1195               STR      R5,[SP, #+68]
   \   0000011C   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000011E   4725               MOVS     R5,#+71
   \   00000120   ....               LDR.N    R6,??DataTable16_17
   \   00000122   05FB0465           MLA      R5,R5,R4,R6
   \   00000126   D5F81550           LDR      R5,[R5, #+21]
   \   0000012A   1095               STR      R5,[SP, #+64]
   \   0000012C   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000012E   4725               MOVS     R5,#+71
   \   00000130   ....               LDR.N    R6,??DataTable16_17
   \   00000132   05FB0465           MLA      R5,R5,R4,R6
   \   00000136   B5F81350           LDRH     R5,[R5, #+19]
   \   0000013A   0F95               STR      R5,[SP, #+60]
   \   0000013C   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000013E   4725               MOVS     R5,#+71
   \   00000140   ....               LDR.N    R6,??DataTable16_17
   \   00000142   05FB0465           MLA      R5,R5,R4,R6
   \   00000146   B5F92D50           LDRSH    R5,[R5, #+45]
   \   0000014A   0E95               STR      R5,[SP, #+56]
   \   0000014C   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000014E   4725               MOVS     R5,#+71
   \   00000150   ....               LDR.N    R6,??DataTable16_17
   \   00000152   05FB0465           MLA      R5,R5,R4,R6
   \   00000156   B5F92B50           LDRSH    R5,[R5, #+43]
   \   0000015A   0D95               STR      R5,[SP, #+52]
   \   0000015C   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000015E   4725               MOVS     R5,#+71
   \   00000160   ....               LDR.N    R6,??DataTable16_17
   \   00000162   05FB0465           MLA      R5,R5,R4,R6
   \   00000166   B5F82950           LDRH     R5,[R5, #+41]
   \   0000016A   0C95               STR      R5,[SP, #+48]
   \   0000016C   B0FBF1F5           UDIV     R5,R0,R1
   \   00000170   01FB1500           MLS      R0,R1,R5,R0
   \   00000174   0B90               STR      R0,[SP, #+44]
   \   00000176   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000178   4720               MOVS     R0,#+71
   \   0000017A   ....               LDR.N    R1,??DataTable16_17
   \   0000017C   00FB0410           MLA      R0,R0,R4,R1
   \   00000180   D0F82500           LDR      R0,[R0, #+37]
   \   00000184   ....               LDR.N    R1,??DataTable16_26  ;; 0xf4240
   \   00000186   B0FBF1F0           UDIV     R0,R0,R1
   \   0000018A   0A90               STR      R0,[SP, #+40]
   \   0000018C   B2FBF3F0           UDIV     R0,R2,R3
   \   00000190   03FB1020           MLS      R0,R3,R0,R2
   \   00000194   0990               STR      R0,[SP, #+36]
   \   00000196   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000198   4720               MOVS     R0,#+71
   \   0000019A   ....               LDR.N    R1,??DataTable16_17
   \   0000019C   00FB0410           MLA      R0,R0,R4,R1
   \   000001A0   D0F82100           LDR      R0,[R0, #+33]
   \   000001A4   ....               LDR.N    R1,??DataTable16_26  ;; 0xf4240
   \   000001A6   B0FBF1F0           UDIV     R0,R0,R1
   \   000001AA   0890               STR      R0,[SP, #+32]
   \   000001AC   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001AE   4720               MOVS     R0,#+71
   \   000001B0   ....               LDR.N    R1,??DataTable16_17
   \   000001B2   00FB0410           MLA      R0,R0,R4,R1
   \   000001B6   90F82000           LDRB     R0,[R0, #+32]
   \   000001BA   0790               STR      R0,[SP, #+28]
   \   000001BC   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001BE   4720               MOVS     R0,#+71
   \   000001C0   ....               LDR.N    R1,??DataTable16_17
   \   000001C2   00FB0410           MLA      R0,R0,R4,R1
   \   000001C6   C08B               LDRH     R0,[R0, #+30]
   \   000001C8   0690               STR      R0,[SP, #+24]
   \   000001CA   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001CC   4720               MOVS     R0,#+71
   \   000001CE   ....               LDR.N    R1,??DataTable16_17
   \   000001D0   00FB0410           MLA      R0,R0,R4,R1
   \   000001D4   407F               LDRB     R0,[R0, #+29]
   \   000001D6   0590               STR      R0,[SP, #+20]
   \   000001D8   ....               LDR.N    R0,??DataTable16_19
   \   000001DA   0490               STR      R0,[SP, #+16]
   \   000001DC   2198               LDR      R0,[SP, #+132]
   \   000001DE   0390               STR      R0,[SP, #+12]
   \   000001E0   2298               LDR      R0,[SP, #+136]
   \   000001E2   0290               STR      R0,[SP, #+8]
   \   000001E4   2398               LDR      R0,[SP, #+140]
   \   000001E6   0190               STR      R0,[SP, #+4]
   \   000001E8   2498               LDR      R0,[SP, #+144]
   \   000001EA   0090               STR      R0,[SP, #+0]
   \   000001EC   259B               LDR      R3,[SP, #+148]
   \   000001EE   269A               LDR      R2,[SP, #+152]
   \   000001F0   ........           ADR.W    R1,`?<Constant "%02d/%02d/%02d-%02d:%...">`
   \   000001F4   ....               LDR.N    R0,??DataTable16_25
   \   000001F6   ........           BL       sprintf
    576          
    577          }
   \   000001FA   2AB0               ADD      SP,SP,#+168
   \   000001FC   70BD               POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
    578          void Conver_EMS_Data(void)
    579          {
   \                     Conver_EMS_Data:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   91B0               SUB      SP,SP,#+68
    580          //     TM_Struct Timer;
    581               // -- 초기화 
    582               memset(USBH_USR_DTG_Buffer,0,sizeof(USBH_USR_DTG_Buffer));
   \   00000004   4FF48072           MOV      R2,#+256
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   ....               LDR.N    R0,??DataTable16_25
   \   0000000C   ........           BL       memset
    583               // -- 메인 루트     
    584          //     RTC_BinaryToDate( RTC_DateToBinary(&SYSTEM_TIME) , &Timer );		// 시간저장된 데이터 변환    
    585          
    586               sprintf((char*)USBH_USR_DTG_Buffer,"%02d/%02d/%02d-%02d:%02d:%02d,"
    587                       "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\r\n",     
    588                       SYSTEM_TIME.tm_year-2000,SYSTEM_TIME.tm_mon,SYSTEM_TIME.tm_mday,
    589                       SYSTEM_TIME.tm_hour,SYSTEM_TIME.tm_min,SYSTEM_TIME.tm_sec,             
    590                                 EMS_Drive_Value.Today_Speed_PulsCount,
    591                                 Info.DayDriveLength,
    592                                 EMS_Drive_Value.Drive_Time,
    593                                 EMS_Drive_Value.DriveStop_Time,
    594                                 EMS_Drive_Value.EngineStop_Time,
    595                                 EMS_Drive_Value.EcoUse_Time,                       
    596                                 EMS_Drive_Value.Day_StarterMotor,
    597                                 ACC_Drive_Value.Total_StartMotor,
    598                                 EMS_Drive_Value.QuickAccel_Count,
    599                                 EMS_Drive_Value.QuickStart_Count,
    600                                 EMS_Drive_Value.QuickStop_Count,
    601                                 EMS_Drive_Value.HighRPM_Count,
    602                                 EMS_Drive_Value.Break_Count);
   \   00000010   ....               LDR.N    R0,??DataTable16_8
   \   00000012   408C               LDRH     R0,[R0, #+34]
   \   00000014   1090               STR      R0,[SP, #+64]
   \   00000016   ....               LDR.N    R0,??DataTable16_8
   \   00000018   008C               LDRH     R0,[R0, #+32]
   \   0000001A   0F90               STR      R0,[SP, #+60]
   \   0000001C   ....               LDR.N    R0,??DataTable16_8
   \   0000001E   C08B               LDRH     R0,[R0, #+30]
   \   00000020   0E90               STR      R0,[SP, #+56]
   \   00000022   ....               LDR.N    R0,??DataTable16_8
   \   00000024   808B               LDRH     R0,[R0, #+28]
   \   00000026   0D90               STR      R0,[SP, #+52]
   \   00000028   ....               LDR.N    R0,??DataTable16_8
   \   0000002A   408B               LDRH     R0,[R0, #+26]
   \   0000002C   0C90               STR      R0,[SP, #+48]
   \   0000002E   ....               LDR.N    R0,??DataTable16_9
   \   00000030   0088               LDRH     R0,[R0, #+0]
   \   00000032   0B90               STR      R0,[SP, #+44]
   \   00000034   ....               LDR.N    R0,??DataTable16_8
   \   00000036   008B               LDRH     R0,[R0, #+24]
   \   00000038   0A90               STR      R0,[SP, #+40]
   \   0000003A   ....               LDR.N    R0,??DataTable16_8
   \   0000003C   4069               LDR      R0,[R0, #+20]
   \   0000003E   0990               STR      R0,[SP, #+36]
   \   00000040   ....               LDR.N    R0,??DataTable16_8
   \   00000042   0069               LDR      R0,[R0, #+16]
   \   00000044   0890               STR      R0,[SP, #+32]
   \   00000046   ....               LDR.N    R0,??DataTable16_8
   \   00000048   C068               LDR      R0,[R0, #+12]
   \   0000004A   0790               STR      R0,[SP, #+28]
   \   0000004C   ....               LDR.N    R0,??DataTable16_8
   \   0000004E   4068               LDR      R0,[R0, #+4]
   \   00000050   0690               STR      R0,[SP, #+24]
   \   00000052   ....               LDR.N    R0,??DataTable16_6
   \   00000054   408B               LDRH     R0,[R0, #+26]
   \   00000056   0590               STR      R0,[SP, #+20]
   \   00000058   ....               LDR.N    R0,??DataTable16_8
   \   0000005A   8068               LDR      R0,[R0, #+8]
   \   0000005C   0490               STR      R0,[SP, #+16]
   \   0000005E   ....               LDR.N    R0,??DataTable16_1
   \   00000060   0068               LDR      R0,[R0, #+0]
   \   00000062   0390               STR      R0,[SP, #+12]
   \   00000064   ....               LDR.N    R0,??DataTable16_1
   \   00000066   4068               LDR      R0,[R0, #+4]
   \   00000068   0290               STR      R0,[SP, #+8]
   \   0000006A   ....               LDR.N    R0,??DataTable16_1
   \   0000006C   8068               LDR      R0,[R0, #+8]
   \   0000006E   0190               STR      R0,[SP, #+4]
   \   00000070   ....               LDR.N    R0,??DataTable16_1
   \   00000072   C068               LDR      R0,[R0, #+12]
   \   00000074   0090               STR      R0,[SP, #+0]
   \   00000076   ....               LDR.N    R0,??DataTable16_1
   \   00000078   0369               LDR      R3,[R0, #+16]
   \   0000007A   ....               LDR.N    R0,??DataTable16_1
   \   0000007C   4069               LDR      R0,[R0, #+20]
   \   0000007E   B0F5FA62           SUBS     R2,R0,#+2000
   \   00000082   ........           ADR.W    R1,`?<Constant "%02d/%02d/%02d-%02d:%...">_1`
   \   00000086   ....               LDR.N    R0,??DataTable16_25
   \   00000088   ........           BL       sprintf
    603          }
   \   0000008C   11B0               ADD      SP,SP,#+68
   \   0000008E   00BD               POP      {PC}             ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   ........           DC32     NAND_Header_Info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   ........           DC32     SYSTEM_TIME

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   ........           DC32     NAND_Header_Index

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   ........           DC32     Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   ........           DC32     NAND_Data_Transmit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   ........           DC32     I2C_Ems_Accure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   ........           DC32     Info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   ........           DC32     NAND_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   ........           DC32     EMS_Drive_Value

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   ........           DC32     ACC_Drive_Value

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   ........           DC32     NAND_Buffer+0x1FFD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   ........           DC32     NAND_Buffer+0x1FFE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   ........           DC32     NAND_Buffer+0x1FFF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   ........           DC32     Accident_Time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \   00000000   ........           DC32     Accident_SaveBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \   00000000   ........           DC32     Accident2_SaveBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_16:
   \   00000000   ........           DC32     LookUpTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_17:
   \   00000000   ........           DC32     DTG_NAND_Binary

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_18:
   \   00000000   ........           DC32     ??OldSec

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_19:
   \   00000000   ........           DC32     Info+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_20:
   \   00000000   ........           DC32     Info+0x3F

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_21:
   \   00000000   ........           DC32     USBH_USR_ApplicationState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_22:
   \   00000000   ........           DC32     USBH_USR_ActionFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_23:
   \   00000000   ........           DC32     Flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_24:
   \   00000000   FFE70300           DC32     0x3e7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_25:
   \   00000000   ........           DC32     USBH_USR_DTG_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_26:
   \   00000000   40420F00           DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%02d/%02d/%02d-%02d:%...">`:
   \   00000000                      ; Initializer data, 180 bytes
   \   00000000   253032642F25       DC8 37, 48, 50, 100, 47, 37, 48, 50, 100, 47
   \              3032642F    
   \   0000000A   253032642D25       DC8 37, 48, 50, 100, 45, 37, 48, 50, 100, 58
   \              3032643A    
   \   00000014   253032643A25       DC8 37, 48, 50, 100, 58, 37, 48, 50, 100, 44
   \              3032642C    
   \   0000001E   25303138732C       DC8 37, 48, 49, 56, 115, 44, 37, 48, 51, 100
   \              25303364    
   \   00000028   2C253034642C       DC8 44, 37, 48, 52, 100, 44, 37, 100, 44, 37
   \              25642C25    
   \   00000032   3033642E2530       DC8 48, 51, 100, 46, 37, 48, 54, 100, 44, 37
   \              36642C25    
   \   0000003C   3033642E2530       DC8 48, 51, 100, 46, 37, 48, 54, 100, 44, 37
   \              36642C25    
   \   00000046   3033642C2530       DC8 48, 51, 100, 44, 37, 48, 43, 52, 100, 44
   \              2B34642C    
   \   00000050   25302B34642C       DC8 37, 48, 43, 52, 100, 44, 37, 48, 52, 100
   \              25303464    
   \   0000005A   2C253037642C       DC8 44, 37, 48, 55, 100, 44, 37, 48, 50, 100
   \              25303264    
   \   00000064   2C253034642C       DC8 44, 37, 48, 52, 100, 44, 37, 48, 52, 100
   \              25303464    
   \   0000006E   2C253034642C       DC8 44, 37, 48, 52, 100, 44, 37, 48, 52, 100
   \              25303464    
   \   00000078   2C253034642C       DC8 44, 37, 48, 52, 100, 44, 37, 48, 52, 100
   \              25303464    
   \   00000082   2C252B303364       DC8 44, 37, 43, 48, 51, 100, 44, 37, 43, 48
   \              2C252B30    
   \   0000008C   33642C253033       DC8 51, 100, 44, 37, 48, 51, 100, 44, 37, 48
   \              642C2530    
   \   00000096   33642C253038       DC8 51, 100, 44, 37, 48, 56, 120, 44, 37, 48
   \              782C2530    
   \   000000A0   38782C253034       DC8 56, 120, 44, 37, 48, 52, 120, 44, 37, 48
   \              782C2530    
   \   000000AA   32782C253032       DC8 50, 120, 44, 37, 48, 50, 120, 13, 10, 0
   \              780D0A00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%02d/%02d/%02d-%02d:%...">_1`:
   \   00000000                      ; Initializer data, 72 bytes
   \   00000000   253032642F25       DC8 37, 48, 50, 100, 47, 37, 48, 50, 100, 47
   \              3032642F    
   \   0000000A   253032642D25       DC8 37, 48, 50, 100, 45, 37, 48, 50, 100, 58
   \              3032643A    
   \   00000014   253032643A25       DC8 37, 48, 50, 100, 58, 37, 48, 50, 100, 44
   \              3032642C    
   \   0000001E   25642C25642C       DC8 37, 100, 44, 37, 100, 44, 37, 100, 44, 37
   \              25642C25    
   \   00000028   642C25642C25       DC8 100, 44, 37, 100, 44, 37, 100, 44, 37, 100
   \              642C2564    
   \   00000032   2C25642C2564       DC8 44, 37, 100, 44, 37, 100, 44, 37, 100, 44
   \              2C25642C    
   \   0000003C   25642C25642C       DC8 37, 100, 44, 37, 100, 44, 37, 100, 13, 10
   \              25640D0A    
   \   00000046   0000               DC8 0, 0

   Maximum stack usage in bytes:

     Function                   .cstack
     --------                   -------
     Accident_DataLoad              16
     Accident_DataSave              16
     Conver_EMS_Data                72
     Convert_Binary                  0
     Convert_DTG_Data              184
     Convert_Data                    0
     DTG_EMS_DataLoad               16
     DTG_EMS_DataSave               32
     GetHeader_Index                 0
     Memory_Config                  24
     Memory_Process                 16
     NAND_ERASE_PAGE                16
     Page_Stack                      0
     Read_Header_Information        24
     Search_Header                   0
     Setting_Header_Information      8
     Write_Header_EMS                8
     Write_Header_Index              8
     Write_Header_Information        8
     Write_Transmit_Header           8
     memcpy                          8
     memset                          8


   Section sizes:

     Function/Label                           Bytes
     --------------                           -----
     memcpy                                     14
     memset                                     20
     VIEW_Header                                24
     I2C_Ems_Accure                              8
     NAND_Header_Info                           16
     NAND_Header_Index                          12
     NAND_Data_Transmit                         12
     GetHeader_Index                            42
     DTG_NAND_Binary                          6392
     Search_Header                               2
     Setting_Header_Information                 88
     Read_Header_Information                    72
     Memory_Config                             568
     Write_Header_EMS                           70
     Write_Header_Index                         40
     Write_Transmit_Header                      40
     Write_Header_Information                   56
     Accident_DataLoad                          46
     Accident_DataSave                         136
     NAND_ERASE_PAGE                            88
     DTG_EMS_DataSave                          192
     DTG_EMS_DataLoad                           44
     Convert_Binary                             16
     Convert_Data                                2
     Page_Stack                                  2
     Memory_Process                            668
     OldSec                                      1
     Convert_DTG_Data                          510
     Conver_EMS_Data                           144
     ??DataTable16                               4
     ??DataTable16_1                             4
     ??DataTable16_2                             4
     ??DataTable16_3                             4
     ??DataTable16_4                             4
     ??DataTable16_5                             4
     ??DataTable16_6                             4
     ??DataTable16_7                             4
     ??DataTable16_8                             4
     ??DataTable16_9                             4
     ??DataTable16_10                            4
     ??DataTable16_11                            4
     ??DataTable16_12                            4
     ??DataTable16_13                            4
     ??DataTable16_14                            4
     ??DataTable16_15                            4
     ??DataTable16_16                            4
     ??DataTable16_17                            4
     ??DataTable16_18                            4
     ??DataTable16_19                            4
     ??DataTable16_20                            4
     ??DataTable16_21                            4
     ??DataTable16_22                            4
     ??DataTable16_23                            4
     ??DataTable16_24                            4
     ??DataTable16_25                            4
     ??DataTable16_26                            4
     ?<Constant "%02d/%02d/%02d-%02d:%...">    180
     ?<Constant "%02d/%02d/%02d-%02d:%...">_1   72

 
 6 465 bytes in section .bss
 3 220 bytes in section .text
 
 3 186 bytes of CODE memory (+ 34 bytes shared)
 6 465 bytes of DATA memory

Errors: none
Warnings: 1
